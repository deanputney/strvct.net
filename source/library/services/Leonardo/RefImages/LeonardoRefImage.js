"use strict";

/**
 * @module library.services.Leonardo.RefImages
 */

/**
 * @class LeonardoRefImage
 * @extends SvSummaryNode
 * @classdesc Represents an image generated by Leonardo's text-to-image service.
 */

(class LeonardoRefImage extends SvSummaryNode {
  /**
   * @description Initializes the prototype slots for the LeonardoRefImage class.
   */
  initPrototypeSlots () {

    /**
     * @member {string} imageUrl - The URL of the generated image.
     * @category Image Data
     */
    {
      const slot = this.newSlot("imageUrl", null);
      slot.setShouldJsonArchive(true);
      slot.setInspectorPath("");
      slot.setLabel("image");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("String");
      slot.setIsSubnodeField(true);
      slot.setCanEditInspection(false);
      slot.setFieldInspectorViewClassName("SvImageWellField"); // field inspector view class
    }

    /**
     * @member {string} url - The URL of the image.
     * @category Image Data
     */
    {
      const slot = this.newSlot("url", "");
      slot.setShouldJsonArchive(true);
      slot.setInspectorPath("");
      slot.setLabel("url");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("String");
      slot.setIsSubnodeField(true);
      slot.setCanEditInspection(false);
    }

    /**
    {
      const slot = this.newSlot("xhrRequest", null);
      slot.setShouldJsonArchive(true);
      slot.setInspectorPath("");
      slot.setLabel("xhr request");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setSlotType("SvXhrRequest");
      slot.setIsSubnodeField(true)
      slot.setCanEditInspection(false)
    }

    /**
     * @member {Action} fetchAction - The action to fetch the image.
     * @category Actions
     */
    {
      const slot = this.newSlot("fetchAction", null);
      slot.setInspectorPath("");
      slot.setLabel("Fetch");
      //slot.setShouldStoreSlot(true)
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("Action");
      slot.setIsSubnodeField(true);
      slot.setActionMethodName("fetch");
    }

    /**
     * @member {string} error - Error message if any.
     * @category Error Handling
     */
    {
      const slot = this.newSlot("error", ""); // String
      slot.setInspectorPath("");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("String");
      //slot.setIsSubnodeField(true);
      slot.setCanEditInspection(false);
    }

    /**
     * @member {string} status - Current status of the image.
     * @category Status
     */
    {
      const slot = this.newSlot("status", ""); // String
      slot.setInspectorPath("");
      slot.setShouldStoreSlot(true);
      slot.setSyncsToView(true);
      slot.setDuplicateOp("duplicate");
      slot.setSlotType("String");
      slot.setIsSubnodeField(true);
      slot.setCanEditInspection(false);
    }

    /**
     * @member {boolean} isLoading - Indicates if the image is currently loading.
     * @category Status
     */
    {
      const slot = this.newSlot("isLoading", false); // String
      slot.setSlotType("Boolean");
    }

    this.setTitle("Reference Image");
    this.setShouldStore(true);
    this.setShouldStoreSubnodes(false);
    this.setSubnodeClasses([]);
    this.setNodeCanAddSubnode(false);
    this.setNodeCanReorderSubnodes(false);
    this.setCanDelete(true);
    this.setNodeFillsRemainingWidth(true);
  }

  /**
   * @description Gets the subtitle for the image.
   * @returns {string} The status of the image.
   * @category UI
   */
  subtitle () {
    return this.status();
  }


  /**
   * @description Gets the service used for image generation.
   * @returns {Object} The service.
   * @category Service
   */
  service () {
    return LeonardoService.shared();
  }

  /**
   * @description Checks if the image is loaded.
   * @returns {boolean} True if the image is loaded, false otherwise.
   * @category Status
   */
  isLoaded () {
    return this.imageUrl() !== null;
  }

  /**
   * @description Checks if there's an error.
   * @returns {boolean} True if there's an error, false otherwise.
   * @category Error Handling
   */
  hasError () {
    return this.error() !== "" && this.error() !== null;
  }

  /**
   * @description Checks if the image can be fetched.
   * @returns {boolean} True if the image can be fetched, false otherwise.
   * @category Actions
   */
  canFetch () {
    return Type.isString(this.url());
  }

  /**
   * @description Gets the fetch action information.
   * @returns {Object} An object containing fetch action information.
   * @category Actions
   */
  fetchActionInfo () {
    return {
        isEnabled: this.canFetch(),
        //title: this.title(),
        isVisible: true
    };
  }

  /**
   * @description Gets the proxy URL for the image.
   * @returns {string} The proxy URL.
   * @category Networking
   */
  getProxyUrl () {
    return ProxyServers.shared().defaultServer().proxyUrlForUrl(this.url());
  }

  /**
   * @description Fetches the image.
   * @returns {Promise<void>}
   * @category Actions
   */
  async fetch () {
    if (this.isLoading()) {
      return;
    }

    this.setIsLoading(true);

    const url = this.getProxyUrl();
    const apiKey = this.service().apiKeyOrUserAuthToken();

    const xhr = new SvXhrRequest();
    this.setXhrRequest(xhr);
    xhr.setEndpoint(url);
    xhr.setMethod("GET");
    xhr.setHeaders({
      "Authorization": `Bearer ` + apiKey,
      "Content-Type": "application/json"
    });
    xhr.setDelegate(this);
    await xhr.asyncSend();
    // handle the rest in the delegate methods
  }

    /* delegate messages we should implement:
      *   onRequestBegin(request)
      *   onRequestProgress(request)
      *   onRequestFailure(request)
      *   onRequestSuccess(request)
      *   onRequestAbort(request)
      *   onRequestError(request)
      *   onRequestComplete(request) // send whether success, error, or aborted
      */

  // --- delegate methods ---

  onRequestBegin (/*request*/) {
    this.setStatus("fetching...");
  }

  onRequestProgress (request) {
    console.log("onRequestProgress " + request.status());
  }

  onRequestComplete (/*request*/) {
  }

  onRequestError (/*request*/) {
  }

  onRequestFailure (/*request*/) {
    this.setIsLoading(false);
  }

  onRequestSuccess (request) {
    this.setIsLoading(false);

    console.log("onRequestComplete " + request.status());
    // get the image data url
    const text = request.responseText();
    // convert response text to image data url
    const imageDataUrl = "data:image/png;base64," + text;
    this.setImageUrl(imageDataUrl);
    this.setStatus("complete")
    this.sendDelegate("onImageLoaded", [this])
  }

  onRequestAbort (/*request*/) {
    this.setIsLoading(false);
  }

  /**
   * @description Shuts down the image fetching process.
   * @returns {this} The current instance.
   * @category Lifecycle
   */
  shutdown () {
    if (this.xhr()) {
      this.xhr().abort();
    }
   return this;
  }


  /**
   * @description Sends a method call to the delegate.
   * @param {string} methodName - The name of the method to call.
   * @param {Array} args - The arguments to pass to the method.
   * @returns {boolean} True if the method was called successfully, false otherwise.
   * @category Delegation
   */
  sendDelegate (methodName, args = [this]) {
    const d = this.delegate();
    if (d) {
      const f = d[methodName];
      if (f) {
        f.apply(d, args);
        return true;
      }
    }
    return false;
  }

}.initThisClass());