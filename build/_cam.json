{
  "ubT1ApprcrOGWJW94c4bMSnmcENZTPalvs3q+lonuas=": "html, body {\n    display: flex;\n    position: absolute;\n    overflow: hidden;\n\n    overscroll-behavior-x: none;\n    overscroll-behavior-y: none;\n\n    top: 0px;\n    left: 0px;\n\n    height: 100%;\n    width: 100%;\n\n    padding: 0px;\n    margin: 0px;\n    border: 0px;\n\n    background-color: black;\n    zoom: 100%;\n\n    font-size: 16px;\n\n    /* font smoothing */\n    -webkit-font-smoothing: subpixel-antialiased;\n    font-smooth: always;\n\n    /* text-size-adjust fixes issue with contenteditable fonts being tiny */\n    text-size-adjust: 100%;\n\n\n    /* disable pinch-zoom browser action, but still available to JS */\n    touch-action: none;\n\n    /* disable left-right paging on windows surface */\n    -ms-scroll-chaining: none;\n}\n\n/* an attempt to deal with tiny fonts on mobile */\n/* NOTE: I've read use of * can slow down rendering, so try to avoid them and see if that helps */\n\n/*\nhtml * {\n    min-height: 1px;\n    max-height: 999999px;\n    zoom: 100%;\n}\n*/\n\n/* to avoid slow/choppy handling of touchmove events */\n\n* {\n    touch-action: pan-y;\n}\n\n/* use border-box to make sure padding is included in dom width calculations */\n\n* {\n    box-sizing: border-box;\n}\n\n* {\n    overflow: hidden;\n}\n\n/* avoid outlines */\n\n/*\nhtml * {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\nhtml * :focus {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\nhtml * :active {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\n*/\n\n/* --- */\n\nhtml {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\n* :focus {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n\nhtml :active {\n    outline: none;\n    outline-style: none;\n    -moz-outline-style: none;\n}\n",
  "bbNosz5JlGdezcH8vxdbJ+b/hVKQTTRxrb+kM13pxc0=": "/**\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\n *\n * @version 0.9.0\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\n * @copyright Chen, Yi-Cyuan 2014-2017\n * @license MIT\n */\n/*jslint bitwise: true */\n(function () {\n  'use strict';\n\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var K = [\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n  ];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function (outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function (is224) {\n    var method = createOutputMethod('hex', is224);\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n    method.create = function () {\n      return new Sha256(is224);\n    };\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  var nodeWrap = function (method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n    var nodeMethod = function (message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n      if (Array.isArray(message) || ArrayBuffer.isView(message) ||\n        message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function (outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function (is224) {\n    var method = createHmacOutputMethod('hex', is224);\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else { // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n    var notString, type = typeof message;\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n      notString = true;\n    }\n    var code, index = 0, i, length = message.length, blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n          blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n          blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n          blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\n            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n    this.finalized = true;\n    var blocks = this.blocks, i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] =\n        blocks[4] = blocks[5] = blocks[6] = blocks[7] =\n        blocks[8] = blocks[9] = blocks[10] = blocks[11] =\n        blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6,\n      h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3);\n      t1 = blocks[j - 2];\n      s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10);\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n        this.first = false;\n      } else {\n        s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10));\n        s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7));\n        ab = a & b;\n        maj = ab ^ (a & c) ^ bc;\n        ch = (e & f) ^ (~e & g);\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n      s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10));\n      s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7));\n      da = d & a;\n      maj = da ^ (d & b) ^ ab;\n      ch = (h & e) ^ (~h & f);\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10));\n      s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7));\n      cd = c & d;\n      maj = cd ^ (c & a) ^ da;\n      ch = (g & h) ^ (~g & e);\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10));\n      s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7));\n      bc = b & c;\n      maj = bc ^ (b & d) ^ cd;\n      ch = (f & g) ^ (~f & h);\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var hex = HEX_CHARS[(h0 >> 28) & 0x0F] + HEX_CHARS[(h0 >> 24) & 0x0F] +\n      HEX_CHARS[(h0 >> 20) & 0x0F] + HEX_CHARS[(h0 >> 16) & 0x0F] +\n      HEX_CHARS[(h0 >> 12) & 0x0F] + HEX_CHARS[(h0 >> 8) & 0x0F] +\n      HEX_CHARS[(h0 >> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] +\n      HEX_CHARS[(h1 >> 28) & 0x0F] + HEX_CHARS[(h1 >> 24) & 0x0F] +\n      HEX_CHARS[(h1 >> 20) & 0x0F] + HEX_CHARS[(h1 >> 16) & 0x0F] +\n      HEX_CHARS[(h1 >> 12) & 0x0F] + HEX_CHARS[(h1 >> 8) & 0x0F] +\n      HEX_CHARS[(h1 >> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] +\n      HEX_CHARS[(h2 >> 28) & 0x0F] + HEX_CHARS[(h2 >> 24) & 0x0F] +\n      HEX_CHARS[(h2 >> 20) & 0x0F] + HEX_CHARS[(h2 >> 16) & 0x0F] +\n      HEX_CHARS[(h2 >> 12) & 0x0F] + HEX_CHARS[(h2 >> 8) & 0x0F] +\n      HEX_CHARS[(h2 >> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] +\n      HEX_CHARS[(h3 >> 28) & 0x0F] + HEX_CHARS[(h3 >> 24) & 0x0F] +\n      HEX_CHARS[(h3 >> 20) & 0x0F] + HEX_CHARS[(h3 >> 16) & 0x0F] +\n      HEX_CHARS[(h3 >> 12) & 0x0F] + HEX_CHARS[(h3 >> 8) & 0x0F] +\n      HEX_CHARS[(h3 >> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] +\n      HEX_CHARS[(h4 >> 28) & 0x0F] + HEX_CHARS[(h4 >> 24) & 0x0F] +\n      HEX_CHARS[(h4 >> 20) & 0x0F] + HEX_CHARS[(h4 >> 16) & 0x0F] +\n      HEX_CHARS[(h4 >> 12) & 0x0F] + HEX_CHARS[(h4 >> 8) & 0x0F] +\n      HEX_CHARS[(h4 >> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] +\n      HEX_CHARS[(h5 >> 28) & 0x0F] + HEX_CHARS[(h5 >> 24) & 0x0F] +\n      HEX_CHARS[(h5 >> 20) & 0x0F] + HEX_CHARS[(h5 >> 16) & 0x0F] +\n      HEX_CHARS[(h5 >> 12) & 0x0F] + HEX_CHARS[(h5 >> 8) & 0x0F] +\n      HEX_CHARS[(h5 >> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] +\n      HEX_CHARS[(h6 >> 28) & 0x0F] + HEX_CHARS[(h6 >> 24) & 0x0F] +\n      HEX_CHARS[(h6 >> 20) & 0x0F] + HEX_CHARS[(h6 >> 16) & 0x0F] +\n      HEX_CHARS[(h6 >> 12) & 0x0F] + HEX_CHARS[(h6 >> 8) & 0x0F] +\n      HEX_CHARS[(h6 >> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F];\n    if (!this.is224) {\n      hex += HEX_CHARS[(h7 >> 28) & 0x0F] + HEX_CHARS[(h7 >> 24) & 0x0F] +\n        HEX_CHARS[(h7 >> 20) & 0x0F] + HEX_CHARS[(h7 >> 16) & 0x0F] +\n        HEX_CHARS[(h7 >> 12) & 0x0F] + HEX_CHARS[(h7 >> 8) & 0x0F] +\n        HEX_CHARS[(h7 >> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n\n    var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5,\n      h6 = this.h6, h7 = this.h7;\n\n    var arr = [\n      (h0 >> 24) & 0xFF, (h0 >> 16) & 0xFF, (h0 >> 8) & 0xFF, h0 & 0xFF,\n      (h1 >> 24) & 0xFF, (h1 >> 16) & 0xFF, (h1 >> 8) & 0xFF, h1 & 0xFF,\n      (h2 >> 24) & 0xFF, (h2 >> 16) & 0xFF, (h2 >> 8) & 0xFF, h2 & 0xFF,\n      (h3 >> 24) & 0xFF, (h3 >> 16) & 0xFF, (h3 >> 8) & 0xFF, h3 & 0xFF,\n      (h4 >> 24) & 0xFF, (h4 >> 16) & 0xFF, (h4 >> 8) & 0xFF, h4 & 0xFF,\n      (h5 >> 24) & 0xFF, (h5 >> 16) & 0xFF, (h5 >> 8) & 0xFF, h5 & 0xFF,\n      (h6 >> 24) & 0xFF, (h6 >> 16) & 0xFF, (h6 >> 8) & 0xFF, h6 & 0xFF\n    ];\n    if (!this.is224) {\n      arr.push((h7 >> 24) & 0xFF, (h7 >> 16) & 0xFF, (h7 >> 8) & 0xFF, h7 & 0xFF);\n    }\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i, type = typeof key;\n    if (type === 'string') {\n      var bytes = [], length = key.length, index = 0, code;\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = (0xc0 | (code >> 6));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = (0xe0 | (code >> 12));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        } else {\n          code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff));\n          bytes[index++] = (0xf0 | (code >> 18));\n          bytes[index++] = (0x80 | ((code >> 12) & 0x3f));\n          bytes[index++] = (0x80 | ((code >> 6) & 0x3f));\n          bytes[index++] = (0x80 | (code & 0x3f));\n        }\n      }\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = (new Sha256(is224, true)).update(key).array();\n    }\n\n    var oKeyPad = [], iKeyPad = [];\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n\n  if (COMMON_JS) {\n    module.exports = exports;\n  } else {\n    root.sha256 = exports.sha256;\n    root.sha224 = exports.sha224;\n    if (AMD) {\n      define(function () {\n        return exports;\n      });\n    }\n  }\n})();\n",
  "ckaqXTgn7bWI5Dvm1sgNY33xyo2iCrS9c4a5tkguIDs=": "//var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');\n\nJSON.stableStringify = function (obj, opts) {\n    var json = JSON\n    \n    var isArray = Array.isArray || function (x) {\n        return {}.toString.call(x) === '[object Array]';\n    };\n    \n    var objectKeys = Object.keys || function (obj) {\n        var has = Object.prototype.hasOwnProperty || function () { return true };\n        var keys = [];\n        for (var key in obj) {\n            if (has.call(obj, key)) keys.push(key);\n        }\n        return keys;\n    };\n\n    if (!opts) opts = {};\n    if (typeof opts === 'function') opts = { cmp: opts };\n    var space = opts.space || '';\n    if (typeof space === 'number') space = Array(space+1).join(' ');\n    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;\n    var replacer = opts.replacer || function(key, value) { return value; };\n\n    var cmp = opts.cmp && (function (f) {\n        return function (node) {\n            return function (a, b) {\n                var aobj = { key: a, value: node[a] };\n                var bobj = { key: b, value: node[b] };\n                return f(aobj, bobj);\n            };\n        };\n    })(opts.cmp);\n\n    var seen = [];\n    return (function stringify (parent, key, node, level) {\n        var indent = space ? ('\\n' + new Array(level + 1).join(space)) : '';\n        var colonSeparator = space ? ': ' : ':';\n\n        if (node && node.toJSON && typeof node.toJSON === 'function') {\n            node = node.toJSON();\n        }\n\n        node = replacer.call(parent, key, node);\n\n        if (node === undefined) {\n            return;\n        }\n        if (typeof node !== 'object' || node === null) {\n            return json.stringify(node);\n        }\n        if (isArray(node)) {\n            var out = [];\n            for (var i = 0; i < node.length; i++) {\n                var item = stringify(node, i, node[i], level+1) || json.stringify(null);\n                out.push(indent + space + item);\n            }\n            return '[' + out.join(',') + indent + ']';\n        }\n        else {\n            if (seen.indexOf(node) !== -1) {\n                if (cycles) return json.stringify('__cycle__');\n                throw new TypeError('Converting circular structure to JSON');\n            }\n            else seen.push(node);\n\n            var keys = objectKeys(node).sort(cmp && cmp(node));\n            var out = [];\n            for (var i = 0; i < keys.length; i++) {\n                var key = keys[i];\n                var value = stringify(node, key, node[key], level+1);\n\n                if(!value) continue;\n\n                var keyValue = json.stringify(key)\n                    + colonSeparator\n                    + value;\n                ;\n                out.push(indent + space + keyValue);\n            }\n            seen.splice(seen.indexOf(node), 1);\n            return '{' + out.join(',') + indent + '}';\n        }\n    })({ '': obj }, '', obj, 0);\n};\n\n",
  "qn4YNl5TIOX2z4XeVAg7OR75AWuIUSo18zq5+BNf3+8=": "/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./entry.js\":\n/*!******************!*\\\n  !*** ./entry.js ***!\n  \\******************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsondiffpatch */ \\\"../../node_modules/jsondiffpatch/lib/index.js\\\");\\n \\nwindow.jsondiffpatch = jsondiffpatch__WEBPACK_IMPORTED_MODULE_0__;\\n\\n\\n//# sourceURL=webpack:///./entry.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/clone.js\":\n/*!*****************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/clone.js ***!\n  \\*****************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ clone)\\n/* harmony export */ });\\nfunction cloneRegExp(re) {\\n    const regexMatch = /^\\\\/(.*)\\\\/([gimyu]*)$/.exec(re.toString());\\n    return new RegExp(regexMatch[1], regexMatch[2]);\\n}\\nfunction clone(arg) {\\n    if (typeof arg !== 'object') {\\n        return arg;\\n    }\\n    if (arg === null) {\\n        return null;\\n    }\\n    if (Array.isArray(arg)) {\\n        return arg.map(clone);\\n    }\\n    if (arg instanceof Date) {\\n        return new Date(arg.getTime());\\n    }\\n    if (arg instanceof RegExp) {\\n        return cloneRegExp(arg);\\n    }\\n    const cloned = {};\\n    for (const name in arg) {\\n        if (Object.prototype.hasOwnProperty.call(arg, name)) {\\n            cloned[name] = clone(arg[name]);\\n        }\\n    }\\n    return cloned;\\n}\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/clone.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/contexts/context.js\":\n/*!****************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/contexts/context.js ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ Context)\\n/* harmony export */ });\\nclass Context {\\n    setResult(result) {\\n        this.result = result;\\n        this.hasResult = true;\\n        return this;\\n    }\\n    exit() {\\n        this.exiting = true;\\n        return this;\\n    }\\n    push(child, name) {\\n        child.parent = this;\\n        if (typeof name !== 'undefined') {\\n            child.childName = name;\\n        }\\n        child.root = this.root || this;\\n        child.options = child.options || this.options;\\n        if (!this.children) {\\n            this.children = [child];\\n            this.nextAfterChildren = this.next || null;\\n            this.next = child;\\n        }\\n        else {\\n            this.children[this.children.length - 1].next = child;\\n            this.children.push(child);\\n        }\\n        child.next = this;\\n        return this;\\n    }\\n}\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/contexts/context.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/contexts/diff.js\":\n/*!*************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/contexts/diff.js ***!\n  \\*************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/context.js\\\");\\n/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../clone.js */ \\\"../../node_modules/jsondiffpatch/lib/clone.js\\\");\\n\\n\\nclass DiffContext extends _context_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"] {\\n    constructor(left, right) {\\n        super();\\n        this.left = left;\\n        this.right = right;\\n        this.pipe = 'diff';\\n    }\\n    setResult(result) {\\n        if (this.options.cloneDiffValues && typeof result === 'object') {\\n            const clone = typeof this.options.cloneDiffValues === 'function'\\n                ? this.options.cloneDiffValues\\n                : _clone_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"];\\n            if (typeof result[0] === 'object') {\\n                result[0] = clone(result[0]);\\n            }\\n            if (typeof result[1] === 'object') {\\n                result[1] = clone(result[1]);\\n            }\\n        }\\n        return super.setResult(result);\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiffContext);\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/contexts/diff.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/contexts/patch.js\":\n/*!**************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/contexts/patch.js ***!\n  \\**************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/context.js\\\");\\n\\nclass PatchContext extends _context_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"] {\\n    constructor(left, delta) {\\n        super();\\n        this.left = left;\\n        this.delta = delta;\\n        this.pipe = 'patch';\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (PatchContext);\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/contexts/patch.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/contexts/reverse.js\":\n/*!****************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/contexts/reverse.js ***!\n  \\****************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _context_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./context.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/context.js\\\");\\n\\nclass ReverseContext extends _context_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"] {\\n    constructor(delta) {\\n        super();\\n        this.delta = delta;\\n        this.pipe = 'reverse';\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ReverseContext);\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/contexts/reverse.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/date-reviver.js\":\n/*!************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/date-reviver.js ***!\n  \\************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ dateReviver)\\n/* harmony export */ });\\n// use as 2nd parameter for JSON.parse to revive Date instances\\nfunction dateReviver(key, value) {\\n    let parts;\\n    if (typeof value === 'string') {\\n        parts =\\n            /^(\\\\d{4})-(\\\\d{2})-(\\\\d{2})T(\\\\d{2}):(\\\\d{2}):(\\\\d{2})(?:\\\\.(\\\\d*))?(Z|([+-])(\\\\d{2}):(\\\\d{2}))$/.exec(value);\\n        if (parts) {\\n            return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));\\n        }\\n    }\\n    return value;\\n}\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/date-reviver.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/diffpatcher.js\":\n/*!***********************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/diffpatcher.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var _processor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./processor.js */ \\\"../../node_modules/jsondiffpatch/lib/processor.js\\\");\\n/* harmony import */ var _pipe_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pipe.js */ \\\"../../node_modules/jsondiffpatch/lib/pipe.js\\\");\\n/* harmony import */ var _contexts_diff_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./contexts/diff.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/diff.js\\\");\\n/* harmony import */ var _contexts_patch_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./contexts/patch.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/patch.js\\\");\\n/* harmony import */ var _contexts_reverse_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contexts/reverse.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/reverse.js\\\");\\n/* harmony import */ var _clone_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./clone.js */ \\\"../../node_modules/jsondiffpatch/lib/clone.js\\\");\\n/* harmony import */ var _filters_trivial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./filters/trivial.js */ \\\"../../node_modules/jsondiffpatch/lib/filters/trivial.js\\\");\\n/* harmony import */ var _filters_nested_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filters/nested.js */ \\\"../../node_modules/jsondiffpatch/lib/filters/nested.js\\\");\\n/* harmony import */ var _filters_arrays_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./filters/arrays.js */ \\\"../../node_modules/jsondiffpatch/lib/filters/arrays.js\\\");\\n/* harmony import */ var _filters_dates_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./filters/dates.js */ \\\"../../node_modules/jsondiffpatch/lib/filters/dates.js\\\");\\n/* harmony import */ var _filters_texts_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./filters/texts.js */ \\\"../../node_modules/jsondiffpatch/lib/filters/texts.js\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass DiffPatcher {\\n    constructor(options) {\\n        this.processor = new _processor_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](options);\\n        this.processor.pipe(new _pipe_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"]('diff')\\n            .append(_filters_nested_js__WEBPACK_IMPORTED_MODULE_2__.collectChildrenDiffFilter, _filters_trivial_js__WEBPACK_IMPORTED_MODULE_3__.diffFilter, _filters_dates_js__WEBPACK_IMPORTED_MODULE_4__.diffFilter, _filters_texts_js__WEBPACK_IMPORTED_MODULE_5__.diffFilter, _filters_nested_js__WEBPACK_IMPORTED_MODULE_2__.objectsDiffFilter, _filters_arrays_js__WEBPACK_IMPORTED_MODULE_6__.diffFilter)\\n            .shouldHaveResult());\\n        this.processor.pipe(new _pipe_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"]('patch')\\n            .append(_filters_nested_js__WEBPACK_IMPORTED_MODULE_2__.collectChildrenPatchFilter, _filters_arrays_js__WEBPACK_IMPORTED_MODULE_6__.collectChildrenPatchFilter, _filters_trivial_js__WEBPACK_IMPORTED_MODULE_3__.patchFilter, _filters_texts_js__WEBPACK_IMPORTED_MODULE_5__.patchFilter, _filters_nested_js__WEBPACK_IMPORTED_MODULE_2__.patchFilter, _filters_arrays_js__WEBPACK_IMPORTED_MODULE_6__.patchFilter)\\n            .shouldHaveResult());\\n        this.processor.pipe(new _pipe_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"]('reverse')\\n            .append(_filters_nested_js__WEBPACK_IMPORTED_MODULE_2__.collectChildrenReverseFilter, _filters_arrays_js__WEBPACK_IMPORTED_MODULE_6__.collectChildrenReverseFilter, _filters_trivial_js__WEBPACK_IMPORTED_MODULE_3__.reverseFilter, _filters_texts_js__WEBPACK_IMPORTED_MODULE_5__.reverseFilter, _filters_nested_js__WEBPACK_IMPORTED_MODULE_2__.reverseFilter, _filters_arrays_js__WEBPACK_IMPORTED_MODULE_6__.reverseFilter)\\n            .shouldHaveResult());\\n    }\\n    options(options) {\\n        return this.processor.options(options);\\n    }\\n    diff(left, right) {\\n        return this.processor.process(new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"](left, right));\\n    }\\n    patch(left, delta) {\\n        return this.processor.process(new _contexts_patch_js__WEBPACK_IMPORTED_MODULE_8__[\\\"default\\\"](left, delta));\\n    }\\n    reverse(delta) {\\n        return this.processor.process(new _contexts_reverse_js__WEBPACK_IMPORTED_MODULE_9__[\\\"default\\\"](delta));\\n    }\\n    unpatch(right, delta) {\\n        return this.patch(right, this.reverse(delta));\\n    }\\n    clone(value) {\\n        return (0,_clone_js__WEBPACK_IMPORTED_MODULE_10__[\\\"default\\\"])(value);\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DiffPatcher);\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/diffpatcher.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/filters/arrays.js\":\n/*!**************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/filters/arrays.js ***!\n  \\**************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   collectChildrenPatchFilter: () => (/* binding */ collectChildrenPatchFilter),\\n/* harmony export */   collectChildrenReverseFilter: () => (/* binding */ collectChildrenReverseFilter),\\n/* harmony export */   diffFilter: () => (/* binding */ diffFilter),\\n/* harmony export */   patchFilter: () => (/* binding */ patchFilter),\\n/* harmony export */   reverseFilter: () => (/* binding */ reverseFilter)\\n/* harmony export */ });\\n/* harmony import */ var _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contexts/diff.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/diff.js\\\");\\n/* harmony import */ var _contexts_patch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/patch.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/patch.js\\\");\\n/* harmony import */ var _contexts_reverse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../contexts/reverse.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/reverse.js\\\");\\n/* harmony import */ var _lcs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lcs.js */ \\\"../../node_modules/jsondiffpatch/lib/filters/lcs.js\\\");\\n\\n\\n\\n\\nconst ARRAY_MOVE = 3;\\nfunction arraysHaveMatchByRef(array1, array2, len1, len2) {\\n    for (let index1 = 0; index1 < len1; index1++) {\\n        const val1 = array1[index1];\\n        for (let index2 = 0; index2 < len2; index2++) {\\n            const val2 = array2[index2];\\n            if (index1 !== index2 && val1 === val2) {\\n                return true;\\n            }\\n        }\\n    }\\n}\\nfunction matchItems(array1, array2, index1, index2, context) {\\n    const value1 = array1[index1];\\n    const value2 = array2[index2];\\n    if (value1 === value2) {\\n        return true;\\n    }\\n    if (typeof value1 !== 'object' || typeof value2 !== 'object') {\\n        return false;\\n    }\\n    const objectHash = context.objectHash;\\n    if (!objectHash) {\\n        // no way to match objects was provided, try match by position\\n        return context.matchByPosition && index1 === index2;\\n    }\\n    context.hashCache1 = context.hashCache1 || [];\\n    let hash1 = context.hashCache1[index1];\\n    if (typeof hash1 === 'undefined') {\\n        context.hashCache1[index1] = hash1 = objectHash(value1, index1);\\n    }\\n    if (typeof hash1 === 'undefined') {\\n        return false;\\n    }\\n    context.hashCache2 = context.hashCache2 || [];\\n    let hash2 = context.hashCache2[index2];\\n    if (typeof hash2 === 'undefined') {\\n        context.hashCache2[index2] = hash2 = objectHash(value2, index2);\\n    }\\n    if (typeof hash2 === 'undefined') {\\n        return false;\\n    }\\n    return hash1 === hash2;\\n}\\nconst diffFilter = function arraysDiffFilter(context) {\\n    if (!context.leftIsArray) {\\n        return;\\n    }\\n    const matchContext = {\\n        objectHash: context.options && context.options.objectHash,\\n        matchByPosition: context.options && context.options.matchByPosition,\\n    };\\n    let commonHead = 0;\\n    let commonTail = 0;\\n    let index;\\n    let index1;\\n    let index2;\\n    const array1 = context.left;\\n    const array2 = context.right;\\n    const len1 = array1.length;\\n    const len2 = array2.length;\\n    let child;\\n    if (len1 > 0 &&\\n        len2 > 0 &&\\n        !matchContext.objectHash &&\\n        typeof matchContext.matchByPosition !== 'boolean') {\\n        matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);\\n    }\\n    // separate common head\\n    while (commonHead < len1 &&\\n        commonHead < len2 &&\\n        matchItems(array1, array2, commonHead, commonHead, matchContext)) {\\n        index = commonHead;\\n        child = new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](array1[index], array2[index]);\\n        context.push(child, index);\\n        commonHead++;\\n    }\\n    // separate common tail\\n    while (commonTail + commonHead < len1 &&\\n        commonTail + commonHead < len2 &&\\n        matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {\\n        index1 = len1 - 1 - commonTail;\\n        index2 = len2 - 1 - commonTail;\\n        child = new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](array1[index1], array2[index2]);\\n        context.push(child, index2);\\n        commonTail++;\\n    }\\n    let result;\\n    if (commonHead + commonTail === len1) {\\n        if (len1 === len2) {\\n            // arrays are identical\\n            context.setResult(undefined).exit();\\n            return;\\n        }\\n        // trivial case, a block (1 or more consecutive items) was added\\n        result = result || {\\n            _t: 'a',\\n        };\\n        for (index = commonHead; index < len2 - commonTail; index++) {\\n            result[index] = [array2[index]];\\n        }\\n        context.setResult(result).exit();\\n        return;\\n    }\\n    if (commonHead + commonTail === len2) {\\n        // trivial case, a block (1 or more consecutive items) was removed\\n        result = result || {\\n            _t: 'a',\\n        };\\n        for (index = commonHead; index < len1 - commonTail; index++) {\\n            result[`_${index}`] = [array1[index], 0, 0];\\n        }\\n        context.setResult(result).exit();\\n        return;\\n    }\\n    // reset hash cache\\n    delete matchContext.hashCache1;\\n    delete matchContext.hashCache2;\\n    // diff is not trivial, find the LCS (Longest Common Subsequence)\\n    const trimmed1 = array1.slice(commonHead, len1 - commonTail);\\n    const trimmed2 = array2.slice(commonHead, len2 - commonTail);\\n    const seq = _lcs_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"].get(trimmed1, trimmed2, matchItems, matchContext);\\n    const removedItems = [];\\n    result = result || {\\n        _t: 'a',\\n    };\\n    for (index = commonHead; index < len1 - commonTail; index++) {\\n        if (seq.indices1.indexOf(index - commonHead) < 0) {\\n            // removed\\n            result[`_${index}`] = [array1[index], 0, 0];\\n            removedItems.push(index);\\n        }\\n    }\\n    let detectMove = true;\\n    if (context.options &&\\n        context.options.arrays &&\\n        context.options.arrays.detectMove === false) {\\n        detectMove = false;\\n    }\\n    let includeValueOnMove = false;\\n    if (context.options &&\\n        context.options.arrays &&\\n        context.options.arrays.includeValueOnMove) {\\n        includeValueOnMove = true;\\n    }\\n    const removedItemsLength = removedItems.length;\\n    for (index = commonHead; index < len2 - commonTail; index++) {\\n        const indexOnArray2 = seq.indices2.indexOf(index - commonHead);\\n        if (indexOnArray2 < 0) {\\n            // added, try to match with a removed item and register as position move\\n            let isMove = false;\\n            if (detectMove && removedItemsLength > 0) {\\n                for (let removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {\\n                    index1 = removedItems[removeItemIndex1];\\n                    if (matchItems(trimmed1, trimmed2, index1 - commonHead, index - commonHead, matchContext)) {\\n                        // store position move as: [originalValue, newPosition, ARRAY_MOVE]\\n                        result[`_${index1}`].splice(1, 2, index, ARRAY_MOVE);\\n                        if (!includeValueOnMove) {\\n                            // don't include moved value on diff, to save bytes\\n                            result[`_${index1}`][0] = '';\\n                        }\\n                        index2 = index;\\n                        child = new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](array1[index1], array2[index2]);\\n                        context.push(child, index2);\\n                        removedItems.splice(removeItemIndex1, 1);\\n                        isMove = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            if (!isMove) {\\n                // added\\n                result[index] = [array2[index]];\\n            }\\n        }\\n        else {\\n            // match, do inner diff\\n            index1 = seq.indices1[indexOnArray2] + commonHead;\\n            index2 = seq.indices2[indexOnArray2] + commonHead;\\n            child = new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](array1[index1], array2[index2]);\\n            context.push(child, index2);\\n        }\\n    }\\n    context.setResult(result).exit();\\n};\\ndiffFilter.filterName = 'arrays';\\nconst compare = {\\n    numerically(a, b) {\\n        return a - b;\\n    },\\n    numericallyBy(name) {\\n        return (a, b) => a[name] - b[name];\\n    },\\n};\\nconst patchFilter = function nestedPatchFilter(context) {\\n    if (!context.nested) {\\n        return;\\n    }\\n    const nestedDelta = context.delta;\\n    if (nestedDelta._t !== 'a') {\\n        return;\\n    }\\n    let index;\\n    let index1;\\n    const delta = nestedDelta;\\n    const array = context.left;\\n    // first, separate removals, insertions and modifications\\n    let toRemove = [];\\n    let toInsert = [];\\n    const toModify = [];\\n    for (index in delta) {\\n        if (index !== '_t') {\\n            if (index[0] === '_') {\\n                const removedOrMovedIndex = index;\\n                // removed item from original array\\n                if (delta[removedOrMovedIndex][2] === 0 ||\\n                    delta[removedOrMovedIndex][2] === ARRAY_MOVE) {\\n                    toRemove.push(parseInt(index.slice(1), 10));\\n                }\\n                else {\\n                    throw new Error('only removal or move can be applied at original array indices,' +\\n                        ` invalid diff type: ${delta[removedOrMovedIndex][2]}`);\\n                }\\n            }\\n            else {\\n                const numberIndex = index;\\n                if (delta[numberIndex].length === 1) {\\n                    // added item at new array\\n                    toInsert.push({\\n                        index: parseInt(numberIndex, 10),\\n                        value: delta[numberIndex][0],\\n                    });\\n                }\\n                else {\\n                    // modified item at new array\\n                    toModify.push({\\n                        index: parseInt(numberIndex, 10),\\n                        delta: delta[numberIndex],\\n                    });\\n                }\\n            }\\n        }\\n    }\\n    // remove items, in reverse order to avoid sawing our own floor\\n    toRemove = toRemove.sort(compare.numerically);\\n    for (index = toRemove.length - 1; index >= 0; index--) {\\n        index1 = toRemove[index];\\n        const indexDiff = delta[`_${index1}`];\\n        const removedValue = array.splice(index1, 1)[0];\\n        if (indexDiff[2] === ARRAY_MOVE) {\\n            // reinsert later\\n            toInsert.push({\\n                index: indexDiff[1],\\n                value: removedValue,\\n            });\\n        }\\n    }\\n    // insert items, in reverse order to avoid moving our own floor\\n    toInsert = toInsert.sort(compare.numericallyBy('index'));\\n    const toInsertLength = toInsert.length;\\n    for (index = 0; index < toInsertLength; index++) {\\n        const insertion = toInsert[index];\\n        array.splice(insertion.index, 0, insertion.value);\\n    }\\n    // apply modifications\\n    const toModifyLength = toModify.length;\\n    let child;\\n    if (toModifyLength > 0) {\\n        for (index = 0; index < toModifyLength; index++) {\\n            const modification = toModify[index];\\n            child = new _contexts_patch_js__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"](array[modification.index], modification.delta);\\n            context.push(child, modification.index);\\n        }\\n    }\\n    if (!context.children) {\\n        context.setResult(array).exit();\\n        return;\\n    }\\n    context.exit();\\n};\\npatchFilter.filterName = 'arrays';\\nconst collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\\n    if (!context || !context.children) {\\n        return;\\n    }\\n    const deltaWithChildren = context.delta;\\n    if (deltaWithChildren._t !== 'a') {\\n        return;\\n    }\\n    const array = context.left;\\n    const length = context.children.length;\\n    let child;\\n    for (let index = 0; index < length; index++) {\\n        child = context.children[index];\\n        const arrayIndex = child.childName;\\n        array[arrayIndex] = child.result;\\n    }\\n    context.setResult(array).exit();\\n};\\ncollectChildrenPatchFilter.filterName = 'arraysCollectChildren';\\nconst reverseFilter = function arraysReverseFilter(context) {\\n    if (!context.nested) {\\n        const nonNestedDelta = context.delta;\\n        if (nonNestedDelta[2] === ARRAY_MOVE) {\\n            const arrayMoveDelta = nonNestedDelta;\\n            context.newName = `_${arrayMoveDelta[1]}`;\\n            context\\n                .setResult([\\n                arrayMoveDelta[0],\\n                parseInt(context.childName.substring(1), 10),\\n                ARRAY_MOVE,\\n            ])\\n                .exit();\\n        }\\n        return;\\n    }\\n    const nestedDelta = context.delta;\\n    if (nestedDelta._t !== 'a') {\\n        return;\\n    }\\n    const arrayDelta = nestedDelta;\\n    let name;\\n    let child;\\n    for (name in arrayDelta) {\\n        if (name === '_t') {\\n            continue;\\n        }\\n        child = new _contexts_reverse_js__WEBPACK_IMPORTED_MODULE_3__[\\\"default\\\"](arrayDelta[name]);\\n        context.push(child, name);\\n    }\\n    context.exit();\\n};\\nreverseFilter.filterName = 'arrays';\\nconst reverseArrayDeltaIndex = (delta, index, itemDelta) => {\\n    if (typeof index === 'string' && index[0] === '_') {\\n        return parseInt(index.substring(1), 10);\\n    }\\n    else if (Array.isArray(itemDelta) && itemDelta[2] === 0) {\\n        return `_${index}`;\\n    }\\n    let reverseIndex = +index;\\n    for (const deltaIndex in delta) {\\n        const deltaItem = delta[deltaIndex];\\n        if (Array.isArray(deltaItem)) {\\n            if (deltaItem[2] === ARRAY_MOVE) {\\n                const moveFromIndex = parseInt(deltaIndex.substring(1), 10);\\n                const moveToIndex = deltaItem[1];\\n                if (moveToIndex === +index) {\\n                    return moveFromIndex;\\n                }\\n                if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {\\n                    reverseIndex++;\\n                }\\n                else if (moveFromIndex >= reverseIndex &&\\n                    moveToIndex < reverseIndex) {\\n                    reverseIndex--;\\n                }\\n            }\\n            else if (deltaItem[2] === 0) {\\n                const deleteIndex = parseInt(deltaIndex.substring(1), 10);\\n                if (deleteIndex <= reverseIndex) {\\n                    reverseIndex++;\\n                }\\n            }\\n            else if (deltaItem.length === 1 &&\\n                parseInt(deltaIndex, 10) <= reverseIndex) {\\n                reverseIndex--;\\n            }\\n        }\\n    }\\n    return reverseIndex;\\n};\\nconst collectChildrenReverseFilter = (context) => {\\n    if (!context || !context.children) {\\n        return;\\n    }\\n    const deltaWithChildren = context.delta;\\n    if (deltaWithChildren._t !== 'a') {\\n        return;\\n    }\\n    const arrayDelta = deltaWithChildren;\\n    const length = context.children.length;\\n    let child;\\n    const delta = {\\n        _t: 'a',\\n    };\\n    for (let index = 0; index < length; index++) {\\n        child = context.children[index];\\n        let name = child.newName;\\n        if (typeof name === 'undefined') {\\n            name = reverseArrayDeltaIndex(arrayDelta, child.childName, child.result);\\n        }\\n        if (delta[name] !== child.result) {\\n            // There's no way to type this well.\\n            delta[name] = child.result;\\n        }\\n    }\\n    context.setResult(delta).exit();\\n};\\ncollectChildrenReverseFilter.filterName = 'arraysCollectChildren';\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/filters/arrays.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/filters/dates.js\":\n/*!*************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/filters/dates.js ***!\n  \\*************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   diffFilter: () => (/* binding */ diffFilter)\\n/* harmony export */ });\\nconst diffFilter = function datesDiffFilter(context) {\\n    if (context.left instanceof Date) {\\n        if (context.right instanceof Date) {\\n            if (context.left.getTime() !== context.right.getTime()) {\\n                context.setResult([context.left, context.right]);\\n            }\\n            else {\\n                context.setResult(undefined);\\n            }\\n        }\\n        else {\\n            context.setResult([context.left, context.right]);\\n        }\\n        context.exit();\\n    }\\n    else if (context.right instanceof Date) {\\n        context.setResult([context.left, context.right]).exit();\\n    }\\n};\\ndiffFilter.filterName = 'dates';\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/filters/dates.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/filters/lcs.js\":\n/*!***********************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/filters/lcs.js ***!\n  \\***********************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/*\\n\\nLCS implementation that supports arrays or strings\\n\\nreference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem\\n\\n*/\\nconst defaultMatch = function (array1, array2, index1, index2) {\\n    return array1[index1] === array2[index2];\\n};\\nconst lengthMatrix = function (array1, array2, match, context) {\\n    const len1 = array1.length;\\n    const len2 = array2.length;\\n    let x, y;\\n    // initialize empty matrix of len1+1 x len2+1\\n    const matrix = new Array(len1 + 1);\\n    for (x = 0; x < len1 + 1; x++) {\\n        matrix[x] = new Array(len2 + 1);\\n        for (y = 0; y < len2 + 1; y++) {\\n            matrix[x][y] = 0;\\n        }\\n    }\\n    matrix.match = match;\\n    // save sequence lengths for each coordinate\\n    for (x = 1; x < len1 + 1; x++) {\\n        for (y = 1; y < len2 + 1; y++) {\\n            if (match(array1, array2, x - 1, y - 1, context)) {\\n                matrix[x][y] = matrix[x - 1][y - 1] + 1;\\n            }\\n            else {\\n                matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);\\n            }\\n        }\\n    }\\n    return matrix;\\n};\\nconst backtrack = function (matrix, array1, array2, context) {\\n    let index1 = array1.length;\\n    let index2 = array2.length;\\n    const subsequence = {\\n        sequence: [],\\n        indices1: [],\\n        indices2: [],\\n    };\\n    while (index1 !== 0 && index2 !== 0) {\\n        const sameLetter = matrix.match(array1, array2, index1 - 1, index2 - 1, context);\\n        if (sameLetter) {\\n            subsequence.sequence.unshift(array1[index1 - 1]);\\n            subsequence.indices1.unshift(index1 - 1);\\n            subsequence.indices2.unshift(index2 - 1);\\n            --index1;\\n            --index2;\\n        }\\n        else {\\n            const valueAtMatrixAbove = matrix[index1][index2 - 1];\\n            const valueAtMatrixLeft = matrix[index1 - 1][index2];\\n            if (valueAtMatrixAbove > valueAtMatrixLeft) {\\n                --index2;\\n            }\\n            else {\\n                --index1;\\n            }\\n        }\\n    }\\n    return subsequence;\\n};\\nconst get = function (array1, array2, match, context) {\\n    const innerContext = context || {};\\n    const matrix = lengthMatrix(array1, array2, match || defaultMatch, innerContext);\\n    return backtrack(matrix, array1, array2, innerContext);\\n};\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\\n    get,\\n});\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/filters/lcs.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/filters/nested.js\":\n/*!**************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/filters/nested.js ***!\n  \\**************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   collectChildrenDiffFilter: () => (/* binding */ collectChildrenDiffFilter),\\n/* harmony export */   collectChildrenPatchFilter: () => (/* binding */ collectChildrenPatchFilter),\\n/* harmony export */   collectChildrenReverseFilter: () => (/* binding */ collectChildrenReverseFilter),\\n/* harmony export */   objectsDiffFilter: () => (/* binding */ objectsDiffFilter),\\n/* harmony export */   patchFilter: () => (/* binding */ patchFilter),\\n/* harmony export */   reverseFilter: () => (/* binding */ reverseFilter)\\n/* harmony export */ });\\n/* harmony import */ var _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contexts/diff.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/diff.js\\\");\\n/* harmony import */ var _contexts_patch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../contexts/patch.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/patch.js\\\");\\n/* harmony import */ var _contexts_reverse_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../contexts/reverse.js */ \\\"../../node_modules/jsondiffpatch/lib/contexts/reverse.js\\\");\\n\\n\\n\\nconst collectChildrenDiffFilter = (context) => {\\n    if (!context || !context.children) {\\n        return;\\n    }\\n    const length = context.children.length;\\n    let child;\\n    let result = context.result;\\n    for (let index = 0; index < length; index++) {\\n        child = context.children[index];\\n        if (typeof child.result === 'undefined') {\\n            continue;\\n        }\\n        result = result || {};\\n        result[child.childName] = child.result;\\n    }\\n    if (result && context.leftIsArray) {\\n        result._t = 'a';\\n    }\\n    context.setResult(result).exit();\\n};\\ncollectChildrenDiffFilter.filterName = 'collectChildren';\\nconst objectsDiffFilter = (context) => {\\n    if (context.leftIsArray || context.leftType !== 'object') {\\n        return;\\n    }\\n    const left = context.left;\\n    const right = context.right;\\n    let name;\\n    let child;\\n    const propertyFilter = context.options.propertyFilter;\\n    for (name in left) {\\n        if (!Object.prototype.hasOwnProperty.call(left, name)) {\\n            continue;\\n        }\\n        if (propertyFilter && !propertyFilter(name, context)) {\\n            continue;\\n        }\\n        child = new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](left[name], right[name]);\\n        context.push(child, name);\\n    }\\n    for (name in right) {\\n        if (!Object.prototype.hasOwnProperty.call(right, name)) {\\n            continue;\\n        }\\n        if (propertyFilter && !propertyFilter(name, context)) {\\n            continue;\\n        }\\n        if (typeof left[name] === 'undefined') {\\n            child = new _contexts_diff_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](undefined, right[name]);\\n            context.push(child, name);\\n        }\\n    }\\n    if (!context.children || context.children.length === 0) {\\n        context.setResult(undefined).exit();\\n        return;\\n    }\\n    context.exit();\\n};\\nobjectsDiffFilter.filterName = 'objects';\\nconst patchFilter = function nestedPatchFilter(context) {\\n    if (!context.nested) {\\n        return;\\n    }\\n    const nestedDelta = context.delta;\\n    if (nestedDelta._t) {\\n        return;\\n    }\\n    const objectDelta = nestedDelta;\\n    let name;\\n    let child;\\n    for (name in objectDelta) {\\n        child = new _contexts_patch_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"](context.left[name], objectDelta[name]);\\n        context.push(child, name);\\n    }\\n    context.exit();\\n};\\npatchFilter.filterName = 'objects';\\nconst collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {\\n    if (!context || !context.children) {\\n        return;\\n    }\\n    const deltaWithChildren = context.delta;\\n    if (deltaWithChildren._t) {\\n        return;\\n    }\\n    const object = context.left;\\n    const length = context.children.length;\\n    let child;\\n    for (let index = 0; index < length; index++) {\\n        child = context.children[index];\\n        const property = child.childName;\\n        if (Object.prototype.hasOwnProperty.call(context.left, property) &&\\n            child.result === undefined) {\\n            delete object[property];\\n        }\\n        else if (object[property] !== child.result) {\\n            object[property] = child.result;\\n        }\\n    }\\n    context.setResult(object).exit();\\n};\\ncollectChildrenPatchFilter.filterName = 'collectChildren';\\nconst reverseFilter = function nestedReverseFilter(context) {\\n    if (!context.nested) {\\n        return;\\n    }\\n    const nestedDelta = context.delta;\\n    if (nestedDelta._t) {\\n        return;\\n    }\\n    const objectDelta = context.delta;\\n    let name;\\n    let child;\\n    for (name in objectDelta) {\\n        child = new _contexts_reverse_js__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"](objectDelta[name]);\\n        context.push(child, name);\\n    }\\n    context.exit();\\n};\\nreverseFilter.filterName = 'objects';\\nconst collectChildrenReverseFilter = (context) => {\\n    if (!context || !context.children) {\\n        return;\\n    }\\n    const deltaWithChildren = context.delta;\\n    if (deltaWithChildren._t) {\\n        return;\\n    }\\n    const length = context.children.length;\\n    let child;\\n    const delta = {};\\n    for (let index = 0; index < length; index++) {\\n        child = context.children[index];\\n        const property = child.childName;\\n        if (delta[property] !== child.result) {\\n            delta[property] = child.result;\\n        }\\n    }\\n    context.setResult(delta).exit();\\n};\\ncollectChildrenReverseFilter.filterName = 'collectChildren';\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/filters/nested.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/filters/texts.js\":\n/*!*************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/filters/texts.js ***!\n  \\*************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   diffFilter: () => (/* binding */ diffFilter),\\n/* harmony export */   patchFilter: () => (/* binding */ patchFilter),\\n/* harmony export */   reverseFilter: () => (/* binding */ reverseFilter)\\n/* harmony export */ });\\nconst TEXT_DIFF = 2;\\nconst DEFAULT_MIN_LENGTH = 60;\\nlet cachedDiffPatch = null;\\nfunction getDiffMatchPatch(options, required) {\\n    var _a;\\n    if (!cachedDiffPatch) {\\n        let instance;\\n        if ((_a = options === null || options === void 0 ? void 0 : options.textDiff) === null || _a === void 0 ? void 0 : _a.diffMatchPatch) {\\n            instance = new options.textDiff.diffMatchPatch();\\n        }\\n        else {\\n            if (!required) {\\n                return null;\\n            }\\n            const error = new Error('The diff-match-patch library was not provided. Pass the library in through the options or use the `jsondiffpatch/with-text-diffs` entry-point.');\\n            // eslint-disable-next-line camelcase\\n            error.diff_match_patch_not_found = true;\\n            throw error;\\n        }\\n        cachedDiffPatch = {\\n            diff: function (txt1, txt2) {\\n                return instance.patch_toText(instance.patch_make(txt1, txt2));\\n            },\\n            patch: function (txt1, patch) {\\n                const results = instance.patch_apply(instance.patch_fromText(patch), txt1);\\n                for (let i = 0; i < results[1].length; i++) {\\n                    if (!results[1][i]) {\\n                        const error = new Error('text patch failed');\\n                        error.textPatchFailed = true;\\n                    }\\n                }\\n                return results[0];\\n            },\\n        };\\n    }\\n    return cachedDiffPatch;\\n}\\nconst diffFilter = function textsDiffFilter(context) {\\n    if (context.leftType !== 'string') {\\n        return;\\n    }\\n    const left = context.left;\\n    const right = context.right;\\n    const minLength = (context.options &&\\n        context.options.textDiff &&\\n        context.options.textDiff.minLength) ||\\n        DEFAULT_MIN_LENGTH;\\n    if (left.length < minLength || right.length < minLength) {\\n        context.setResult([left, right]).exit();\\n        return;\\n    }\\n    // large text, try to use a text-diff algorithm\\n    const diffMatchPatch = getDiffMatchPatch(context.options);\\n    if (!diffMatchPatch) {\\n        // diff-match-patch library not available,\\n        // fallback to regular string replace\\n        context.setResult([left, right]).exit();\\n        return;\\n    }\\n    const diff = diffMatchPatch.diff;\\n    context.setResult([diff(left, right), 0, TEXT_DIFF]).exit();\\n};\\ndiffFilter.filterName = 'texts';\\nconst patchFilter = function textsPatchFilter(context) {\\n    if (context.nested) {\\n        return;\\n    }\\n    const nonNestedDelta = context.delta;\\n    if (nonNestedDelta[2] !== TEXT_DIFF) {\\n        return;\\n    }\\n    const textDiffDelta = nonNestedDelta;\\n    // text-diff, use a text-patch algorithm\\n    const patch = getDiffMatchPatch(context.options, true).patch;\\n    context.setResult(patch(context.left, textDiffDelta[0])).exit();\\n};\\npatchFilter.filterName = 'texts';\\nconst textDeltaReverse = function (delta) {\\n    let i;\\n    let l;\\n    let line;\\n    let lineTmp;\\n    let header = null;\\n    const headerRegex = /^@@ +-(\\\\d+),(\\\\d+) +\\\\+(\\\\d+),(\\\\d+) +@@$/;\\n    let lineHeader;\\n    const lines = delta.split('\\\\n');\\n    for (i = 0, l = lines.length; i < l; i++) {\\n        line = lines[i];\\n        const lineStart = line.slice(0, 1);\\n        if (lineStart === '@') {\\n            header = headerRegex.exec(line);\\n            lineHeader = i;\\n            // fix header\\n            lines[lineHeader] =\\n                '@@ -' +\\n                    header[3] +\\n                    ',' +\\n                    header[4] +\\n                    ' +' +\\n                    header[1] +\\n                    ',' +\\n                    header[2] +\\n                    ' @@';\\n        }\\n        else if (lineStart === '+') {\\n            lines[i] = '-' + lines[i].slice(1);\\n            if (lines[i - 1].slice(0, 1) === '+') {\\n                // swap lines to keep default order (-+)\\n                lineTmp = lines[i];\\n                lines[i] = lines[i - 1];\\n                lines[i - 1] = lineTmp;\\n            }\\n        }\\n        else if (lineStart === '-') {\\n            lines[i] = '+' + lines[i].slice(1);\\n        }\\n    }\\n    return lines.join('\\\\n');\\n};\\nconst reverseFilter = function textsReverseFilter(context) {\\n    if (context.nested) {\\n        return;\\n    }\\n    const nonNestedDelta = context.delta;\\n    if (nonNestedDelta[2] !== TEXT_DIFF) {\\n        return;\\n    }\\n    const textDiffDelta = nonNestedDelta;\\n    // text-diff, use a text-diff algorithm\\n    context\\n        .setResult([textDeltaReverse(textDiffDelta[0]), 0, TEXT_DIFF])\\n        .exit();\\n};\\nreverseFilter.filterName = 'texts';\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/filters/texts.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/filters/trivial.js\":\n/*!***************************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/filters/trivial.js ***!\n  \\***************************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   diffFilter: () => (/* binding */ diffFilter),\\n/* harmony export */   patchFilter: () => (/* binding */ patchFilter),\\n/* harmony export */   reverseFilter: () => (/* binding */ reverseFilter)\\n/* harmony export */ });\\nconst diffFilter = function trivialMatchesDiffFilter(context) {\\n    if (context.left === context.right) {\\n        context.setResult(undefined).exit();\\n        return;\\n    }\\n    if (typeof context.left === 'undefined') {\\n        if (typeof context.right === 'function') {\\n            throw new Error('functions are not supported');\\n        }\\n        context.setResult([context.right]).exit();\\n        return;\\n    }\\n    if (typeof context.right === 'undefined') {\\n        context.setResult([context.left, 0, 0]).exit();\\n        return;\\n    }\\n    if (typeof context.left === 'function' ||\\n        typeof context.right === 'function') {\\n        throw new Error('functions are not supported');\\n    }\\n    context.leftType = context.left === null ? 'null' : typeof context.left;\\n    context.rightType = context.right === null ? 'null' : typeof context.right;\\n    if (context.leftType !== context.rightType) {\\n        context.setResult([context.left, context.right]).exit();\\n        return;\\n    }\\n    if (context.leftType === 'boolean' || context.leftType === 'number') {\\n        context.setResult([context.left, context.right]).exit();\\n        return;\\n    }\\n    if (context.leftType === 'object') {\\n        context.leftIsArray = Array.isArray(context.left);\\n    }\\n    if (context.rightType === 'object') {\\n        context.rightIsArray = Array.isArray(context.right);\\n    }\\n    if (context.leftIsArray !== context.rightIsArray) {\\n        context.setResult([context.left, context.right]).exit();\\n        return;\\n    }\\n    if (context.left instanceof RegExp) {\\n        if (context.right instanceof RegExp) {\\n            context\\n                .setResult([context.left.toString(), context.right.toString()])\\n                .exit();\\n        }\\n        else {\\n            context.setResult([context.left, context.right]).exit();\\n        }\\n    }\\n};\\ndiffFilter.filterName = 'trivial';\\nconst patchFilter = function trivialMatchesPatchFilter(context) {\\n    if (typeof context.delta === 'undefined') {\\n        context.setResult(context.left).exit();\\n        return;\\n    }\\n    context.nested = !Array.isArray(context.delta);\\n    if (context.nested) {\\n        return;\\n    }\\n    const nonNestedDelta = context.delta;\\n    if (nonNestedDelta.length === 1) {\\n        context.setResult(nonNestedDelta[0]).exit();\\n        return;\\n    }\\n    if (nonNestedDelta.length === 2) {\\n        if (context.left instanceof RegExp) {\\n            const regexArgs = /^\\\\/(.*)\\\\/([gimyu]+)$/.exec(nonNestedDelta[1]);\\n            if (regexArgs) {\\n                context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();\\n                return;\\n            }\\n        }\\n        context.setResult(nonNestedDelta[1]).exit();\\n        return;\\n    }\\n    if (nonNestedDelta.length === 3 && nonNestedDelta[2] === 0) {\\n        context.setResult(undefined).exit();\\n    }\\n};\\npatchFilter.filterName = 'trivial';\\nconst reverseFilter = function trivialReferseFilter(context) {\\n    if (typeof context.delta === 'undefined') {\\n        context.setResult(context.delta).exit();\\n        return;\\n    }\\n    context.nested = !Array.isArray(context.delta);\\n    if (context.nested) {\\n        return;\\n    }\\n    const nonNestedDelta = context.delta;\\n    if (nonNestedDelta.length === 1) {\\n        context.setResult([nonNestedDelta[0], 0, 0]).exit();\\n        return;\\n    }\\n    if (nonNestedDelta.length === 2) {\\n        context.setResult([nonNestedDelta[1], nonNestedDelta[0]]).exit();\\n        return;\\n    }\\n    if (nonNestedDelta.length === 3 && nonNestedDelta[2] === 0) {\\n        context.setResult([nonNestedDelta[0]]).exit();\\n    }\\n};\\nreverseFilter.filterName = 'trivial';\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/filters/trivial.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/index.js\":\n/*!*****************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/index.js ***!\n  \\*****************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   DiffPatcher: () => (/* reexport safe */ _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]),\\n/* harmony export */   clone: () => (/* binding */ clone),\\n/* harmony export */   create: () => (/* binding */ create),\\n/* harmony export */   dateReviver: () => (/* reexport safe */ _date_reviver_js__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"]),\\n/* harmony export */   diff: () => (/* binding */ diff),\\n/* harmony export */   patch: () => (/* binding */ patch),\\n/* harmony export */   reverse: () => (/* binding */ reverse),\\n/* harmony export */   unpatch: () => (/* binding */ unpatch)\\n/* harmony export */ });\\n/* harmony import */ var _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diffpatcher.js */ \\\"../../node_modules/jsondiffpatch/lib/diffpatcher.js\\\");\\n/* harmony import */ var _date_reviver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./date-reviver.js */ \\\"../../node_modules/jsondiffpatch/lib/date-reviver.js\\\");\\n\\n\\n\\nfunction create(options) {\\n    return new _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"](options);\\n}\\nlet defaultInstance;\\nfunction diff(left, right) {\\n    if (!defaultInstance) {\\n        defaultInstance = new _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]();\\n    }\\n    return defaultInstance.diff(left, right);\\n}\\nfunction patch(left, delta) {\\n    if (!defaultInstance) {\\n        defaultInstance = new _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]();\\n    }\\n    return defaultInstance.patch(left, delta);\\n}\\nfunction unpatch(right, delta) {\\n    if (!defaultInstance) {\\n        defaultInstance = new _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]();\\n    }\\n    return defaultInstance.unpatch(right, delta);\\n}\\nfunction reverse(delta) {\\n    if (!defaultInstance) {\\n        defaultInstance = new _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]();\\n    }\\n    return defaultInstance.reverse(delta);\\n}\\nfunction clone(value) {\\n    if (!defaultInstance) {\\n        defaultInstance = new _diffpatcher_js__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"]();\\n    }\\n    return defaultInstance.clone(value);\\n}\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/index.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/pipe.js\":\n/*!****************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/pipe.js ***!\n  \\****************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\nclass Pipe {\\n    constructor(name) {\\n        this.name = name;\\n        this.filters = [];\\n    }\\n    process(input) {\\n        if (!this.processor) {\\n            throw new Error('add this pipe to a processor before using it');\\n        }\\n        const debug = this.debug;\\n        const length = this.filters.length;\\n        const context = input;\\n        for (let index = 0; index < length; index++) {\\n            const filter = this.filters[index];\\n            if (debug) {\\n                this.log(`filter: ${filter.filterName}`);\\n            }\\n            filter(context);\\n            if (typeof context === 'object' && context.exiting) {\\n                context.exiting = false;\\n                break;\\n            }\\n        }\\n        if (!context.next && this.resultCheck) {\\n            this.resultCheck(context);\\n        }\\n    }\\n    log(msg) {\\n        console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`);\\n    }\\n    append(...args) {\\n        this.filters.push(...args);\\n        return this;\\n    }\\n    prepend(...args) {\\n        this.filters.unshift(...args);\\n        return this;\\n    }\\n    indexOf(filterName) {\\n        if (!filterName) {\\n            throw new Error('a filter name is required');\\n        }\\n        for (let index = 0; index < this.filters.length; index++) {\\n            const filter = this.filters[index];\\n            if (filter.filterName === filterName) {\\n                return index;\\n            }\\n        }\\n        throw new Error(`filter not found: ${filterName}`);\\n    }\\n    list() {\\n        return this.filters.map((f) => f.filterName);\\n    }\\n    after(filterName, ...params) {\\n        const index = this.indexOf(filterName);\\n        this.filters.splice(index + 1, 0, ...params);\\n        return this;\\n    }\\n    before(filterName, ...params) {\\n        const index = this.indexOf(filterName);\\n        this.filters.splice(index, 0, ...params);\\n        return this;\\n    }\\n    replace(filterName, ...params) {\\n        const index = this.indexOf(filterName);\\n        this.filters.splice(index, 1, ...params);\\n        return this;\\n    }\\n    remove(filterName) {\\n        const index = this.indexOf(filterName);\\n        this.filters.splice(index, 1);\\n        return this;\\n    }\\n    clear() {\\n        this.filters.length = 0;\\n        return this;\\n    }\\n    shouldHaveResult(should) {\\n        if (should === false) {\\n            this.resultCheck = null;\\n            return;\\n        }\\n        if (this.resultCheck) {\\n            return;\\n        }\\n        this.resultCheck = (context) => {\\n            if (!context.hasResult) {\\n                console.log(context);\\n                const error = new Error(`${this.name} failed`);\\n                error.noResult = true;\\n                throw error;\\n            }\\n        };\\n        return this;\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pipe);\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/pipe.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/jsondiffpatch/lib/processor.js\":\n/*!*********************************************************!*\\\n  !*** ../../node_modules/jsondiffpatch/lib/processor.js ***!\n  \\*********************************************************/\n/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {\n\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\nclass Processor {\\n    constructor(options) {\\n        this.selfOptions = options || {};\\n        this.pipes = {};\\n    }\\n    options(options) {\\n        if (options) {\\n            this.selfOptions = options;\\n        }\\n        return this.selfOptions;\\n    }\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    pipe(name, pipeArg) {\\n        let pipe = pipeArg;\\n        if (typeof name === 'string') {\\n            if (typeof pipe === 'undefined') {\\n                return this.pipes[name];\\n            }\\n            else {\\n                this.pipes[name] = pipe;\\n            }\\n        }\\n        if (name && name.name) {\\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n            pipe = name;\\n            if (pipe.processor === this) {\\n                return pipe;\\n            }\\n            this.pipes[pipe.name] = pipe;\\n        }\\n        pipe.processor = this;\\n        return pipe;\\n    }\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    process(input, pipe) {\\n        let context = input;\\n        context.options = this.options();\\n        let nextPipe = pipe || input.pipe || 'default';\\n        let lastPipe;\\n        while (nextPipe) {\\n            if (typeof context.nextAfterChildren !== 'undefined') {\\n                // children processed and coming back to parent\\n                context.next = context.nextAfterChildren;\\n                context.nextAfterChildren = null;\\n            }\\n            if (typeof nextPipe === 'string') {\\n                nextPipe = this.pipe(nextPipe);\\n            }\\n            nextPipe.process(context);\\n            lastPipe = nextPipe;\\n            nextPipe = null;\\n            if (context) {\\n                if (context.next) {\\n                    context = context.next;\\n                    nextPipe = context.pipe || lastPipe;\\n                }\\n            }\\n        }\\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\\n        return context.hasResult ? context.result : undefined;\\n    }\\n}\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Processor);\\n\\n\\n//# sourceURL=webpack:///../../node_modules/jsondiffpatch/lib/processor.js?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __webpack_require__(\"./entry.js\");\n/******/ \t\n/******/ })()\n;",
  "WFLs+cOgt9QinoIRTW6gGCsvbRtyBPeacj+pvS9G9zM=": "\n/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.pako = {}));\n  }(this, (function (exports) { 'use strict';\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\t/* eslint-disable space-unary-ops */\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n  \n\t//const Z_FILTERED          = 1;\n\t//const Z_HUFFMAN_ONLY      = 2;\n\t//const Z_RLE               = 3;\n\tconst Z_FIXED$1               = 4;\n\t//const Z_DEFAULT_STRATEGY  = 0;\n  \n\t/* Possible values of the data_type field (though see inflate()) */\n\tconst Z_BINARY              = 0;\n\tconst Z_TEXT                = 1;\n\t//const Z_ASCII             = 1; // = Z_TEXT\n\tconst Z_UNKNOWN$1             = 2;\n  \n\t/*============================================================================*/\n  \n  \n\tfunction zero$1(buf) { let len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n  \n\t// From zutil.h\n  \n\tconst STORED_BLOCK = 0;\n\tconst STATIC_TREES = 1;\n\tconst DYN_TREES    = 2;\n\t/* The three kinds of block type */\n  \n\tconst MIN_MATCH$1    = 3;\n\tconst MAX_MATCH$1    = 258;\n\t/* The minimum and maximum match lengths */\n  \n\t// From deflate.h\n\t/* ===========================================================================\n\t * Internal compression state.\n\t */\n  \n\tconst LENGTH_CODES$1  = 29;\n\t/* number of length codes, not counting the special END_BLOCK code */\n  \n\tconst LITERALS$1      = 256;\n\t/* number of literal bytes 0..255 */\n  \n\tconst L_CODES$1       = LITERALS$1 + 1 + LENGTH_CODES$1;\n\t/* number of Literal or Length codes, including the END_BLOCK code */\n  \n\tconst D_CODES$1       = 30;\n\t/* number of distance codes */\n  \n\tconst BL_CODES$1      = 19;\n\t/* number of codes used to transfer the bit lengths */\n  \n\tconst HEAP_SIZE$1     = 2 * L_CODES$1 + 1;\n\t/* maximum heap size */\n  \n\tconst MAX_BITS$1      = 15;\n\t/* All codes must not exceed MAX_BITS bits */\n  \n\tconst Buf_size      = 16;\n\t/* size of bit buffer in bi_buf */\n  \n  \n\t/* ===========================================================================\n\t * Constants\n\t */\n  \n\tconst MAX_BL_BITS = 7;\n\t/* Bit length codes must not exceed MAX_BL_BITS bits */\n  \n\tconst END_BLOCK   = 256;\n\t/* end of block literal code */\n  \n\tconst REP_3_6     = 16;\n\t/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n  \n\tconst REPZ_3_10   = 17;\n\t/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n  \n\tconst REPZ_11_138 = 18;\n\t/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n  \n\t/* eslint-disable comma-spacing,array-bracket-spacing */\n\tconst extra_lbits =   /* extra bits for each length code */\n\t  new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]);\n  \n\tconst extra_dbits =   /* extra bits for each distance code */\n\t  new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]);\n  \n\tconst extra_blbits =  /* extra bits for each bit length code */\n\t  new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]);\n  \n\tconst bl_order =\n\t  new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);\n\t/* eslint-enable comma-spacing,array-bracket-spacing */\n  \n\t/* The lengths of the bit length codes are sent in order of decreasing\n\t * probability, to avoid transmitting the lengths for unused bit length codes.\n\t */\n  \n\t/* ===========================================================================\n\t * Local data. These are initialized only once.\n\t */\n  \n\t// We pre-fill arrays with 0 to avoid uninitialized gaps\n  \n\tconst DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n  \n\t// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\n\tconst static_ltree  = new Array((L_CODES$1 + 2) * 2);\n\tzero$1(static_ltree);\n\t/* The static literal tree. Since the bit lengths are imposed, there is no\n\t * need for the L_CODES extra codes used during heap construction. However\n\t * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n\t * below).\n\t */\n  \n\tconst static_dtree  = new Array(D_CODES$1 * 2);\n\tzero$1(static_dtree);\n\t/* The static distance tree. (Actually a trivial tree since all codes use\n\t * 5 bits.)\n\t */\n  \n\tconst _dist_code    = new Array(DIST_CODE_LEN);\n\tzero$1(_dist_code);\n\t/* Distance codes. The first 256 values correspond to the distances\n\t * 3 .. 258, the last 256 values correspond to the top 8 bits of\n\t * the 15 bit distances.\n\t */\n  \n\tconst _length_code  = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\n\tzero$1(_length_code);\n\t/* length code for each normalized match length (0 == MIN_MATCH) */\n  \n\tconst base_length   = new Array(LENGTH_CODES$1);\n\tzero$1(base_length);\n\t/* First normalized length for each code (0 = MIN_MATCH) */\n  \n\tconst base_dist     = new Array(D_CODES$1);\n\tzero$1(base_dist);\n\t/* First normalized distance for each code (0 = distance of 1) */\n  \n  \n\tfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n  \n\t  this.static_tree  = static_tree;  /* static tree or NULL */\n\t  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n\t  this.extra_base   = extra_base;   /* base index for extra_bits */\n\t  this.elems        = elems;        /* max number of elements in the tree */\n\t  this.max_length   = max_length;   /* max bit length for the codes */\n  \n\t  // show if `static_tree` has data or dummy - needed for monomorphic objects\n\t  this.has_stree    = static_tree && static_tree.length;\n\t}\n  \n  \n\tlet static_l_desc;\n\tlet static_d_desc;\n\tlet static_bl_desc;\n  \n  \n\tfunction TreeDesc(dyn_tree, stat_desc) {\n\t  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n\t  this.max_code = 0;            /* largest code with non zero frequency */\n\t  this.stat_desc = stat_desc;   /* the corresponding static tree */\n\t}\n  \n  \n  \n\tconst d_code = (dist) => {\n  \n\t  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Output a short LSB first on the stream.\n\t * IN assertion: there is enough room in pendingBuf.\n\t */\n\tconst put_short = (s, w) => {\n\t//    put_byte(s, (uch)((w) & 0xff));\n\t//    put_byte(s, (uch)((ush)(w) >> 8));\n\t  s.pending_buf[s.pending++] = (w) & 0xff;\n\t  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send a value on a given number of bits.\n\t * IN assertion: length <= 16 and value fits in length bits.\n\t */\n\tconst send_bits = (s, value, length) => {\n  \n\t  if (s.bi_valid > (Buf_size - length)) {\n\t\ts.bi_buf |= (value << s.bi_valid) & 0xffff;\n\t\tput_short(s, s.bi_buf);\n\t\ts.bi_buf = value >> (Buf_size - s.bi_valid);\n\t\ts.bi_valid += length - Buf_size;\n\t  } else {\n\t\ts.bi_buf |= (value << s.bi_valid) & 0xffff;\n\t\ts.bi_valid += length;\n\t  }\n\t};\n  \n  \n\tconst send_code = (s, c, tree) => {\n  \n\t  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Reverse the first len bits of a code, using straightforward code (a faster\n\t * method would use a table)\n\t * IN assertion: 1 <= len <= 15\n\t */\n\tconst bi_reverse = (code, len) => {\n  \n\t  let res = 0;\n\t  do {\n\t\tres |= code & 1;\n\t\tcode >>>= 1;\n\t\tres <<= 1;\n\t  } while (--len > 0);\n\t  return res >>> 1;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Flush the bit buffer, keeping at most 7 bits in it.\n\t */\n\tconst bi_flush = (s) => {\n  \n\t  if (s.bi_valid === 16) {\n\t\tput_short(s, s.bi_buf);\n\t\ts.bi_buf = 0;\n\t\ts.bi_valid = 0;\n  \n\t  } else if (s.bi_valid >= 8) {\n\t\ts.pending_buf[s.pending++] = s.bi_buf & 0xff;\n\t\ts.bi_buf >>= 8;\n\t\ts.bi_valid -= 8;\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Compute the optimal bit lengths for a tree and update the total bit length\n\t * for the current block.\n\t * IN assertion: the fields freq and dad are set, heap[heap_max] and\n\t *    above are the tree nodes sorted by increasing frequency.\n\t * OUT assertions: the field len is set to the optimal bit length, the\n\t *     array bl_count contains the frequencies for each bit length.\n\t *     The length opt_len is updated; static_len is also updated if stree is\n\t *     not null.\n\t */\n\tconst gen_bitlen = (s, desc) =>\n\t//    deflate_state *s;\n\t//    tree_desc *desc;    /* the tree descriptor */\n\t{\n\t  const tree            = desc.dyn_tree;\n\t  const max_code        = desc.max_code;\n\t  const stree           = desc.stat_desc.static_tree;\n\t  const has_stree       = desc.stat_desc.has_stree;\n\t  const extra           = desc.stat_desc.extra_bits;\n\t  const base            = desc.stat_desc.extra_base;\n\t  const max_length      = desc.stat_desc.max_length;\n\t  let h;              /* heap index */\n\t  let n, m;           /* iterate over the tree elements */\n\t  let bits;           /* bit length */\n\t  let xbits;          /* extra bits */\n\t  let f;              /* frequency */\n\t  let overflow = 0;   /* number of elements with bit length too large */\n  \n\t  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n\t\ts.bl_count[bits] = 0;\n\t  }\n  \n\t  /* In a first pass, compute the optimal bit lengths (which may\n\t   * overflow in the case of the bit length tree).\n\t   */\n\t  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n  \n\t  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n\t\tn = s.heap[h];\n\t\tbits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n\t\tif (bits > max_length) {\n\t\t  bits = max_length;\n\t\t  overflow++;\n\t\t}\n\t\ttree[n * 2 + 1]/*.Len*/ = bits;\n\t\t/* We overwrite tree[n].Dad which is no longer needed */\n  \n\t\tif (n > max_code) { continue; } /* not a leaf node */\n  \n\t\ts.bl_count[bits]++;\n\t\txbits = 0;\n\t\tif (n >= base) {\n\t\t  xbits = extra[n - base];\n\t\t}\n\t\tf = tree[n * 2]/*.Freq*/;\n\t\ts.opt_len += f * (bits + xbits);\n\t\tif (has_stree) {\n\t\t  s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n\t\t}\n\t  }\n\t  if (overflow === 0) { return; }\n  \n\t  // Trace((stderr,\"\\nbit length overflow\\n\"));\n\t  /* This happens for example on obj2 and pic of the Calgary corpus */\n  \n\t  /* Find the first bit length which could increase: */\n\t  do {\n\t\tbits = max_length - 1;\n\t\twhile (s.bl_count[bits] === 0) { bits--; }\n\t\ts.bl_count[bits]--;      /* move one leaf down the tree */\n\t\ts.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n\t\ts.bl_count[max_length]--;\n\t\t/* The brother of the overflow item also moves one step up,\n\t\t * but this does not affect bl_count[max_length]\n\t\t */\n\t\toverflow -= 2;\n\t  } while (overflow > 0);\n  \n\t  /* Now recompute all bit lengths, scanning in increasing frequency.\n\t   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n\t   * lengths instead of fixing only the wrong ones. This idea is taken\n\t   * from 'ar' written by Haruhiko Okumura.)\n\t   */\n\t  for (bits = max_length; bits !== 0; bits--) {\n\t\tn = s.bl_count[bits];\n\t\twhile (n !== 0) {\n\t\t  m = s.heap[--h];\n\t\t  if (m > max_code) { continue; }\n\t\t  if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n\t\t\t// Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n\t\t\ts.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n\t\t\ttree[m * 2 + 1]/*.Len*/ = bits;\n\t\t  }\n\t\t  n--;\n\t\t}\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Generate the codes for a given tree and bit counts (which need not be\n\t * optimal).\n\t * IN assertion: the array bl_count contains the bit length statistics for\n\t * the given tree and the field len is set for all tree elements.\n\t * OUT assertion: the field code is set for all tree elements of non\n\t *     zero code length.\n\t */\n\tconst gen_codes = (tree, max_code, bl_count) =>\n\t//    ct_data *tree;             /* the tree to decorate */\n\t//    int max_code;              /* largest code with non zero frequency */\n\t//    ushf *bl_count;            /* number of codes at each bit length */\n\t{\n\t  const next_code = new Array(MAX_BITS$1 + 1); /* next code value for each bit length */\n\t  let code = 0;              /* running code value */\n\t  let bits;                  /* bit index */\n\t  let n;                     /* code index */\n  \n\t  /* The distribution counts are first used to generate the code values\n\t   * without bit reversal.\n\t   */\n\t  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n\t\tnext_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n\t  }\n\t  /* Check that the bit counts in bl_count are consistent. The last code\n\t   * must be all ones.\n\t   */\n\t  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n\t  //        \"inconsistent bit counts\");\n\t  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n  \n\t  for (n = 0;  n <= max_code; n++) {\n\t\tlet len = tree[n * 2 + 1]/*.Len*/;\n\t\tif (len === 0) { continue; }\n\t\t/* Now reverse the bits */\n\t\ttree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n  \n\t\t//Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n\t\t//     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Initialize the various 'constant' tables.\n\t */\n\tconst tr_static_init = () => {\n  \n\t  let n;        /* iterates over tree elements */\n\t  let bits;     /* bit counter */\n\t  let length;   /* length value */\n\t  let code;     /* code value */\n\t  let dist;     /* distance index */\n\t  const bl_count = new Array(MAX_BITS$1 + 1);\n\t  /* number of codes at each bit length for an optimal tree */\n  \n\t  // do check in _tr_init()\n\t  //if (static_init_done) return;\n  \n\t  /* For some embedded targets, global variables are not initialized: */\n\t/*#ifdef NO_INIT_GLOBAL_POINTERS\n\t  static_l_desc.static_tree = static_ltree;\n\t  static_l_desc.extra_bits = extra_lbits;\n\t  static_d_desc.static_tree = static_dtree;\n\t  static_d_desc.extra_bits = extra_dbits;\n\t  static_bl_desc.extra_bits = extra_blbits;\n\t#endif*/\n  \n\t  /* Initialize the mapping length (0..255) -> length code (0..28) */\n\t  length = 0;\n\t  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n\t\tbase_length[code] = length;\n\t\tfor (n = 0; n < (1 << extra_lbits[code]); n++) {\n\t\t  _length_code[length++] = code;\n\t\t}\n\t  }\n\t  //Assert (length == 256, \"tr_static_init: length != 256\");\n\t  /* Note that the length 255 (match length 258) can be represented\n\t   * in two different ways: code 284 + 5 bits or code 285, so we\n\t   * overwrite length_code[255] to use the best encoding:\n\t   */\n\t  _length_code[length - 1] = code;\n  \n\t  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n\t  dist = 0;\n\t  for (code = 0; code < 16; code++) {\n\t\tbase_dist[code] = dist;\n\t\tfor (n = 0; n < (1 << extra_dbits[code]); n++) {\n\t\t  _dist_code[dist++] = code;\n\t\t}\n\t  }\n\t  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n\t  dist >>= 7; /* from now on, all distances are divided by 128 */\n\t  for (; code < D_CODES$1; code++) {\n\t\tbase_dist[code] = dist << 7;\n\t\tfor (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n\t\t  _dist_code[256 + dist++] = code;\n\t\t}\n\t  }\n\t  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n  \n\t  /* Construct the codes of the static literal tree */\n\t  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n\t\tbl_count[bits] = 0;\n\t  }\n  \n\t  n = 0;\n\t  while (n <= 143) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 8;\n\t\tn++;\n\t\tbl_count[8]++;\n\t  }\n\t  while (n <= 255) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 9;\n\t\tn++;\n\t\tbl_count[9]++;\n\t  }\n\t  while (n <= 279) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 7;\n\t\tn++;\n\t\tbl_count[7]++;\n\t  }\n\t  while (n <= 287) {\n\t\tstatic_ltree[n * 2 + 1]/*.Len*/ = 8;\n\t\tn++;\n\t\tbl_count[8]++;\n\t  }\n\t  /* Codes 286 and 287 do not exist, but we must include them in the\n\t   * tree construction to get a canonical Huffman tree (longest code\n\t   * all ones)\n\t   */\n\t  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n  \n\t  /* The static distance tree is trivial: */\n\t  for (n = 0; n < D_CODES$1; n++) {\n\t\tstatic_dtree[n * 2 + 1]/*.Len*/ = 5;\n\t\tstatic_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n\t  }\n  \n\t  // Now data ready and we can init static trees\n\t  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n\t  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES$1, MAX_BITS$1);\n\t  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES$1, MAX_BL_BITS);\n  \n\t  //static_init_done = true;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Initialize a new block.\n\t */\n\tconst init_block = (s) => {\n  \n\t  let n; /* iterates over tree elements */\n  \n\t  /* Initialize the trees. */\n\t  for (n = 0; n < L_CODES$1;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n\t  for (n = 0; n < D_CODES$1;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n\t  for (n = 0; n < BL_CODES$1; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n  \n\t  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n\t  s.opt_len = s.static_len = 0;\n\t  s.last_lit = s.matches = 0;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Flush the bit buffer and align the output on a byte boundary\n\t */\n\tconst bi_windup = (s) =>\n\t{\n\t  if (s.bi_valid > 8) {\n\t\tput_short(s, s.bi_buf);\n\t  } else if (s.bi_valid > 0) {\n\t\t//put_byte(s, (Byte)s->bi_buf);\n\t\ts.pending_buf[s.pending++] = s.bi_buf;\n\t  }\n\t  s.bi_buf = 0;\n\t  s.bi_valid = 0;\n\t};\n  \n\t/* ===========================================================================\n\t * Copy a stored block, storing first the length and its\n\t * one's complement if requested.\n\t */\n\tconst copy_block = (s, buf, len, header) =>\n\t//DeflateState *s;\n\t//charf    *buf;    /* the input data */\n\t//unsigned len;     /* its length */\n\t//int      header;  /* true if block header must be written */\n\t{\n\t  bi_windup(s);        /* align on byte boundary */\n  \n\t  if (header) {\n\t\tput_short(s, len);\n\t\tput_short(s, ~len);\n\t  }\n\t//  while (len--) {\n\t//    put_byte(s, *buf++);\n\t//  }\n\t  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n\t  s.pending += len;\n\t};\n  \n\t/* ===========================================================================\n\t * Compares to subtrees, using the tree depth as tie breaker when\n\t * the subtrees have equal frequency. This minimizes the worst case length.\n\t */\n\tconst smaller = (tree, n, m, depth) => {\n  \n\t  const _n2 = n * 2;\n\t  const _m2 = m * 2;\n\t  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n\t\t\t (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n\t};\n  \n\t/* ===========================================================================\n\t * Restore the heap property by moving down the tree starting at node k,\n\t * exchanging a node with the smallest of its two sons if necessary, stopping\n\t * when the heap property is re-established (each father smaller than its\n\t * two sons).\n\t */\n\tconst pqdownheap = (s, tree, k) =>\n\t//    deflate_state *s;\n\t//    ct_data *tree;  /* the tree to restore */\n\t//    int k;               /* node to move down */\n\t{\n\t  const v = s.heap[k];\n\t  let j = k << 1;  /* left son of k */\n\t  while (j <= s.heap_len) {\n\t\t/* Set j to the smallest of the two sons: */\n\t\tif (j < s.heap_len &&\n\t\t  smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n\t\t  j++;\n\t\t}\n\t\t/* Exit if v is smaller than both sons */\n\t\tif (smaller(tree, v, s.heap[j], s.depth)) { break; }\n  \n\t\t/* Exchange v with the smallest son */\n\t\ts.heap[k] = s.heap[j];\n\t\tk = j;\n  \n\t\t/* And continue down the tree, setting j to the left son of k */\n\t\tj <<= 1;\n\t  }\n\t  s.heap[k] = v;\n\t};\n  \n  \n\t// inlined manually\n\t// const SMALLEST = 1;\n  \n\t/* ===========================================================================\n\t * Send the block data compressed using the given Huffman trees\n\t */\n\tconst compress_block = (s, ltree, dtree) =>\n\t//    deflate_state *s;\n\t//    const ct_data *ltree; /* literal tree */\n\t//    const ct_data *dtree; /* distance tree */\n\t{\n\t  let dist;           /* distance of matched string */\n\t  let lc;             /* match length or unmatched char (if dist == 0) */\n\t  let lx = 0;         /* running index in l_buf */\n\t  let code;           /* the code to send */\n\t  let extra;          /* number of extra bits to send */\n  \n\t  if (s.last_lit !== 0) {\n\t\tdo {\n\t\t  dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n\t\t  lc = s.pending_buf[s.l_buf + lx];\n\t\t  lx++;\n  \n\t\t  if (dist === 0) {\n\t\t\tsend_code(s, lc, ltree); /* send a literal byte */\n\t\t\t//Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n\t\t  } else {\n\t\t\t/* Here, lc is the match length - MIN_MATCH */\n\t\t\tcode = _length_code[lc];\n\t\t\tsend_code(s, code + LITERALS$1 + 1, ltree); /* send the length code */\n\t\t\textra = extra_lbits[code];\n\t\t\tif (extra !== 0) {\n\t\t\t  lc -= base_length[code];\n\t\t\t  send_bits(s, lc, extra);       /* send the extra length bits */\n\t\t\t}\n\t\t\tdist--; /* dist is now the match distance - 1 */\n\t\t\tcode = d_code(dist);\n\t\t\t//Assert (code < D_CODES, \"bad d_code\");\n  \n\t\t\tsend_code(s, code, dtree);       /* send the distance code */\n\t\t\textra = extra_dbits[code];\n\t\t\tif (extra !== 0) {\n\t\t\t  dist -= base_dist[code];\n\t\t\t  send_bits(s, dist, extra);   /* send the extra distance bits */\n\t\t\t}\n\t\t  } /* literal or match pair ? */\n  \n\t\t  /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n\t\t  //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n\t\t  //       \"pendingBuf overflow\");\n  \n\t\t} while (lx < s.last_lit);\n\t  }\n  \n\t  send_code(s, END_BLOCK, ltree);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Construct one Huffman tree and assigns the code bit strings and lengths.\n\t * Update the total bit length for the current block.\n\t * IN assertion: the field freq is set for all tree elements.\n\t * OUT assertions: the fields len and code are set to the optimal bit length\n\t *     and corresponding code. The length opt_len is updated; static_len is\n\t *     also updated if stree is not null. The field max_code is set.\n\t */\n\tconst build_tree = (s, desc) =>\n\t//    deflate_state *s;\n\t//    tree_desc *desc; /* the tree descriptor */\n\t{\n\t  const tree     = desc.dyn_tree;\n\t  const stree    = desc.stat_desc.static_tree;\n\t  const has_stree = desc.stat_desc.has_stree;\n\t  const elems    = desc.stat_desc.elems;\n\t  let n, m;          /* iterate over heap elements */\n\t  let max_code = -1; /* largest code with non zero frequency */\n\t  let node;          /* new node being created */\n  \n\t  /* Construct the initial heap, with least frequent element in\n\t   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n\t   * heap[0] is not used.\n\t   */\n\t  s.heap_len = 0;\n\t  s.heap_max = HEAP_SIZE$1;\n  \n\t  for (n = 0; n < elems; n++) {\n\t\tif (tree[n * 2]/*.Freq*/ !== 0) {\n\t\t  s.heap[++s.heap_len] = max_code = n;\n\t\t  s.depth[n] = 0;\n  \n\t\t} else {\n\t\t  tree[n * 2 + 1]/*.Len*/ = 0;\n\t\t}\n\t  }\n  \n\t  /* The pkzip format requires that at least one distance code exists,\n\t   * and that at least one bit should be sent even if there is only one\n\t   * possible code. So to avoid special checks later on we force at least\n\t   * two codes of non zero frequency.\n\t   */\n\t  while (s.heap_len < 2) {\n\t\tnode = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n\t\ttree[node * 2]/*.Freq*/ = 1;\n\t\ts.depth[node] = 0;\n\t\ts.opt_len--;\n  \n\t\tif (has_stree) {\n\t\t  s.static_len -= stree[node * 2 + 1]/*.Len*/;\n\t\t}\n\t\t/* node is 0 or 1 so it does not have extra bits */\n\t  }\n\t  desc.max_code = max_code;\n  \n\t  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n\t   * establish sub-heaps of increasing lengths:\n\t   */\n\t  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n  \n\t  /* Construct the Huffman tree by repeatedly combining the least two\n\t   * frequent nodes.\n\t   */\n\t  node = elems;              /* next internal node of the tree */\n\t  do {\n\t\t//pqremove(s, tree, n);  /* n = node of least frequency */\n\t\t/*** pqremove ***/\n\t\tn = s.heap[1/*SMALLEST*/];\n\t\ts.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n\t\tpqdownheap(s, tree, 1/*SMALLEST*/);\n\t\t/***/\n  \n\t\tm = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n  \n\t\ts.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n\t\ts.heap[--s.heap_max] = m;\n  \n\t\t/* Create a new node father of n and m */\n\t\ttree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n\t\ts.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n\t\ttree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n  \n\t\t/* and insert the new node in the heap */\n\t\ts.heap[1/*SMALLEST*/] = node++;\n\t\tpqdownheap(s, tree, 1/*SMALLEST*/);\n  \n\t  } while (s.heap_len >= 2);\n  \n\t  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n  \n\t  /* At this point, the fields freq and dad are set. We can now\n\t   * generate the bit lengths.\n\t   */\n\t  gen_bitlen(s, desc);\n  \n\t  /* The field len is now set, we can generate the bit codes */\n\t  gen_codes(tree, max_code, s.bl_count);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Scan a literal or distance tree to determine the frequencies of the codes\n\t * in the bit length tree.\n\t */\n\tconst scan_tree = (s, tree, max_code) =>\n\t//    deflate_state *s;\n\t//    ct_data *tree;   /* the tree to be scanned */\n\t//    int max_code;    /* and its largest code of non zero frequency */\n\t{\n\t  let n;                     /* iterates over all tree elements */\n\t  let prevlen = -1;          /* last emitted length */\n\t  let curlen;                /* length of current code */\n  \n\t  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n  \n\t  let count = 0;             /* repeat count of the current code */\n\t  let max_count = 7;         /* max repeat count */\n\t  let min_count = 4;         /* min repeat count */\n  \n\t  if (nextlen === 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t  }\n\t  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n  \n\t  for (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n  \n\t\tif (++count < max_count && curlen === nextlen) {\n\t\t  continue;\n  \n\t\t} else if (count < min_count) {\n\t\t  s.bl_tree[curlen * 2]/*.Freq*/ += count;\n  \n\t\t} else if (curlen !== 0) {\n  \n\t\t  if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n\t\t  s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n  \n\t\t} else if (count <= 10) {\n\t\t  s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n  \n\t\t} else {\n\t\t  s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n\t\t}\n  \n\t\tcount = 0;\n\t\tprevlen = curlen;\n  \n\t\tif (nextlen === 0) {\n\t\t  max_count = 138;\n\t\t  min_count = 3;\n  \n\t\t} else if (curlen === nextlen) {\n\t\t  max_count = 6;\n\t\t  min_count = 3;\n  \n\t\t} else {\n\t\t  max_count = 7;\n\t\t  min_count = 4;\n\t\t}\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send a literal or distance tree in compressed form, using the codes in\n\t * bl_tree.\n\t */\n\tconst send_tree = (s, tree, max_code) =>\n\t//    deflate_state *s;\n\t//    ct_data *tree; /* the tree to be scanned */\n\t//    int max_code;       /* and its largest code of non zero frequency */\n\t{\n\t  let n;                     /* iterates over all tree elements */\n\t  let prevlen = -1;          /* last emitted length */\n\t  let curlen;                /* length of current code */\n  \n\t  let nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n  \n\t  let count = 0;             /* repeat count of the current code */\n\t  let max_count = 7;         /* max repeat count */\n\t  let min_count = 4;         /* min repeat count */\n  \n\t  /* tree[max_code+1].Len = -1; */  /* guard already set */\n\t  if (nextlen === 0) {\n\t\tmax_count = 138;\n\t\tmin_count = 3;\n\t  }\n  \n\t  for (n = 0; n <= max_code; n++) {\n\t\tcurlen = nextlen;\n\t\tnextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n  \n\t\tif (++count < max_count && curlen === nextlen) {\n\t\t  continue;\n  \n\t\t} else if (count < min_count) {\n\t\t  do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n  \n\t\t} else if (curlen !== 0) {\n\t\t  if (curlen !== prevlen) {\n\t\t\tsend_code(s, curlen, s.bl_tree);\n\t\t\tcount--;\n\t\t  }\n\t\t  //Assert(count >= 3 && count <= 6, \" 3_6?\");\n\t\t  send_code(s, REP_3_6, s.bl_tree);\n\t\t  send_bits(s, count - 3, 2);\n  \n\t\t} else if (count <= 10) {\n\t\t  send_code(s, REPZ_3_10, s.bl_tree);\n\t\t  send_bits(s, count - 3, 3);\n  \n\t\t} else {\n\t\t  send_code(s, REPZ_11_138, s.bl_tree);\n\t\t  send_bits(s, count - 11, 7);\n\t\t}\n  \n\t\tcount = 0;\n\t\tprevlen = curlen;\n\t\tif (nextlen === 0) {\n\t\t  max_count = 138;\n\t\t  min_count = 3;\n  \n\t\t} else if (curlen === nextlen) {\n\t\t  max_count = 6;\n\t\t  min_count = 3;\n  \n\t\t} else {\n\t\t  max_count = 7;\n\t\t  min_count = 4;\n\t\t}\n\t  }\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Construct the Huffman tree for the bit lengths and return the index in\n\t * bl_order of the last bit length code to send.\n\t */\n\tconst build_bl_tree = (s) => {\n  \n\t  let max_blindex;  /* index of last bit length code of non zero freq */\n  \n\t  /* Determine the bit length frequencies for literal and distance trees */\n\t  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n\t  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n  \n\t  /* Build the bit length tree: */\n\t  build_tree(s, s.bl_desc);\n\t  /* opt_len now includes the length of the tree representations, except\n\t   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n\t   */\n  \n\t  /* Determine the number of bit length codes to send. The pkzip format\n\t   * requires that at least 4 bit length codes be sent. (appnote.txt says\n\t   * 3 but the actual value used is 4.)\n\t   */\n\t  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n\t\tif (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n\t\t  break;\n\t\t}\n\t  }\n\t  /* Update opt_len to include the bit length tree and counts */\n\t  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n\t  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n\t  //        s->opt_len, s->static_len));\n  \n\t  return max_blindex;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send the header for a block using dynamic Huffman trees: the counts, the\n\t * lengths of the bit length codes, the literal tree and the distance tree.\n\t * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n\t */\n\tconst send_all_trees = (s, lcodes, dcodes, blcodes) =>\n\t//    deflate_state *s;\n\t//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n\t{\n\t  let rank;                    /* index in bl_order */\n  \n\t  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n\t  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n\t  //        \"too many codes\");\n\t  //Tracev((stderr, \"\\nbl counts: \"));\n\t  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n\t  send_bits(s, dcodes - 1,   5);\n\t  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n\t  for (rank = 0; rank < blcodes; rank++) {\n\t\t//Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n\t\tsend_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n\t  }\n\t  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n  \n\t  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n\t  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n  \n\t  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n\t  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Check if the data type is TEXT or BINARY, using the following algorithm:\n\t * - TEXT if the two conditions below are satisfied:\n\t *    a) There are no non-portable control characters belonging to the\n\t *       \"black list\" (0..6, 14..25, 28..31).\n\t *    b) There is at least one printable character belonging to the\n\t *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n\t * - BINARY otherwise.\n\t * - The following partially-portable control characters form a\n\t *   \"gray list\" that is ignored in this detection algorithm:\n\t *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n\t * IN assertion: the fields Freq of dyn_ltree are set.\n\t */\n\tconst detect_data_type = (s) => {\n\t  /* black_mask is the bit mask of black-listed bytes\n\t   * set bits 0..6, 14..25, and 28..31\n\t   * 0xf3ffc07f = binary 11110011111111111100000001111111\n\t   */\n\t  let black_mask = 0xf3ffc07f;\n\t  let n;\n  \n\t  /* Check for non-textual (\"black-listed\") bytes. */\n\t  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n\t\tif ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n\t\t  return Z_BINARY;\n\t\t}\n\t  }\n  \n\t  /* Check for textual (\"white-listed\") bytes. */\n\t  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n\t\t  s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n\t\treturn Z_TEXT;\n\t  }\n\t  for (n = 32; n < LITERALS$1; n++) {\n\t\tif (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n\t\t  return Z_TEXT;\n\t\t}\n\t  }\n  \n\t  /* There are no \"black-listed\" or \"white-listed\" bytes:\n\t   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n\t   */\n\t  return Z_BINARY;\n\t};\n  \n  \n\tlet static_init_done = false;\n  \n\t/* ===========================================================================\n\t * Initialize the tree data structures for a new zlib stream.\n\t */\n\tconst _tr_init$1 = (s) =>\n\t{\n  \n\t  if (!static_init_done) {\n\t\ttr_static_init();\n\t\tstatic_init_done = true;\n\t  }\n  \n\t  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n\t  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n\t  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n  \n\t  s.bi_buf = 0;\n\t  s.bi_valid = 0;\n  \n\t  /* Initialize the first block of the first file: */\n\t  init_block(s);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send a stored block\n\t */\n\tconst _tr_stored_block$1 = (s, buf, stored_len, last) =>\n\t//DeflateState *s;\n\t//charf *buf;       /* input block */\n\t//ulg stored_len;   /* length of input block */\n\t//int last;         /* one if this is the last block for a file */\n\t{\n\t  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n\t  copy_block(s, buf, stored_len, true); /* with header */\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Send one empty static block to give enough lookahead for inflate.\n\t * This takes 10 bits, of which 7 may remain in the bit buffer.\n\t */\n\tconst _tr_align$1 = (s) => {\n\t  send_bits(s, STATIC_TREES << 1, 3);\n\t  send_code(s, END_BLOCK, static_ltree);\n\t  bi_flush(s);\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Determine the best encoding for the current block: dynamic trees, static\n\t * trees or store, and output the encoded block to the zip file.\n\t */\n\tconst _tr_flush_block$1 = (s, buf, stored_len, last) =>\n\t//DeflateState *s;\n\t//charf *buf;       /* input block, or NULL if too old */\n\t//ulg stored_len;   /* length of input block */\n\t//int last;         /* one if this is the last block for a file */\n\t{\n\t  let opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n\t  let max_blindex = 0;        /* index of last bit length code of non zero freq */\n  \n\t  /* Build the Huffman trees unless a stored block is forced */\n\t  if (s.level > 0) {\n  \n\t\t/* Check if the file is binary or text */\n\t\tif (s.strm.data_type === Z_UNKNOWN$1) {\n\t\t  s.strm.data_type = detect_data_type(s);\n\t\t}\n  \n\t\t/* Construct the literal and distance trees */\n\t\tbuild_tree(s, s.l_desc);\n\t\t// Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n\t\t//        s->static_len));\n  \n\t\tbuild_tree(s, s.d_desc);\n\t\t// Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n\t\t//        s->static_len));\n\t\t/* At this point, opt_len and static_len are the total bit lengths of\n\t\t * the compressed block data, excluding the tree representations.\n\t\t */\n  \n\t\t/* Build the bit length tree for the above two trees, and get the index\n\t\t * in bl_order of the last bit length code to send.\n\t\t */\n\t\tmax_blindex = build_bl_tree(s);\n  \n\t\t/* Determine the best encoding. Compute the block lengths in bytes. */\n\t\topt_lenb = (s.opt_len + 3 + 7) >>> 3;\n\t\tstatic_lenb = (s.static_len + 3 + 7) >>> 3;\n  \n\t\t// Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n\t\t//        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n\t\t//        s->last_lit));\n  \n\t\tif (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n  \n\t  } else {\n\t\t// Assert(buf != (char*)0, \"lost buf\");\n\t\topt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n\t  }\n  \n\t  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n\t\t/* 4: two words for the lengths */\n  \n\t\t/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n\t\t * Otherwise we can't have processed more than WSIZE input bytes since\n\t\t * the last block flush, because compression would have been\n\t\t * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n\t\t * transform a block into a stored block.\n\t\t */\n\t\t_tr_stored_block$1(s, buf, stored_len, last);\n  \n\t  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n  \n\t\tsend_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n\t\tcompress_block(s, static_ltree, static_dtree);\n  \n\t  } else {\n\t\tsend_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n\t\tsend_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n\t\tcompress_block(s, s.dyn_ltree, s.dyn_dtree);\n\t  }\n\t  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n\t  /* The above check is made mod 2^32, for files larger than 512 MB\n\t   * and uLong implemented on 32 bits.\n\t   */\n\t  init_block(s);\n  \n\t  if (last) {\n\t\tbi_windup(s);\n\t  }\n\t  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n\t  //       s->compressed_len-7*last));\n\t};\n  \n\t/* ===========================================================================\n\t * Save the match info and tally the frequency counts. Return true if\n\t * the current block must be flushed.\n\t */\n\tconst _tr_tally$1 = (s, dist, lc) =>\n\t//    deflate_state *s;\n\t//    unsigned dist;  /* distance of matched string */\n\t//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n\t{\n\t  //let out_length, in_length, dcode;\n  \n\t  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n\t  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n  \n\t  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n\t  s.last_lit++;\n  \n\t  if (dist === 0) {\n\t\t/* lc is the unmatched char */\n\t\ts.dyn_ltree[lc * 2]/*.Freq*/++;\n\t  } else {\n\t\ts.matches++;\n\t\t/* Here, lc is the match length - MIN_MATCH */\n\t\tdist--;             /* dist = match distance - 1 */\n\t\t//Assert((ush)dist < (ush)MAX_DIST(s) &&\n\t\t//       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n\t\t//       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n  \n\t\ts.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]/*.Freq*/++;\n\t\ts.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n\t  }\n  \n\t// (!) This block is disabled in zlib defaults,\n\t// don't enable it for binary compatibility\n  \n\t//#ifdef TRUNCATE_BLOCK\n\t//  /* Try to guess if it is profitable to stop the current block here */\n\t//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n\t//    /* Compute an upper bound for the compressed length */\n\t//    out_length = s.last_lit*8;\n\t//    in_length = s.strstart - s.block_start;\n\t//\n\t//    for (dcode = 0; dcode < D_CODES; dcode++) {\n\t//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n\t//    }\n\t//    out_length >>>= 3;\n\t//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n\t//    //       s->last_lit, in_length, out_length,\n\t//    //       100L - out_length*100L/in_length));\n\t//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n\t//      return true;\n\t//    }\n\t//  }\n\t//#endif\n  \n\t  return (s.last_lit === s.lit_bufsize - 1);\n\t  /* We avoid equality with lit_bufsize because of wraparound at 64K\n\t   * on 16 bit machines and because stored blocks are restricted to\n\t   * 64K-1 bytes.\n\t   */\n\t};\n  \n\tvar _tr_init_1  = _tr_init$1;\n\tvar _tr_stored_block_1 = _tr_stored_block$1;\n\tvar _tr_flush_block_1  = _tr_flush_block$1;\n\tvar _tr_tally_1 = _tr_tally$1;\n\tvar _tr_align_1 = _tr_align$1;\n  \n\tvar trees = {\n\t\t_tr_init: _tr_init_1,\n\t\t_tr_stored_block: _tr_stored_block_1,\n\t\t_tr_flush_block: _tr_flush_block_1,\n\t\t_tr_tally: _tr_tally_1,\n\t\t_tr_align: _tr_align_1\n\t};\n  \n\t// Note: adler32 takes 12% for level 0 and 2% for level 6.\n\t// It isn't worth it to make additional optimizations as in original.\n\t// Small size is preferable.\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tconst adler32 = (adler, buf, len, pos) => {\n\t  let s1 = (adler & 0xffff) |0,\n\t\t  s2 = ((adler >>> 16) & 0xffff) |0,\n\t\t  n = 0;\n  \n\t  while (len !== 0) {\n\t\t// Set limit ~ twice less than 5552, to keep\n\t\t// s2 in 31-bits, because we force signed ints.\n\t\t// in other case %= will fail.\n\t\tn = len > 2000 ? 2000 : len;\n\t\tlen -= n;\n  \n\t\tdo {\n\t\t  s1 = (s1 + buf[pos++]) |0;\n\t\t  s2 = (s2 + s1) |0;\n\t\t} while (--n);\n  \n\t\ts1 %= 65521;\n\t\ts2 %= 65521;\n\t  }\n  \n\t  return (s1 | (s2 << 16)) |0;\n\t};\n  \n  \n\tvar adler32_1 = adler32;\n  \n\t// Note: we can't get significant speed boost here.\n\t// So write code to minimize size - no pregenerated tables\n\t// and array tools dependencies.\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\t// Use ordinary array, since untyped makes no boost here\n\tconst makeTable = () => {\n\t  let c, table = [];\n  \n\t  for (var n = 0; n < 256; n++) {\n\t\tc = n;\n\t\tfor (var k = 0; k < 8; k++) {\n\t\t  c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n\t\t}\n\t\ttable[n] = c;\n\t  }\n  \n\t  return table;\n\t};\n  \n\t// Create table on load. Just 255 signed longs. Not a problem.\n\tconst crcTable = new Uint32Array(makeTable());\n  \n  \n\tconst crc32 = (crc, buf, len, pos) => {\n\t  const t = crcTable;\n\t  const end = pos + len;\n  \n\t  crc ^= -1;\n  \n\t  for (let i = pos; i < end; i++) {\n\t\tcrc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n\t  }\n  \n\t  return (crc ^ (-1)); // >>> 0;\n\t};\n  \n  \n\tvar crc32_1 = crc32;\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tvar messages = {\n\t  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n\t  1:      'stream end',          /* Z_STREAM_END      1  */\n\t  0:      '',                    /* Z_OK              0  */\n\t  '-1':   'file error',          /* Z_ERRNO         (-1) */\n\t  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n\t  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n\t  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n\t  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n\t  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tvar constants$2 = {\n  \n\t  /* Allowed flush values; see deflate() and inflate() below for details */\n\t  Z_NO_FLUSH:         0,\n\t  Z_PARTIAL_FLUSH:    1,\n\t  Z_SYNC_FLUSH:       2,\n\t  Z_FULL_FLUSH:       3,\n\t  Z_FINISH:           4,\n\t  Z_BLOCK:            5,\n\t  Z_TREES:            6,\n  \n\t  /* Return codes for the compression/decompression functions. Negative values\n\t  * are errors, positive values are used for special but normal events.\n\t  */\n\t  Z_OK:               0,\n\t  Z_STREAM_END:       1,\n\t  Z_NEED_DICT:        2,\n\t  Z_ERRNO:           -1,\n\t  Z_STREAM_ERROR:    -2,\n\t  Z_DATA_ERROR:      -3,\n\t  Z_MEM_ERROR:       -4,\n\t  Z_BUF_ERROR:       -5,\n\t  //Z_VERSION_ERROR: -6,\n  \n\t  /* compression levels */\n\t  Z_NO_COMPRESSION:         0,\n\t  Z_BEST_SPEED:             1,\n\t  Z_BEST_COMPRESSION:       9,\n\t  Z_DEFAULT_COMPRESSION:   -1,\n  \n  \n\t  Z_FILTERED:               1,\n\t  Z_HUFFMAN_ONLY:           2,\n\t  Z_RLE:                    3,\n\t  Z_FIXED:                  4,\n\t  Z_DEFAULT_STRATEGY:       0,\n  \n\t  /* Possible values of the data_type field (though see inflate()) */\n\t  Z_BINARY:                 0,\n\t  Z_TEXT:                   1,\n\t  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n\t  Z_UNKNOWN:                2,\n  \n\t  /* The deflate compression method */\n\t  Z_DEFLATED:               8\n\t  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tconst { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\n  \n  \n  \n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_NO_FLUSH: Z_NO_FLUSH$2, Z_PARTIAL_FLUSH, Z_FULL_FLUSH: Z_FULL_FLUSH$1, Z_FINISH: Z_FINISH$3, Z_BLOCK: Z_BLOCK$1,\n\t  Z_OK: Z_OK$3, Z_STREAM_END: Z_STREAM_END$3, Z_STREAM_ERROR: Z_STREAM_ERROR$2, Z_DATA_ERROR: Z_DATA_ERROR$2, Z_BUF_ERROR: Z_BUF_ERROR$1,\n\t  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n\t  Z_FILTERED, Z_HUFFMAN_ONLY, Z_RLE, Z_FIXED, Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n\t  Z_UNKNOWN,\n\t  Z_DEFLATED: Z_DEFLATED$2\n\t} = constants$2;\n  \n\t/*============================================================================*/\n  \n  \n\tconst MAX_MEM_LEVEL = 9;\n\t/* Maximum value for memLevel in deflateInit2 */\n\tconst MAX_WBITS$1 = 15;\n\t/* 32K LZ77 window */\n\tconst DEF_MEM_LEVEL = 8;\n  \n  \n\tconst LENGTH_CODES  = 29;\n\t/* number of length codes, not counting the special END_BLOCK code */\n\tconst LITERALS      = 256;\n\t/* number of literal bytes 0..255 */\n\tconst L_CODES       = LITERALS + 1 + LENGTH_CODES;\n\t/* number of Literal or Length codes, including the END_BLOCK code */\n\tconst D_CODES       = 30;\n\t/* number of distance codes */\n\tconst BL_CODES      = 19;\n\t/* number of codes used to transfer the bit lengths */\n\tconst HEAP_SIZE     = 2 * L_CODES + 1;\n\t/* maximum heap size */\n\tconst MAX_BITS  = 15;\n\t/* All codes must not exceed MAX_BITS bits */\n  \n\tconst MIN_MATCH = 3;\n\tconst MAX_MATCH = 258;\n\tconst MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n  \n\tconst PRESET_DICT = 0x20;\n  \n\tconst INIT_STATE = 42;\n\tconst EXTRA_STATE = 69;\n\tconst NAME_STATE = 73;\n\tconst COMMENT_STATE = 91;\n\tconst HCRC_STATE = 103;\n\tconst BUSY_STATE = 113;\n\tconst FINISH_STATE = 666;\n  \n\tconst BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\n\tconst BS_BLOCK_DONE     = 2; /* block flush performed */\n\tconst BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\n\tconst BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n  \n\tconst OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n  \n\tconst err = (strm, errorCode) => {\n\t  strm.msg = messages[errorCode];\n\t  return errorCode;\n\t};\n  \n\tconst rank = (f) => {\n\t  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n\t};\n  \n\tconst zero = (buf) => {\n\t  let len = buf.length; while (--len >= 0) { buf[len] = 0; }\n\t};\n  \n  \n\t/* eslint-disable new-cap */\n\tlet HASH_ZLIB = (s, prev, data) => ((prev << s.hash_shift) ^ data) & s.hash_mask;\n\t// This hash causes less collisions, https://github.com/nodeca/pako/issues/135\n\t// But breaks binary compatibility\n\t//let HASH_FAST = (s, prev, data) => ((prev << 8) + (prev >> 8) + (data << 4)) & s.hash_mask;\n\tlet HASH = HASH_ZLIB;\n  \n\t/* =========================================================================\n\t * Flush as much pending output as possible. All deflate() output goes\n\t * through this function so some applications may wish to modify it\n\t * to avoid allocating a large strm->output buffer and copying into it.\n\t * (See also read_buf()).\n\t */\n\tconst flush_pending = (strm) => {\n\t  const s = strm.state;\n  \n\t  //_tr_flush_bits(s);\n\t  let len = s.pending;\n\t  if (len > strm.avail_out) {\n\t\tlen = strm.avail_out;\n\t  }\n\t  if (len === 0) { return; }\n  \n\t  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n\t  strm.next_out += len;\n\t  s.pending_out += len;\n\t  strm.total_out += len;\n\t  strm.avail_out -= len;\n\t  s.pending -= len;\n\t  if (s.pending === 0) {\n\t\ts.pending_out = 0;\n\t  }\n\t};\n  \n  \n\tconst flush_block_only = (s, last) => {\n\t  _tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n\t  s.block_start = s.strstart;\n\t  flush_pending(s.strm);\n\t};\n  \n  \n\tconst put_byte = (s, b) => {\n\t  s.pending_buf[s.pending++] = b;\n\t};\n  \n  \n\t/* =========================================================================\n\t * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n\t * IN assertion: the stream state is correct and there is enough room in\n\t * pending_buf.\n\t */\n\tconst putShortMSB = (s, b) => {\n  \n\t  //  put_byte(s, (Byte)(b >> 8));\n\t//  put_byte(s, (Byte)(b & 0xff));\n\t  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n\t  s.pending_buf[s.pending++] = b & 0xff;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Read a new buffer from the current input stream, update the adler32\n\t * and total number of bytes read.  All deflate() input goes through\n\t * this function so some applications may wish to modify it to avoid\n\t * allocating a large strm->input buffer and copying from it.\n\t * (See also flush_pending()).\n\t */\n\tconst read_buf = (strm, buf, start, size) => {\n  \n\t  let len = strm.avail_in;\n  \n\t  if (len > size) { len = size; }\n\t  if (len === 0) { return 0; }\n  \n\t  strm.avail_in -= len;\n  \n\t  // zmemcpy(buf, strm->next_in, len);\n\t  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n\t  if (strm.state.wrap === 1) {\n\t\tstrm.adler = adler32_1(strm.adler, buf, len, start);\n\t  }\n  \n\t  else if (strm.state.wrap === 2) {\n\t\tstrm.adler = crc32_1(strm.adler, buf, len, start);\n\t  }\n  \n\t  strm.next_in += len;\n\t  strm.total_in += len;\n  \n\t  return len;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Set match_start to the longest match starting at the given string and\n\t * return its length. Matches shorter or equal to prev_length are discarded,\n\t * in which case the result is equal to prev_length and match_start is\n\t * garbage.\n\t * IN assertions: cur_match is the head of the hash chain for the current\n\t *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n\t * OUT assertion: the match length is not greater than s->lookahead.\n\t */\n\tconst longest_match = (s, cur_match) => {\n  \n\t  let chain_length = s.max_chain_length;      /* max hash chain length */\n\t  let scan = s.strstart; /* current string */\n\t  let match;                       /* matched string */\n\t  let len;                           /* length of current match */\n\t  let best_len = s.prev_length;              /* best match length so far */\n\t  let nice_match = s.nice_match;             /* stop if match long enough */\n\t  const limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n\t\t  s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n  \n\t  const _win = s.window; // shortcut\n  \n\t  const wmask = s.w_mask;\n\t  const prev  = s.prev;\n  \n\t  /* Stop when cur_match becomes <= limit. To simplify the code,\n\t   * we prevent matches with the string of window index 0.\n\t   */\n  \n\t  const strend = s.strstart + MAX_MATCH;\n\t  let scan_end1  = _win[scan + best_len - 1];\n\t  let scan_end   = _win[scan + best_len];\n  \n\t  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n\t   * It is easy to get rid of this optimization if necessary.\n\t   */\n\t  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n  \n\t  /* Do not waste too much time if we already have a good match: */\n\t  if (s.prev_length >= s.good_match) {\n\t\tchain_length >>= 2;\n\t  }\n\t  /* Do not look for matches beyond the end of the input. This is necessary\n\t   * to make deflate deterministic.\n\t   */\n\t  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n  \n\t  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n  \n\t  do {\n\t\t// Assert(cur_match < s->strstart, \"no future\");\n\t\tmatch = cur_match;\n  \n\t\t/* Skip to next match if the match length cannot increase\n\t\t * or if the match length is less than 2.  Note that the checks below\n\t\t * for insufficient lookahead only occur occasionally for performance\n\t\t * reasons.  Therefore uninitialized memory will be accessed, and\n\t\t * conditional jumps will be made that depend on those values.\n\t\t * However the length of the match is limited to the lookahead, so\n\t\t * the output of deflate is not affected by the uninitialized values.\n\t\t */\n  \n\t\tif (_win[match + best_len]     !== scan_end  ||\n\t\t\t_win[match + best_len - 1] !== scan_end1 ||\n\t\t\t_win[match]                !== _win[scan] ||\n\t\t\t_win[++match]              !== _win[scan + 1]) {\n\t\t  continue;\n\t\t}\n  \n\t\t/* The check at best_len-1 can be removed because it will be made\n\t\t * again later. (This heuristic is not always a win.)\n\t\t * It is not necessary to compare scan[2] and match[2] since they\n\t\t * are always equal when the other bytes match, given that\n\t\t * the hash keys are equal and that HASH_BITS >= 8.\n\t\t */\n\t\tscan += 2;\n\t\tmatch++;\n\t\t// Assert(*scan == *match, \"match[2]?\");\n  \n\t\t/* We check for insufficient lookahead only every 8th comparison;\n\t\t * the 256th check will be made at strstart+258.\n\t\t */\n\t\tdo {\n\t\t  /*jshint noempty:false*/\n\t\t} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n\t\t\t\t scan < strend);\n  \n\t\t// Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n  \n\t\tlen = MAX_MATCH - (strend - scan);\n\t\tscan = strend - MAX_MATCH;\n  \n\t\tif (len > best_len) {\n\t\t  s.match_start = cur_match;\n\t\t  best_len = len;\n\t\t  if (len >= nice_match) {\n\t\t\tbreak;\n\t\t  }\n\t\t  scan_end1  = _win[scan + best_len - 1];\n\t\t  scan_end   = _win[scan + best_len];\n\t\t}\n\t  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n  \n\t  if (best_len <= s.lookahead) {\n\t\treturn best_len;\n\t  }\n\t  return s.lookahead;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * Fill the window when the lookahead becomes insufficient.\n\t * Updates strstart and lookahead.\n\t *\n\t * IN assertion: lookahead < MIN_LOOKAHEAD\n\t * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n\t *    At least one byte has been read, or avail_in == 0; reads are\n\t *    performed for at least two bytes (required for the zip translate_eol\n\t *    option -- not supported here).\n\t */\n\tconst fill_window = (s) => {\n  \n\t  const _w_size = s.w_size;\n\t  let p, n, m, more, str;\n  \n\t  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n  \n\t  do {\n\t\tmore = s.window_size - s.lookahead - s.strstart;\n  \n\t\t// JS ints have 32 bit, block below not needed\n\t\t/* Deal with !@#$% 64K limit: */\n\t\t//if (sizeof(int) <= 2) {\n\t\t//    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n\t\t//        more = wsize;\n\t\t//\n\t\t//  } else if (more == (unsigned)(-1)) {\n\t\t//        /* Very unlikely, but possible on 16 bit machine if\n\t\t//         * strstart == 0 && lookahead == 1 (input done a byte at time)\n\t\t//         */\n\t\t//        more--;\n\t\t//    }\n\t\t//}\n  \n  \n\t\t/* If the window is almost full and there is insufficient lookahead,\n\t\t * move the upper half to the lower one to make room in the upper half.\n\t\t */\n\t\tif (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n  \n\t\t  s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n\t\t  s.match_start -= _w_size;\n\t\t  s.strstart -= _w_size;\n\t\t  /* we now have strstart >= MAX_DIST */\n\t\t  s.block_start -= _w_size;\n  \n\t\t  /* Slide the hash table (could be avoided with 32 bit values\n\t\t   at the expense of memory usage). We slide even when level == 0\n\t\t   to keep the hash table consistent if we switch back to level > 0\n\t\t   later. (Using level 0 permanently is not an optimal usage of\n\t\t   zlib, so we don't care about this pathological case.)\n\t\t   */\n  \n\t\t  n = s.hash_size;\n\t\t  p = n;\n  \n\t\t  do {\n\t\t\tm = s.head[--p];\n\t\t\ts.head[p] = (m >= _w_size ? m - _w_size : 0);\n\t\t  } while (--n);\n  \n\t\t  n = _w_size;\n\t\t  p = n;\n  \n\t\t  do {\n\t\t\tm = s.prev[--p];\n\t\t\ts.prev[p] = (m >= _w_size ? m - _w_size : 0);\n\t\t\t/* If n is not on any hash chain, prev[n] is garbage but\n\t\t\t * its value will never be used.\n\t\t\t */\n\t\t  } while (--n);\n  \n\t\t  more += _w_size;\n\t\t}\n\t\tif (s.strm.avail_in === 0) {\n\t\t  break;\n\t\t}\n  \n\t\t/* If there was no sliding:\n\t\t *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n\t\t *    more == window_size - lookahead - strstart\n\t\t * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n\t\t * => more >= window_size - 2*WSIZE + 2\n\t\t * In the BIG_MEM or MMAP case (not yet supported),\n\t\t *   window_size == input_size + MIN_LOOKAHEAD  &&\n\t\t *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n\t\t * Otherwise, window_size == 2*WSIZE so more >= 2.\n\t\t * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n\t\t */\n\t\t//Assert(more >= 2, \"more < 2\");\n\t\tn = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n\t\ts.lookahead += n;\n  \n\t\t/* Initialize the hash value now that we have some input: */\n\t\tif (s.lookahead + s.insert >= MIN_MATCH) {\n\t\t  str = s.strstart - s.insert;\n\t\t  s.ins_h = s.window[str];\n  \n\t\t  /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n\t//#if MIN_MATCH != 3\n\t//        Call update_hash() MIN_MATCH-3 more times\n\t//#endif\n\t\t  while (s.insert) {\n\t\t\t/* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n\t\t\ts.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n  \n\t\t\ts.prev[str & s.w_mask] = s.head[s.ins_h];\n\t\t\ts.head[s.ins_h] = str;\n\t\t\tstr++;\n\t\t\ts.insert--;\n\t\t\tif (s.lookahead + s.insert < MIN_MATCH) {\n\t\t\t  break;\n\t\t\t}\n\t\t  }\n\t\t}\n\t\t/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n\t\t * but this is not important since only literal bytes will be emitted.\n\t\t */\n  \n\t  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n  \n\t  /* If the WIN_INIT bytes after the end of the current data have never been\n\t   * written, then zero those bytes in order to avoid memory check reports of\n\t   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n\t   * the longest match routines.  Update the high water mark for the next\n\t   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n\t   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n\t   */\n\t//  if (s.high_water < s.window_size) {\n\t//    const curr = s.strstart + s.lookahead;\n\t//    let init = 0;\n\t//\n\t//    if (s.high_water < curr) {\n\t//      /* Previous high water mark below current data -- zero WIN_INIT\n\t//       * bytes or up to end of window, whichever is less.\n\t//       */\n\t//      init = s.window_size - curr;\n\t//      if (init > WIN_INIT)\n\t//        init = WIN_INIT;\n\t//      zmemzero(s->window + curr, (unsigned)init);\n\t//      s->high_water = curr + init;\n\t//    }\n\t//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n\t//      /* High water mark at or above current data, but below current data\n\t//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n\t//       * to end of window, whichever is less.\n\t//       */\n\t//      init = (ulg)curr + WIN_INIT - s->high_water;\n\t//      if (init > s->window_size - s->high_water)\n\t//        init = s->window_size - s->high_water;\n\t//      zmemzero(s->window + s->high_water, (unsigned)init);\n\t//      s->high_water += init;\n\t//    }\n\t//  }\n\t//\n\t//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n\t//    \"not enough room for search\");\n\t};\n  \n\t/* ===========================================================================\n\t * Copy without compression as much as possible from the input stream, return\n\t * the current block state.\n\t * This function does not insert new strings in the dictionary since\n\t * uncompressible data is probably not useful. This function is used\n\t * only for the level=0 compression option.\n\t * NOTE: this function should be optimized to avoid extra copying from\n\t * window to pending_buf.\n\t */\n\tconst deflate_stored = (s, flush) => {\n  \n\t  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n\t   * to pending_buf_size, and each stored block has a 5 byte header:\n\t   */\n\t  let max_block_size = 0xffff;\n  \n\t  if (max_block_size > s.pending_buf_size - 5) {\n\t\tmax_block_size = s.pending_buf_size - 5;\n\t  }\n  \n\t  /* Copy as much as possible from input to output: */\n\t  for (;;) {\n\t\t/* Fill the window as much as possible: */\n\t\tif (s.lookahead <= 1) {\n  \n\t\t  //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n\t\t  //  s->block_start >= (long)s->w_size, \"slide too late\");\n\t//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n\t//        s.block_start >= s.w_size)) {\n\t//        throw  new Error(\"slide too late\");\n\t//      }\n  \n\t\t  fill_window(s);\n\t\t  if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n  \n\t\t  if (s.lookahead === 0) {\n\t\t\tbreak;\n\t\t  }\n\t\t  /* flush the current block */\n\t\t}\n\t\t//Assert(s->block_start >= 0L, \"block gone\");\n\t//    if (s.block_start < 0) throw new Error(\"block gone\");\n  \n\t\ts.strstart += s.lookahead;\n\t\ts.lookahead = 0;\n  \n\t\t/* Emit a stored block if pending_buf will be full: */\n\t\tconst max_start = s.block_start + max_block_size;\n  \n\t\tif (s.strstart === 0 || s.strstart >= max_start) {\n\t\t  /* strstart == 0 is possible when wraparound on 16-bit machine */\n\t\t  s.lookahead = s.strstart - max_start;\n\t\t  s.strstart = max_start;\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n  \n  \n\t\t}\n\t\t/* Flush if we may have to slide, otherwise block_start may become\n\t\t * negative and the data will be gone:\n\t\t */\n\t\tif (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n  \n\t  s.insert = 0;\n  \n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n  \n\t  if (s.strstart > s.block_start) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n  \n\t  return BS_NEED_MORE;\n\t};\n  \n\t/* ===========================================================================\n\t * Compress as much as possible from the input stream, return the current\n\t * block state.\n\t * This function does not perform lazy evaluation of matches and inserts\n\t * new strings in the dictionary only for unmatched strings or for short\n\t * matches. It is used only for the fast compression options.\n\t */\n\tconst deflate_fast = (s, flush) => {\n  \n\t  let hash_head;        /* head of the hash chain */\n\t  let bflush;           /* set if current block must be flushed */\n  \n\t  for (;;) {\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t * string following the next match.\n\t\t */\n\t\tif (s.lookahead < MIN_LOOKAHEAD) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  if (s.lookahead === 0) {\n\t\t\tbreak; /* flush the current block */\n\t\t  }\n\t\t}\n  \n\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t */\n\t\thash_head = 0/*NIL*/;\n\t\tif (s.lookahead >= MIN_MATCH) {\n\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t  s.head[s.ins_h] = s.strstart;\n\t\t  /***/\n\t\t}\n  \n\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t * At this point we have always match_length < MIN_MATCH\n\t\t */\n\t\tif (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n\t\t  /* To simplify the code, we prevent matches with the string\n\t\t   * of window index 0 (in particular we have to avoid a match\n\t\t   * of the string with itself at the start of the input file).\n\t\t   */\n\t\t  s.match_length = longest_match(s, hash_head);\n\t\t  /* longest_match() sets match_start */\n\t\t}\n\t\tif (s.match_length >= MIN_MATCH) {\n\t\t  // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n  \n\t\t  /*** _tr_tally_dist(s, s.strstart - s.match_start,\n\t\t\t\t\t\t s.match_length - MIN_MATCH, bflush); ***/\n\t\t  bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n  \n\t\t  s.lookahead -= s.match_length;\n  \n\t\t  /* Insert new strings in the hash table only if the match length\n\t\t   * is not too large. This saves time but degrades compression.\n\t\t   */\n\t\t  if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n\t\t\ts.match_length--; /* string at strstart already in table */\n\t\t\tdo {\n\t\t\t  s.strstart++;\n\t\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t\t  s.head[s.ins_h] = s.strstart;\n\t\t\t  /***/\n\t\t\t  /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n\t\t\t   * always MIN_MATCH bytes ahead.\n\t\t\t   */\n\t\t\t} while (--s.match_length !== 0);\n\t\t\ts.strstart++;\n\t\t  } else\n\t\t  {\n\t\t\ts.strstart += s.match_length;\n\t\t\ts.match_length = 0;\n\t\t\ts.ins_h = s.window[s.strstart];\n\t\t\t/* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n\t\t\ts.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n  \n\t//#if MIN_MATCH != 3\n\t//                Call UPDATE_HASH() MIN_MATCH-3 more times\n\t//#endif\n\t\t\t/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n\t\t\t * matter since it will be recomputed at next deflate call.\n\t\t\t */\n\t\t  }\n\t\t} else {\n\t\t  /* No match, output a literal byte */\n\t\t  //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n\t\t  /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t\t  bflush = _tr_tally(s, 0, s.window[s.strstart]);\n  \n\t\t  s.lookahead--;\n\t\t  s.strstart++;\n\t\t}\n\t\tif (bflush) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n\t  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t};\n  \n\t/* ===========================================================================\n\t * Same as above, but achieves better compression. We use a lazy\n\t * evaluation for matches: a match is finally adopted only if there is\n\t * no better match at the next window position.\n\t */\n\tconst deflate_slow = (s, flush) => {\n  \n\t  let hash_head;          /* head of hash chain */\n\t  let bflush;              /* set if current block must be flushed */\n  \n\t  let max_insert;\n  \n\t  /* Process the input block. */\n\t  for (;;) {\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the next match, plus MIN_MATCH bytes to insert the\n\t\t * string following the next match.\n\t\t */\n\t\tif (s.lookahead < MIN_LOOKAHEAD) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  if (s.lookahead === 0) { break; } /* flush the current block */\n\t\t}\n  \n\t\t/* Insert the string window[strstart .. strstart+2] in the\n\t\t * dictionary, and set hash_head to the head of the hash chain:\n\t\t */\n\t\thash_head = 0/*NIL*/;\n\t\tif (s.lookahead >= MIN_MATCH) {\n\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t  s.head[s.ins_h] = s.strstart;\n\t\t  /***/\n\t\t}\n  \n\t\t/* Find the longest match, discarding those <= prev_length.\n\t\t */\n\t\ts.prev_length = s.match_length;\n\t\ts.prev_match = s.match_start;\n\t\ts.match_length = MIN_MATCH - 1;\n  \n\t\tif (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n\t\t\ts.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n\t\t  /* To simplify the code, we prevent matches with the string\n\t\t   * of window index 0 (in particular we have to avoid a match\n\t\t   * of the string with itself at the start of the input file).\n\t\t   */\n\t\t  s.match_length = longest_match(s, hash_head);\n\t\t  /* longest_match() sets match_start */\n  \n\t\t  if (s.match_length <= 5 &&\n\t\t\t (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n  \n\t\t\t/* If prev_match is also MIN_MATCH, match_start is garbage\n\t\t\t * but we will ignore the current match anyway.\n\t\t\t */\n\t\t\ts.match_length = MIN_MATCH - 1;\n\t\t  }\n\t\t}\n\t\t/* If there was a match at the previous step and the current\n\t\t * match is not better, output the previous match:\n\t\t */\n\t\tif (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n\t\t  max_insert = s.strstart + s.lookahead - MIN_MATCH;\n\t\t  /* Do not insert strings in hash table beyond this. */\n  \n\t\t  //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n  \n\t\t  /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n\t\t\t\t\t\t s.prev_length - MIN_MATCH, bflush);***/\n\t\t  bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n\t\t  /* Insert in hash table all strings up to the end of the match.\n\t\t   * strstart-1 and strstart are already inserted. If there is not\n\t\t   * enough lookahead, the last two strings are not inserted in\n\t\t   * the hash table.\n\t\t   */\n\t\t  s.lookahead -= s.prev_length - 1;\n\t\t  s.prev_length -= 2;\n\t\t  do {\n\t\t\tif (++s.strstart <= max_insert) {\n\t\t\t  /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n\t\t\t  s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n\t\t\t  hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n\t\t\t  s.head[s.ins_h] = s.strstart;\n\t\t\t  /***/\n\t\t\t}\n\t\t  } while (--s.prev_length !== 0);\n\t\t  s.match_available = 0;\n\t\t  s.match_length = MIN_MATCH - 1;\n\t\t  s.strstart++;\n  \n\t\t  if (bflush) {\n\t\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\t\tflush_block_only(s, false);\n\t\t\tif (s.strm.avail_out === 0) {\n\t\t\t  return BS_NEED_MORE;\n\t\t\t}\n\t\t\t/***/\n\t\t  }\n  \n\t\t} else if (s.match_available) {\n\t\t  /* If there was no match at the previous position, output a\n\t\t   * single literal. If there was a match but the current match\n\t\t   * is longer, truncate the previous match to a single literal.\n\t\t   */\n\t\t  //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\t\t  /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n\t\t  bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n  \n\t\t  if (bflush) {\n\t\t\t/*** FLUSH_BLOCK_ONLY(s, 0) ***/\n\t\t\tflush_block_only(s, false);\n\t\t\t/***/\n\t\t  }\n\t\t  s.strstart++;\n\t\t  s.lookahead--;\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t} else {\n\t\t  /* There is no previous match to compare with, wait for\n\t\t   * the next step to decide.\n\t\t   */\n\t\t  s.match_available = 1;\n\t\t  s.strstart++;\n\t\t  s.lookahead--;\n\t\t}\n\t  }\n\t  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n\t  if (s.match_available) {\n\t\t//Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n\t\t/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n\t\tbflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n  \n\t\ts.match_available = 0;\n\t  }\n\t  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n  \n\t  return BS_BLOCK_DONE;\n\t};\n  \n  \n\t/* ===========================================================================\n\t * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n\t * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n\t * deflate switches away from Z_RLE.)\n\t */\n\tconst deflate_rle = (s, flush) => {\n  \n\t  let bflush;            /* set if current block must be flushed */\n\t  let prev;              /* byte at distance one to match */\n\t  let scan, strend;      /* scan goes up to strend for length of run */\n  \n\t  const _win = s.window;\n  \n\t  for (;;) {\n\t\t/* Make sure that we always have enough lookahead, except\n\t\t * at the end of the input file. We need MAX_MATCH bytes\n\t\t * for the longest run, plus one for the unrolled loop.\n\t\t */\n\t\tif (s.lookahead <= MAX_MATCH) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  if (s.lookahead === 0) { break; } /* flush the current block */\n\t\t}\n  \n\t\t/* See how many times the previous byte repeats */\n\t\ts.match_length = 0;\n\t\tif (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n\t\t  scan = s.strstart - 1;\n\t\t  prev = _win[scan];\n\t\t  if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n\t\t\tstrend = s.strstart + MAX_MATCH;\n\t\t\tdo {\n\t\t\t  /*jshint noempty:false*/\n\t\t\t} while (prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t prev === _win[++scan] && prev === _win[++scan] &&\n\t\t\t\t\t scan < strend);\n\t\t\ts.match_length = MAX_MATCH - (strend - scan);\n\t\t\tif (s.match_length > s.lookahead) {\n\t\t\t  s.match_length = s.lookahead;\n\t\t\t}\n\t\t  }\n\t\t  //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n\t\t}\n  \n\t\t/* Emit match if have run of MIN_MATCH or longer, else emit literal */\n\t\tif (s.match_length >= MIN_MATCH) {\n\t\t  //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n  \n\t\t  /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n\t\t  bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n  \n\t\t  s.lookahead -= s.match_length;\n\t\t  s.strstart += s.match_length;\n\t\t  s.match_length = 0;\n\t\t} else {\n\t\t  /* No match, output a literal byte */\n\t\t  //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\t\t  /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t\t  bflush = _tr_tally(s, 0, s.window[s.strstart]);\n  \n\t\t  s.lookahead--;\n\t\t  s.strstart++;\n\t\t}\n\t\tif (bflush) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n\t  s.insert = 0;\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t};\n  \n\t/* ===========================================================================\n\t * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n\t * (It will be regenerated if this run of deflate switches away from Huffman.)\n\t */\n\tconst deflate_huff = (s, flush) => {\n  \n\t  let bflush;             /* set if current block must be flushed */\n  \n\t  for (;;) {\n\t\t/* Make sure that we have a literal to write. */\n\t\tif (s.lookahead === 0) {\n\t\t  fill_window(s);\n\t\t  if (s.lookahead === 0) {\n\t\t\tif (flush === Z_NO_FLUSH$2) {\n\t\t\t  return BS_NEED_MORE;\n\t\t\t}\n\t\t\tbreak;      /* flush the current block */\n\t\t  }\n\t\t}\n  \n\t\t/* Output a literal byte */\n\t\ts.match_length = 0;\n\t\t//Tracevv((stderr,\"%c\", s->window[s->strstart]));\n\t\t/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n\t\tbflush = _tr_tally(s, 0, s.window[s.strstart]);\n\t\ts.lookahead--;\n\t\ts.strstart++;\n\t\tif (bflush) {\n\t\t  /*** FLUSH_BLOCK(s, 0); ***/\n\t\t  flush_block_only(s, false);\n\t\t  if (s.strm.avail_out === 0) {\n\t\t\treturn BS_NEED_MORE;\n\t\t  }\n\t\t  /***/\n\t\t}\n\t  }\n\t  s.insert = 0;\n\t  if (flush === Z_FINISH$3) {\n\t\t/*** FLUSH_BLOCK(s, 1); ***/\n\t\tflush_block_only(s, true);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_FINISH_STARTED;\n\t\t}\n\t\t/***/\n\t\treturn BS_FINISH_DONE;\n\t  }\n\t  if (s.last_lit) {\n\t\t/*** FLUSH_BLOCK(s, 0); ***/\n\t\tflush_block_only(s, false);\n\t\tif (s.strm.avail_out === 0) {\n\t\t  return BS_NEED_MORE;\n\t\t}\n\t\t/***/\n\t  }\n\t  return BS_BLOCK_DONE;\n\t};\n  \n\t/* Values for max_lazy_match, good_match and max_chain_length, depending on\n\t * the desired pack level (0..9). The values given below have been tuned to\n\t * exclude worst case performance for pathological files. Better values may be\n\t * found for specific files.\n\t */\n\tfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  \n\t  this.good_length = good_length;\n\t  this.max_lazy = max_lazy;\n\t  this.nice_length = nice_length;\n\t  this.max_chain = max_chain;\n\t  this.func = func;\n\t}\n  \n\tconst configuration_table = [\n\t  /*      good lazy nice chain */\n\t  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n\t  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n\t  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n\t  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n  \n\t  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n\t  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n\t  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n\t  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n\t  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n\t  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n\t];\n  \n  \n\t/* ===========================================================================\n\t * Initialize the \"longest match\" routines for a new zlib stream\n\t */\n\tconst lm_init = (s) => {\n  \n\t  s.window_size = 2 * s.w_size;\n  \n\t  /*** CLEAR_HASH(s); ***/\n\t  zero(s.head); // Fill with NIL (= 0);\n  \n\t  /* Set the default configuration parameters:\n\t   */\n\t  s.max_lazy_match = configuration_table[s.level].max_lazy;\n\t  s.good_match = configuration_table[s.level].good_length;\n\t  s.nice_match = configuration_table[s.level].nice_length;\n\t  s.max_chain_length = configuration_table[s.level].max_chain;\n  \n\t  s.strstart = 0;\n\t  s.block_start = 0;\n\t  s.lookahead = 0;\n\t  s.insert = 0;\n\t  s.match_length = s.prev_length = MIN_MATCH - 1;\n\t  s.match_available = 0;\n\t  s.ins_h = 0;\n\t};\n  \n  \n\tfunction DeflateState() {\n\t  this.strm = null;            /* pointer back to this zlib stream */\n\t  this.status = 0;            /* as the name implies */\n\t  this.pending_buf = null;      /* output still pending */\n\t  this.pending_buf_size = 0;  /* size of pending_buf */\n\t  this.pending_out = 0;       /* next pending byte to output to the stream */\n\t  this.pending = 0;           /* nb of bytes in the pending buffer */\n\t  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n\t  this.gzhead = null;         /* gzip header information to write */\n\t  this.gzindex = 0;           /* where in extra, name, or comment */\n\t  this.method = Z_DEFLATED$2; /* can only be DEFLATED */\n\t  this.last_flush = -1;   /* value of flush param for previous deflate call */\n  \n\t  this.w_size = 0;  /* LZ77 window size (32K by default) */\n\t  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n\t  this.w_mask = 0;  /* w_size - 1 */\n  \n\t  this.window = null;\n\t  /* Sliding window. Input bytes are read into the second half of the window,\n\t   * and move to the first half later to keep a dictionary of at least wSize\n\t   * bytes. With this organization, matches are limited to a distance of\n\t   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n\t   * performed with a length multiple of the block size.\n\t   */\n  \n\t  this.window_size = 0;\n\t  /* Actual size of window: 2*wSize, except when the user input buffer\n\t   * is directly used as sliding window.\n\t   */\n  \n\t  this.prev = null;\n\t  /* Link to older string with same hash index. To limit the size of this\n\t   * array to 64K, this link is maintained only for the last 32K strings.\n\t   * An index in this array is thus a window index modulo 32K.\n\t   */\n  \n\t  this.head = null;   /* Heads of the hash chains or NIL. */\n  \n\t  this.ins_h = 0;       /* hash index of string to be inserted */\n\t  this.hash_size = 0;   /* number of elements in hash table */\n\t  this.hash_bits = 0;   /* log2(hash_size) */\n\t  this.hash_mask = 0;   /* hash_size-1 */\n  \n\t  this.hash_shift = 0;\n\t  /* Number of bits by which ins_h must be shifted at each input\n\t   * step. It must be such that after MIN_MATCH steps, the oldest\n\t   * byte no longer takes part in the hash key, that is:\n\t   *   hash_shift * MIN_MATCH >= hash_bits\n\t   */\n  \n\t  this.block_start = 0;\n\t  /* Window position at the beginning of the current output block. Gets\n\t   * negative when the window is moved backwards.\n\t   */\n  \n\t  this.match_length = 0;      /* length of best match */\n\t  this.prev_match = 0;        /* previous match */\n\t  this.match_available = 0;   /* set if previous match exists */\n\t  this.strstart = 0;          /* start of string to insert */\n\t  this.match_start = 0;       /* start of matching string */\n\t  this.lookahead = 0;         /* number of valid bytes ahead in window */\n  \n\t  this.prev_length = 0;\n\t  /* Length of the best match at previous step. Matches not greater than this\n\t   * are discarded. This is used in the lazy match evaluation.\n\t   */\n  \n\t  this.max_chain_length = 0;\n\t  /* To speed up deflation, hash chains are never searched beyond this\n\t   * length.  A higher limit improves compression ratio but degrades the\n\t   * speed.\n\t   */\n  \n\t  this.max_lazy_match = 0;\n\t  /* Attempt to find a better match only when the current match is strictly\n\t   * smaller than this value. This mechanism is used only for compression\n\t   * levels >= 4.\n\t   */\n\t  // That's alias to max_lazy_match, don't use directly\n\t  //this.max_insert_length = 0;\n\t  /* Insert new strings in the hash table only if the match length is not\n\t   * greater than this length. This saves time but degrades compression.\n\t   * max_insert_length is used only for compression levels <= 3.\n\t   */\n  \n\t  this.level = 0;     /* compression level (1..9) */\n\t  this.strategy = 0;  /* favor or force Huffman coding*/\n  \n\t  this.good_match = 0;\n\t  /* Use a faster search when the previous match is longer than this */\n  \n\t  this.nice_match = 0; /* Stop searching when current match exceeds this */\n  \n\t\t\t\t  /* used by trees.c: */\n  \n\t  /* Didn't use ct_data typedef below to suppress compiler warning */\n  \n\t  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n\t  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n\t  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n  \n\t  // Use flat array of DOUBLE size, with interleaved fata,\n\t  // because JS does not support effective\n\t  this.dyn_ltree  = new Uint16Array(HEAP_SIZE * 2);\n\t  this.dyn_dtree  = new Uint16Array((2 * D_CODES + 1) * 2);\n\t  this.bl_tree    = new Uint16Array((2 * BL_CODES + 1) * 2);\n\t  zero(this.dyn_ltree);\n\t  zero(this.dyn_dtree);\n\t  zero(this.bl_tree);\n  \n\t  this.l_desc   = null;         /* desc. for literal tree */\n\t  this.d_desc   = null;         /* desc. for distance tree */\n\t  this.bl_desc  = null;         /* desc. for bit length tree */\n  \n\t  //ush bl_count[MAX_BITS+1];\n\t  this.bl_count = new Uint16Array(MAX_BITS + 1);\n\t  /* number of codes at each bit length for an optimal tree */\n  \n\t  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n\t  this.heap = new Uint16Array(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n\t  zero(this.heap);\n  \n\t  this.heap_len = 0;               /* number of elements in the heap */\n\t  this.heap_max = 0;               /* element of largest frequency */\n\t  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n\t   * The same heap array is used to build all trees.\n\t   */\n  \n\t  this.depth = new Uint16Array(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n\t  zero(this.depth);\n\t  /* Depth of each subtree used as tie breaker for trees of equal frequency\n\t   */\n  \n\t  this.l_buf = 0;          /* buffer index for literals or lengths */\n  \n\t  this.lit_bufsize = 0;\n\t  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n\t   * limiting lit_bufsize to 64K:\n\t   *   - frequencies can be kept in 16 bit counters\n\t   *   - if compression is not successful for the first block, all input\n\t   *     data is still in the window so we can still emit a stored block even\n\t   *     when input comes from standard input.  (This can also be done for\n\t   *     all blocks if lit_bufsize is not greater than 32K.)\n\t   *   - if compression is not successful for a file smaller than 64K, we can\n\t   *     even emit a stored file instead of a stored block (saving 5 bytes).\n\t   *     This is applicable only for zip (not gzip or zlib).\n\t   *   - creating new Huffman trees less frequently may not provide fast\n\t   *     adaptation to changes in the input data statistics. (Take for\n\t   *     example a binary file with poorly compressible code followed by\n\t   *     a highly compressible string table.) Smaller buffer sizes give\n\t   *     fast adaptation but have of course the overhead of transmitting\n\t   *     trees more frequently.\n\t   *   - I can't count above 4\n\t   */\n  \n\t  this.last_lit = 0;      /* running index in l_buf */\n  \n\t  this.d_buf = 0;\n\t  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n\t   * the same number of elements. To use different lengths, an extra flag\n\t   * array would be necessary.\n\t   */\n  \n\t  this.opt_len = 0;       /* bit length of current block with optimal trees */\n\t  this.static_len = 0;    /* bit length of current block with static trees */\n\t  this.matches = 0;       /* number of string matches in current block */\n\t  this.insert = 0;        /* bytes at end of window left to insert */\n  \n  \n\t  this.bi_buf = 0;\n\t  /* Output buffer. bits are inserted starting at the bottom (least\n\t   * significant bits).\n\t   */\n\t  this.bi_valid = 0;\n\t  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n\t   * are always zero.\n\t   */\n  \n\t  // Used for window memory init. We safely ignore it for JS. That makes\n\t  // sense only for pointers and memory check tools.\n\t  //this.high_water = 0;\n\t  /* High water mark offset in window for initialized bytes -- bytes above\n\t   * this are set to zero in order to avoid memory check warnings when\n\t   * longest match routines access bytes past the input.  This is then\n\t   * updated to the new high water mark.\n\t   */\n\t}\n  \n  \n\tconst deflateResetKeep = (strm) => {\n  \n\t  if (!strm || !strm.state) {\n\t\treturn err(strm, Z_STREAM_ERROR$2);\n\t  }\n  \n\t  strm.total_in = strm.total_out = 0;\n\t  strm.data_type = Z_UNKNOWN;\n  \n\t  const s = strm.state;\n\t  s.pending = 0;\n\t  s.pending_out = 0;\n  \n\t  if (s.wrap < 0) {\n\t\ts.wrap = -s.wrap;\n\t\t/* was made negative by deflate(..., Z_FINISH); */\n\t  }\n\t  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n\t  strm.adler = (s.wrap === 2) ?\n\t\t0  // crc32(0, Z_NULL, 0)\n\t  :\n\t\t1; // adler32(0, Z_NULL, 0)\n\t  s.last_flush = Z_NO_FLUSH$2;\n\t  _tr_init(s);\n\t  return Z_OK$3;\n\t};\n  \n  \n\tconst deflateReset = (strm) => {\n  \n\t  const ret = deflateResetKeep(strm);\n\t  if (ret === Z_OK$3) {\n\t\tlm_init(strm.state);\n\t  }\n\t  return ret;\n\t};\n  \n  \n\tconst deflateSetHeader = (strm, head) => {\n  \n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$2; }\n\t  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR$2; }\n\t  strm.state.gzhead = head;\n\t  return Z_OK$3;\n\t};\n  \n  \n\tconst deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n  \n\t  if (!strm) { // === Z_NULL\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n\t  let wrap = 1;\n  \n\t  if (level === Z_DEFAULT_COMPRESSION$1) {\n\t\tlevel = 6;\n\t  }\n  \n\t  if (windowBits < 0) { /* suppress zlib wrapper */\n\t\twrap = 0;\n\t\twindowBits = -windowBits;\n\t  }\n  \n\t  else if (windowBits > 15) {\n\t\twrap = 2;           /* write gzip wrapper instead */\n\t\twindowBits -= 16;\n\t  }\n  \n  \n\t  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 ||\n\t\twindowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n\t\tstrategy < 0 || strategy > Z_FIXED) {\n\t\treturn err(strm, Z_STREAM_ERROR$2);\n\t  }\n  \n  \n\t  if (windowBits === 8) {\n\t\twindowBits = 9;\n\t  }\n\t  /* until 256-byte window bug fixed */\n  \n\t  const s = new DeflateState();\n  \n\t  strm.state = s;\n\t  s.strm = strm;\n  \n\t  s.wrap = wrap;\n\t  s.gzhead = null;\n\t  s.w_bits = windowBits;\n\t  s.w_size = 1 << s.w_bits;\n\t  s.w_mask = s.w_size - 1;\n  \n\t  s.hash_bits = memLevel + 7;\n\t  s.hash_size = 1 << s.hash_bits;\n\t  s.hash_mask = s.hash_size - 1;\n\t  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n  \n\t  s.window = new Uint8Array(s.w_size * 2);\n\t  s.head = new Uint16Array(s.hash_size);\n\t  s.prev = new Uint16Array(s.w_size);\n  \n\t  // Don't need mem init magic for JS.\n\t  //s.high_water = 0;  /* nothing written to s->window yet */\n  \n\t  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n  \n\t  s.pending_buf_size = s.lit_bufsize * 4;\n  \n\t  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n\t  //s->pending_buf = (uchf *) overlay;\n\t  s.pending_buf = new Uint8Array(s.pending_buf_size);\n  \n\t  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n\t  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n\t  s.d_buf = 1 * s.lit_bufsize;\n  \n\t  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n\t  s.l_buf = (1 + 2) * s.lit_bufsize;\n  \n\t  s.level = level;\n\t  s.strategy = strategy;\n\t  s.method = method;\n  \n\t  return deflateReset(strm);\n\t};\n  \n\tconst deflateInit = (strm, level) => {\n  \n\t  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n\t};\n  \n  \n\tconst deflate$2 = (strm, flush) => {\n  \n\t  let beg, val; // for gzip header write only\n  \n\t  if (!strm || !strm.state ||\n\t\tflush > Z_BLOCK$1 || flush < 0) {\n\t\treturn strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n\t  }\n  \n\t  const s = strm.state;\n  \n\t  if (!strm.output ||\n\t\t  (!strm.input && strm.avail_in !== 0) ||\n\t\t  (s.status === FINISH_STATE && flush !== Z_FINISH$3)) {\n\t\treturn err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n\t  }\n  \n\t  s.strm = strm; /* just in case */\n\t  const old_flush = s.last_flush;\n\t  s.last_flush = flush;\n  \n\t  /* Write the header */\n\t  if (s.status === INIT_STATE) {\n  \n\t\tif (s.wrap === 2) { // GZIP header\n\t\t  strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n\t\t  put_byte(s, 31);\n\t\t  put_byte(s, 139);\n\t\t  put_byte(s, 8);\n\t\t  if (!s.gzhead) { // s->gzhead == Z_NULL\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, 0);\n\t\t\tput_byte(s, s.level === 9 ? 2 :\n\t\t\t\t\t\t(s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n\t\t\t\t\t\t 4 : 0));\n\t\t\tput_byte(s, OS_CODE);\n\t\t\ts.status = BUSY_STATE;\n\t\t  }\n\t\t  else {\n\t\t\tput_byte(s, (s.gzhead.text ? 1 : 0) +\n\t\t\t\t\t\t(s.gzhead.hcrc ? 2 : 0) +\n\t\t\t\t\t\t(!s.gzhead.extra ? 0 : 4) +\n\t\t\t\t\t\t(!s.gzhead.name ? 0 : 8) +\n\t\t\t\t\t\t(!s.gzhead.comment ? 0 : 16)\n\t\t\t);\n\t\t\tput_byte(s, s.gzhead.time & 0xff);\n\t\t\tput_byte(s, (s.gzhead.time >> 8) & 0xff);\n\t\t\tput_byte(s, (s.gzhead.time >> 16) & 0xff);\n\t\t\tput_byte(s, (s.gzhead.time >> 24) & 0xff);\n\t\t\tput_byte(s, s.level === 9 ? 2 :\n\t\t\t\t\t\t(s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n\t\t\t\t\t\t 4 : 0));\n\t\t\tput_byte(s, s.gzhead.os & 0xff);\n\t\t\tif (s.gzhead.extra && s.gzhead.extra.length) {\n\t\t\t  put_byte(s, s.gzhead.extra.length & 0xff);\n\t\t\t  put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n\t\t\t}\n\t\t\tif (s.gzhead.hcrc) {\n\t\t\t  strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n\t\t\t}\n\t\t\ts.gzindex = 0;\n\t\t\ts.status = EXTRA_STATE;\n\t\t  }\n\t\t}\n\t\telse // DEFLATE header\n\t\t{\n\t\t  let header = (Z_DEFLATED$2 + ((s.w_bits - 8) << 4)) << 8;\n\t\t  let level_flags = -1;\n  \n\t\t  if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n\t\t\tlevel_flags = 0;\n\t\t  } else if (s.level < 6) {\n\t\t\tlevel_flags = 1;\n\t\t  } else if (s.level === 6) {\n\t\t\tlevel_flags = 2;\n\t\t  } else {\n\t\t\tlevel_flags = 3;\n\t\t  }\n\t\t  header |= (level_flags << 6);\n\t\t  if (s.strstart !== 0) { header |= PRESET_DICT; }\n\t\t  header += 31 - (header % 31);\n  \n\t\t  s.status = BUSY_STATE;\n\t\t  putShortMSB(s, header);\n  \n\t\t  /* Save the adler32 of the preset dictionary: */\n\t\t  if (s.strstart !== 0) {\n\t\t\tputShortMSB(s, strm.adler >>> 16);\n\t\t\tputShortMSB(s, strm.adler & 0xffff);\n\t\t  }\n\t\t  strm.adler = 1; // adler32(0L, Z_NULL, 0);\n\t\t}\n\t  }\n  \n\t//#ifdef GZIP\n\t  if (s.status === EXTRA_STATE) {\n\t\tif (s.gzhead.extra/* != Z_NULL*/) {\n\t\t  beg = s.pending;  /* start of bytes to update crc */\n  \n\t\t  while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n\t\t\tif (s.pending === s.pending_buf_size) {\n\t\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t\t  }\n\t\t\t  flush_pending(strm);\n\t\t\t  beg = s.pending;\n\t\t\t  if (s.pending === s.pending_buf_size) {\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\tput_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n\t\t\ts.gzindex++;\n\t\t  }\n\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t  }\n\t\t  if (s.gzindex === s.gzhead.extra.length) {\n\t\t\ts.gzindex = 0;\n\t\t\ts.status = NAME_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = NAME_STATE;\n\t\t}\n\t  }\n\t  if (s.status === NAME_STATE) {\n\t\tif (s.gzhead.name/* != Z_NULL*/) {\n\t\t  beg = s.pending;  /* start of bytes to update crc */\n\t\t  //int val;\n  \n\t\t  do {\n\t\t\tif (s.pending === s.pending_buf_size) {\n\t\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t\t  }\n\t\t\t  flush_pending(strm);\n\t\t\t  beg = s.pending;\n\t\t\t  if (s.pending === s.pending_buf_size) {\n\t\t\t\tval = 1;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t// JS specific: little magic to add zero terminator to end of string\n\t\t\tif (s.gzindex < s.gzhead.name.length) {\n\t\t\t  val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n\t\t\t} else {\n\t\t\t  val = 0;\n\t\t\t}\n\t\t\tput_byte(s, val);\n\t\t  } while (val !== 0);\n  \n\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t  }\n\t\t  if (val === 0) {\n\t\t\ts.gzindex = 0;\n\t\t\ts.status = COMMENT_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = COMMENT_STATE;\n\t\t}\n\t  }\n\t  if (s.status === COMMENT_STATE) {\n\t\tif (s.gzhead.comment/* != Z_NULL*/) {\n\t\t  beg = s.pending;  /* start of bytes to update crc */\n\t\t  //int val;\n  \n\t\t  do {\n\t\t\tif (s.pending === s.pending_buf_size) {\n\t\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t\t  }\n\t\t\t  flush_pending(strm);\n\t\t\t  beg = s.pending;\n\t\t\t  if (s.pending === s.pending_buf_size) {\n\t\t\t\tval = 1;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t}\n\t\t\t// JS specific: little magic to add zero terminator to end of string\n\t\t\tif (s.gzindex < s.gzhead.comment.length) {\n\t\t\t  val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n\t\t\t} else {\n\t\t\t  val = 0;\n\t\t\t}\n\t\t\tput_byte(s, val);\n\t\t  } while (val !== 0);\n  \n\t\t  if (s.gzhead.hcrc && s.pending > beg) {\n\t\t\tstrm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n\t\t  }\n\t\t  if (val === 0) {\n\t\t\ts.status = HCRC_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = HCRC_STATE;\n\t\t}\n\t  }\n\t  if (s.status === HCRC_STATE) {\n\t\tif (s.gzhead.hcrc) {\n\t\t  if (s.pending + 2 > s.pending_buf_size) {\n\t\t\tflush_pending(strm);\n\t\t  }\n\t\t  if (s.pending + 2 <= s.pending_buf_size) {\n\t\t\tput_byte(s, strm.adler & 0xff);\n\t\t\tput_byte(s, (strm.adler >> 8) & 0xff);\n\t\t\tstrm.adler = 0; //crc32(0L, Z_NULL, 0);\n\t\t\ts.status = BUSY_STATE;\n\t\t  }\n\t\t}\n\t\telse {\n\t\t  s.status = BUSY_STATE;\n\t\t}\n\t  }\n\t//#endif\n  \n\t  /* Flush as much pending output as possible */\n\t  if (s.pending !== 0) {\n\t\tflush_pending(strm);\n\t\tif (strm.avail_out === 0) {\n\t\t  /* Since avail_out is 0, deflate will be called again with\n\t\t   * more output space, but possibly with both pending and\n\t\t   * avail_in equal to zero. There won't be anything to do,\n\t\t   * but this is not an error situation so make sure we\n\t\t   * return OK instead of BUF_ERROR at next call of deflate:\n\t\t   */\n\t\t  s.last_flush = -1;\n\t\t  return Z_OK$3;\n\t\t}\n  \n\t\t/* Make sure there is something to do and avoid duplicate consecutive\n\t\t * flushes. For repeated and useless calls with Z_FINISH, we keep\n\t\t * returning Z_STREAM_END instead of Z_BUF_ERROR.\n\t\t */\n\t  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n\t\tflush !== Z_FINISH$3) {\n\t\treturn err(strm, Z_BUF_ERROR$1);\n\t  }\n  \n\t  /* User must not provide more input after the first FINISH: */\n\t  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n\t\treturn err(strm, Z_BUF_ERROR$1);\n\t  }\n  \n\t  /* Start a new block or continue the current one.\n\t   */\n\t  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n\t\t(flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE)) {\n\t\tlet bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n\t\t  (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n\t\t\tconfiguration_table[s.level].func(s, flush));\n  \n\t\tif (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n\t\t  s.status = FINISH_STATE;\n\t\t}\n\t\tif (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n\t\t  if (strm.avail_out === 0) {\n\t\t\ts.last_flush = -1;\n\t\t\t/* avoid BUF_ERROR next call, see above */\n\t\t  }\n\t\t  return Z_OK$3;\n\t\t  /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n\t\t   * of deflate should use the same flush parameter to make sure\n\t\t   * that the flush is complete. So we don't have to output an\n\t\t   * empty block here, this will be done at next call. This also\n\t\t   * ensures that for a very small output buffer, we emit at most\n\t\t   * one empty block.\n\t\t   */\n\t\t}\n\t\tif (bstate === BS_BLOCK_DONE) {\n\t\t  if (flush === Z_PARTIAL_FLUSH) {\n\t\t\t_tr_align(s);\n\t\t  }\n\t\t  else if (flush !== Z_BLOCK$1) { /* FULL_FLUSH or SYNC_FLUSH */\n  \n\t\t\t_tr_stored_block(s, 0, 0, false);\n\t\t\t/* For a full flush, this empty block will be recognized\n\t\t\t * as a special marker by inflate_sync().\n\t\t\t */\n\t\t\tif (flush === Z_FULL_FLUSH$1) {\n\t\t\t  /*** CLEAR_HASH(s); ***/             /* forget history */\n\t\t\t  zero(s.head); // Fill with NIL (= 0);\n  \n\t\t\t  if (s.lookahead === 0) {\n\t\t\t\ts.strstart = 0;\n\t\t\t\ts.block_start = 0;\n\t\t\t\ts.insert = 0;\n\t\t\t  }\n\t\t\t}\n\t\t  }\n\t\t  flush_pending(strm);\n\t\t  if (strm.avail_out === 0) {\n\t\t\ts.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n\t\t\treturn Z_OK$3;\n\t\t  }\n\t\t}\n\t  }\n\t  //Assert(strm->avail_out > 0, \"bug2\");\n\t  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n  \n\t  if (flush !== Z_FINISH$3) { return Z_OK$3; }\n\t  if (s.wrap <= 0) { return Z_STREAM_END$3; }\n  \n\t  /* Write the trailer */\n\t  if (s.wrap === 2) {\n\t\tput_byte(s, strm.adler & 0xff);\n\t\tput_byte(s, (strm.adler >> 8) & 0xff);\n\t\tput_byte(s, (strm.adler >> 16) & 0xff);\n\t\tput_byte(s, (strm.adler >> 24) & 0xff);\n\t\tput_byte(s, strm.total_in & 0xff);\n\t\tput_byte(s, (strm.total_in >> 8) & 0xff);\n\t\tput_byte(s, (strm.total_in >> 16) & 0xff);\n\t\tput_byte(s, (strm.total_in >> 24) & 0xff);\n\t  }\n\t  else\n\t  {\n\t\tputShortMSB(s, strm.adler >>> 16);\n\t\tputShortMSB(s, strm.adler & 0xffff);\n\t  }\n  \n\t  flush_pending(strm);\n\t  /* If avail_out is zero, the application will call deflate again\n\t   * to flush the rest.\n\t   */\n\t  if (s.wrap > 0) { s.wrap = -s.wrap; }\n\t  /* write the trailer only once! */\n\t  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n\t};\n  \n  \n\tconst deflateEnd = (strm) => {\n  \n\t  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n  \n\t  const status = strm.state.status;\n\t  if (status !== INIT_STATE &&\n\t\tstatus !== EXTRA_STATE &&\n\t\tstatus !== NAME_STATE &&\n\t\tstatus !== COMMENT_STATE &&\n\t\tstatus !== HCRC_STATE &&\n\t\tstatus !== BUSY_STATE &&\n\t\tstatus !== FINISH_STATE\n\t  ) {\n\t\treturn err(strm, Z_STREAM_ERROR$2);\n\t  }\n  \n\t  strm.state = null;\n  \n\t  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n\t};\n  \n  \n\t/* =========================================================================\n\t * Initializes the compression dictionary from the given byte\n\t * sequence without producing any compressed output.\n\t */\n\tconst deflateSetDictionary = (strm, dictionary) => {\n  \n\t  let dictLength = dictionary.length;\n  \n\t  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n  \n\t  const s = strm.state;\n\t  const wrap = s.wrap;\n  \n\t  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n\t\treturn Z_STREAM_ERROR$2;\n\t  }\n  \n\t  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n\t  if (wrap === 1) {\n\t\t/* adler32(strm->adler, dictionary, dictLength); */\n\t\tstrm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n\t  }\n  \n\t  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n  \n\t  /* if dictionary would fill window, just replace the history */\n\t  if (dictLength >= s.w_size) {\n\t\tif (wrap === 0) {            /* already empty otherwise */\n\t\t  /*** CLEAR_HASH(s); ***/\n\t\t  zero(s.head); // Fill with NIL (= 0);\n\t\t  s.strstart = 0;\n\t\t  s.block_start = 0;\n\t\t  s.insert = 0;\n\t\t}\n\t\t/* use the tail */\n\t\t// dictionary = dictionary.slice(dictLength - s.w_size);\n\t\tlet tmpDict = new Uint8Array(s.w_size);\n\t\ttmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n\t\tdictionary = tmpDict;\n\t\tdictLength = s.w_size;\n\t  }\n\t  /* insert dictionary into window and hash */\n\t  const avail = strm.avail_in;\n\t  const next = strm.next_in;\n\t  const input = strm.input;\n\t  strm.avail_in = dictLength;\n\t  strm.next_in = 0;\n\t  strm.input = dictionary;\n\t  fill_window(s);\n\t  while (s.lookahead >= MIN_MATCH) {\n\t\tlet str = s.strstart;\n\t\tlet n = s.lookahead - (MIN_MATCH - 1);\n\t\tdo {\n\t\t  /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n\t\t  s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n  \n\t\t  s.prev[str & s.w_mask] = s.head[s.ins_h];\n  \n\t\t  s.head[s.ins_h] = str;\n\t\t  str++;\n\t\t} while (--n);\n\t\ts.strstart = str;\n\t\ts.lookahead = MIN_MATCH - 1;\n\t\tfill_window(s);\n\t  }\n\t  s.strstart += s.lookahead;\n\t  s.block_start = s.strstart;\n\t  s.insert = s.lookahead;\n\t  s.lookahead = 0;\n\t  s.match_length = s.prev_length = MIN_MATCH - 1;\n\t  s.match_available = 0;\n\t  strm.next_in = next;\n\t  strm.input = input;\n\t  strm.avail_in = avail;\n\t  s.wrap = wrap;\n\t  return Z_OK$3;\n\t};\n  \n  \n\tvar deflateInit_1 = deflateInit;\n\tvar deflateInit2_1 = deflateInit2;\n\tvar deflateReset_1 = deflateReset;\n\tvar deflateResetKeep_1 = deflateResetKeep;\n\tvar deflateSetHeader_1 = deflateSetHeader;\n\tvar deflate_2$1 = deflate$2;\n\tvar deflateEnd_1 = deflateEnd;\n\tvar deflateSetDictionary_1 = deflateSetDictionary;\n\tvar deflateInfo = 'pako deflate (from Nodeca project)';\n  \n\t/* Not implemented\n\tmodule.exports.deflateBound = deflateBound;\n\tmodule.exports.deflateCopy = deflateCopy;\n\tmodule.exports.deflateParams = deflateParams;\n\tmodule.exports.deflatePending = deflatePending;\n\tmodule.exports.deflatePrime = deflatePrime;\n\tmodule.exports.deflateTune = deflateTune;\n\t*/\n  \n\tvar deflate_1$2 = {\n\t\tdeflateInit: deflateInit_1,\n\t\tdeflateInit2: deflateInit2_1,\n\t\tdeflateReset: deflateReset_1,\n\t\tdeflateResetKeep: deflateResetKeep_1,\n\t\tdeflateSetHeader: deflateSetHeader_1,\n\t\tdeflate: deflate_2$1,\n\t\tdeflateEnd: deflateEnd_1,\n\t\tdeflateSetDictionary: deflateSetDictionary_1,\n\t\tdeflateInfo: deflateInfo\n\t};\n  \n\tconst _has = (obj, key) => {\n\t  return Object.prototype.hasOwnProperty.call(obj, key);\n\t};\n  \n\tvar assign = function (obj /*from1, from2, from3, ...*/) {\n\t  const sources = Array.prototype.slice.call(arguments, 1);\n\t  while (sources.length) {\n\t\tconst source = sources.shift();\n\t\tif (!source) { continue; }\n  \n\t\tif (typeof source !== 'object') {\n\t\t  throw new TypeError(source + 'must be non-object');\n\t\t}\n  \n\t\tfor (const p in source) {\n\t\t  if (_has(source, p)) {\n\t\t\tobj[p] = source[p];\n\t\t  }\n\t\t}\n\t  }\n  \n\t  return obj;\n\t};\n  \n  \n\t// Join array of chunks to single array.\n\tvar flattenChunks = (chunks) => {\n\t  // calculate data length\n\t  let len = 0;\n  \n\t  for (let i = 0, l = chunks.length; i < l; i++) {\n\t\tlen += chunks[i].length;\n\t  }\n  \n\t  // join chunks\n\t  const result = new Uint8Array(len);\n  \n\t  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n\t\tlet chunk = chunks[i];\n\t\tresult.set(chunk, pos);\n\t\tpos += chunk.length;\n\t  }\n  \n\t  return result;\n\t};\n  \n\tvar common = {\n\t\tassign: assign,\n\t\tflattenChunks: flattenChunks\n\t};\n  \n\t// String encode/decode helpers\n  \n  \n\t// Quick check if we can use fast array to bin string conversion\n\t//\n\t// - apply(Array) can fail on Android 2.2\n\t// - apply(Uint8Array) can fail on iOS 5.1 Safari\n\t//\n\tlet STR_APPLY_UIA_OK = true;\n  \n\ttry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n  \n  \n\t// Table with utf8 lengths (calculated by first byte of sequence)\n\t// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n\t// because max possible codepoint is 0x10ffff\n\tconst _utf8len = new Uint8Array(256);\n\tfor (let q = 0; q < 256; q++) {\n\t  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n\t}\n\t_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n  \n  \n\t// convert string to array (typed, when possible)\n\tvar string2buf = (str) => {\n\t  if (typeof TextEncoder === 'function' && TextEncoder.prototype.encode) {\n\t\treturn new TextEncoder().encode(str);\n\t  }\n  \n\t  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n  \n\t  // count binary size\n\t  for (m_pos = 0; m_pos < str_len; m_pos++) {\n\t\tc = str.charCodeAt(m_pos);\n\t\tif ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n\t\t  c2 = str.charCodeAt(m_pos + 1);\n\t\t  if ((c2 & 0xfc00) === 0xdc00) {\n\t\t\tc = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n\t\t\tm_pos++;\n\t\t  }\n\t\t}\n\t\tbuf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n\t  }\n  \n\t  // allocate buffer\n\t  buf = new Uint8Array(buf_len);\n  \n\t  // convert\n\t  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n\t\tc = str.charCodeAt(m_pos);\n\t\tif ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n\t\t  c2 = str.charCodeAt(m_pos + 1);\n\t\t  if ((c2 & 0xfc00) === 0xdc00) {\n\t\t\tc = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n\t\t\tm_pos++;\n\t\t  }\n\t\t}\n\t\tif (c < 0x80) {\n\t\t  /* one byte */\n\t\t  buf[i++] = c;\n\t\t} else if (c < 0x800) {\n\t\t  /* two bytes */\n\t\t  buf[i++] = 0xC0 | (c >>> 6);\n\t\t  buf[i++] = 0x80 | (c & 0x3f);\n\t\t} else if (c < 0x10000) {\n\t\t  /* three bytes */\n\t\t  buf[i++] = 0xE0 | (c >>> 12);\n\t\t  buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n\t\t  buf[i++] = 0x80 | (c & 0x3f);\n\t\t} else {\n\t\t  /* four bytes */\n\t\t  buf[i++] = 0xf0 | (c >>> 18);\n\t\t  buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n\t\t  buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n\t\t  buf[i++] = 0x80 | (c & 0x3f);\n\t\t}\n\t  }\n  \n\t  return buf;\n\t};\n  \n\t// Helper\n\tconst buf2binstring = (buf, len) => {\n\t  // On Chrome, the arguments in a function call that are allowed is `65534`.\n\t  // If the length of the buffer is smaller than that, we can use this optimization,\n\t  // otherwise we will take a slower path.\n\t  if (len < 65534) {\n\t\tif (buf.subarray && STR_APPLY_UIA_OK) {\n\t\t  return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n\t\t}\n\t  }\n  \n\t  let result = '';\n\t  for (let i = 0; i < len; i++) {\n\t\tresult += String.fromCharCode(buf[i]);\n\t  }\n\t  return result;\n\t};\n  \n  \n\t// convert array to string\n\tvar buf2string = (buf, max) => {\n\t  const len = max || buf.length;\n  \n\t  if (typeof TextDecoder === 'function' && TextDecoder.prototype.decode) {\n\t\treturn new TextDecoder().decode(buf.subarray(0, max));\n\t  }\n  \n\t  let i, out;\n  \n\t  // Reserve max possible length (2 words per char)\n\t  // NB: by unknown reasons, Array is significantly faster for\n\t  //     String.fromCharCode.apply than Uint16Array.\n\t  const utf16buf = new Array(len * 2);\n  \n\t  for (out = 0, i = 0; i < len;) {\n\t\tlet c = buf[i++];\n\t\t// quick process ascii\n\t\tif (c < 0x80) { utf16buf[out++] = c; continue; }\n  \n\t\tlet c_len = _utf8len[c];\n\t\t// skip 5 & 6 byte codes\n\t\tif (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n  \n\t\t// apply mask on first byte\n\t\tc &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n\t\t// join the rest\n\t\twhile (c_len > 1 && i < len) {\n\t\t  c = (c << 6) | (buf[i++] & 0x3f);\n\t\t  c_len--;\n\t\t}\n  \n\t\t// terminated by end of string?\n\t\tif (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n  \n\t\tif (c < 0x10000) {\n\t\t  utf16buf[out++] = c;\n\t\t} else {\n\t\t  c -= 0x10000;\n\t\t  utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n\t\t  utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n\t\t}\n\t  }\n  \n\t  return buf2binstring(utf16buf, out);\n\t};\n  \n  \n\t// Calculate max possible position in utf8 buffer,\n\t// that will not break sequence. If that's not possible\n\t// - (very small limits) return max size as is.\n\t//\n\t// buf[] - utf8 bytes array\n\t// max   - length limit (mandatory);\n\tvar utf8border = (buf, max) => {\n  \n\t  max = max || buf.length;\n\t  if (max > buf.length) { max = buf.length; }\n  \n\t  // go back from last position, until start of sequence found\n\t  let pos = max - 1;\n\t  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n  \n\t  // Very small and broken sequence,\n\t  // return max, because we should return something anyway.\n\t  if (pos < 0) { return max; }\n  \n\t  // If we came to start of buffer - that means buffer is too small,\n\t  // return max too.\n\t  if (pos === 0) { return max; }\n  \n\t  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n\t};\n  \n\tvar strings = {\n\t\tstring2buf: string2buf,\n\t\tbuf2string: buf2string,\n\t\tutf8border: utf8border\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tfunction ZStream() {\n\t  /* next input byte */\n\t  this.input = null; // JS specific, because we have no pointers\n\t  this.next_in = 0;\n\t  /* number of bytes available at input */\n\t  this.avail_in = 0;\n\t  /* total number of input bytes read so far */\n\t  this.total_in = 0;\n\t  /* next output byte should be put there */\n\t  this.output = null; // JS specific, because we have no pointers\n\t  this.next_out = 0;\n\t  /* remaining free space at output */\n\t  this.avail_out = 0;\n\t  /* total number of bytes output so far */\n\t  this.total_out = 0;\n\t  /* last error message, NULL if no error */\n\t  this.msg = ''/*Z_NULL*/;\n\t  /* not visible by applications */\n\t  this.state = null;\n\t  /* best guess about the data type: binary or text */\n\t  this.data_type = 2/*Z_UNKNOWN*/;\n\t  /* adler32 value of the uncompressed data */\n\t  this.adler = 0;\n\t}\n  \n\tvar zstream = ZStream;\n  \n\tconst toString$1 = Object.prototype.toString;\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_NO_FLUSH: Z_NO_FLUSH$1, Z_SYNC_FLUSH, Z_FULL_FLUSH, Z_FINISH: Z_FINISH$2,\n\t  Z_OK: Z_OK$2, Z_STREAM_END: Z_STREAM_END$2,\n\t  Z_DEFAULT_COMPRESSION,\n\t  Z_DEFAULT_STRATEGY,\n\t  Z_DEFLATED: Z_DEFLATED$1\n\t} = constants$2;\n  \n\t/* ===========================================================================*/\n  \n  \n\t/**\n\t * class Deflate\n\t *\n\t * Generic JS-style wrapper for zlib calls. If you don't need\n\t * streaming behaviour - use more simple functions: [[deflate]],\n\t * [[deflateRaw]] and [[gzip]].\n\t **/\n  \n\t/* internal\n\t * Deflate.chunks -> Array\n\t *\n\t * Chunks of output data, if [[Deflate#onData]] not overridden.\n\t **/\n  \n\t/**\n\t * Deflate.result -> Uint8Array\n\t *\n\t * Compressed result, generated by default [[Deflate#onData]]\n\t * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n\t * (call [[Deflate#push]] with `Z_FINISH` / `true` param).\n\t **/\n  \n\t/**\n\t * Deflate.err -> Number\n\t *\n\t * Error code after deflate finished. 0 (Z_OK) on success.\n\t * You will not need it in real life, because deflate errors\n\t * are possible only on wrong options or bad `onData` / `onEnd`\n\t * custom handlers.\n\t **/\n  \n\t/**\n\t * Deflate.msg -> String\n\t *\n\t * Error message, if [[Deflate.err]] != 0\n\t **/\n  \n  \n\t/**\n\t * new Deflate(options)\n\t * - options (Object): zlib deflate options.\n\t *\n\t * Creates new deflator instance with specified params. Throws exception\n\t * on bad params. Supported options:\n\t *\n\t * - `level`\n\t * - `windowBits`\n\t * - `memLevel`\n\t * - `strategy`\n\t * - `dictionary`\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information on these.\n\t *\n\t * Additional options, for internal needs:\n\t *\n\t * - `chunkSize` - size of generated data chunks (16K by default)\n\t * - `raw` (Boolean) - do raw deflate\n\t * - `gzip` (Boolean) - create gzip wrapper\n\t * - `header` (Object) - custom header for gzip\n\t *   - `text` (Boolean) - true if compressed data believed to be text\n\t *   - `time` (Number) - modification time, unix timestamp\n\t *   - `os` (Number) - operation system code\n\t *   - `extra` (Array) - array of bytes with extra data (max 65536)\n\t *   - `name` (String) - file name (binary string)\n\t *   - `comment` (String) - comment (binary string)\n\t *   - `hcrc` (Boolean) - true if header crc should be added\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako')\n\t *   , chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n\t *   , chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n\t *\n\t * const deflate = new pako.Deflate({ level: 3});\n\t *\n\t * deflate.push(chunk1, false);\n\t * deflate.push(chunk2, true);  // true -> last chunk\n\t *\n\t * if (deflate.err) { throw new Error(deflate.err); }\n\t *\n\t * console.log(deflate.result);\n\t * ```\n\t **/\n\tfunction Deflate$1(options) {\n\t  this.options = common.assign({\n\t\tlevel: Z_DEFAULT_COMPRESSION,\n\t\tmethod: Z_DEFLATED$1,\n\t\tchunkSize: 16384,\n\t\twindowBits: 15,\n\t\tmemLevel: 8,\n\t\tstrategy: Z_DEFAULT_STRATEGY\n\t  }, options || {});\n  \n\t  let opt = this.options;\n  \n\t  if (opt.raw && (opt.windowBits > 0)) {\n\t\topt.windowBits = -opt.windowBits;\n\t  }\n  \n\t  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n\t\topt.windowBits += 16;\n\t  }\n  \n\t  this.err    = 0;      // error code, if happens (0 = Z_OK)\n\t  this.msg    = '';     // error message\n\t  this.ended  = false;  // used to avoid multiple onEnd() calls\n\t  this.chunks = [];     // chunks of compressed data\n  \n\t  this.strm = new zstream();\n\t  this.strm.avail_out = 0;\n  \n\t  let status = deflate_1$2.deflateInit2(\n\t\tthis.strm,\n\t\topt.level,\n\t\topt.method,\n\t\topt.windowBits,\n\t\topt.memLevel,\n\t\topt.strategy\n\t  );\n  \n\t  if (status !== Z_OK$2) {\n\t\tthrow new Error(messages[status]);\n\t  }\n  \n\t  if (opt.header) {\n\t\tdeflate_1$2.deflateSetHeader(this.strm, opt.header);\n\t  }\n  \n\t  if (opt.dictionary) {\n\t\tlet dict;\n\t\t// Convert data if needed\n\t\tif (typeof opt.dictionary === 'string') {\n\t\t  // If we need to compress text, change encoding to utf8.\n\t\t  dict = strings.string2buf(opt.dictionary);\n\t\t} else if (toString$1.call(opt.dictionary) === '[object ArrayBuffer]') {\n\t\t  dict = new Uint8Array(opt.dictionary);\n\t\t} else {\n\t\t  dict = opt.dictionary;\n\t\t}\n  \n\t\tstatus = deflate_1$2.deflateSetDictionary(this.strm, dict);\n  \n\t\tif (status !== Z_OK$2) {\n\t\t  throw new Error(messages[status]);\n\t\t}\n  \n\t\tthis._dict_set = true;\n\t  }\n\t}\n  \n\t/**\n\t * Deflate#push(data[, flush_mode]) -> Boolean\n\t * - data (Uint8Array|ArrayBuffer|String): input data. Strings will be\n\t *   converted to utf8 byte sequence.\n\t * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n\t *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n\t *\n\t * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n\t * new compressed chunks. Returns `true` on success. The last data block must\n\t * have `flush_mode` Z_FINISH (or `true`). That will flush internal pending\n\t * buffers and call [[Deflate#onEnd]].\n\t *\n\t * On fail call [[Deflate#onEnd]] with error code and return false.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * push(chunk, false); // push one of data chunks\n\t * ...\n\t * push(chunk, true);  // push last chunk\n\t * ```\n\t **/\n\tDeflate$1.prototype.push = function (data, flush_mode) {\n\t  const strm = this.strm;\n\t  const chunkSize = this.options.chunkSize;\n\t  let status, _flush_mode;\n  \n\t  if (this.ended) { return false; }\n  \n\t  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n\t  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n  \n\t  // Convert data if needed\n\t  if (typeof data === 'string') {\n\t\t// If we need to compress text, change encoding to utf8.\n\t\tstrm.input = strings.string2buf(data);\n\t  } else if (toString$1.call(data) === '[object ArrayBuffer]') {\n\t\tstrm.input = new Uint8Array(data);\n\t  } else {\n\t\tstrm.input = data;\n\t  }\n  \n\t  strm.next_in = 0;\n\t  strm.avail_in = strm.input.length;\n  \n\t  for (;;) {\n\t\tif (strm.avail_out === 0) {\n\t\t  strm.output = new Uint8Array(chunkSize);\n\t\t  strm.next_out = 0;\n\t\t  strm.avail_out = chunkSize;\n\t\t}\n  \n\t\t// Make sure avail_out > 6 to avoid repeating markers\n\t\tif ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n\t\t  this.onData(strm.output.subarray(0, strm.next_out));\n\t\t  strm.avail_out = 0;\n\t\t  continue;\n\t\t}\n  \n\t\tstatus = deflate_1$2.deflate(strm, _flush_mode);\n  \n\t\t// Ended => flush and finish\n\t\tif (status === Z_STREAM_END$2) {\n\t\t  if (strm.next_out > 0) {\n\t\t\tthis.onData(strm.output.subarray(0, strm.next_out));\n\t\t  }\n\t\t  status = deflate_1$2.deflateEnd(this.strm);\n\t\t  this.onEnd(status);\n\t\t  this.ended = true;\n\t\t  return status === Z_OK$2;\n\t\t}\n  \n\t\t// Flush if out buffer full\n\t\tif (strm.avail_out === 0) {\n\t\t  this.onData(strm.output);\n\t\t  continue;\n\t\t}\n  \n\t\t// Flush if requested and has data\n\t\tif (_flush_mode > 0 && strm.next_out > 0) {\n\t\t  this.onData(strm.output.subarray(0, strm.next_out));\n\t\t  strm.avail_out = 0;\n\t\t  continue;\n\t\t}\n  \n\t\tif (strm.avail_in === 0) break;\n\t  }\n  \n\t  return true;\n\t};\n  \n  \n\t/**\n\t * Deflate#onData(chunk) -> Void\n\t * - chunk (Uint8Array): output data.\n\t *\n\t * By default, stores data blocks in `chunks[]` property and glue\n\t * those in `onEnd`. Override this handler, if you need another behaviour.\n\t **/\n\tDeflate$1.prototype.onData = function (chunk) {\n\t  this.chunks.push(chunk);\n\t};\n  \n  \n\t/**\n\t * Deflate#onEnd(status) -> Void\n\t * - status (Number): deflate status. 0 (Z_OK) on success,\n\t *   other if not.\n\t *\n\t * Called once after you tell deflate that the input stream is\n\t * complete (Z_FINISH). By default - join collected chunks,\n\t * free memory and fill `results` / `err` properties.\n\t **/\n\tDeflate$1.prototype.onEnd = function (status) {\n\t  // On success - join\n\t  if (status === Z_OK$2) {\n\t\tthis.result = common.flattenChunks(this.chunks);\n\t  }\n\t  this.chunks = [];\n\t  this.err = status;\n\t  this.msg = this.strm.msg;\n\t};\n  \n  \n\t/**\n\t * deflate(data[, options]) -> Uint8Array\n\t * - data (Uint8Array|String): input data to compress.\n\t * - options (Object): zlib deflate options.\n\t *\n\t * Compress `data` with deflate algorithm and `options`.\n\t *\n\t * Supported options are:\n\t *\n\t * - level\n\t * - windowBits\n\t * - memLevel\n\t * - strategy\n\t * - dictionary\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information on these.\n\t *\n\t * Sugar (options):\n\t *\n\t * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n\t *   negative windowBits implicitly.\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako')\n\t * const data = new Uint8Array([1,2,3,4,5,6,7,8,9]);\n\t *\n\t * console.log(pako.deflate(data));\n\t * ```\n\t **/\n\tfunction deflate$1(input, options) {\n\t  const deflator = new Deflate$1(options);\n  \n\t  deflator.push(input, true);\n  \n\t  // That will never happens, if you don't cheat with options :)\n\t  if (deflator.err) { throw deflator.msg || messages[deflator.err]; }\n  \n\t  return deflator.result;\n\t}\n  \n  \n\t/**\n\t * deflateRaw(data[, options]) -> Uint8Array\n\t * - data (Uint8Array|String): input data to compress.\n\t * - options (Object): zlib deflate options.\n\t *\n\t * The same as [[deflate]], but creates raw data, without wrapper\n\t * (header and adler32 crc).\n\t **/\n\tfunction deflateRaw$1(input, options) {\n\t  options = options || {};\n\t  options.raw = true;\n\t  return deflate$1(input, options);\n\t}\n  \n  \n\t/**\n\t * gzip(data[, options]) -> Uint8Array\n\t * - data (Uint8Array|String): input data to compress.\n\t * - options (Object): zlib deflate options.\n\t *\n\t * The same as [[deflate]], but create gzip wrapper instead of\n\t * deflate one.\n\t **/\n\tfunction gzip$1(input, options) {\n\t  options = options || {};\n\t  options.gzip = true;\n\t  return deflate$1(input, options);\n\t}\n  \n  \n\tvar Deflate_1$1 = Deflate$1;\n\tvar deflate_2 = deflate$1;\n\tvar deflateRaw_1$1 = deflateRaw$1;\n\tvar gzip_1$1 = gzip$1;\n\tvar constants$1 = constants$2;\n  \n\tvar deflate_1$1 = {\n\t\tDeflate: Deflate_1$1,\n\t\tdeflate: deflate_2,\n\t\tdeflateRaw: deflateRaw_1$1,\n\t\tgzip: gzip_1$1,\n\t\tconstants: constants$1\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\t// See state defs from inflate.js\n\tconst BAD$1 = 30;       /* got a data error -- remain here until reset */\n\tconst TYPE$1 = 12;      /* i: waiting for type bits, including last-flag bit */\n  \n\t/*\n\t   Decode literal, length, and distance codes and write out the resulting\n\t   literal and match bytes until either not enough input or output is\n\t   available, an end-of-block is encountered, or a data error is encountered.\n\t   When large enough input and output buffers are supplied to inflate(), for\n\t   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n\t   inflate execution time is spent in this routine.\n  \n\t   Entry assumptions:\n  \n\t\t\tstate.mode === LEN\n\t\t\tstrm.avail_in >= 6\n\t\t\tstrm.avail_out >= 258\n\t\t\tstart >= strm.avail_out\n\t\t\tstate.bits < 8\n  \n\t   On return, state.mode is one of:\n  \n\t\t\tLEN -- ran out of enough output space or enough available input\n\t\t\tTYPE -- reached end of block code, inflate() to interpret next block\n\t\t\tBAD -- error in block data\n  \n\t   Notes:\n  \n\t\t- The maximum input bits used by a length/distance pair is 15 bits for the\n\t\t  length code, 5 bits for the length extra, 15 bits for the distance code,\n\t\t  and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n\t\t  Therefore if strm.avail_in >= 6, then there is enough input to avoid\n\t\t  checking for available input while decoding.\n  \n\t\t- The maximum bytes that a single length/distance pair can output is 258\n\t\t  bytes, which is the maximum length that can be coded.  inflate_fast()\n\t\t  requires strm.avail_out >= 258 for each loop to avoid checking for\n\t\t  output space.\n\t */\n\tvar inffast = function inflate_fast(strm, start) {\n\t  let _in;                    /* local strm.input */\n\t  let last;                   /* have enough input while in < last */\n\t  let _out;                   /* local strm.output */\n\t  let beg;                    /* inflate()'s initial strm.output */\n\t  let end;                    /* while out < end, enough space available */\n\t//#ifdef INFLATE_STRICT\n\t  let dmax;                   /* maximum distance from zlib header */\n\t//#endif\n\t  let wsize;                  /* window size or zero if not using window */\n\t  let whave;                  /* valid bytes in the window */\n\t  let wnext;                  /* window write index */\n\t  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n\t  let s_window;               /* allocated sliding window, if wsize != 0 */\n\t  let hold;                   /* local strm.hold */\n\t  let bits;                   /* local strm.bits */\n\t  let lcode;                  /* local strm.lencode */\n\t  let dcode;                  /* local strm.distcode */\n\t  let lmask;                  /* mask for first level of length codes */\n\t  let dmask;                  /* mask for first level of distance codes */\n\t  let here;                   /* retrieved table entry */\n\t  let op;                     /* code bits, operation, extra bits, or */\n\t\t\t\t\t\t\t\t  /*  window position, window bytes to copy */\n\t  let len;                    /* match length, unused bytes */\n\t  let dist;                   /* match distance */\n\t  let from;                   /* where to copy match from */\n\t  let from_source;\n  \n  \n\t  let input, output; // JS specific, because we have no pointers\n  \n\t  /* copy state to local variables */\n\t  const state = strm.state;\n\t  //here = state.here;\n\t  _in = strm.next_in;\n\t  input = strm.input;\n\t  last = _in + (strm.avail_in - 5);\n\t  _out = strm.next_out;\n\t  output = strm.output;\n\t  beg = _out - (start - strm.avail_out);\n\t  end = _out + (strm.avail_out - 257);\n\t//#ifdef INFLATE_STRICT\n\t  dmax = state.dmax;\n\t//#endif\n\t  wsize = state.wsize;\n\t  whave = state.whave;\n\t  wnext = state.wnext;\n\t  s_window = state.window;\n\t  hold = state.hold;\n\t  bits = state.bits;\n\t  lcode = state.lencode;\n\t  dcode = state.distcode;\n\t  lmask = (1 << state.lenbits) - 1;\n\t  dmask = (1 << state.distbits) - 1;\n  \n  \n\t  /* decode literals and length/distances until end-of-block or not enough\n\t\t input data or output space */\n  \n\t  top:\n\t  do {\n\t\tif (bits < 15) {\n\t\t  hold += input[_in++] << bits;\n\t\t  bits += 8;\n\t\t  hold += input[_in++] << bits;\n\t\t  bits += 8;\n\t\t}\n  \n\t\there = lcode[hold & lmask];\n  \n\t\tdolen:\n\t\tfor (;;) { // Goto emulation\n\t\t  op = here >>> 24/*here.bits*/;\n\t\t  hold >>>= op;\n\t\t  bits -= op;\n\t\t  op = (here >>> 16) & 0xff/*here.op*/;\n\t\t  if (op === 0) {                          /* literal */\n\t\t\t//Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n\t\t\t//        \"inflate:         literal '%c'\\n\" :\n\t\t\t//        \"inflate:         literal 0x%02x\\n\", here.val));\n\t\t\toutput[_out++] = here & 0xffff/*here.val*/;\n\t\t  }\n\t\t  else if (op & 16) {                     /* length base */\n\t\t\tlen = here & 0xffff/*here.val*/;\n\t\t\top &= 15;                           /* number of extra bits */\n\t\t\tif (op) {\n\t\t\t  if (bits < op) {\n\t\t\t\thold += input[_in++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  len += hold & ((1 << op) - 1);\n\t\t\t  hold >>>= op;\n\t\t\t  bits -= op;\n\t\t\t}\n\t\t\t//Tracevv((stderr, \"inflate:         length %u\\n\", len));\n\t\t\tif (bits < 15) {\n\t\t\t  hold += input[_in++] << bits;\n\t\t\t  bits += 8;\n\t\t\t  hold += input[_in++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\there = dcode[hold & dmask];\n  \n\t\t\tdodist:\n\t\t\tfor (;;) { // goto emulation\n\t\t\t  op = here >>> 24/*here.bits*/;\n\t\t\t  hold >>>= op;\n\t\t\t  bits -= op;\n\t\t\t  op = (here >>> 16) & 0xff/*here.op*/;\n  \n\t\t\t  if (op & 16) {                      /* distance base */\n\t\t\t\tdist = here & 0xffff/*here.val*/;\n\t\t\t\top &= 15;                       /* number of extra bits */\n\t\t\t\tif (bits < op) {\n\t\t\t\t  hold += input[_in++] << bits;\n\t\t\t\t  bits += 8;\n\t\t\t\t  if (bits < op) {\n\t\t\t\t\thold += input[_in++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\tdist += hold & ((1 << op) - 1);\n\t//#ifdef INFLATE_STRICT\n\t\t\t\tif (dist > dmax) {\n\t\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t\t  state.mode = BAD$1;\n\t\t\t\t  break top;\n\t\t\t\t}\n\t//#endif\n\t\t\t\thold >>>= op;\n\t\t\t\tbits -= op;\n\t\t\t\t//Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n\t\t\t\top = _out - beg;                /* max distance in output */\n\t\t\t\tif (dist > op) {                /* see if copy from window */\n\t\t\t\t  op = dist - op;               /* distance back in window */\n\t\t\t\t  if (op > whave) {\n\t\t\t\t\tif (state.sane) {\n\t\t\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t\t\t  state.mode = BAD$1;\n\t\t\t\t\t  break top;\n\t\t\t\t\t}\n  \n\t// (!) This block is disabled in zlib defaults,\n\t// don't enable it for binary compatibility\n\t//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\t//                if (len <= op - whave) {\n\t//                  do {\n\t//                    output[_out++] = 0;\n\t//                  } while (--len);\n\t//                  continue top;\n\t//                }\n\t//                len -= op - whave;\n\t//                do {\n\t//                  output[_out++] = 0;\n\t//                } while (--op > whave);\n\t//                if (op === 0) {\n\t//                  from = _out - dist;\n\t//                  do {\n\t//                    output[_out++] = output[from++];\n\t//                  } while (--len);\n\t//                  continue top;\n\t//                }\n\t//#endif\n\t\t\t\t  }\n\t\t\t\t  from = 0; // window index\n\t\t\t\t  from_source = s_window;\n\t\t\t\t  if (wnext === 0) {           /* very common case */\n\t\t\t\t\tfrom += wsize - op;\n\t\t\t\t\tif (op < len) {         /* some from window */\n\t\t\t\t\t  len -= op;\n\t\t\t\t\t  do {\n\t\t\t\t\t\toutput[_out++] = s_window[from++];\n\t\t\t\t\t  } while (--op);\n\t\t\t\t\t  from = _out - dist;  /* rest from output */\n\t\t\t\t\t  from_source = output;\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  else if (wnext < op) {      /* wrap around window */\n\t\t\t\t\tfrom += wsize + wnext - op;\n\t\t\t\t\top -= wnext;\n\t\t\t\t\tif (op < len) {         /* some from end of window */\n\t\t\t\t\t  len -= op;\n\t\t\t\t\t  do {\n\t\t\t\t\t\toutput[_out++] = s_window[from++];\n\t\t\t\t\t  } while (--op);\n\t\t\t\t\t  from = 0;\n\t\t\t\t\t  if (wnext < len) {  /* some from start of window */\n\t\t\t\t\t\top = wnext;\n\t\t\t\t\t\tlen -= op;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t  output[_out++] = s_window[from++];\n\t\t\t\t\t\t} while (--op);\n\t\t\t\t\t\tfrom = _out - dist;      /* rest from output */\n\t\t\t\t\t\tfrom_source = output;\n\t\t\t\t\t  }\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  else {                      /* contiguous in window */\n\t\t\t\t\tfrom += wnext - op;\n\t\t\t\t\tif (op < len) {         /* some from window */\n\t\t\t\t\t  len -= op;\n\t\t\t\t\t  do {\n\t\t\t\t\t\toutput[_out++] = s_window[from++];\n\t\t\t\t\t  } while (--op);\n\t\t\t\t\t  from = _out - dist;  /* rest from output */\n\t\t\t\t\t  from_source = output;\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  while (len > 2) {\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\tlen -= 3;\n\t\t\t\t  }\n\t\t\t\t  if (len) {\n\t\t\t\t\toutput[_out++] = from_source[from++];\n\t\t\t\t\tif (len > 1) {\n\t\t\t\t\t  output[_out++] = from_source[from++];\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t  from = _out - dist;          /* copy direct from output */\n\t\t\t\t  do {                        /* minimum length is three */\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\tlen -= 3;\n\t\t\t\t  } while (len > 2);\n\t\t\t\t  if (len) {\n\t\t\t\t\toutput[_out++] = output[from++];\n\t\t\t\t\tif (len > 1) {\n\t\t\t\t\t  output[_out++] = output[from++];\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t  }\n\t\t\t  else if ((op & 64) === 0) {          /* 2nd level distance code */\n\t\t\t\there = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n\t\t\t\tcontinue dodist;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tstrm.msg = 'invalid distance code';\n\t\t\t\tstate.mode = BAD$1;\n\t\t\t\tbreak top;\n\t\t\t  }\n  \n\t\t\t  break; // need to emulate goto via \"continue\"\n\t\t\t}\n\t\t  }\n\t\t  else if ((op & 64) === 0) {              /* 2nd level length code */\n\t\t\there = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n\t\t\tcontinue dolen;\n\t\t  }\n\t\t  else if (op & 32) {                     /* end-of-block */\n\t\t\t//Tracevv((stderr, \"inflate:         end of block\\n\"));\n\t\t\tstate.mode = TYPE$1;\n\t\t\tbreak top;\n\t\t  }\n\t\t  else {\n\t\t\tstrm.msg = 'invalid literal/length code';\n\t\t\tstate.mode = BAD$1;\n\t\t\tbreak top;\n\t\t  }\n  \n\t\t  break; // need to emulate goto via \"continue\"\n\t\t}\n\t  } while (_in < last && _out < end);\n  \n\t  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n\t  len = bits >> 3;\n\t  _in -= len;\n\t  bits -= len << 3;\n\t  hold &= (1 << bits) - 1;\n  \n\t  /* update state and return */\n\t  strm.next_in = _in;\n\t  strm.next_out = _out;\n\t  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n\t  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n\t  state.hold = hold;\n\t  state.bits = bits;\n\t  return;\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tconst MAXBITS = 15;\n\tconst ENOUGH_LENS$1 = 852;\n\tconst ENOUGH_DISTS$1 = 592;\n\t//const ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n  \n\tconst CODES$1 = 0;\n\tconst LENS$1 = 1;\n\tconst DISTS$1 = 2;\n  \n\tconst lbase = new Uint16Array([ /* Length codes 257..285 base */\n\t  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n\t  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n\t]);\n  \n\tconst lext = new Uint8Array([ /* Length codes 257..285 extra */\n\t  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n\t  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n\t]);\n  \n\tconst dbase = new Uint16Array([ /* Distance codes 0..29 base */\n\t  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n\t  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n\t  8193, 12289, 16385, 24577, 0, 0\n\t]);\n  \n\tconst dext = new Uint8Array([ /* Distance codes 0..29 extra */\n\t  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n\t  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n\t  28, 28, 29, 29, 64, 64\n\t]);\n  \n\tconst inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) =>\n\t{\n\t  const bits = opts.bits;\n\t\t  //here = opts.here; /* table entry for duplication */\n  \n\t  let len = 0;               /* a code's length in bits */\n\t  let sym = 0;               /* index of code symbols */\n\t  let min = 0, max = 0;          /* minimum and maximum code lengths */\n\t  let root = 0;              /* number of index bits for root table */\n\t  let curr = 0;              /* number of index bits for current table */\n\t  let drop = 0;              /* code bits to drop for sub-table */\n\t  let left = 0;                   /* number of prefix codes available */\n\t  let used = 0;              /* code entries in table used */\n\t  let huff = 0;              /* Huffman code */\n\t  let incr;              /* for incrementing code, index */\n\t  let fill;              /* index for replicating entries */\n\t  let low;               /* low bits for current root entry */\n\t  let mask;              /* mask for low root bits */\n\t  let next;             /* next available space in table */\n\t  let base = null;     /* base value table to use */\n\t  let base_index = 0;\n\t//  let shoextra;    /* extra bits table to use */\n\t  let end;                    /* use base and extra for symbol > end */\n\t  const count = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n\t  const offs = new Uint16Array(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n\t  let extra = null;\n\t  let extra_index = 0;\n  \n\t  let here_bits, here_op, here_val;\n  \n\t  /*\n\t   Process a set of code lengths to create a canonical Huffman code.  The\n\t   code lengths are lens[0..codes-1].  Each length corresponds to the\n\t   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n\t   symbols by length from short to long, and retaining the symbol order\n\t   for codes with equal lengths.  Then the code starts with all zero bits\n\t   for the first code of the shortest length, and the codes are integer\n\t   increments for the same length, and zeros are appended as the length\n\t   increases.  For the deflate format, these bits are stored backwards\n\t   from their more natural integer increment ordering, and so when the\n\t   decoding tables are built in the large loop below, the integer codes\n\t   are incremented backwards.\n  \n\t   This routine assumes, but does not check, that all of the entries in\n\t   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n\t   1..MAXBITS is interpreted as that code length.  zero means that that\n\t   symbol does not occur in this code.\n  \n\t   The codes are sorted by computing a count of codes for each length,\n\t   creating from that a table of starting indices for each length in the\n\t   sorted table, and then entering the symbols in order in the sorted\n\t   table.  The sorted table is work[], with that space being provided by\n\t   the caller.\n  \n\t   The length counts are used for other purposes as well, i.e. finding\n\t   the minimum and maximum length codes, determining if there are any\n\t   codes at all, checking for a valid set of lengths, and looking ahead\n\t   at length counts to determine sub-table sizes when building the\n\t   decoding tables.\n\t   */\n  \n\t  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n\t  for (len = 0; len <= MAXBITS; len++) {\n\t\tcount[len] = 0;\n\t  }\n\t  for (sym = 0; sym < codes; sym++) {\n\t\tcount[lens[lens_index + sym]]++;\n\t  }\n  \n\t  /* bound code lengths, force root to be within code lengths */\n\t  root = bits;\n\t  for (max = MAXBITS; max >= 1; max--) {\n\t\tif (count[max] !== 0) { break; }\n\t  }\n\t  if (root > max) {\n\t\troot = max;\n\t  }\n\t  if (max === 0) {                     /* no symbols to code at all */\n\t\t//table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n\t\t//table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n\t\t//table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n\t\ttable[table_index++] = (1 << 24) | (64 << 16) | 0;\n  \n  \n\t\t//table.op[opts.table_index] = 64;\n\t\t//table.bits[opts.table_index] = 1;\n\t\t//table.val[opts.table_index++] = 0;\n\t\ttable[table_index++] = (1 << 24) | (64 << 16) | 0;\n  \n\t\topts.bits = 1;\n\t\treturn 0;     /* no symbols, but wait for decoding to report error */\n\t  }\n\t  for (min = 1; min < max; min++) {\n\t\tif (count[min] !== 0) { break; }\n\t  }\n\t  if (root < min) {\n\t\troot = min;\n\t  }\n  \n\t  /* check for an over-subscribed or incomplete set of lengths */\n\t  left = 1;\n\t  for (len = 1; len <= MAXBITS; len++) {\n\t\tleft <<= 1;\n\t\tleft -= count[len];\n\t\tif (left < 0) {\n\t\t  return -1;\n\t\t}        /* over-subscribed */\n\t  }\n\t  if (left > 0 && (type === CODES$1 || max !== 1)) {\n\t\treturn -1;                      /* incomplete set */\n\t  }\n  \n\t  /* generate offsets into symbol table for each length for sorting */\n\t  offs[1] = 0;\n\t  for (len = 1; len < MAXBITS; len++) {\n\t\toffs[len + 1] = offs[len] + count[len];\n\t  }\n  \n\t  /* sort symbols by length, by symbol order within each length */\n\t  for (sym = 0; sym < codes; sym++) {\n\t\tif (lens[lens_index + sym] !== 0) {\n\t\t  work[offs[lens[lens_index + sym]]++] = sym;\n\t\t}\n\t  }\n  \n\t  /*\n\t   Create and fill in decoding tables.  In this loop, the table being\n\t   filled is at next and has curr index bits.  The code being used is huff\n\t   with length len.  That code is converted to an index by dropping drop\n\t   bits off of the bottom.  For codes where len is less than drop + curr,\n\t   those top drop + curr - len bits are incremented through all values to\n\t   fill the table with replicated entries.\n  \n\t   root is the number of index bits for the root table.  When len exceeds\n\t   root, sub-tables are created pointed to by the root entry with an index\n\t   of the low root bits of huff.  This is saved in low to check for when a\n\t   new sub-table should be started.  drop is zero when the root table is\n\t   being filled, and drop is root when sub-tables are being filled.\n  \n\t   When a new sub-table is needed, it is necessary to look ahead in the\n\t   code lengths to determine what size sub-table is needed.  The length\n\t   counts are used for this, and so count[] is decremented as codes are\n\t   entered in the tables.\n  \n\t   used keeps track of how many table entries have been allocated from the\n\t   provided *table space.  It is checked for LENS and DIST tables against\n\t   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n\t   the initial root table size constants.  See the comments in inftrees.h\n\t   for more information.\n  \n\t   sym increments through all symbols, and the loop terminates when\n\t   all codes of length max, i.e. all codes, have been processed.  This\n\t   routine permits incomplete codes, so another loop after this one fills\n\t   in the rest of the decoding tables with invalid code markers.\n\t   */\n  \n\t  /* set up for code type */\n\t  // poor man optimization - use if-else instead of switch,\n\t  // to avoid deopts in old v8\n\t  if (type === CODES$1) {\n\t\tbase = extra = work;    /* dummy value--not used */\n\t\tend = 19;\n  \n\t  } else if (type === LENS$1) {\n\t\tbase = lbase;\n\t\tbase_index -= 257;\n\t\textra = lext;\n\t\textra_index -= 257;\n\t\tend = 256;\n  \n\t  } else {                    /* DISTS */\n\t\tbase = dbase;\n\t\textra = dext;\n\t\tend = -1;\n\t  }\n  \n\t  /* initialize opts for loop */\n\t  huff = 0;                   /* starting code */\n\t  sym = 0;                    /* starting code symbol */\n\t  len = min;                  /* starting code length */\n\t  next = table_index;              /* current table to fill in */\n\t  curr = root;                /* current table index bits */\n\t  drop = 0;                   /* current bits to drop from code for index */\n\t  low = -1;                   /* trigger new sub-table when len > root */\n\t  used = 1 << root;          /* use root table entries */\n\t  mask = used - 1;            /* mask for comparing low */\n  \n\t  /* check available table space */\n\t  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n\t\t(type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n\t\treturn 1;\n\t  }\n  \n\t  /* process all codes and make table entries */\n\t  for (;;) {\n\t\t/* create table entry */\n\t\there_bits = len - drop;\n\t\tif (work[sym] < end) {\n\t\t  here_op = 0;\n\t\t  here_val = work[sym];\n\t\t}\n\t\telse if (work[sym] > end) {\n\t\t  here_op = extra[extra_index + work[sym]];\n\t\t  here_val = base[base_index + work[sym]];\n\t\t}\n\t\telse {\n\t\t  here_op = 32 + 64;         /* end of block */\n\t\t  here_val = 0;\n\t\t}\n  \n\t\t/* replicate for those indices with low len bits equal to huff */\n\t\tincr = 1 << (len - drop);\n\t\tfill = 1 << curr;\n\t\tmin = fill;                 /* save offset to next table */\n\t\tdo {\n\t\t  fill -= incr;\n\t\t  table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n\t\t} while (fill !== 0);\n  \n\t\t/* backwards increment the len-bit code huff */\n\t\tincr = 1 << (len - 1);\n\t\twhile (huff & incr) {\n\t\t  incr >>= 1;\n\t\t}\n\t\tif (incr !== 0) {\n\t\t  huff &= incr - 1;\n\t\t  huff += incr;\n\t\t} else {\n\t\t  huff = 0;\n\t\t}\n  \n\t\t/* go to next symbol, update count, len */\n\t\tsym++;\n\t\tif (--count[len] === 0) {\n\t\t  if (len === max) { break; }\n\t\t  len = lens[lens_index + work[sym]];\n\t\t}\n  \n\t\t/* create new sub-table if needed */\n\t\tif (len > root && (huff & mask) !== low) {\n\t\t  /* if first time, transition to sub-tables */\n\t\t  if (drop === 0) {\n\t\t\tdrop = root;\n\t\t  }\n  \n\t\t  /* increment past last table */\n\t\t  next += min;            /* here min is 1 << curr */\n  \n\t\t  /* determine length of next table */\n\t\t  curr = len - drop;\n\t\t  left = 1 << curr;\n\t\t  while (curr + drop < max) {\n\t\t\tleft -= count[curr + drop];\n\t\t\tif (left <= 0) { break; }\n\t\t\tcurr++;\n\t\t\tleft <<= 1;\n\t\t  }\n  \n\t\t  /* check for enough space */\n\t\t  used += 1 << curr;\n\t\t  if ((type === LENS$1 && used > ENOUGH_LENS$1) ||\n\t\t\t(type === DISTS$1 && used > ENOUGH_DISTS$1)) {\n\t\t\treturn 1;\n\t\t  }\n  \n\t\t  /* point entry in root table to sub-table */\n\t\t  low = huff & mask;\n\t\t  /*table.op[low] = curr;\n\t\t  table.bits[low] = root;\n\t\t  table.val[low] = next - opts.table_index;*/\n\t\t  table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n\t\t}\n\t  }\n  \n\t  /* fill in remaining table entry if code is incomplete (guaranteed to have\n\t   at most one remaining entry, since if the code is incomplete, the\n\t   maximum code length that was allowed to get this far is one bit) */\n\t  if (huff !== 0) {\n\t\t//table.op[next + huff] = 64;            /* invalid code marker */\n\t\t//table.bits[next + huff] = len - drop;\n\t\t//table.val[next + huff] = 0;\n\t\ttable[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n\t  }\n  \n\t  /* set return parameters */\n\t  //opts.table_index += used;\n\t  opts.bits = root;\n\t  return 0;\n\t};\n  \n  \n\tvar inftrees = inflate_table;\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n  \n  \n  \n  \n  \n\tconst CODES = 0;\n\tconst LENS = 1;\n\tconst DISTS = 2;\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES,\n\t  Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR,\n\t  Z_DEFLATED\n\t} = constants$2;\n  \n  \n\t/* STATES ====================================================================*/\n\t/* ===========================================================================*/\n  \n  \n\tconst    HEAD = 1;       /* i: waiting for magic header */\n\tconst    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\n\tconst    TIME = 3;       /* i: waiting for modification time (gzip) */\n\tconst    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\n\tconst    EXLEN = 5;      /* i: waiting for extra length (gzip) */\n\tconst    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\n\tconst    NAME = 7;       /* i: waiting for end of file name (gzip) */\n\tconst    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\n\tconst    HCRC = 9;       /* i: waiting for header crc (gzip) */\n\tconst    DICTID = 10;    /* i: waiting for dictionary check value */\n\tconst    DICT = 11;      /* waiting for inflateSetDictionary() call */\n\tconst        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\tconst        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\n\tconst        STORED = 14;    /* i: waiting for stored size (length and complement) */\n\tconst        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\n\tconst        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\n\tconst        TABLE = 17;     /* i: waiting for dynamic block table lengths */\n\tconst        LENLENS = 18;   /* i: waiting for code length code lengths */\n\tconst        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\n\tconst            LEN_ = 20;      /* i: same as LEN below, but only first time in */\n\tconst            LEN = 21;       /* i: waiting for length/lit/eob code */\n\tconst            LENEXT = 22;    /* i: waiting for length extra bits */\n\tconst            DIST = 23;      /* i: waiting for distance code */\n\tconst            DISTEXT = 24;   /* i: waiting for distance extra bits */\n\tconst            MATCH = 25;     /* o: waiting for output space to copy string */\n\tconst            LIT = 26;       /* o: waiting for output space to write literal */\n\tconst    CHECK = 27;     /* i: waiting for 32-bit check value */\n\tconst    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\n\tconst    DONE = 29;      /* finished check, done -- remain here until reset */\n\tconst    BAD = 30;       /* got a data error -- remain here until reset */\n\tconst    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\n\tconst    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n  \n\t/* ===========================================================================*/\n  \n  \n  \n\tconst ENOUGH_LENS = 852;\n\tconst ENOUGH_DISTS = 592;\n\t//const ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n  \n\tconst MAX_WBITS = 15;\n\t/* 32K LZ77 window */\n\tconst DEF_WBITS = MAX_WBITS;\n  \n  \n\tconst zswap32 = (q) => {\n  \n\t  return  (((q >>> 24) & 0xff) +\n\t\t\t  ((q >>> 8) & 0xff00) +\n\t\t\t  ((q & 0xff00) << 8) +\n\t\t\t  ((q & 0xff) << 24));\n\t};\n  \n  \n\tfunction InflateState() {\n\t  this.mode = 0;             /* current inflate mode */\n\t  this.last = false;          /* true if processing last block */\n\t  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n\t  this.havedict = false;      /* true if dictionary provided */\n\t  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n\t  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n\t  this.check = 0;             /* protected copy of check value */\n\t  this.total = 0;             /* protected copy of output count */\n\t  // TODO: may be {}\n\t  this.head = null;           /* where to save gzip header information */\n  \n\t  /* sliding window */\n\t  this.wbits = 0;             /* log base 2 of requested window size */\n\t  this.wsize = 0;             /* window size or zero if not using window */\n\t  this.whave = 0;             /* valid bytes in the window */\n\t  this.wnext = 0;             /* window write index */\n\t  this.window = null;         /* allocated sliding window, if needed */\n  \n\t  /* bit accumulator */\n\t  this.hold = 0;              /* input bit accumulator */\n\t  this.bits = 0;              /* number of bits in \"in\" */\n  \n\t  /* for string and stored block copying */\n\t  this.length = 0;            /* literal or length of data to copy */\n\t  this.offset = 0;            /* distance back to copy string from */\n  \n\t  /* for table and code decoding */\n\t  this.extra = 0;             /* extra bits needed */\n  \n\t  /* fixed and dynamic code tables */\n\t  this.lencode = null;          /* starting table for length/literal codes */\n\t  this.distcode = null;         /* starting table for distance codes */\n\t  this.lenbits = 0;           /* index bits for lencode */\n\t  this.distbits = 0;          /* index bits for distcode */\n  \n\t  /* dynamic table building */\n\t  this.ncode = 0;             /* number of code length code lengths */\n\t  this.nlen = 0;              /* number of length code lengths */\n\t  this.ndist = 0;             /* number of distance code lengths */\n\t  this.have = 0;              /* number of code lengths in lens[] */\n\t  this.next = null;              /* next available space in codes[] */\n  \n\t  this.lens = new Uint16Array(320); /* temporary storage for code lengths */\n\t  this.work = new Uint16Array(288); /* work area for code table building */\n  \n\t  /*\n\t   because we don't have pointers in js, we use lencode and distcode directly\n\t   as buffers so we don't need codes\n\t  */\n\t  //this.codes = new Int32Array(ENOUGH);       /* space for code tables */\n\t  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n\t  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n\t  this.sane = 0;                   /* if false, allow invalid distance too far */\n\t  this.back = 0;                   /* bits back of last unprocessed length/lit */\n\t  this.was = 0;                    /* initial length of match */\n\t}\n  \n  \n\tconst inflateResetKeep = (strm) => {\n  \n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n\t  strm.total_in = strm.total_out = state.total = 0;\n\t  strm.msg = ''; /*Z_NULL*/\n\t  if (state.wrap) {       /* to support ill-conceived Java test suite */\n\t\tstrm.adler = state.wrap & 1;\n\t  }\n\t  state.mode = HEAD;\n\t  state.last = 0;\n\t  state.havedict = 0;\n\t  state.dmax = 32768;\n\t  state.head = null/*Z_NULL*/;\n\t  state.hold = 0;\n\t  state.bits = 0;\n\t  //state.lencode = state.distcode = state.next = state.codes;\n\t  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n\t  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n  \n\t  state.sane = 1;\n\t  state.back = -1;\n\t  //Tracev((stderr, \"inflate: reset\\n\"));\n\t  return Z_OK$1;\n\t};\n  \n  \n\tconst inflateReset = (strm) => {\n  \n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n\t  state.wsize = 0;\n\t  state.whave = 0;\n\t  state.wnext = 0;\n\t  return inflateResetKeep(strm);\n  \n\t};\n  \n  \n\tconst inflateReset2 = (strm, windowBits) => {\n\t  let wrap;\n  \n\t  /* get the state */\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n  \n\t  /* extract wrap request from windowBits parameter */\n\t  if (windowBits < 0) {\n\t\twrap = 0;\n\t\twindowBits = -windowBits;\n\t  }\n\t  else {\n\t\twrap = (windowBits >> 4) + 1;\n\t\tif (windowBits < 48) {\n\t\t  windowBits &= 15;\n\t\t}\n\t  }\n  \n\t  /* set number of window bits, free window if different */\n\t  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n\t  if (state.window !== null && state.wbits !== windowBits) {\n\t\tstate.window = null;\n\t  }\n  \n\t  /* update state and reset the rest of it */\n\t  state.wrap = wrap;\n\t  state.wbits = windowBits;\n\t  return inflateReset(strm);\n\t};\n  \n  \n\tconst inflateInit2 = (strm, windowBits) => {\n  \n\t  if (!strm) { return Z_STREAM_ERROR$1; }\n\t  //strm.msg = Z_NULL;                 /* in case we return an error */\n  \n\t  const state = new InflateState();\n  \n\t  //if (state === Z_NULL) return Z_MEM_ERROR;\n\t  //Tracev((stderr, \"inflate: allocated\\n\"));\n\t  strm.state = state;\n\t  state.window = null/*Z_NULL*/;\n\t  const ret = inflateReset2(strm, windowBits);\n\t  if (ret !== Z_OK$1) {\n\t\tstrm.state = null/*Z_NULL*/;\n\t  }\n\t  return ret;\n\t};\n  \n  \n\tconst inflateInit = (strm) => {\n  \n\t  return inflateInit2(strm, DEF_WBITS);\n\t};\n  \n  \n\t/*\n\t Return state with length and distance decoding tables and index sizes set to\n\t fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n\t If BUILDFIXED is defined, then instead this routine builds the tables the\n\t first time it's called, and returns those tables the first time and\n\t thereafter.  This reduces the size of the code by about 2K bytes, in\n\t exchange for a little execution time.  However, BUILDFIXED should not be\n\t used for threaded applications, since the rewriting of the tables and virgin\n\t may not be thread-safe.\n\t */\n\tlet virgin = true;\n  \n\tlet lenfix, distfix; // We have no pointers in JS, so keep tables separate\n  \n  \n\tconst fixedtables = (state) => {\n  \n\t  /* build fixed huffman tables if first call (may not be thread safe) */\n\t  if (virgin) {\n\t\tlenfix = new Int32Array(512);\n\t\tdistfix = new Int32Array(32);\n  \n\t\t/* literal/length table */\n\t\tlet sym = 0;\n\t\twhile (sym < 144) { state.lens[sym++] = 8; }\n\t\twhile (sym < 256) { state.lens[sym++] = 9; }\n\t\twhile (sym < 280) { state.lens[sym++] = 7; }\n\t\twhile (sym < 288) { state.lens[sym++] = 8; }\n  \n\t\tinftrees(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n  \n\t\t/* distance table */\n\t\tsym = 0;\n\t\twhile (sym < 32) { state.lens[sym++] = 5; }\n  \n\t\tinftrees(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n  \n\t\t/* do this just once */\n\t\tvirgin = false;\n\t  }\n  \n\t  state.lencode = lenfix;\n\t  state.lenbits = 9;\n\t  state.distcode = distfix;\n\t  state.distbits = 5;\n\t};\n  \n  \n\t/*\n\t Update the window with the last wsize (normally 32K) bytes written before\n\t returning.  If window does not exist yet, create it.  This is only called\n\t when a window is already in use, or when output has been written during this\n\t inflate call, but the end of the deflate stream has not been reached yet.\n\t It is also called to create a window for dictionary data when a dictionary\n\t is loaded.\n  \n\t Providing output buffers larger than 32K to inflate() should provide a speed\n\t advantage, since only the last 32K of output is copied to the sliding window\n\t upon return from inflate(), and since all distances after the first 32K of\n\t output will fall in the output data, making match copies simpler and faster.\n\t The advantage may be dependent on the size of the processor's data caches.\n\t */\n\tconst updatewindow = (strm, src, end, copy) => {\n  \n\t  let dist;\n\t  const state = strm.state;\n  \n\t  /* if it hasn't been done already, allocate space for the window */\n\t  if (state.window === null) {\n\t\tstate.wsize = 1 << state.wbits;\n\t\tstate.wnext = 0;\n\t\tstate.whave = 0;\n  \n\t\tstate.window = new Uint8Array(state.wsize);\n\t  }\n  \n\t  /* copy state->wsize or less output bytes into the circular window */\n\t  if (copy >= state.wsize) {\n\t\tstate.window.set(src.subarray(end - state.wsize, end), 0);\n\t\tstate.wnext = 0;\n\t\tstate.whave = state.wsize;\n\t  }\n\t  else {\n\t\tdist = state.wsize - state.wnext;\n\t\tif (dist > copy) {\n\t\t  dist = copy;\n\t\t}\n\t\t//zmemcpy(state->window + state->wnext, end - copy, dist);\n\t\tstate.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n\t\tcopy -= dist;\n\t\tif (copy) {\n\t\t  //zmemcpy(state->window, end - copy, copy);\n\t\t  state.window.set(src.subarray(end - copy, end), 0);\n\t\t  state.wnext = copy;\n\t\t  state.whave = state.wsize;\n\t\t}\n\t\telse {\n\t\t  state.wnext += dist;\n\t\t  if (state.wnext === state.wsize) { state.wnext = 0; }\n\t\t  if (state.whave < state.wsize) { state.whave += dist; }\n\t\t}\n\t  }\n\t  return 0;\n\t};\n  \n  \n\tconst inflate$2 = (strm, flush) => {\n  \n\t  let state;\n\t  let input, output;          // input/output buffers\n\t  let next;                   /* next input INDEX */\n\t  let put;                    /* next output INDEX */\n\t  let have, left;             /* available input and output */\n\t  let hold;                   /* bit buffer */\n\t  let bits;                   /* bits in bit buffer */\n\t  let _in, _out;              /* save starting available input and output */\n\t  let copy;                   /* number of stored or match bytes to copy */\n\t  let from;                   /* where to copy match bytes from */\n\t  let from_source;\n\t  let here = 0;               /* current decoding table entry */\n\t  let here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n\t  //let last;                   /* parent table entry */\n\t  let last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n\t  let len;                    /* length to copy for repeats, bits to drop */\n\t  let ret;                    /* return code */\n\t  const hbuf = new Uint8Array(4);    /* buffer for gzip header crc calculation */\n\t  let opts;\n  \n\t  let n; // temporary variable for NEED_BITS\n  \n\t  const order = /* permutation of code lengths */\n\t\tnew Uint8Array([ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ]);\n  \n  \n\t  if (!strm || !strm.state || !strm.output ||\n\t\t  (!strm.input && strm.avail_in !== 0)) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n  \n\t  state = strm.state;\n\t  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n  \n  \n\t  //--- LOAD() ---\n\t  put = strm.next_out;\n\t  output = strm.output;\n\t  left = strm.avail_out;\n\t  next = strm.next_in;\n\t  input = strm.input;\n\t  have = strm.avail_in;\n\t  hold = state.hold;\n\t  bits = state.bits;\n\t  //---\n  \n\t  _in = have;\n\t  _out = left;\n\t  ret = Z_OK$1;\n  \n\t  inf_leave: // goto emulation\n\t  for (;;) {\n\t\tswitch (state.mode) {\n\t\t  case HEAD:\n\t\t\tif (state.wrap === 0) {\n\t\t\t  state.mode = TYPEDO;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//=== NEEDBITS(16);\n\t\t\twhile (bits < 16) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n\t\t\t  state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n\t\t\t  //=== CRC2(state.check, hold);\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t  //===//\n  \n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t  state.mode = FLAGS;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.flags = 0;           /* expect zlib header */\n\t\t\tif (state.head) {\n\t\t\t  state.head.done = false;\n\t\t\t}\n\t\t\tif (!(state.wrap & 1) ||   /* check if zlib header allowed */\n\t\t\t  (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n\t\t\t  strm.msg = 'incorrect header check';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n\t\t\t  strm.msg = 'unknown compression method';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//--- DROPBITS(4) ---//\n\t\t\thold >>>= 4;\n\t\t\tbits -= 4;\n\t\t\t//---//\n\t\t\tlen = (hold & 0x0f)/*BITS(4)*/ + 8;\n\t\t\tif (state.wbits === 0) {\n\t\t\t  state.wbits = len;\n\t\t\t}\n\t\t\telse if (len > state.wbits) {\n\t\t\t  strm.msg = 'invalid window size';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n  \n\t\t\t// !!! pako patch. Force use `options.windowBits` if passed.\n\t\t\t// Required to always use max window size by default.\n\t\t\tstate.dmax = 1 << state.wbits;\n\t\t\t//state.dmax = 1 << len;\n  \n\t\t\t//Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n\t\t\tstrm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n\t\t\tstate.mode = hold & 0x200 ? DICTID : TYPE;\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tbreak;\n\t\t  case FLAGS:\n\t\t\t//=== NEEDBITS(16); */\n\t\t\twhile (bits < 16) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstate.flags = hold;\n\t\t\tif ((state.flags & 0xff) !== Z_DEFLATED) {\n\t\t\t  strm.msg = 'unknown compression method';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (state.flags & 0xe000) {\n\t\t\t  strm.msg = 'unknown header flags set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (state.head) {\n\t\t\t  state.head.text = ((hold >> 8) & 1);\n\t\t\t}\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== CRC2(state.check, hold);\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t  //===//\n\t\t\t}\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = TIME;\n\t\t\t/* falls through */\n\t\t  case TIME:\n\t\t\t//=== NEEDBITS(32); */\n\t\t\twhile (bits < 32) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif (state.head) {\n\t\t\t  state.head.time = hold;\n\t\t\t}\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== CRC4(state.check, hold)\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  hbuf[2] = (hold >>> 16) & 0xff;\n\t\t\t  hbuf[3] = (hold >>> 24) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 4, 0);\n\t\t\t  //===\n\t\t\t}\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = OS;\n\t\t\t/* falls through */\n\t\t  case OS:\n\t\t\t//=== NEEDBITS(16); */\n\t\t\twhile (bits < 16) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif (state.head) {\n\t\t\t  state.head.xflags = (hold & 0xff);\n\t\t\t  state.head.os = (hold >> 8);\n\t\t\t}\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== CRC2(state.check, hold);\n\t\t\t  hbuf[0] = hold & 0xff;\n\t\t\t  hbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t  state.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t  //===//\n\t\t\t}\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = EXLEN;\n\t\t\t/* falls through */\n\t\t  case EXLEN:\n\t\t\tif (state.flags & 0x0400) {\n\t\t\t  //=== NEEDBITS(16); */\n\t\t\t  while (bits < 16) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.length = hold;\n\t\t\t  if (state.head) {\n\t\t\t\tstate.head.extra_len = hold;\n\t\t\t  }\n\t\t\t  if (state.flags & 0x0200) {\n\t\t\t\t//=== CRC2(state.check, hold);\n\t\t\t\thbuf[0] = hold & 0xff;\n\t\t\t\thbuf[1] = (hold >>> 8) & 0xff;\n\t\t\t\tstate.check = crc32_1(state.check, hbuf, 2, 0);\n\t\t\t\t//===//\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t}\n\t\t\telse if (state.head) {\n\t\t\t  state.head.extra = null/*Z_NULL*/;\n\t\t\t}\n\t\t\tstate.mode = EXTRA;\n\t\t\t/* falls through */\n\t\t  case EXTRA:\n\t\t\tif (state.flags & 0x0400) {\n\t\t\t  copy = state.length;\n\t\t\t  if (copy > have) { copy = have; }\n\t\t\t  if (copy) {\n\t\t\t\tif (state.head) {\n\t\t\t\t  len = state.head.extra_len - state.length;\n\t\t\t\t  if (!state.head.extra) {\n\t\t\t\t\t// Use untyped array for more convenient processing later\n\t\t\t\t\tstate.head.extra = new Uint8Array(state.head.extra_len);\n\t\t\t\t  }\n\t\t\t\t  state.head.extra.set(\n\t\t\t\t\tinput.subarray(\n\t\t\t\t\t  next,\n\t\t\t\t\t  // extra field is limited to 65536 bytes\n\t\t\t\t\t  // - no need for additional size check\n\t\t\t\t\t  next + copy\n\t\t\t\t\t),\n\t\t\t\t\t/*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n\t\t\t\t\tlen\n\t\t\t\t  );\n\t\t\t\t  //zmemcpy(state.head.extra + len, next,\n\t\t\t\t  //        len + copy > state.head.extra_max ?\n\t\t\t\t  //        state.head.extra_max - len : copy);\n\t\t\t\t}\n\t\t\t\tif (state.flags & 0x0200) {\n\t\t\t\t  state.check = crc32_1(state.check, input, copy, next);\n\t\t\t\t}\n\t\t\t\thave -= copy;\n\t\t\t\tnext += copy;\n\t\t\t\tstate.length -= copy;\n\t\t\t  }\n\t\t\t  if (state.length) { break inf_leave; }\n\t\t\t}\n\t\t\tstate.length = 0;\n\t\t\tstate.mode = NAME;\n\t\t\t/* falls through */\n\t\t  case NAME:\n\t\t\tif (state.flags & 0x0800) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  copy = 0;\n\t\t\t  do {\n\t\t\t\t// TODO: 2 or 1 bytes?\n\t\t\t\tlen = input[next + copy++];\n\t\t\t\t/* use constant limit because in js we should not preallocate memory */\n\t\t\t\tif (state.head && len &&\n\t\t\t\t\t(state.length < 65536 /*state.head.name_max*/)) {\n\t\t\t\t  state.head.name += String.fromCharCode(len);\n\t\t\t\t}\n\t\t\t  } while (len && copy < have);\n  \n\t\t\t  if (state.flags & 0x0200) {\n\t\t\t\tstate.check = crc32_1(state.check, input, copy, next);\n\t\t\t  }\n\t\t\t  have -= copy;\n\t\t\t  next += copy;\n\t\t\t  if (len) { break inf_leave; }\n\t\t\t}\n\t\t\telse if (state.head) {\n\t\t\t  state.head.name = null;\n\t\t\t}\n\t\t\tstate.length = 0;\n\t\t\tstate.mode = COMMENT;\n\t\t\t/* falls through */\n\t\t  case COMMENT:\n\t\t\tif (state.flags & 0x1000) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  copy = 0;\n\t\t\t  do {\n\t\t\t\tlen = input[next + copy++];\n\t\t\t\t/* use constant limit because in js we should not preallocate memory */\n\t\t\t\tif (state.head && len &&\n\t\t\t\t\t(state.length < 65536 /*state.head.comm_max*/)) {\n\t\t\t\t  state.head.comment += String.fromCharCode(len);\n\t\t\t\t}\n\t\t\t  } while (len && copy < have);\n\t\t\t  if (state.flags & 0x0200) {\n\t\t\t\tstate.check = crc32_1(state.check, input, copy, next);\n\t\t\t  }\n\t\t\t  have -= copy;\n\t\t\t  next += copy;\n\t\t\t  if (len) { break inf_leave; }\n\t\t\t}\n\t\t\telse if (state.head) {\n\t\t\t  state.head.comment = null;\n\t\t\t}\n\t\t\tstate.mode = HCRC;\n\t\t\t/* falls through */\n\t\t  case HCRC:\n\t\t\tif (state.flags & 0x0200) {\n\t\t\t  //=== NEEDBITS(16); */\n\t\t\t  while (bits < 16) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  if (hold !== (state.check & 0xffff)) {\n\t\t\t\tstrm.msg = 'header crc mismatch';\n\t\t\t\tstate.mode = BAD;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t}\n\t\t\tif (state.head) {\n\t\t\t  state.head.hcrc = ((state.flags >> 9) & 1);\n\t\t\t  state.head.done = true;\n\t\t\t}\n\t\t\tstrm.adler = state.check = 0;\n\t\t\tstate.mode = TYPE;\n\t\t\tbreak;\n\t\t  case DICTID:\n\t\t\t//=== NEEDBITS(32); */\n\t\t\twhile (bits < 32) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstrm.adler = state.check = zswap32(hold);\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = DICT;\n\t\t\t/* falls through */\n\t\t  case DICT:\n\t\t\tif (state.havedict === 0) {\n\t\t\t  //--- RESTORE() ---\n\t\t\t  strm.next_out = put;\n\t\t\t  strm.avail_out = left;\n\t\t\t  strm.next_in = next;\n\t\t\t  strm.avail_in = have;\n\t\t\t  state.hold = hold;\n\t\t\t  state.bits = bits;\n\t\t\t  //---\n\t\t\t  return Z_NEED_DICT$1;\n\t\t\t}\n\t\t\tstrm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n\t\t\tstate.mode = TYPE;\n\t\t\t/* falls through */\n\t\t  case TYPE:\n\t\t\tif (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n\t\t\t/* falls through */\n\t\t  case TYPEDO:\n\t\t\tif (state.last) {\n\t\t\t  //--- BYTEBITS() ---//\n\t\t\t  hold >>>= bits & 7;\n\t\t\t  bits -= bits & 7;\n\t\t\t  //---//\n\t\t\t  state.mode = CHECK;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//=== NEEDBITS(3); */\n\t\t\twhile (bits < 3) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstate.last = (hold & 0x01)/*BITS(1)*/;\n\t\t\t//--- DROPBITS(1) ---//\n\t\t\thold >>>= 1;\n\t\t\tbits -= 1;\n\t\t\t//---//\n  \n\t\t\tswitch ((hold & 0x03)/*BITS(2)*/) {\n\t\t\t  case 0:                             /* stored block */\n\t\t\t\t//Tracev((stderr, \"inflate:     stored block%s\\n\",\n\t\t\t\t//        state.last ? \" (last)\" : \"\"));\n\t\t\t\tstate.mode = STORED;\n\t\t\t\tbreak;\n\t\t\t  case 1:                             /* fixed block */\n\t\t\t\tfixedtables(state);\n\t\t\t\t//Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n\t\t\t\t//        state.last ? \" (last)\" : \"\"));\n\t\t\t\tstate.mode = LEN_;             /* decode codes */\n\t\t\t\tif (flush === Z_TREES) {\n\t\t\t\t  //--- DROPBITS(2) ---//\n\t\t\t\t  hold >>>= 2;\n\t\t\t\t  bits -= 2;\n\t\t\t\t  //---//\n\t\t\t\t  break inf_leave;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t  case 2:                             /* dynamic block */\n\t\t\t\t//Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n\t\t\t\t//        state.last ? \" (last)\" : \"\"));\n\t\t\t\tstate.mode = TABLE;\n\t\t\t\tbreak;\n\t\t\t  case 3:\n\t\t\t\tstrm.msg = 'invalid block type';\n\t\t\t\tstate.mode = BAD;\n\t\t\t}\n\t\t\t//--- DROPBITS(2) ---//\n\t\t\thold >>>= 2;\n\t\t\tbits -= 2;\n\t\t\t//---//\n\t\t\tbreak;\n\t\t  case STORED:\n\t\t\t//--- BYTEBITS() ---// /* go to byte boundary */\n\t\t\thold >>>= bits & 7;\n\t\t\tbits -= bits & 7;\n\t\t\t//---//\n\t\t\t//=== NEEDBITS(32); */\n\t\t\twhile (bits < 32) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tif ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n\t\t\t  strm.msg = 'invalid stored block lengths';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.length = hold & 0xffff;\n\t\t\t//Tracev((stderr, \"inflate:       stored length %u\\n\",\n\t\t\t//        state.length));\n\t\t\t//=== INITBITS();\n\t\t\thold = 0;\n\t\t\tbits = 0;\n\t\t\t//===//\n\t\t\tstate.mode = COPY_;\n\t\t\tif (flush === Z_TREES) { break inf_leave; }\n\t\t\t/* falls through */\n\t\t  case COPY_:\n\t\t\tstate.mode = COPY;\n\t\t\t/* falls through */\n\t\t  case COPY:\n\t\t\tcopy = state.length;\n\t\t\tif (copy) {\n\t\t\t  if (copy > have) { copy = have; }\n\t\t\t  if (copy > left) { copy = left; }\n\t\t\t  if (copy === 0) { break inf_leave; }\n\t\t\t  //--- zmemcpy(put, next, copy); ---\n\t\t\t  output.set(input.subarray(next, next + copy), put);\n\t\t\t  //---//\n\t\t\t  have -= copy;\n\t\t\t  next += copy;\n\t\t\t  left -= copy;\n\t\t\t  put += copy;\n\t\t\t  state.length -= copy;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//Tracev((stderr, \"inflate:       stored end\\n\"));\n\t\t\tstate.mode = TYPE;\n\t\t\tbreak;\n\t\t  case TABLE:\n\t\t\t//=== NEEDBITS(14); */\n\t\t\twhile (bits < 14) {\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t}\n\t\t\t//===//\n\t\t\tstate.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n\t\t\t//--- DROPBITS(5) ---//\n\t\t\thold >>>= 5;\n\t\t\tbits -= 5;\n\t\t\t//---//\n\t\t\tstate.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n\t\t\t//--- DROPBITS(5) ---//\n\t\t\thold >>>= 5;\n\t\t\tbits -= 5;\n\t\t\t//---//\n\t\t\tstate.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n\t\t\t//--- DROPBITS(4) ---//\n\t\t\thold >>>= 4;\n\t\t\tbits -= 4;\n\t\t\t//---//\n\t//#ifndef PKZIP_BUG_WORKAROUND\n\t\t\tif (state.nlen > 286 || state.ndist > 30) {\n\t\t\t  strm.msg = 'too many length or distance symbols';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t//#endif\n\t\t\t//Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n\t\t\tstate.have = 0;\n\t\t\tstate.mode = LENLENS;\n\t\t\t/* falls through */\n\t\t  case LENLENS:\n\t\t\twhile (state.have < state.ncode) {\n\t\t\t  //=== NEEDBITS(3);\n\t\t\t  while (bits < 3) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n\t\t\t  //--- DROPBITS(3) ---//\n\t\t\t  hold >>>= 3;\n\t\t\t  bits -= 3;\n\t\t\t  //---//\n\t\t\t}\n\t\t\twhile (state.have < 19) {\n\t\t\t  state.lens[order[state.have++]] = 0;\n\t\t\t}\n\t\t\t// We have separate tables & no pointers. 2 commented lines below not needed.\n\t\t\t//state.next = state.codes;\n\t\t\t//state.lencode = state.next;\n\t\t\t// Switch to use dynamic table\n\t\t\tstate.lencode = state.lendyn;\n\t\t\tstate.lenbits = 7;\n  \n\t\t\topts = { bits: state.lenbits };\n\t\t\tret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n\t\t\tstate.lenbits = opts.bits;\n  \n\t\t\tif (ret) {\n\t\t\t  strm.msg = 'invalid code lengths set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n\t\t\tstate.have = 0;\n\t\t\tstate.mode = CODELENS;\n\t\t\t/* falls through */\n\t\t  case CODELENS:\n\t\t\twhile (state.have < state.nlen + state.ndist) {\n\t\t\t  for (;;) {\n\t\t\t\there = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n\t\t\t\there_bits = here >>> 24;\n\t\t\t\there_op = (here >>> 16) & 0xff;\n\t\t\t\there_val = here & 0xffff;\n  \n\t\t\t\tif ((here_bits) <= bits) { break; }\n\t\t\t\t//--- PULLBYTE() ---//\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t\t//---//\n\t\t\t  }\n\t\t\t  if (here_val < 16) {\n\t\t\t\t//--- DROPBITS(here.bits) ---//\n\t\t\t\thold >>>= here_bits;\n\t\t\t\tbits -= here_bits;\n\t\t\t\t//---//\n\t\t\t\tstate.lens[state.have++] = here_val;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tif (here_val === 16) {\n\t\t\t\t  //=== NEEDBITS(here.bits + 2);\n\t\t\t\t  n = here_bits + 2;\n\t\t\t\t  while (bits < n) {\n\t\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\t\thave--;\n\t\t\t\t\thold += input[next++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t  //===//\n\t\t\t\t  //--- DROPBITS(here.bits) ---//\n\t\t\t\t  hold >>>= here_bits;\n\t\t\t\t  bits -= here_bits;\n\t\t\t\t  //---//\n\t\t\t\t  if (state.have === 0) {\n\t\t\t\t\tstrm.msg = 'invalid bit length repeat';\n\t\t\t\t\tstate.mode = BAD;\n\t\t\t\t\tbreak;\n\t\t\t\t  }\n\t\t\t\t  len = state.lens[state.have - 1];\n\t\t\t\t  copy = 3 + (hold & 0x03);//BITS(2);\n\t\t\t\t  //--- DROPBITS(2) ---//\n\t\t\t\t  hold >>>= 2;\n\t\t\t\t  bits -= 2;\n\t\t\t\t  //---//\n\t\t\t\t}\n\t\t\t\telse if (here_val === 17) {\n\t\t\t\t  //=== NEEDBITS(here.bits + 3);\n\t\t\t\t  n = here_bits + 3;\n\t\t\t\t  while (bits < n) {\n\t\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\t\thave--;\n\t\t\t\t\thold += input[next++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t  //===//\n\t\t\t\t  //--- DROPBITS(here.bits) ---//\n\t\t\t\t  hold >>>= here_bits;\n\t\t\t\t  bits -= here_bits;\n\t\t\t\t  //---//\n\t\t\t\t  len = 0;\n\t\t\t\t  copy = 3 + (hold & 0x07);//BITS(3);\n\t\t\t\t  //--- DROPBITS(3) ---//\n\t\t\t\t  hold >>>= 3;\n\t\t\t\t  bits -= 3;\n\t\t\t\t  //---//\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t  //=== NEEDBITS(here.bits + 7);\n\t\t\t\t  n = here_bits + 7;\n\t\t\t\t  while (bits < n) {\n\t\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\t\thave--;\n\t\t\t\t\thold += input[next++] << bits;\n\t\t\t\t\tbits += 8;\n\t\t\t\t  }\n\t\t\t\t  //===//\n\t\t\t\t  //--- DROPBITS(here.bits) ---//\n\t\t\t\t  hold >>>= here_bits;\n\t\t\t\t  bits -= here_bits;\n\t\t\t\t  //---//\n\t\t\t\t  len = 0;\n\t\t\t\t  copy = 11 + (hold & 0x7f);//BITS(7);\n\t\t\t\t  //--- DROPBITS(7) ---//\n\t\t\t\t  hold >>>= 7;\n\t\t\t\t  bits -= 7;\n\t\t\t\t  //---//\n\t\t\t\t}\n\t\t\t\tif (state.have + copy > state.nlen + state.ndist) {\n\t\t\t\t  strm.msg = 'invalid bit length repeat';\n\t\t\t\t  state.mode = BAD;\n\t\t\t\t  break;\n\t\t\t\t}\n\t\t\t\twhile (copy--) {\n\t\t\t\t  state.lens[state.have++] = len;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n  \n\t\t\t/* handle error breaks in while */\n\t\t\tif (state.mode === BAD) { break; }\n  \n\t\t\t/* check for end-of-block code (better have one) */\n\t\t\tif (state.lens[256] === 0) {\n\t\t\t  strm.msg = 'invalid code -- missing end-of-block';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n  \n\t\t\t/* build code tables -- note: do not change the lenbits or distbits\n\t\t\t   values here (9 and 6) without reading the comments in inftrees.h\n\t\t\t   concerning the ENOUGH constants, which depend on those values */\n\t\t\tstate.lenbits = 9;\n  \n\t\t\topts = { bits: state.lenbits };\n\t\t\tret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n\t\t\t// We have separate tables & no pointers. 2 commented lines below not needed.\n\t\t\t// state.next_index = opts.table_index;\n\t\t\tstate.lenbits = opts.bits;\n\t\t\t// state.lencode = state.next;\n  \n\t\t\tif (ret) {\n\t\t\t  strm.msg = 'invalid literal/lengths set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n  \n\t\t\tstate.distbits = 6;\n\t\t\t//state.distcode.copy(state.codes);\n\t\t\t// Switch to use dynamic table\n\t\t\tstate.distcode = state.distdyn;\n\t\t\topts = { bits: state.distbits };\n\t\t\tret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n\t\t\t// We have separate tables & no pointers. 2 commented lines below not needed.\n\t\t\t// state.next_index = opts.table_index;\n\t\t\tstate.distbits = opts.bits;\n\t\t\t// state.distcode = state.next;\n  \n\t\t\tif (ret) {\n\t\t\t  strm.msg = 'invalid distances set';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\t//Tracev((stderr, 'inflate:       codes ok\\n'));\n\t\t\tstate.mode = LEN_;\n\t\t\tif (flush === Z_TREES) { break inf_leave; }\n\t\t\t/* falls through */\n\t\t  case LEN_:\n\t\t\tstate.mode = LEN;\n\t\t\t/* falls through */\n\t\t  case LEN:\n\t\t\tif (have >= 6 && left >= 258) {\n\t\t\t  //--- RESTORE() ---\n\t\t\t  strm.next_out = put;\n\t\t\t  strm.avail_out = left;\n\t\t\t  strm.next_in = next;\n\t\t\t  strm.avail_in = have;\n\t\t\t  state.hold = hold;\n\t\t\t  state.bits = bits;\n\t\t\t  //---\n\t\t\t  inffast(strm, _out);\n\t\t\t  //--- LOAD() ---\n\t\t\t  put = strm.next_out;\n\t\t\t  output = strm.output;\n\t\t\t  left = strm.avail_out;\n\t\t\t  next = strm.next_in;\n\t\t\t  input = strm.input;\n\t\t\t  have = strm.avail_in;\n\t\t\t  hold = state.hold;\n\t\t\t  bits = state.bits;\n\t\t\t  //---\n  \n\t\t\t  if (state.mode === TYPE) {\n\t\t\t\tstate.back = -1;\n\t\t\t  }\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.back = 0;\n\t\t\tfor (;;) {\n\t\t\t  here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n\t\t\t  here_bits = here >>> 24;\n\t\t\t  here_op = (here >>> 16) & 0xff;\n\t\t\t  here_val = here & 0xffff;\n  \n\t\t\t  if (here_bits <= bits) { break; }\n\t\t\t  //--- PULLBYTE() ---//\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t  //---//\n\t\t\t}\n\t\t\tif (here_op && (here_op & 0xf0) === 0) {\n\t\t\t  last_bits = here_bits;\n\t\t\t  last_op = here_op;\n\t\t\t  last_val = here_val;\n\t\t\t  for (;;) {\n\t\t\t\there = state.lencode[last_val +\n\t\t\t\t\t\t((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n\t\t\t\there_bits = here >>> 24;\n\t\t\t\there_op = (here >>> 16) & 0xff;\n\t\t\t\there_val = here & 0xffff;\n  \n\t\t\t\tif ((last_bits + here_bits) <= bits) { break; }\n\t\t\t\t//--- PULLBYTE() ---//\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t\t//---//\n\t\t\t  }\n\t\t\t  //--- DROPBITS(last.bits) ---//\n\t\t\t  hold >>>= last_bits;\n\t\t\t  bits -= last_bits;\n\t\t\t  //---//\n\t\t\t  state.back += last_bits;\n\t\t\t}\n\t\t\t//--- DROPBITS(here.bits) ---//\n\t\t\thold >>>= here_bits;\n\t\t\tbits -= here_bits;\n\t\t\t//---//\n\t\t\tstate.back += here_bits;\n\t\t\tstate.length = here_val;\n\t\t\tif (here_op === 0) {\n\t\t\t  //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n\t\t\t  //        \"inflate:         literal '%c'\\n\" :\n\t\t\t  //        \"inflate:         literal 0x%02x\\n\", here.val));\n\t\t\t  state.mode = LIT;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (here_op & 32) {\n\t\t\t  //Tracevv((stderr, \"inflate:         end of block\\n\"));\n\t\t\t  state.back = -1;\n\t\t\t  state.mode = TYPE;\n\t\t\t  break;\n\t\t\t}\n\t\t\tif (here_op & 64) {\n\t\t\t  strm.msg = 'invalid literal/length code';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.extra = here_op & 15;\n\t\t\tstate.mode = LENEXT;\n\t\t\t/* falls through */\n\t\t  case LENEXT:\n\t\t\tif (state.extra) {\n\t\t\t  //=== NEEDBITS(state.extra);\n\t\t\t  n = state.extra;\n\t\t\t  while (bits < n) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n\t\t\t  //--- DROPBITS(state.extra) ---//\n\t\t\t  hold >>>= state.extra;\n\t\t\t  bits -= state.extra;\n\t\t\t  //---//\n\t\t\t  state.back += state.extra;\n\t\t\t}\n\t\t\t//Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n\t\t\tstate.was = state.length;\n\t\t\tstate.mode = DIST;\n\t\t\t/* falls through */\n\t\t  case DIST:\n\t\t\tfor (;;) {\n\t\t\t  here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n\t\t\t  here_bits = here >>> 24;\n\t\t\t  here_op = (here >>> 16) & 0xff;\n\t\t\t  here_val = here & 0xffff;\n  \n\t\t\t  if ((here_bits) <= bits) { break; }\n\t\t\t  //--- PULLBYTE() ---//\n\t\t\t  if (have === 0) { break inf_leave; }\n\t\t\t  have--;\n\t\t\t  hold += input[next++] << bits;\n\t\t\t  bits += 8;\n\t\t\t  //---//\n\t\t\t}\n\t\t\tif ((here_op & 0xf0) === 0) {\n\t\t\t  last_bits = here_bits;\n\t\t\t  last_op = here_op;\n\t\t\t  last_val = here_val;\n\t\t\t  for (;;) {\n\t\t\t\there = state.distcode[last_val +\n\t\t\t\t\t\t((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n\t\t\t\there_bits = here >>> 24;\n\t\t\t\there_op = (here >>> 16) & 0xff;\n\t\t\t\there_val = here & 0xffff;\n  \n\t\t\t\tif ((last_bits + here_bits) <= bits) { break; }\n\t\t\t\t//--- PULLBYTE() ---//\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t\t//---//\n\t\t\t  }\n\t\t\t  //--- DROPBITS(last.bits) ---//\n\t\t\t  hold >>>= last_bits;\n\t\t\t  bits -= last_bits;\n\t\t\t  //---//\n\t\t\t  state.back += last_bits;\n\t\t\t}\n\t\t\t//--- DROPBITS(here.bits) ---//\n\t\t\thold >>>= here_bits;\n\t\t\tbits -= here_bits;\n\t\t\t//---//\n\t\t\tstate.back += here_bits;\n\t\t\tif (here_op & 64) {\n\t\t\t  strm.msg = 'invalid distance code';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t\t\tstate.offset = here_val;\n\t\t\tstate.extra = (here_op) & 15;\n\t\t\tstate.mode = DISTEXT;\n\t\t\t/* falls through */\n\t\t  case DISTEXT:\n\t\t\tif (state.extra) {\n\t\t\t  //=== NEEDBITS(state.extra);\n\t\t\t  n = state.extra;\n\t\t\t  while (bits < n) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n\t\t\t  //--- DROPBITS(state.extra) ---//\n\t\t\t  hold >>>= state.extra;\n\t\t\t  bits -= state.extra;\n\t\t\t  //---//\n\t\t\t  state.back += state.extra;\n\t\t\t}\n\t//#ifdef INFLATE_STRICT\n\t\t\tif (state.offset > state.dmax) {\n\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t  state.mode = BAD;\n\t\t\t  break;\n\t\t\t}\n\t//#endif\n\t\t\t//Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n\t\t\tstate.mode = MATCH;\n\t\t\t/* falls through */\n\t\t  case MATCH:\n\t\t\tif (left === 0) { break inf_leave; }\n\t\t\tcopy = _out - left;\n\t\t\tif (state.offset > copy) {         /* copy from window */\n\t\t\t  copy = state.offset - copy;\n\t\t\t  if (copy > state.whave) {\n\t\t\t\tif (state.sane) {\n\t\t\t\t  strm.msg = 'invalid distance too far back';\n\t\t\t\t  state.mode = BAD;\n\t\t\t\t  break;\n\t\t\t\t}\n\t// (!) This block is disabled in zlib defaults,\n\t// don't enable it for binary compatibility\n\t//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n\t//          Trace((stderr, \"inflate.c too far\\n\"));\n\t//          copy -= state.whave;\n\t//          if (copy > state.length) { copy = state.length; }\n\t//          if (copy > left) { copy = left; }\n\t//          left -= copy;\n\t//          state.length -= copy;\n\t//          do {\n\t//            output[put++] = 0;\n\t//          } while (--copy);\n\t//          if (state.length === 0) { state.mode = LEN; }\n\t//          break;\n\t//#endif\n\t\t\t  }\n\t\t\t  if (copy > state.wnext) {\n\t\t\t\tcopy -= state.wnext;\n\t\t\t\tfrom = state.wsize - copy;\n\t\t\t  }\n\t\t\t  else {\n\t\t\t\tfrom = state.wnext - copy;\n\t\t\t  }\n\t\t\t  if (copy > state.length) { copy = state.length; }\n\t\t\t  from_source = state.window;\n\t\t\t}\n\t\t\telse {                              /* copy from output */\n\t\t\t  from_source = output;\n\t\t\t  from = put - state.offset;\n\t\t\t  copy = state.length;\n\t\t\t}\n\t\t\tif (copy > left) { copy = left; }\n\t\t\tleft -= copy;\n\t\t\tstate.length -= copy;\n\t\t\tdo {\n\t\t\t  output[put++] = from_source[from++];\n\t\t\t} while (--copy);\n\t\t\tif (state.length === 0) { state.mode = LEN; }\n\t\t\tbreak;\n\t\t  case LIT:\n\t\t\tif (left === 0) { break inf_leave; }\n\t\t\toutput[put++] = state.length;\n\t\t\tleft--;\n\t\t\tstate.mode = LEN;\n\t\t\tbreak;\n\t\t  case CHECK:\n\t\t\tif (state.wrap) {\n\t\t\t  //=== NEEDBITS(32);\n\t\t\t  while (bits < 32) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\t// Use '|' instead of '+' to make sure that result is signed\n\t\t\t\thold |= input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  _out -= left;\n\t\t\t  strm.total_out += _out;\n\t\t\t  state.total += _out;\n\t\t\t  if (_out) {\n\t\t\t\tstrm.adler = state.check =\n\t\t\t\t\t/*UPDATE(state.check, put - _out, _out);*/\n\t\t\t\t\t(state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out));\n  \n\t\t\t  }\n\t\t\t  _out = left;\n\t\t\t  // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n\t\t\t  if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n\t\t\t\tstrm.msg = 'incorrect data check';\n\t\t\t\tstate.mode = BAD;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t  //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n\t\t\t}\n\t\t\tstate.mode = LENGTH;\n\t\t\t/* falls through */\n\t\t  case LENGTH:\n\t\t\tif (state.wrap && state.flags) {\n\t\t\t  //=== NEEDBITS(32);\n\t\t\t  while (bits < 32) {\n\t\t\t\tif (have === 0) { break inf_leave; }\n\t\t\t\thave--;\n\t\t\t\thold += input[next++] << bits;\n\t\t\t\tbits += 8;\n\t\t\t  }\n\t\t\t  //===//\n\t\t\t  if (hold !== (state.total & 0xffffffff)) {\n\t\t\t\tstrm.msg = 'incorrect length check';\n\t\t\t\tstate.mode = BAD;\n\t\t\t\tbreak;\n\t\t\t  }\n\t\t\t  //=== INITBITS();\n\t\t\t  hold = 0;\n\t\t\t  bits = 0;\n\t\t\t  //===//\n\t\t\t  //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n\t\t\t}\n\t\t\tstate.mode = DONE;\n\t\t\t/* falls through */\n\t\t  case DONE:\n\t\t\tret = Z_STREAM_END$1;\n\t\t\tbreak inf_leave;\n\t\t  case BAD:\n\t\t\tret = Z_DATA_ERROR$1;\n\t\t\tbreak inf_leave;\n\t\t  case MEM:\n\t\t\treturn Z_MEM_ERROR$1;\n\t\t  case SYNC:\n\t\t\t/* falls through */\n\t\t  default:\n\t\t\treturn Z_STREAM_ERROR$1;\n\t\t}\n\t  }\n  \n\t  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n  \n\t  /*\n\t\t Return from inflate(), updating the total counts and the check value.\n\t\t If there was no progress during the inflate() call, return a buffer\n\t\t error.  Call updatewindow() to create and/or update the window state.\n\t\t Note: a memory error from inflate() is non-recoverable.\n\t   */\n  \n\t  //--- RESTORE() ---\n\t  strm.next_out = put;\n\t  strm.avail_out = left;\n\t  strm.next_in = next;\n\t  strm.avail_in = have;\n\t  state.hold = hold;\n\t  state.bits = bits;\n\t  //---\n  \n\t  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n\t\t\t\t\t\t  (state.mode < CHECK || flush !== Z_FINISH$1))) {\n\t\tif (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;\n\t  }\n\t  _in -= strm.avail_in;\n\t  _out -= strm.avail_out;\n\t  strm.total_in += _in;\n\t  strm.total_out += _out;\n\t  state.total += _out;\n\t  if (state.wrap && _out) {\n\t\tstrm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n\t\t  (state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out));\n\t  }\n\t  strm.data_type = state.bits + (state.last ? 64 : 0) +\n\t\t\t\t\t\t(state.mode === TYPE ? 128 : 0) +\n\t\t\t\t\t\t(state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n\t  if (((_in === 0 && _out === 0) || flush === Z_FINISH$1) && ret === Z_OK$1) {\n\t\tret = Z_BUF_ERROR;\n\t  }\n\t  return ret;\n\t};\n  \n  \n\tconst inflateEnd = (strm) => {\n  \n\t  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n  \n\t  let state = strm.state;\n\t  if (state.window) {\n\t\tstate.window = null;\n\t  }\n\t  strm.state = null;\n\t  return Z_OK$1;\n\t};\n  \n  \n\tconst inflateGetHeader = (strm, head) => {\n  \n\t  /* check state */\n\t  if (!strm || !strm.state) { return Z_STREAM_ERROR$1; }\n\t  const state = strm.state;\n\t  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR$1; }\n  \n\t  /* save header structure */\n\t  state.head = head;\n\t  head.done = false;\n\t  return Z_OK$1;\n\t};\n  \n  \n\tconst inflateSetDictionary = (strm, dictionary) => {\n\t  const dictLength = dictionary.length;\n  \n\t  let state;\n\t  let dictid;\n\t  let ret;\n  \n\t  /* check state */\n\t  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR$1; }\n\t  state = strm.state;\n  \n\t  if (state.wrap !== 0 && state.mode !== DICT) {\n\t\treturn Z_STREAM_ERROR$1;\n\t  }\n  \n\t  /* check for correct dictionary identifier */\n\t  if (state.mode === DICT) {\n\t\tdictid = 1; /* adler32(0, null, 0)*/\n\t\t/* dictid = adler32(dictid, dictionary, dictLength); */\n\t\tdictid = adler32_1(dictid, dictionary, dictLength, 0);\n\t\tif (dictid !== state.check) {\n\t\t  return Z_DATA_ERROR$1;\n\t\t}\n\t  }\n\t  /* copy dictionary to window using updatewindow(), which will amend the\n\t   existing dictionary if appropriate */\n\t  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n\t  if (ret) {\n\t\tstate.mode = MEM;\n\t\treturn Z_MEM_ERROR$1;\n\t  }\n\t  state.havedict = 1;\n\t  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n\t  return Z_OK$1;\n\t};\n  \n  \n\tvar inflateReset_1 = inflateReset;\n\tvar inflateReset2_1 = inflateReset2;\n\tvar inflateResetKeep_1 = inflateResetKeep;\n\tvar inflateInit_1 = inflateInit;\n\tvar inflateInit2_1 = inflateInit2;\n\tvar inflate_2$1 = inflate$2;\n\tvar inflateEnd_1 = inflateEnd;\n\tvar inflateGetHeader_1 = inflateGetHeader;\n\tvar inflateSetDictionary_1 = inflateSetDictionary;\n\tvar inflateInfo = 'pako inflate (from Nodeca project)';\n  \n\t/* Not implemented\n\tmodule.exports.inflateCopy = inflateCopy;\n\tmodule.exports.inflateGetDictionary = inflateGetDictionary;\n\tmodule.exports.inflateMark = inflateMark;\n\tmodule.exports.inflatePrime = inflatePrime;\n\tmodule.exports.inflateSync = inflateSync;\n\tmodule.exports.inflateSyncPoint = inflateSyncPoint;\n\tmodule.exports.inflateUndermine = inflateUndermine;\n\t*/\n  \n\tvar inflate_1$2 = {\n\t\tinflateReset: inflateReset_1,\n\t\tinflateReset2: inflateReset2_1,\n\t\tinflateResetKeep: inflateResetKeep_1,\n\t\tinflateInit: inflateInit_1,\n\t\tinflateInit2: inflateInit2_1,\n\t\tinflate: inflate_2$1,\n\t\tinflateEnd: inflateEnd_1,\n\t\tinflateGetHeader: inflateGetHeader_1,\n\t\tinflateSetDictionary: inflateSetDictionary_1,\n\t\tinflateInfo: inflateInfo\n\t};\n  \n\t// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n\t// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n\t//\n\t// This software is provided 'as-is', without any express or implied\n\t// warranty. In no event will the authors be held liable for any damages\n\t// arising from the use of this software.\n\t//\n\t// Permission is granted to anyone to use this software for any purpose,\n\t// including commercial applications, and to alter it and redistribute it\n\t// freely, subject to the following restrictions:\n\t//\n\t// 1. The origin of this software must not be misrepresented; you must not\n\t//   claim that you wrote the original software. If you use this software\n\t//   in a product, an acknowledgment in the product documentation would be\n\t//   appreciated but is not required.\n\t// 2. Altered source versions must be plainly marked as such, and must not be\n\t//   misrepresented as being the original software.\n\t// 3. This notice may not be removed or altered from any source distribution.\n  \n\tfunction GZheader() {\n\t  /* true if compressed data believed to be text */\n\t  this.text       = 0;\n\t  /* modification time */\n\t  this.time       = 0;\n\t  /* extra flags (not used when writing a gzip file) */\n\t  this.xflags     = 0;\n\t  /* operating system */\n\t  this.os         = 0;\n\t  /* pointer to extra field or Z_NULL if none */\n\t  this.extra      = null;\n\t  /* extra field length (valid if extra != Z_NULL) */\n\t  this.extra_len  = 0; // Actually, we don't need it in JS,\n\t\t\t\t\t\t   // but leave for few code modifications\n  \n\t  //\n\t  // Setup limits is not necessary because in js we should not preallocate memory\n\t  // for inflate use constant limit in 65536 bytes\n\t  //\n  \n\t  /* space at extra (only when reading header) */\n\t  // this.extra_max  = 0;\n\t  /* pointer to zero-terminated file name or Z_NULL */\n\t  this.name       = '';\n\t  /* space at name (only when reading header) */\n\t  // this.name_max   = 0;\n\t  /* pointer to zero-terminated comment or Z_NULL */\n\t  this.comment    = '';\n\t  /* space at comment (only when reading header) */\n\t  // this.comm_max   = 0;\n\t  /* true if there was or will be a header crc */\n\t  this.hcrc       = 0;\n\t  /* true when done reading gzip header (not used when writing a gzip file) */\n\t  this.done       = false;\n\t}\n  \n\tvar gzheader = GZheader;\n  \n\tconst toString = Object.prototype.toString;\n  \n\t/* Public constants ==========================================================*/\n\t/* ===========================================================================*/\n  \n\tconst {\n\t  Z_NO_FLUSH, Z_FINISH,\n\t  Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR\n\t} = constants$2;\n  \n\t/* ===========================================================================*/\n  \n  \n\t/**\n\t * class Inflate\n\t *\n\t * Generic JS-style wrapper for zlib calls. If you don't need\n\t * streaming behaviour - use more simple functions: [[inflate]]\n\t * and [[inflateRaw]].\n\t **/\n  \n\t/* internal\n\t * inflate.chunks -> Array\n\t *\n\t * Chunks of output data, if [[Inflate#onData]] not overridden.\n\t **/\n  \n\t/**\n\t * Inflate.result -> Uint8Array|String\n\t *\n\t * Uncompressed result, generated by default [[Inflate#onData]]\n\t * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n\t * (call [[Inflate#push]] with `Z_FINISH` / `true` param).\n\t **/\n  \n\t/**\n\t * Inflate.err -> Number\n\t *\n\t * Error code after inflate finished. 0 (Z_OK) on success.\n\t * Should be checked if broken data possible.\n\t **/\n  \n\t/**\n\t * Inflate.msg -> String\n\t *\n\t * Error message, if [[Inflate.err]] != 0\n\t **/\n  \n  \n\t/**\n\t * new Inflate(options)\n\t * - options (Object): zlib inflate options.\n\t *\n\t * Creates new inflator instance with specified params. Throws exception\n\t * on bad params. Supported options:\n\t *\n\t * - `windowBits`\n\t * - `dictionary`\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information on these.\n\t *\n\t * Additional options, for internal needs:\n\t *\n\t * - `chunkSize` - size of generated data chunks (16K by default)\n\t * - `raw` (Boolean) - do raw inflate\n\t * - `to` (String) - if equal to 'string', then result will be converted\n\t *   from utf8 to utf16 (javascript) string. When string output requested,\n\t *   chunk length can differ from `chunkSize`, depending on content.\n\t *\n\t * By default, when no options set, autodetect deflate/gzip data format via\n\t * wrapper header.\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako')\n\t * const chunk1 = new Uint8Array([1,2,3,4,5,6,7,8,9])\n\t * const chunk2 = new Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n\t *\n\t * const inflate = new pako.Inflate({ level: 3});\n\t *\n\t * inflate.push(chunk1, false);\n\t * inflate.push(chunk2, true);  // true -> last chunk\n\t *\n\t * if (inflate.err) { throw new Error(inflate.err); }\n\t *\n\t * console.log(inflate.result);\n\t * ```\n\t **/\n\tfunction Inflate$1(options) {\n\t  this.options = common.assign({\n\t\tchunkSize: 1024 * 64,\n\t\twindowBits: 15,\n\t\tto: ''\n\t  }, options || {});\n  \n\t  const opt = this.options;\n  \n\t  // Force window size for `raw` data, if not set directly,\n\t  // because we have no header for autodetect.\n\t  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n\t\topt.windowBits = -opt.windowBits;\n\t\tif (opt.windowBits === 0) { opt.windowBits = -15; }\n\t  }\n  \n\t  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n\t  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n\t\t  !(options && options.windowBits)) {\n\t\topt.windowBits += 32;\n\t  }\n  \n\t  // Gzip header has no info about windows size, we can do autodetect only\n\t  // for deflate. So, if window size not set, force it to max when gzip possible\n\t  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n\t\t// bit 3 (16) -> gzipped data\n\t\t// bit 4 (32) -> autodetect gzip/deflate\n\t\tif ((opt.windowBits & 15) === 0) {\n\t\t  opt.windowBits |= 15;\n\t\t}\n\t  }\n  \n\t  this.err    = 0;      // error code, if happens (0 = Z_OK)\n\t  this.msg    = '';     // error message\n\t  this.ended  = false;  // used to avoid multiple onEnd() calls\n\t  this.chunks = [];     // chunks of compressed data\n  \n\t  this.strm   = new zstream();\n\t  this.strm.avail_out = 0;\n  \n\t  let status  = inflate_1$2.inflateInit2(\n\t\tthis.strm,\n\t\topt.windowBits\n\t  );\n  \n\t  if (status !== Z_OK) {\n\t\tthrow new Error(messages[status]);\n\t  }\n  \n\t  this.header = new gzheader();\n  \n\t  inflate_1$2.inflateGetHeader(this.strm, this.header);\n  \n\t  // Setup dictionary\n\t  if (opt.dictionary) {\n\t\t// Convert data if needed\n\t\tif (typeof opt.dictionary === 'string') {\n\t\t  opt.dictionary = strings.string2buf(opt.dictionary);\n\t\t} else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n\t\t  opt.dictionary = new Uint8Array(opt.dictionary);\n\t\t}\n\t\tif (opt.raw) { //In raw mode we need to set the dictionary early\n\t\t  status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n\t\t  if (status !== Z_OK) {\n\t\t\tthrow new Error(messages[status]);\n\t\t  }\n\t\t}\n\t  }\n\t}\n  \n\t/**\n\t * Inflate#push(data[, flush_mode]) -> Boolean\n\t * - data (Uint8Array|ArrayBuffer): input data\n\t * - flush_mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE\n\t *   flush modes. See constants. Skipped or `false` means Z_NO_FLUSH,\n\t *   `true` means Z_FINISH.\n\t *\n\t * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n\t * new output chunks. Returns `true` on success. If end of stream detected,\n\t * [[Inflate#onEnd]] will be called.\n\t *\n\t * `flush_mode` is not needed for normal operation, because end of stream\n\t * detected automatically. You may try to use it for advanced things, but\n\t * this functionality was not tested.\n\t *\n\t * On fail call [[Inflate#onEnd]] with error code and return false.\n\t *\n\t * ##### Example\n\t *\n\t * ```javascript\n\t * push(chunk, false); // push one of data chunks\n\t * ...\n\t * push(chunk, true);  // push last chunk\n\t * ```\n\t **/\n\tInflate$1.prototype.push = function (data, flush_mode) {\n\t  const strm = this.strm;\n\t  const chunkSize = this.options.chunkSize;\n\t  const dictionary = this.options.dictionary;\n\t  let status, _flush_mode, last_avail_out;\n  \n\t  if (this.ended) return false;\n  \n\t  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;\n\t  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n  \n\t  // Convert data if needed\n\t  if (toString.call(data) === '[object ArrayBuffer]') {\n\t\tstrm.input = new Uint8Array(data);\n\t  } else {\n\t\tstrm.input = data;\n\t  }\n  \n\t  strm.next_in = 0;\n\t  strm.avail_in = strm.input.length;\n  \n\t  for (;;) {\n\t\tif (strm.avail_out === 0) {\n\t\t  strm.output = new Uint8Array(chunkSize);\n\t\t  strm.next_out = 0;\n\t\t  strm.avail_out = chunkSize;\n\t\t}\n  \n\t\tstatus = inflate_1$2.inflate(strm, _flush_mode);\n  \n\t\tif (status === Z_NEED_DICT && dictionary) {\n\t\t  status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n  \n\t\t  if (status === Z_OK) {\n\t\t\tstatus = inflate_1$2.inflate(strm, _flush_mode);\n\t\t  } else if (status === Z_DATA_ERROR) {\n\t\t\t// Replace code with more verbose\n\t\t\tstatus = Z_NEED_DICT;\n\t\t  }\n\t\t}\n  \n\t\t// Skip snyc markers if more data follows and not raw mode\n\t\twhile (strm.avail_in > 0 &&\n\t\t\t   status === Z_STREAM_END &&\n\t\t\t   strm.state.wrap > 0 &&\n\t\t\t   data[strm.next_in] !== 0)\n\t\t{\n\t\t  inflate_1$2.inflateReset(strm);\n\t\t  status = inflate_1$2.inflate(strm, _flush_mode);\n\t\t}\n  \n\t\tswitch (status) {\n\t\t  case Z_STREAM_ERROR:\n\t\t  case Z_DATA_ERROR:\n\t\t  case Z_NEED_DICT:\n\t\t  case Z_MEM_ERROR:\n\t\t\tthis.onEnd(status);\n\t\t\tthis.ended = true;\n\t\t\treturn false;\n\t\t}\n  \n\t\t// Remember real `avail_out` value, because we may patch out buffer content\n\t\t// to align utf8 strings boundaries.\n\t\tlast_avail_out = strm.avail_out;\n  \n\t\tif (strm.next_out) {\n\t\t  if (strm.avail_out === 0 || status === Z_STREAM_END) {\n  \n\t\t\tif (this.options.to === 'string') {\n  \n\t\t\t  let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n  \n\t\t\t  let tail = strm.next_out - next_out_utf8;\n\t\t\t  let utf8str = strings.buf2string(strm.output, next_out_utf8);\n  \n\t\t\t  // move tail & realign counters\n\t\t\t  strm.next_out = tail;\n\t\t\t  strm.avail_out = chunkSize - tail;\n\t\t\t  if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n  \n\t\t\t  this.onData(utf8str);\n  \n\t\t\t} else {\n\t\t\t  this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n\t\t\t}\n\t\t  }\n\t\t}\n  \n\t\t// Must repeat iteration if out buffer is full\n\t\tif (status === Z_OK && last_avail_out === 0) continue;\n  \n\t\t// Finalize if end of stream reached.\n\t\tif (status === Z_STREAM_END) {\n\t\t  status = inflate_1$2.inflateEnd(this.strm);\n\t\t  this.onEnd(status);\n\t\t  this.ended = true;\n\t\t  return true;\n\t\t}\n  \n\t\tif (strm.avail_in === 0) break;\n\t  }\n  \n\t  return true;\n\t};\n  \n  \n\t/**\n\t * Inflate#onData(chunk) -> Void\n\t * - chunk (Uint8Array|String): output data. When string output requested,\n\t *   each chunk will be string.\n\t *\n\t * By default, stores data blocks in `chunks[]` property and glue\n\t * those in `onEnd`. Override this handler, if you need another behaviour.\n\t **/\n\tInflate$1.prototype.onData = function (chunk) {\n\t  this.chunks.push(chunk);\n\t};\n  \n  \n\t/**\n\t * Inflate#onEnd(status) -> Void\n\t * - status (Number): inflate status. 0 (Z_OK) on success,\n\t *   other if not.\n\t *\n\t * Called either after you tell inflate that the input stream is\n\t * complete (Z_FINISH). By default - join collected chunks,\n\t * free memory and fill `results` / `err` properties.\n\t **/\n\tInflate$1.prototype.onEnd = function (status) {\n\t  // On success - join\n\t  if (status === Z_OK) {\n\t\tif (this.options.to === 'string') {\n\t\t  this.result = this.chunks.join('');\n\t\t} else {\n\t\t  this.result = common.flattenChunks(this.chunks);\n\t\t}\n\t  }\n\t  this.chunks = [];\n\t  this.err = status;\n\t  this.msg = this.strm.msg;\n\t};\n  \n  \n\t/**\n\t * inflate(data[, options]) -> Uint8Array|String\n\t * - data (Uint8Array): input data to decompress.\n\t * - options (Object): zlib inflate options.\n\t *\n\t * Decompress `data` with inflate/ungzip and `options`. Autodetect\n\t * format via wrapper header by default. That's why we don't provide\n\t * separate `ungzip` method.\n\t *\n\t * Supported options are:\n\t *\n\t * - windowBits\n\t *\n\t * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n\t * for more information.\n\t *\n\t * Sugar (options):\n\t *\n\t * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n\t *   negative windowBits implicitly.\n\t * - `to` (String) - if equal to 'string', then result will be converted\n\t *   from utf8 to utf16 (javascript) string. When string output requested,\n\t *   chunk length can differ from `chunkSize`, depending on content.\n\t *\n\t *\n\t * ##### Example:\n\t *\n\t * ```javascript\n\t * const pako = require('pako');\n\t * const input = pako.deflate(new Uint8Array([1,2,3,4,5,6,7,8,9]));\n\t * let output;\n\t *\n\t * try {\n\t *   output = pako.inflate(input);\n\t * } catch (err) {\n\t *   console.log(err);\n\t * }\n\t * ```\n\t **/\n\tfunction inflate$1(input, options) {\n\t  const inflator = new Inflate$1(options);\n  \n\t  inflator.push(input);\n  \n\t  // That will never happens, if you don't cheat with options :)\n\t  if (inflator.err) throw inflator.msg || messages[inflator.err];\n  \n\t  return inflator.result;\n\t}\n  \n  \n\t/**\n\t * inflateRaw(data[, options]) -> Uint8Array|String\n\t * - data (Uint8Array): input data to decompress.\n\t * - options (Object): zlib inflate options.\n\t *\n\t * The same as [[inflate]], but creates raw data, without wrapper\n\t * (header and adler32 crc).\n\t **/\n\tfunction inflateRaw$1(input, options) {\n\t  options = options || {};\n\t  options.raw = true;\n\t  return inflate$1(input, options);\n\t}\n  \n  \n\t/**\n\t * ungzip(data[, options]) -> Uint8Array|String\n\t * - data (Uint8Array): input data to decompress.\n\t * - options (Object): zlib inflate options.\n\t *\n\t * Just shortcut to [[inflate]], because it autodetects format\n\t * by header.content. Done for convenience.\n\t **/\n  \n  \n\tvar Inflate_1$1 = Inflate$1;\n\tvar inflate_2 = inflate$1;\n\tvar inflateRaw_1$1 = inflateRaw$1;\n\tvar ungzip$1 = inflate$1;\n\tvar constants = constants$2;\n  \n\tvar inflate_1$1 = {\n\t\tInflate: Inflate_1$1,\n\t\tinflate: inflate_2,\n\t\tinflateRaw: inflateRaw_1$1,\n\t\tungzip: ungzip$1,\n\t\tconstants: constants\n\t};\n  \n\tconst { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;\n  \n\tconst { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\n  \n  \n  \n\tvar Deflate_1 = Deflate;\n\tvar deflate_1 = deflate;\n\tvar deflateRaw_1 = deflateRaw;\n\tvar gzip_1 = gzip;\n\tvar Inflate_1 = Inflate;\n\tvar inflate_1 = inflate;\n\tvar inflateRaw_1 = inflateRaw;\n\tvar ungzip_1 = ungzip;\n\tvar constants_1 = constants$2;\n  \n\tvar pako = {\n\t\tDeflate: Deflate_1,\n\t\tdeflate: deflate_1,\n\t\tdeflateRaw: deflateRaw_1,\n\t\tgzip: gzip_1,\n\t\tInflate: Inflate_1,\n\t\tinflate: inflate_1,\n\t\tinflateRaw: inflateRaw_1,\n\t\tungzip: ungzip_1,\n\t\tconstants: constants_1\n\t};\n  \n\texports.Deflate = Deflate_1;\n\texports.Inflate = Inflate_1;\n\texports.constants = constants_1;\n\texports['default'] = pako;\n\texports.deflate = deflate_1;\n\texports.deflateRaw = deflateRaw_1;\n\texports.gzip = gzip_1;\n\texports.inflate = inflate_1;\n\texports.inflateRaw = inflateRaw_1;\n\texports.ungzip = ungzip_1;\n  \n\tObject.defineProperty(exports, '__esModule', { value: true });\n  \n  })));",
  "JDlO4hNt4jeh93tOFWHTB2A10SN6/D1EPgF/tfBITBc=": "/*! fast-json-patch, version: 3.1.1 */\nvar jsonpatch =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2022 Joachim Wester\n * MIT licensed\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(obj, key) {\n    return _hasOwnProperty.call(obj, key);\n}\nexports.hasOwnProperty = hasOwnProperty;\nfunction _objectKeys(obj) {\n    if (Array.isArray(obj)) {\n        var keys_1 = new Array(obj.length);\n        for (var k = 0; k < keys_1.length; k++) {\n            keys_1[k] = \"\" + k;\n        }\n        return keys_1;\n    }\n    if (Object.keys) {\n        return Object.keys(obj);\n    }\n    var keys = [];\n    for (var i in obj) {\n        if (hasOwnProperty(obj, i)) {\n            keys.push(i);\n        }\n    }\n    return keys;\n}\nexports._objectKeys = _objectKeys;\n;\n/**\n* Deeply clone the object.\n* https://jsperf.com/deep-copy-vs-json-stringify-json-parse/25 (recursiveDeepCopy)\n* @param  {any} obj value to clone\n* @return {any} cloned obj\n*/\nfunction _deepClone(obj) {\n    switch (typeof obj) {\n        case \"object\":\n            return JSON.parse(JSON.stringify(obj)); //Faster than ES5 clone - http://jsperf.com/deep-cloning-of-objects/5\n        case \"undefined\":\n            return null; //this is how JSON.stringify behaves for array items\n        default:\n            return obj; //no need to clone primitives\n    }\n}\nexports._deepClone = _deepClone;\n//3x faster than cached /^\\d+$/.test(str)\nfunction isInteger(str) {\n    var i = 0;\n    var len = str.length;\n    var charCode;\n    while (i < len) {\n        charCode = str.charCodeAt(i);\n        if (charCode >= 48 && charCode <= 57) {\n            i++;\n            continue;\n        }\n        return false;\n    }\n    return true;\n}\nexports.isInteger = isInteger;\n/**\n* Escapes a json pointer path\n* @param path The raw pointer\n* @return the Escaped path\n*/\nfunction escapePathComponent(path) {\n    if (path.indexOf('/') === -1 && path.indexOf('~') === -1)\n        return path;\n    return path.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\nexports.escapePathComponent = escapePathComponent;\n/**\n * Unescapes a json pointer path\n * @param path The escaped pointer\n * @return The unescaped path\n */\nfunction unescapePathComponent(path) {\n    return path.replace(/~1/g, '/').replace(/~0/g, '~');\n}\nexports.unescapePathComponent = unescapePathComponent;\nfunction _getPathRecursive(root, obj) {\n    var found;\n    for (var key in root) {\n        if (hasOwnProperty(root, key)) {\n            if (root[key] === obj) {\n                return escapePathComponent(key) + '/';\n            }\n            else if (typeof root[key] === 'object') {\n                found = _getPathRecursive(root[key], obj);\n                if (found != '') {\n                    return escapePathComponent(key) + '/' + found;\n                }\n            }\n        }\n    }\n    return '';\n}\nexports._getPathRecursive = _getPathRecursive;\nfunction getPath(root, obj) {\n    if (root === obj) {\n        return '/';\n    }\n    var path = _getPathRecursive(root, obj);\n    if (path === '') {\n        throw new Error(\"Object not found in root\");\n    }\n    return \"/\" + path;\n}\nexports.getPath = getPath;\n/**\n* Recursively checks whether an object has any undefined values inside.\n*/\nfunction hasUndefined(obj) {\n    if (obj === undefined) {\n        return true;\n    }\n    if (obj) {\n        if (Array.isArray(obj)) {\n            for (var i_1 = 0, len = obj.length; i_1 < len; i_1++) {\n                if (hasUndefined(obj[i_1])) {\n                    return true;\n                }\n            }\n        }\n        else if (typeof obj === \"object\") {\n            var objKeys = _objectKeys(obj);\n            var objKeysLength = objKeys.length;\n            for (var i = 0; i < objKeysLength; i++) {\n                if (hasUndefined(obj[objKeys[i]])) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nexports.hasUndefined = hasUndefined;\nfunction patchErrorMessageFormatter(message, args) {\n    var messageParts = [message];\n    for (var key in args) {\n        var value = typeof args[key] === 'object' ? JSON.stringify(args[key], null, 2) : args[key]; // pretty print\n        if (typeof value !== 'undefined') {\n            messageParts.push(key + \": \" + value);\n        }\n    }\n    return messageParts.join('\\n');\n}\nvar PatchError = /** @class */ (function (_super) {\n    __extends(PatchError, _super);\n    function PatchError(message, name, index, operation, tree) {\n        var _newTarget = this.constructor;\n        var _this = _super.call(this, patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree })) || this;\n        _this.name = name;\n        _this.index = index;\n        _this.operation = operation;\n        _this.tree = tree;\n        Object.setPrototypeOf(_this, _newTarget.prototype); // restore prototype chain, see https://stackoverflow.com/a/48342359\n        _this.message = patchErrorMessageFormatter(message, { name: name, index: index, operation: operation, tree: tree });\n        return _this;\n    }\n    return PatchError;\n}(Error));\nexports.PatchError = PatchError;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar helpers_js_1 = __webpack_require__(0);\nexports.JsonPatchError = helpers_js_1.PatchError;\nexports.deepClone = helpers_js_1._deepClone;\n/* We use a Javascript hash to store each\n function. Each hash entry (property) uses\n the operation identifiers specified in rfc6902.\n In this way, we can map each patch operation\n to its dedicated function in efficient way.\n */\n/* The operations applicable to an object */\nvar objOps = {\n    add: function (obj, key, document) {\n        obj[key] = this.value;\n        return { newDocument: document };\n    },\n    remove: function (obj, key, document) {\n        var removed = obj[key];\n        delete obj[key];\n        return { newDocument: document, removed: removed };\n    },\n    replace: function (obj, key, document) {\n        var removed = obj[key];\n        obj[key] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: function (obj, key, document) {\n        /* in case move target overwrites an existing value,\n        return the removed value, this can be taxing performance-wise,\n        and is potentially unneeded */\n        var removed = getValueByPointer(document, this.path);\n        if (removed) {\n            removed = helpers_js_1._deepClone(removed);\n        }\n        var originalValue = applyOperation(document, { op: \"remove\", path: this.from }).removed;\n        applyOperation(document, { op: \"add\", path: this.path, value: originalValue });\n        return { newDocument: document, removed: removed };\n    },\n    copy: function (obj, key, document) {\n        var valueToCopy = getValueByPointer(document, this.from);\n        // enforce copy by value so further operations don't affect source (see issue #177)\n        applyOperation(document, { op: \"add\", path: this.path, value: helpers_js_1._deepClone(valueToCopy) });\n        return { newDocument: document };\n    },\n    test: function (obj, key, document) {\n        return { newDocument: document, test: _areEquals( this.valueobj[key],) };\n    },\n    _get: function (obj, key, document) {\n        this.value = obj[key];\n        return { newDocument: document };\n    }\n};\n/* The operations applicable to an array. Many are the same as for the object */\nvar arrOps = {\n    add: function (arr, i, document) {\n        if (helpers_js_1.isInteger(i)) {\n            arr.splice(i, 0, this.value);\n        }\n        else { // array props\n            arr[i] = this.value;\n        }\n        // this may be needed when using '-' in an array\n        return { newDocument: document, index: i };\n    },\n    remove: function (arr, i, document) {\n        var removedList = arr.splice(i, 1);\n        return { newDocument: document, removed: removedList[0] };\n    },\n    replace: function (arr, i, document) {\n        var removed = arr[i];\n        arr[i] = this.value;\n        return { newDocument: document, removed: removed };\n    },\n    move: objOps.move,\n    copy: objOps.copy,\n    test: objOps.test,\n    _get: objOps._get\n};\n/**\n * Retrieves a value from a JSON document by a JSON pointer.\n * Returns the value.\n *\n * @param document The document to get the value from\n * @param pointer an escaped JSON pointer\n * @return The retrieved value\n */\nfunction getValueByPointer(document, pointer) {\n    if (pointer == '') {\n        return document;\n    }\n    var getOriginalDestination = { op: \"_get\", path: pointer };\n    applyOperation(document, getOriginalDestination);\n    return getOriginalDestination.value;\n}\nexports.getValueByPointer = getValueByPointer;\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the {newDocument, result} of the operation.\n * It modifies the `document` and `operation` objects - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyOperation(document, jsonpatch._deepClone(operation))`.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return `{newDocument, result}` after the operation\n */\nfunction applyOperation(document, operation, validateOperation, mutateDocument, banPrototypeModifications, index) {\n    if (validateOperation === void 0) { validateOperation = false; }\n    if (mutateDocument === void 0) { mutateDocument = true; }\n    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }\n    if (index === void 0) { index = 0; }\n    if (validateOperation) {\n        if (typeof validateOperation == 'function') {\n            validateOperation(operation, 0, document, operation.path);\n        }\n        else {\n            validator(operation, 0);\n        }\n    }\n    /* ROOT OPERATIONS */\n    if (operation.path === \"\") {\n        var returnValue = { newDocument: document };\n        if (operation.op === 'add') {\n            returnValue.newDocument = operation.value;\n            return returnValue;\n        }\n        else if (operation.op === 'replace') {\n            returnValue.newDocument = operation.value;\n            returnValue.removed = document; //document we removed\n            return returnValue;\n        }\n        else if (operation.op === 'move' || operation.op === 'copy') { // it's a move or copy to root\n            returnValue.newDocument = getValueByPointer(document, operation.from); // get the value by json-pointer in `from` field\n            if (operation.op === 'move') { // report removed item\n                returnValue.removed = document;\n            }\n            return returnValue;\n        }\n        else if (operation.op === 'test') {\n            returnValue.test = _areEquals(document, operation.value);\n            if (returnValue.test === false) {\n                throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n            }\n            returnValue.newDocument = document;\n            return returnValue;\n        }\n        else if (operation.op === 'remove') { // a remove on root\n            returnValue.removed = document;\n            returnValue.newDocument = null;\n            return returnValue;\n        }\n        else if (operation.op === '_get') {\n            operation.value = document;\n            return returnValue;\n        }\n        else { /* bad operation */\n            if (validateOperation) {\n                throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n            }\n            else {\n                return returnValue;\n            }\n        }\n    } /* END ROOT OPERATIONS */\n    else {\n        if (!mutateDocument) {\n            document = helpers_js_1._deepClone(document);\n        }\n        var path = operation.path || \"\";\n        var keys = path.split('/');\n        var obj = document;\n        var t = 1; //skip empty element - http://jsperf.com/to-shift-or-not-to-shift\n        var len = keys.length;\n        var existingPathFragment = undefined;\n        var key = void 0;\n        var validateFunction = void 0;\n        if (typeof validateOperation == 'function') {\n            validateFunction = validateOperation;\n        }\n        else {\n            validateFunction = validator;\n        }\n        while (true) {\n            key = keys[t];\n            if (key && key.indexOf('~') != -1) {\n                key = helpers_js_1.unescapePathComponent(key);\n            }\n            if (banPrototypeModifications &&\n                (key == '__proto__' ||\n                    (key == 'prototype' && t > 0 && keys[t - 1] == 'constructor'))) {\n                throw new TypeError('JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README');\n            }\n            if (validateOperation) {\n                if (existingPathFragment === undefined) {\n                    if (obj[key] === undefined) {\n                        existingPathFragment = keys.slice(0, t).join('/');\n                    }\n                    else if (t == len - 1) {\n                        existingPathFragment = operation.path;\n                    }\n                    if (existingPathFragment !== undefined) {\n                        validateFunction(operation, 0, document, existingPathFragment);\n                    }\n                }\n            }\n            t++;\n            if (Array.isArray(obj)) {\n                if (key === '-') {\n                    key = obj.length;\n                }\n                else {\n                    if (validateOperation && !helpers_js_1.isInteger(key)) {\n                        throw new exports.JsonPatchError(\"Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index\", \"OPERATION_PATH_ILLEGAL_ARRAY_INDEX\", index, operation, document);\n                    } // only parse key when it's an integer for `arr.prop` to work\n                    else if (helpers_js_1.isInteger(key)) {\n                        key = ~~key;\n                    }\n                }\n                if (t >= len) {\n                    if (validateOperation && operation.op === \"add\" && key > obj.length) {\n                        throw new exports.JsonPatchError(\"The specified index MUST NOT be greater than the number of elements in the array\", \"OPERATION_VALUE_OUT_OF_BOUNDS\", index, operation, document);\n                    }\n                    var returnValue = arrOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n            else {\n                if (t >= len) {\n                    var returnValue = objOps[operation.op].call(operation, obj, key, document); // Apply patch\n                    if (returnValue.test === false) {\n                        debugger;\n                        objOps[operation.op].call(operation, obj, key, document);\n                        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n                    }\n                    return returnValue;\n                }\n            }\n\n            if (obj[key] === undefined) { // TMP HACK SLD - TODO remove later when there's a better way to handle this\n                console.warn(\"fast json patch ran into missing patch path [\" + operation.path + \"] - inserting a dict to avoid crash\");\n                obj[key] = {}\n                debugger;\n            }\n            obj = obj[key];\n            \n            // If we have more keys in the path, but the next value isn't a non-null object,\n            // throw an OPERATION_PATH_UNRESOLVABLE error instead of iterating again.\n            if (validateOperation && t < len && (!obj || typeof obj !== \"object\")) {\n                throw new exports.JsonPatchError('Cannot perform operation at the desired path', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\nexports.applyOperation = applyOperation;\n/**\n * Apply a full JSON Patch array on a JSON document.\n * Returns the {newDocument, result} of the patch.\n * It modifies the `document` object and `patch` - it gets the values by reference.\n * If you would like to avoid touching your values, clone them:\n * `jsonpatch.applyPatch(document, jsonpatch._deepClone(patch))`.\n *\n * @param document The document to patch\n * @param patch The patch to apply\n * @param validateOperation `false` is without validation, `true` to use default jsonpatch's validation, or you can pass a `validateOperation` callback to be used for validation.\n * @param mutateDocument Whether to mutate the original document or clone it before applying\n * @param banPrototypeModifications Whether to ban modifications to `__proto__`, defaults to `true`.\n * @return An array of `{newDocument, result}` after the patch\n */\nfunction applyPatch(document, patch, validateOperation, mutateDocument, banPrototypeModifications) {\n    if (mutateDocument === void 0) { mutateDocument = true; }\n    if (banPrototypeModifications === void 0) { banPrototypeModifications = true; }\n    if (validateOperation) {\n        if (!Array.isArray(patch)) {\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n    }\n    if (!mutateDocument) {\n        document = helpers_js_1._deepClone(document);\n    }\n    var results = new Array(patch.length);\n    for (var i = 0, length_1 = patch.length; i < length_1; i++) {\n        // we don't need to pass mutateDocument argument because if it was true, we already deep cloned the object, we'll just pass `true`\n        results[i] = applyOperation(document, patch[i], validateOperation, true, banPrototypeModifications, i);\n        document = results[i].newDocument; // in case root was replaced\n    }\n    results.newDocument = document;\n    return results;\n}\nexports.applyPatch = applyPatch;\n/**\n * Apply a single JSON Patch Operation on a JSON document.\n * Returns the updated document.\n * Suitable as a reducer.\n *\n * @param document The document to patch\n * @param operation The operation to apply\n * @return The updated document\n */\nfunction applyReducer(document, operation, index) {\n    var operationResult = applyOperation(document, operation);\n    if (operationResult.test === false) { // failed test\n        throw new exports.JsonPatchError(\"Test operation failed\", 'TEST_OPERATION_FAILED', index, operation, document);\n    }\n    return operationResult.newDocument;\n}\nexports.applyReducer = applyReducer;\n/**\n * Validates a single operation. Called from `jsonpatch.validate`. Throws `JsonPatchError` in case of an error.\n * @param {object} operation - operation object (patch)\n * @param {number} index - index of operation in the sequence\n * @param {object} [document] - object where the operation is supposed to be applied\n * @param {string} [existingPathFragment] - comes along with `document`\n */\nfunction validator(operation, index, document, existingPathFragment) {\n    if (typeof operation !== 'object' || operation === null || Array.isArray(operation)) {\n        throw new exports.JsonPatchError('Operation is not an object', 'OPERATION_NOT_AN_OBJECT', index, operation, document);\n    }\n    else if (!objOps[operation.op]) {\n        throw new exports.JsonPatchError('Operation `op` property is not one of operations defined in RFC-6902', 'OPERATION_OP_INVALID', index, operation, document);\n    }\n    else if (typeof operation.path !== 'string') {\n        throw new exports.JsonPatchError('Operation `path` property is not a string', 'OPERATION_PATH_INVALID', index, operation, document);\n    }\n    else if (operation.path.indexOf('/') !== 0 && operation.path.length > 0) {\n        // paths that aren't empty string should start with \"/\"\n        throw new exports.JsonPatchError('Operation `path` property must start with \"/\"', 'OPERATION_PATH_INVALID', index, operation, document);\n    }\n    else if ((operation.op === 'move' || operation.op === 'copy') && typeof operation.from !== 'string') {\n        throw new exports.JsonPatchError('Operation `from` property is not present (applicable in `move` and `copy` operations)', 'OPERATION_FROM_REQUIRED', index, operation, document);\n    }\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && operation.value === undefined) {\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_REQUIRED', index, operation, document);\n    }\n    else if ((operation.op === 'add' || operation.op === 'replace' || operation.op === 'test') && helpers_js_1.hasUndefined(operation.value)) {\n        throw new exports.JsonPatchError('Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)', 'OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED', index, operation, document);\n    }\n    else if (document) {\n        if (operation.op == \"add\") {\n            var pathLen = operation.path.split(\"/\").length;\n            var existingPathLen = existingPathFragment.split(\"/\").length;\n            if (pathLen !== existingPathLen + 1 && pathLen !== existingPathLen) {\n                throw new exports.JsonPatchError('Cannot perform an `add` operation at the desired path', 'OPERATION_PATH_CANNOT_ADD', index, operation, document);\n            }\n        }\n        else if (operation.op === 'replace' || operation.op === 'remove' || operation.op === '_get') {\n            if (operation.path !== existingPathFragment) {\n                throw new exports.JsonPatchError('Cannot perform the operation at a path that does not exist', 'OPERATION_PATH_UNRESOLVABLE', index, operation, document);\n            }\n        }\n        else if (operation.op === 'move' || operation.op === 'copy') {\n            var existingValue = { op: \"_get\", path: operation.from, value: undefined };\n            var error = validate([existingValue], document);\n            if (error && error.name === 'OPERATION_PATH_UNRESOLVABLE') {\n                throw new exports.JsonPatchError('Cannot perform the operation from a path that does not exist', 'OPERATION_FROM_UNRESOLVABLE', index, operation, document);\n            }\n        }\n    }\n}\nexports.validator = validator;\n/**\n * Validates a sequence of operations. If `document` parameter is provided, the sequence is additionally validated against the object document.\n * If error is encountered, returns a JsonPatchError object\n * @param sequence\n * @param document\n * @returns {JsonPatchError|undefined}\n */\nfunction validate(sequence, document, externalValidator) {\n    try {\n        if (!Array.isArray(sequence)) {\n            throw new exports.JsonPatchError('Patch sequence must be an array', 'SEQUENCE_NOT_AN_ARRAY');\n        }\n        if (document) {\n            //clone document and sequence so that we can safely try applying operations\n            applyPatch(helpers_js_1._deepClone(document), helpers_js_1._deepClone(sequence), externalValidator || true);\n        }\n        else {\n            externalValidator = externalValidator || validator;\n            for (var i = 0; i < sequence.length; i++) {\n                externalValidator(sequence[i], i, document, undefined);\n            }\n        }\n    }\n    catch (e) {\n        if (e instanceof exports.JsonPatchError) {\n            return e;\n        }\n        else {\n            throw e;\n        }\n    }\n}\nexports.validate = validate;\n// based on https://github.com/epoberezkin/fast-deep-equal\n// MIT License\n// Copyright (c) 2017 Evgeny Poberezkin\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nfunction _areEquals(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a == 'object' && typeof b == 'object') {\n        var arrA = Array.isArray(a), arrB = Array.isArray(b), i, length, key;\n        if (arrA && arrB) {\n            length = a.length;\n            if (length != b.length)\n                return false;\n            for (i = length; i-- !== 0;)\n                if (!_areEquals(a[i], b[i]))\n                    return false;\n            return true;\n        }\n        if (arrA != arrB)\n            return false;\n        var keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length)\n            return false;\n        for (i = length; i-- !== 0;)\n            if (!b.hasOwnProperty(keys[i]))\n                return false;\n        for (i = length; i-- !== 0;) {\n            key = keys[i];\n            if (!_areEquals(a[key], b[key]))\n                return false;\n        }\n        return true;\n    }\n    return a !== a && b !== b;\n}\nexports._areEquals = _areEquals;\n;\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar core = __webpack_require__(1);\nObject.assign(exports, core);\n\nvar duplex = __webpack_require__(3);\nObject.assign(exports, duplex);\n\nvar helpers = __webpack_require__(0);\nexports.JsonPatchError = helpers.PatchError;\nexports.deepClone = helpers._deepClone;\nexports.escapePathComponent = helpers.escapePathComponent;\nexports.unescapePathComponent = helpers.unescapePathComponent;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*!\n * https://github.com/Starcounter-Jack/JSON-Patch\n * (c) 2017-2021 Joachim Wester\n * MIT license\n */\nvar helpers_js_1 = __webpack_require__(0);\nvar core_js_1 = __webpack_require__(1);\nvar beforeDict = new WeakMap();\nvar Mirror = /** @class */ (function () {\n    function Mirror(obj) {\n        this.observers = new Map();\n        this.obj = obj;\n    }\n    return Mirror;\n}());\nvar ObserverInfo = /** @class */ (function () {\n    function ObserverInfo(callback, observer) {\n        this.callback = callback;\n        this.observer = observer;\n    }\n    return ObserverInfo;\n}());\nfunction getMirror(obj) {\n    return beforeDict.get(obj);\n}\nfunction getObserverFromMirror(mirror, callback) {\n    return mirror.observers.get(callback);\n}\nfunction removeObserverFromMirror(mirror, observer) {\n    mirror.observers.delete(observer.callback);\n}\n/**\n * Detach an observer from an object\n */\nfunction unobserve(root, observer) {\n    observer.unobserve();\n}\nexports.unobserve = unobserve;\n/**\n * Observes changes made to an object, which can then be retrieved using generate\n */\nfunction observe(obj, callback) {\n    var patches = [];\n    var observer;\n    var mirror = getMirror(obj);\n    if (!mirror) {\n        mirror = new Mirror(obj);\n        beforeDict.set(obj, mirror);\n    }\n    else {\n        var observerInfo = getObserverFromMirror(mirror, callback);\n        observer = observerInfo && observerInfo.observer;\n    }\n    if (observer) {\n        return observer;\n    }\n    observer = {};\n    mirror.value = helpers_js_1._deepClone(obj);\n    if (callback) {\n        observer.callback = callback;\n        observer.next = null;\n        var dirtyCheck = function () {\n            generate(observer);\n        };\n        var fastCheck = function () {\n            clearTimeout(observer.next);\n            observer.next = setTimeout(dirtyCheck);\n        };\n        if (typeof window !== 'undefined') { //not Node\n            window.addEventListener('mouseup', fastCheck);\n            window.addEventListener('keyup', fastCheck);\n            window.addEventListener('mousedown', fastCheck);\n            window.addEventListener('keydown', fastCheck);\n            window.addEventListener('change', fastCheck);\n        }\n    }\n    observer.patches = patches;\n    observer.object = obj;\n    observer.unobserve = function () {\n        generate(observer);\n        clearTimeout(observer.next);\n        removeObserverFromMirror(mirror, observer);\n        if (typeof window !== 'undefined') {\n            window.removeEventListener('mouseup', fastCheck);\n            window.removeEventListener('keyup', fastCheck);\n            window.removeEventListener('mousedown', fastCheck);\n            window.removeEventListener('keydown', fastCheck);\n            window.removeEventListener('change', fastCheck);\n        }\n    };\n    mirror.observers.set(callback, new ObserverInfo(callback, observer));\n    return observer;\n}\nexports.observe = observe;\n/**\n * Generate an array of patches from an observer\n */\nfunction generate(observer, invertible) {\n    if (invertible === void 0) { invertible = false; }\n    var mirror = beforeDict.get(observer.object);\n    _generate(mirror.value, observer.object, observer.patches, \"\", invertible);\n    if (observer.patches.length) {\n        core_js_1.applyPatch(mirror.value, observer.patches);\n    }\n    var temp = observer.patches;\n    if (temp.length > 0) {\n        observer.patches = [];\n        if (observer.callback) {\n            observer.callback(temp);\n        }\n    }\n    return temp;\n}\nexports.generate = generate;\n// Dirty check if obj is different from mirror, generate patches and update mirror\nfunction _generate(mirror, obj, patches, path, invertible) {\n    if (obj === mirror) {\n        return;\n    }\n    if (typeof obj.toJSON === \"function\") {\n        obj = obj.toJSON();\n    }\n    var newKeys = helpers_js_1._objectKeys(obj);\n    var oldKeys = helpers_js_1._objectKeys(mirror);\n    var changed = false;\n    var deleted = false;\n    //if ever \"move\" operation is implemented here, make sure this test runs OK: \"should not generate the same patch twice (move)\"\n    for (var t = oldKeys.length - 1; t >= 0; t--) {\n        var key = oldKeys[t];\n        var oldVal = mirror[key];\n        if (helpers_js_1.hasOwnProperty(obj, key) && !(obj[key] === undefined && oldVal !== undefined && Array.isArray(obj) === false)) {\n            var newVal = obj[key];\n            if (typeof oldVal == \"object\" && oldVal != null && typeof newVal == \"object\" && newVal != null && Array.isArray(oldVal) === Array.isArray(newVal)) {\n                _generate(oldVal, newVal, patches, path + \"/\" + helpers_js_1.escapePathComponent(key), invertible);\n            }\n            else {\n                if (oldVal !== newVal) {\n                    changed = true;\n                    if (invertible) {\n                        patches.push({ op: \"test\", path: path + \"/\" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(oldVal) });\n                    }\n                    patches.push({ op: \"replace\", path: path + \"/\" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(newVal) });\n                }\n            }\n        }\n        else if (Array.isArray(mirror) === Array.isArray(obj)) {\n            if (invertible) {\n                patches.push({ op: \"test\", path: path + \"/\" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(oldVal) });\n            }\n            patches.push({ op: \"remove\", path: path + \"/\" + helpers_js_1.escapePathComponent(key) });\n            deleted = true; // property has been deleted\n        }\n        else {\n            if (invertible) {\n                patches.push({ op: \"test\", path: path, value: mirror });\n            }\n            patches.push({ op: \"replace\", path: path, value: obj });\n            changed = true;\n        }\n    }\n    if (!deleted && newKeys.length == oldKeys.length) {\n        return;\n    }\n    for (var t = 0; t < newKeys.length; t++) {\n        var key = newKeys[t];\n        if (!helpers_js_1.hasOwnProperty(mirror, key) && obj[key] !== undefined) {\n            patches.push({ op: \"add\", path: path + \"/\" + helpers_js_1.escapePathComponent(key), value: helpers_js_1._deepClone(obj[key]) });\n        }\n    }\n}\n/**\n * Create an array of patches from the differences in two objects\n */\nfunction compare(tree1, tree2, invertible) {\n    if (invertible === void 0) { invertible = false; }\n    var patches = [];\n    _generate(tree1, tree2, patches, '', invertible);\n    return patches;\n}\nexports.compare = compare;\n\n\n/***/ })\n/******/ ]);\n\ngetGlobalThis().JsonPatch = jsonpatch; // NOTE: added by SLD to make globally avaialble\n\n\nJsonPatch.pathExists = function (obj, path) {\n    const properties = path.split('/').slice(1); // Removing the leading slash\n    let currentObj = obj;\n\n    for (let i = 0; i < properties.length; i++) {\n      const prop = properties[i];\n  \n      if (currentObj.hasOwnProperty(prop)) {\n        currentObj = currentObj[prop];\n      } else {\n        debugger;\n        return false;\n      }\n    }\n  \n    return true;\n  }\n\nJsonPatch.ensurePathExists = function (jsonObject, path) {\n    // Going to disable this and assume the AI can correctly use JSON patches now\n    // Below is the original code \n\n    // ---------------------\n    // we want to ensure that the path exists in the jsonObject\n    // and have to make sure that we create the right type of object (array or dict) at each step\n    // to determine the type of object to create, we need to look at the next segment of the path\n    // if the next segment is a number, we (guess that we) need to create an array, otherwise we create a dictionary\n    // if the path already exists, we don't need to do anything\n\n    let didCreatePath = false;\n\n    let currentObject = jsonObject;\n    const pathSegments = path.split('/').slice(1); // Removing the leading slash\n\n    for (let i = 0; i < pathSegments.length; i++) {\n        let segment = pathSegments[i];\n        if (Type.isNumber(segment)) {\n            segnment = Number(segnment);\n        }\n        if (Type.isUndefined(currentObject[segment])) {\n            const currentPath = pathSegments.slice(0, i + 1).join('/'); // doesn't include i+1 index\n            const nextSegment = i+1 < pathSegments.length ? pathSegments[i + 1] : undefined;\n            const nextSegmentIsNumber = Type.isNumber(nextSegment);\n            const nextObject = nextSegmentIsNumber ? [] : {}; // this is a guess and doesn't always work\n\n            console.log(\"JsonPatch.ensurePathExists() Creating missing path: [\" + currentPath + \"]\");\n            currentObject[segment] = nextObject;\n            didCreatePath = true;\n        }\n        currentObject = currentObject[segment];\n    }\n\n    assert(JsonPatch.pathExists(jsonObject, path));\n    if (didCreatePath) {\n        //console.log(\"verified created path: \" + path);\n    }\n\n    return didCreatePath;\n}\n\nJsonPatch.applyPatchWithAutoCreation = function (jsonObject, patch) {\n    for (const operation of patch) {\n        JsonPatch.ensurePathExists(jsonObject, operation.path);\n    }\n    return JsonPatch.applyPatch(jsonObject, patch);\n}",
  "ym5WfnAc0hk4Z2+FXO3pB6RY4q9b2L0tIsCtttD1JG4=": "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\ngetGlobalThis().htmlparser2 = require(\"htmlparser2\");\n\n},{\"htmlparser2\":25}],2:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attributeNames = exports.elementNames = void 0;\nexports.elementNames = new Map([\n    \"altGlyph\",\n    \"altGlyphDef\",\n    \"altGlyphItem\",\n    \"animateColor\",\n    \"animateMotion\",\n    \"animateTransform\",\n    \"clipPath\",\n    \"feBlend\",\n    \"feColorMatrix\",\n    \"feComponentTransfer\",\n    \"feComposite\",\n    \"feConvolveMatrix\",\n    \"feDiffuseLighting\",\n    \"feDisplacementMap\",\n    \"feDistantLight\",\n    \"feDropShadow\",\n    \"feFlood\",\n    \"feFuncA\",\n    \"feFuncB\",\n    \"feFuncG\",\n    \"feFuncR\",\n    \"feGaussianBlur\",\n    \"feImage\",\n    \"feMerge\",\n    \"feMergeNode\",\n    \"feMorphology\",\n    \"feOffset\",\n    \"fePointLight\",\n    \"feSpecularLighting\",\n    \"feSpotLight\",\n    \"feTile\",\n    \"feTurbulence\",\n    \"foreignObject\",\n    \"glyphRef\",\n    \"linearGradient\",\n    \"radialGradient\",\n    \"textPath\",\n].map(function (val) { return [val.toLowerCase(), val]; }));\nexports.attributeNames = new Map([\n    \"definitionURL\",\n    \"attributeName\",\n    \"attributeType\",\n    \"baseFrequency\",\n    \"baseProfile\",\n    \"calcMode\",\n    \"clipPathUnits\",\n    \"diffuseConstant\",\n    \"edgeMode\",\n    \"filterUnits\",\n    \"glyphRef\",\n    \"gradientTransform\",\n    \"gradientUnits\",\n    \"kernelMatrix\",\n    \"kernelUnitLength\",\n    \"keyPoints\",\n    \"keySplines\",\n    \"keyTimes\",\n    \"lengthAdjust\",\n    \"limitingConeAngle\",\n    \"markerHeight\",\n    \"markerUnits\",\n    \"markerWidth\",\n    \"maskContentUnits\",\n    \"maskUnits\",\n    \"numOctaves\",\n    \"pathLength\",\n    \"patternContentUnits\",\n    \"patternTransform\",\n    \"patternUnits\",\n    \"pointsAtX\",\n    \"pointsAtY\",\n    \"pointsAtZ\",\n    \"preserveAlpha\",\n    \"preserveAspectRatio\",\n    \"primitiveUnits\",\n    \"refX\",\n    \"refY\",\n    \"repeatCount\",\n    \"repeatDur\",\n    \"requiredExtensions\",\n    \"requiredFeatures\",\n    \"specularConstant\",\n    \"specularExponent\",\n    \"spreadMethod\",\n    \"startOffset\",\n    \"stdDeviation\",\n    \"stitchTiles\",\n    \"surfaceScale\",\n    \"systemLanguage\",\n    \"tableValues\",\n    \"targetX\",\n    \"targetY\",\n    \"textLength\",\n    \"viewBox\",\n    \"viewTarget\",\n    \"xChannelSelector\",\n    \"yChannelSelector\",\n    \"zoomAndPan\",\n].map(function (val) { return [val.toLowerCase(), val]; }));\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.render = void 0;\n/*\n * Module dependencies\n */\nvar ElementType = __importStar(require(\"domelementtype\"));\nvar entities_1 = require(\"entities\");\n/**\n * Mixed-case SVG and MathML tags & attributes\n * recognized by the HTML parser.\n *\n * @see https://html.spec.whatwg.org/multipage/parsing.html#parsing-main-inforeign\n */\nvar foreignNames_js_1 = require(\"./foreignNames.js\");\nvar unencodedElements = new Set([\n    \"style\",\n    \"script\",\n    \"xmp\",\n    \"iframe\",\n    \"noembed\",\n    \"noframes\",\n    \"plaintext\",\n    \"noscript\",\n]);\nfunction replaceQuotes(value) {\n    return value.replace(/\"/g, \"&quot;\");\n}\n/**\n * Format attributes\n */\nfunction formatAttributes(attributes, opts) {\n    var _a;\n    if (!attributes)\n        return;\n    var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false\n        ? replaceQuotes\n        : opts.xmlMode || opts.encodeEntities !== \"utf8\"\n            ? entities_1.encodeXML\n            : entities_1.escapeAttribute;\n    return Object.keys(attributes)\n        .map(function (key) {\n        var _a, _b;\n        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : \"\";\n        if (opts.xmlMode === \"foreign\") {\n            /* Fix up mixed-case attribute names */\n            key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;\n        }\n        if (!opts.emptyAttrs && !opts.xmlMode && value === \"\") {\n            return key;\n        }\n        return \"\".concat(key, \"=\\\"\").concat(encode(value), \"\\\"\");\n    })\n        .join(\" \");\n}\n/**\n * Self-enclosing tags\n */\nvar singleTag = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\n/**\n * Renders a DOM node or an array of DOM nodes to a string.\n *\n * Can be thought of as the equivalent of the `outerHTML` of the passed node(s).\n *\n * @param node Node to be rendered.\n * @param options Changes serialization behavior\n */\nfunction render(node, options) {\n    if (options === void 0) { options = {}; }\n    var nodes = \"length\" in node ? node : [node];\n    var output = \"\";\n    for (var i = 0; i < nodes.length; i++) {\n        output += renderNode(nodes[i], options);\n    }\n    return output;\n}\nexports.render = render;\nexports.default = render;\nfunction renderNode(node, options) {\n    switch (node.type) {\n        case ElementType.Root:\n            return render(node.children, options);\n        // @ts-expect-error We don't use `Doctype` yet\n        case ElementType.Doctype:\n        case ElementType.Directive:\n            return renderDirective(node);\n        case ElementType.Comment:\n            return renderComment(node);\n        case ElementType.CDATA:\n            return renderCdata(node);\n        case ElementType.Script:\n        case ElementType.Style:\n        case ElementType.Tag:\n            return renderTag(node, options);\n        case ElementType.Text:\n            return renderText(node, options);\n    }\n}\nvar foreignModeIntegrationPoints = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignObject\",\n    \"desc\",\n    \"title\",\n]);\nvar foreignElements = new Set([\"svg\", \"math\"]);\nfunction renderTag(elem, opts) {\n    var _a;\n    // Handle SVG / MathML in HTML\n    if (opts.xmlMode === \"foreign\") {\n        /* Fix up mixed-case element names */\n        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;\n        /* Exit foreign mode at integration points */\n        if (elem.parent &&\n            foreignModeIntegrationPoints.has(elem.parent.name)) {\n            opts = __assign(__assign({}, opts), { xmlMode: false });\n        }\n    }\n    if (!opts.xmlMode && foreignElements.has(elem.name)) {\n        opts = __assign(__assign({}, opts), { xmlMode: \"foreign\" });\n    }\n    var tag = \"<\".concat(elem.name);\n    var attribs = formatAttributes(elem.attribs, opts);\n    if (attribs) {\n        tag += \" \".concat(attribs);\n    }\n    if (elem.children.length === 0 &&\n        (opts.xmlMode\n            ? // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags\n                opts.selfClosingTags !== false\n            : // User explicitly asked for self-closing tags, even in HTML mode\n                opts.selfClosingTags && singleTag.has(elem.name))) {\n        if (!opts.xmlMode)\n            tag += \" \";\n        tag += \"/>\";\n    }\n    else {\n        tag += \">\";\n        if (elem.children.length > 0) {\n            tag += render(elem.children, opts);\n        }\n        if (opts.xmlMode || !singleTag.has(elem.name)) {\n            tag += \"</\".concat(elem.name, \">\");\n        }\n    }\n    return tag;\n}\nfunction renderDirective(elem) {\n    return \"<\".concat(elem.data, \">\");\n}\nfunction renderText(elem, opts) {\n    var _a;\n    var data = elem.data || \"\";\n    // If entities weren't decoded, no need to encode them back\n    if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false &&\n        !(!opts.xmlMode &&\n            elem.parent &&\n            unencodedElements.has(elem.parent.name))) {\n        data =\n            opts.xmlMode || opts.encodeEntities !== \"utf8\"\n                ? (0, entities_1.encodeXML)(data)\n                : (0, entities_1.escapeText)(data);\n    }\n    return data;\n}\nfunction renderCdata(elem) {\n    return \"<![CDATA[\".concat(elem.children[0].data, \"]]>\");\n}\nfunction renderComment(elem) {\n    return \"<!--\".concat(elem.data, \"-->\");\n}\n\n},{\"./foreignNames.js\":2,\"domelementtype\":4,\"entities\":22}],4:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Doctype = exports.CDATA = exports.Tag = exports.Style = exports.Script = exports.Comment = exports.Directive = exports.Text = exports.Root = exports.isTag = exports.ElementType = void 0;\n/** Types of elements found in htmlparser2's DOM */\nvar ElementType;\n(function (ElementType) {\n    /** Type for the root element of a document */\n    ElementType[\"Root\"] = \"root\";\n    /** Type for Text */\n    ElementType[\"Text\"] = \"text\";\n    /** Type for <? ... ?> */\n    ElementType[\"Directive\"] = \"directive\";\n    /** Type for <!-- ... --> */\n    ElementType[\"Comment\"] = \"comment\";\n    /** Type for <script> tags */\n    ElementType[\"Script\"] = \"script\";\n    /** Type for <style> tags */\n    ElementType[\"Style\"] = \"style\";\n    /** Type for Any tag */\n    ElementType[\"Tag\"] = \"tag\";\n    /** Type for <![CDATA[ ... ]]> */\n    ElementType[\"CDATA\"] = \"cdata\";\n    /** Type for <!doctype ...> */\n    ElementType[\"Doctype\"] = \"doctype\";\n})(ElementType = exports.ElementType || (exports.ElementType = {}));\n/**\n * Tests whether an element is a tag or not.\n *\n * @param elem Element to test\n */\nfunction isTag(elem) {\n    return (elem.type === ElementType.Tag ||\n        elem.type === ElementType.Script ||\n        elem.type === ElementType.Style);\n}\nexports.isTag = isTag;\n// Exports for backwards compatibility\n/** Type for the root element of a document */\nexports.Root = ElementType.Root;\n/** Type for Text */\nexports.Text = ElementType.Text;\n/** Type for <? ... ?> */\nexports.Directive = ElementType.Directive;\n/** Type for <!-- ... --> */\nexports.Comment = ElementType.Comment;\n/** Type for <script> tags */\nexports.Script = ElementType.Script;\n/** Type for <style> tags */\nexports.Style = ElementType.Style;\n/** Type for Any tag */\nexports.Tag = ElementType.Tag;\n/** Type for <![CDATA[ ... ]]> */\nexports.CDATA = ElementType.CDATA;\n/** Type for <!doctype ...> */\nexports.Doctype = ElementType.Doctype;\n\n},{}],5:[function(require,module,exports){\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DomHandler = void 0;\nvar domelementtype_1 = require(\"domelementtype\");\nvar node_js_1 = require(\"./node.js\");\n__exportStar(require(\"./node.js\"), exports);\n// Default options\nvar defaultOpts = {\n    withStartIndices: false,\n    withEndIndices: false,\n    xmlMode: false,\n};\nvar DomHandler = /** @class */ (function () {\n    /**\n     * @param callback Called once parsing has completed.\n     * @param options Settings for the handler.\n     * @param elementCB Callback whenever a tag is closed.\n     */\n    function DomHandler(callback, options, elementCB) {\n        /** The elements of the DOM */\n        this.dom = [];\n        /** The root element for the DOM */\n        this.root = new node_js_1.Document(this.dom);\n        /** Indicated whether parsing has been completed. */\n        this.done = false;\n        /** Stack of open tags. */\n        this.tagStack = [this.root];\n        /** A data node that is still being written to. */\n        this.lastNode = null;\n        /** Reference to the parser instance. Used for location information. */\n        this.parser = null;\n        // Make it possible to skip arguments, for backwards-compatibility\n        if (typeof options === \"function\") {\n            elementCB = options;\n            options = defaultOpts;\n        }\n        if (typeof callback === \"object\") {\n            options = callback;\n            callback = undefined;\n        }\n        this.callback = callback !== null && callback !== void 0 ? callback : null;\n        this.options = options !== null && options !== void 0 ? options : defaultOpts;\n        this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;\n    }\n    DomHandler.prototype.onparserinit = function (parser) {\n        this.parser = parser;\n    };\n    // Resets the handler back to starting state\n    DomHandler.prototype.onreset = function () {\n        this.dom = [];\n        this.root = new node_js_1.Document(this.dom);\n        this.done = false;\n        this.tagStack = [this.root];\n        this.lastNode = null;\n        this.parser = null;\n    };\n    // Signals the handler that parsing is done\n    DomHandler.prototype.onend = function () {\n        if (this.done)\n            return;\n        this.done = true;\n        this.parser = null;\n        this.handleCallback(null);\n    };\n    DomHandler.prototype.onerror = function (error) {\n        this.handleCallback(error);\n    };\n    DomHandler.prototype.onclosetag = function () {\n        this.lastNode = null;\n        var elem = this.tagStack.pop();\n        if (this.options.withEndIndices) {\n            elem.endIndex = this.parser.endIndex;\n        }\n        if (this.elementCB)\n            this.elementCB(elem);\n    };\n    DomHandler.prototype.onopentag = function (name, attribs) {\n        var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : undefined;\n        var element = new node_js_1.Element(name, attribs, undefined, type);\n        this.addNode(element);\n        this.tagStack.push(element);\n    };\n    DomHandler.prototype.ontext = function (data) {\n        var lastNode = this.lastNode;\n        if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {\n            lastNode.data += data;\n            if (this.options.withEndIndices) {\n                lastNode.endIndex = this.parser.endIndex;\n            }\n        }\n        else {\n            var node = new node_js_1.Text(data);\n            this.addNode(node);\n            this.lastNode = node;\n        }\n    };\n    DomHandler.prototype.oncomment = function (data) {\n        if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {\n            this.lastNode.data += data;\n            return;\n        }\n        var node = new node_js_1.Comment(data);\n        this.addNode(node);\n        this.lastNode = node;\n    };\n    DomHandler.prototype.oncommentend = function () {\n        this.lastNode = null;\n    };\n    DomHandler.prototype.oncdatastart = function () {\n        var text = new node_js_1.Text(\"\");\n        var node = new node_js_1.CDATA([text]);\n        this.addNode(node);\n        text.parent = node;\n        this.lastNode = text;\n    };\n    DomHandler.prototype.oncdataend = function () {\n        this.lastNode = null;\n    };\n    DomHandler.prototype.onprocessinginstruction = function (name, data) {\n        var node = new node_js_1.ProcessingInstruction(name, data);\n        this.addNode(node);\n    };\n    DomHandler.prototype.handleCallback = function (error) {\n        if (typeof this.callback === \"function\") {\n            this.callback(error, this.dom);\n        }\n        else if (error) {\n            throw error;\n        }\n    };\n    DomHandler.prototype.addNode = function (node) {\n        var parent = this.tagStack[this.tagStack.length - 1];\n        var previousSibling = parent.children[parent.children.length - 1];\n        if (this.options.withStartIndices) {\n            node.startIndex = this.parser.startIndex;\n        }\n        if (this.options.withEndIndices) {\n            node.endIndex = this.parser.endIndex;\n        }\n        parent.children.push(node);\n        if (previousSibling) {\n            node.prev = previousSibling;\n            previousSibling.next = node;\n        }\n        node.parent = parent;\n        this.lastNode = null;\n    };\n    return DomHandler;\n}());\nexports.DomHandler = DomHandler;\nexports.default = DomHandler;\n\n},{\"./node.js\":6,\"domelementtype\":4}],6:[function(require,module,exports){\n\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.cloneNode = exports.hasChildren = exports.isDocument = exports.isDirective = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = exports.Element = exports.Document = exports.CDATA = exports.NodeWithChildren = exports.ProcessingInstruction = exports.Comment = exports.Text = exports.DataNode = exports.Node = void 0;\nvar domelementtype_1 = require(\"domelementtype\");\n/**\n * This object will be used as the prototype for Nodes when creating a\n * DOM-Level-1-compliant structure.\n */\nvar Node = /** @class */ (function () {\n    function Node() {\n        /** Parent of the node */\n        this.parent = null;\n        /** Previous sibling */\n        this.prev = null;\n        /** Next sibling */\n        this.next = null;\n        /** The start index of the node. Requires `withStartIndices` on the handler to be `true. */\n        this.startIndex = null;\n        /** The end index of the node. Requires `withEndIndices` on the handler to be `true. */\n        this.endIndex = null;\n    }\n    Object.defineProperty(Node.prototype, \"parentNode\", {\n        // Read-write aliases for properties\n        /**\n         * Same as {@link parent}.\n         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n         */\n        get: function () {\n            return this.parent;\n        },\n        set: function (parent) {\n            this.parent = parent;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"previousSibling\", {\n        /**\n         * Same as {@link prev}.\n         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n         */\n        get: function () {\n            return this.prev;\n        },\n        set: function (prev) {\n            this.prev = prev;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Node.prototype, \"nextSibling\", {\n        /**\n         * Same as {@link next}.\n         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n         */\n        get: function () {\n            return this.next;\n        },\n        set: function (next) {\n            this.next = next;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Clone this node, and optionally its children.\n     *\n     * @param recursive Clone child nodes as well.\n     * @returns A clone of the node.\n     */\n    Node.prototype.cloneNode = function (recursive) {\n        if (recursive === void 0) { recursive = false; }\n        return cloneNode(this, recursive);\n    };\n    return Node;\n}());\nexports.Node = Node;\n/**\n * A node that contains some data.\n */\nvar DataNode = /** @class */ (function (_super) {\n    __extends(DataNode, _super);\n    /**\n     * @param data The content of the data node\n     */\n    function DataNode(data) {\n        var _this = _super.call(this) || this;\n        _this.data = data;\n        return _this;\n    }\n    Object.defineProperty(DataNode.prototype, \"nodeValue\", {\n        /**\n         * Same as {@link data}.\n         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n         */\n        get: function () {\n            return this.data;\n        },\n        set: function (data) {\n            this.data = data;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return DataNode;\n}(Node));\nexports.DataNode = DataNode;\n/**\n * Text within the document.\n */\nvar Text = /** @class */ (function (_super) {\n    __extends(Text, _super);\n    function Text() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = domelementtype_1.ElementType.Text;\n        return _this;\n    }\n    Object.defineProperty(Text.prototype, \"nodeType\", {\n        get: function () {\n            return 3;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Text;\n}(DataNode));\nexports.Text = Text;\n/**\n * Comments within the document.\n */\nvar Comment = /** @class */ (function (_super) {\n    __extends(Comment, _super);\n    function Comment() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = domelementtype_1.ElementType.Comment;\n        return _this;\n    }\n    Object.defineProperty(Comment.prototype, \"nodeType\", {\n        get: function () {\n            return 8;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Comment;\n}(DataNode));\nexports.Comment = Comment;\n/**\n * Processing instructions, including doc types.\n */\nvar ProcessingInstruction = /** @class */ (function (_super) {\n    __extends(ProcessingInstruction, _super);\n    function ProcessingInstruction(name, data) {\n        var _this = _super.call(this, data) || this;\n        _this.name = name;\n        _this.type = domelementtype_1.ElementType.Directive;\n        return _this;\n    }\n    Object.defineProperty(ProcessingInstruction.prototype, \"nodeType\", {\n        get: function () {\n            return 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return ProcessingInstruction;\n}(DataNode));\nexports.ProcessingInstruction = ProcessingInstruction;\n/**\n * A `Node` that can have children.\n */\nvar NodeWithChildren = /** @class */ (function (_super) {\n    __extends(NodeWithChildren, _super);\n    /**\n     * @param children Children of the node. Only certain node types can have children.\n     */\n    function NodeWithChildren(children) {\n        var _this = _super.call(this) || this;\n        _this.children = children;\n        return _this;\n    }\n    Object.defineProperty(NodeWithChildren.prototype, \"firstChild\", {\n        // Aliases\n        /** First child of the node. */\n        get: function () {\n            var _a;\n            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NodeWithChildren.prototype, \"lastChild\", {\n        /** Last child of the node. */\n        get: function () {\n            return this.children.length > 0\n                ? this.children[this.children.length - 1]\n                : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(NodeWithChildren.prototype, \"childNodes\", {\n        /**\n         * Same as {@link children}.\n         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n         */\n        get: function () {\n            return this.children;\n        },\n        set: function (children) {\n            this.children = children;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return NodeWithChildren;\n}(Node));\nexports.NodeWithChildren = NodeWithChildren;\nvar CDATA = /** @class */ (function (_super) {\n    __extends(CDATA, _super);\n    function CDATA() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = domelementtype_1.ElementType.CDATA;\n        return _this;\n    }\n    Object.defineProperty(CDATA.prototype, \"nodeType\", {\n        get: function () {\n            return 4;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return CDATA;\n}(NodeWithChildren));\nexports.CDATA = CDATA;\n/**\n * The root node of the document.\n */\nvar Document = /** @class */ (function (_super) {\n    __extends(Document, _super);\n    function Document() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.type = domelementtype_1.ElementType.Root;\n        return _this;\n    }\n    Object.defineProperty(Document.prototype, \"nodeType\", {\n        get: function () {\n            return 9;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Document;\n}(NodeWithChildren));\nexports.Document = Document;\n/**\n * An element within the DOM.\n */\nvar Element = /** @class */ (function (_super) {\n    __extends(Element, _super);\n    /**\n     * @param name Name of the tag, eg. `div`, `span`.\n     * @param attribs Object mapping attribute names to attribute values.\n     * @param children Children of the node.\n     */\n    function Element(name, attribs, children, type) {\n        if (children === void 0) { children = []; }\n        if (type === void 0) { type = name === \"script\"\n            ? domelementtype_1.ElementType.Script\n            : name === \"style\"\n                ? domelementtype_1.ElementType.Style\n                : domelementtype_1.ElementType.Tag; }\n        var _this = _super.call(this, children) || this;\n        _this.name = name;\n        _this.attribs = attribs;\n        _this.type = type;\n        return _this;\n    }\n    Object.defineProperty(Element.prototype, \"nodeType\", {\n        get: function () {\n            return 1;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"tagName\", {\n        // DOM Level 1 aliases\n        /**\n         * Same as {@link name}.\n         * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.\n         */\n        get: function () {\n            return this.name;\n        },\n        set: function (name) {\n            this.name = name;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Element.prototype, \"attributes\", {\n        get: function () {\n            var _this = this;\n            return Object.keys(this.attribs).map(function (name) {\n                var _a, _b;\n                return ({\n                    name: name,\n                    value: _this.attribs[name],\n                    namespace: (_a = _this[\"x-attribsNamespace\"]) === null || _a === void 0 ? void 0 : _a[name],\n                    prefix: (_b = _this[\"x-attribsPrefix\"]) === null || _b === void 0 ? void 0 : _b[name],\n                });\n            });\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Element;\n}(NodeWithChildren));\nexports.Element = Element;\n/**\n * @param node Node to check.\n * @returns `true` if the node is a `Element`, `false` otherwise.\n */\nfunction isTag(node) {\n    return (0, domelementtype_1.isTag)(node);\n}\nexports.isTag = isTag;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `CDATA`, `false` otherwise.\n */\nfunction isCDATA(node) {\n    return node.type === domelementtype_1.ElementType.CDATA;\n}\nexports.isCDATA = isCDATA;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Text`, `false` otherwise.\n */\nfunction isText(node) {\n    return node.type === domelementtype_1.ElementType.Text;\n}\nexports.isText = isText;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `Comment`, `false` otherwise.\n */\nfunction isComment(node) {\n    return node.type === domelementtype_1.ElementType.Comment;\n}\nexports.isComment = isComment;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nfunction isDirective(node) {\n    return node.type === domelementtype_1.ElementType.Directive;\n}\nexports.isDirective = isDirective;\n/**\n * @param node Node to check.\n * @returns `true` if the node has the type `ProcessingInstruction`, `false` otherwise.\n */\nfunction isDocument(node) {\n    return node.type === domelementtype_1.ElementType.Root;\n}\nexports.isDocument = isDocument;\n/**\n * @param node Node to check.\n * @returns `true` if the node has children, `false` otherwise.\n */\nfunction hasChildren(node) {\n    return Object.prototype.hasOwnProperty.call(node, \"children\");\n}\nexports.hasChildren = hasChildren;\n/**\n * Clone a node, and optionally its children.\n *\n * @param recursive Clone child nodes as well.\n * @returns A clone of the node.\n */\nfunction cloneNode(node, recursive) {\n    if (recursive === void 0) { recursive = false; }\n    var result;\n    if (isText(node)) {\n        result = new Text(node.data);\n    }\n    else if (isComment(node)) {\n        result = new Comment(node.data);\n    }\n    else if (isTag(node)) {\n        var children = recursive ? cloneChildren(node.children) : [];\n        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);\n        children.forEach(function (child) { return (child.parent = clone_1); });\n        if (node.namespace != null) {\n            clone_1.namespace = node.namespace;\n        }\n        if (node[\"x-attribsNamespace\"]) {\n            clone_1[\"x-attribsNamespace\"] = __assign({}, node[\"x-attribsNamespace\"]);\n        }\n        if (node[\"x-attribsPrefix\"]) {\n            clone_1[\"x-attribsPrefix\"] = __assign({}, node[\"x-attribsPrefix\"]);\n        }\n        result = clone_1;\n    }\n    else if (isCDATA(node)) {\n        var children = recursive ? cloneChildren(node.children) : [];\n        var clone_2 = new CDATA(children);\n        children.forEach(function (child) { return (child.parent = clone_2); });\n        result = clone_2;\n    }\n    else if (isDocument(node)) {\n        var children = recursive ? cloneChildren(node.children) : [];\n        var clone_3 = new Document(children);\n        children.forEach(function (child) { return (child.parent = clone_3); });\n        if (node[\"x-mode\"]) {\n            clone_3[\"x-mode\"] = node[\"x-mode\"];\n        }\n        result = clone_3;\n    }\n    else if (isDirective(node)) {\n        var instruction = new ProcessingInstruction(node.name, node.data);\n        if (node[\"x-name\"] != null) {\n            instruction[\"x-name\"] = node[\"x-name\"];\n            instruction[\"x-publicId\"] = node[\"x-publicId\"];\n            instruction[\"x-systemId\"] = node[\"x-systemId\"];\n        }\n        result = instruction;\n    }\n    else {\n        throw new Error(\"Not implemented yet: \".concat(node.type));\n    }\n    result.startIndex = node.startIndex;\n    result.endIndex = node.endIndex;\n    if (node.sourceCodeLocation != null) {\n        result.sourceCodeLocation = node.sourceCodeLocation;\n    }\n    return result;\n}\nexports.cloneNode = cloneNode;\nfunction cloneChildren(childs) {\n    var children = childs.map(function (child) { return cloneNode(child, true); });\n    for (var i = 1; i < children.length; i++) {\n        children[i].prev = children[i - 1];\n        children[i - 1].next = children[i];\n    }\n    return children;\n}\n\n},{\"domelementtype\":4}],7:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getFeed = void 0;\nvar stringify_js_1 = require(\"./stringify.js\");\nvar legacy_js_1 = require(\"./legacy.js\");\n/**\n * Get the feed object from the root of a DOM tree.\n *\n * @category Feeds\n * @param doc - The DOM to to extract the feed from.\n * @returns The feed.\n */\nfunction getFeed(doc) {\n    var feedRoot = getOneElement(isValidFeed, doc);\n    return !feedRoot\n        ? null\n        : feedRoot.name === \"feed\"\n            ? getAtomFeed(feedRoot)\n            : getRssFeed(feedRoot);\n}\nexports.getFeed = getFeed;\n/**\n * Parse an Atom feed.\n *\n * @param feedRoot The root of the feed.\n * @returns The parsed feed.\n */\nfunction getAtomFeed(feedRoot) {\n    var _a;\n    var childs = feedRoot.children;\n    var feed = {\n        type: \"atom\",\n        items: (0, legacy_js_1.getElementsByTagName)(\"entry\", childs).map(function (item) {\n            var _a;\n            var children = item.children;\n            var entry = { media: getMediaElements(children) };\n            addConditionally(entry, \"id\", \"id\", children);\n            addConditionally(entry, \"title\", \"title\", children);\n            var href = (_a = getOneElement(\"link\", children)) === null || _a === void 0 ? void 0 : _a.attribs[\"href\"];\n            if (href) {\n                entry.link = href;\n            }\n            var description = fetch(\"summary\", children) || fetch(\"content\", children);\n            if (description) {\n                entry.description = description;\n            }\n            var pubDate = fetch(\"updated\", children);\n            if (pubDate) {\n                entry.pubDate = new Date(pubDate);\n            }\n            return entry;\n        }),\n    };\n    addConditionally(feed, \"id\", \"id\", childs);\n    addConditionally(feed, \"title\", \"title\", childs);\n    var href = (_a = getOneElement(\"link\", childs)) === null || _a === void 0 ? void 0 : _a.attribs[\"href\"];\n    if (href) {\n        feed.link = href;\n    }\n    addConditionally(feed, \"description\", \"subtitle\", childs);\n    var updated = fetch(\"updated\", childs);\n    if (updated) {\n        feed.updated = new Date(updated);\n    }\n    addConditionally(feed, \"author\", \"email\", childs, true);\n    return feed;\n}\n/**\n * Parse a RSS feed.\n *\n * @param feedRoot The root of the feed.\n * @returns The parsed feed.\n */\nfunction getRssFeed(feedRoot) {\n    var _a, _b;\n    var childs = (_b = (_a = getOneElement(\"channel\", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];\n    var feed = {\n        type: feedRoot.name.substr(0, 3),\n        id: \"\",\n        items: (0, legacy_js_1.getElementsByTagName)(\"item\", feedRoot.children).map(function (item) {\n            var children = item.children;\n            var entry = { media: getMediaElements(children) };\n            addConditionally(entry, \"id\", \"guid\", children);\n            addConditionally(entry, \"title\", \"title\", children);\n            addConditionally(entry, \"link\", \"link\", children);\n            addConditionally(entry, \"description\", \"description\", children);\n            var pubDate = fetch(\"pubDate\", children) || fetch(\"dc:date\", children);\n            if (pubDate)\n                entry.pubDate = new Date(pubDate);\n            return entry;\n        }),\n    };\n    addConditionally(feed, \"title\", \"title\", childs);\n    addConditionally(feed, \"link\", \"link\", childs);\n    addConditionally(feed, \"description\", \"description\", childs);\n    var updated = fetch(\"lastBuildDate\", childs);\n    if (updated) {\n        feed.updated = new Date(updated);\n    }\n    addConditionally(feed, \"author\", \"managingEditor\", childs, true);\n    return feed;\n}\nvar MEDIA_KEYS_STRING = [\"url\", \"type\", \"lang\"];\nvar MEDIA_KEYS_INT = [\n    \"fileSize\",\n    \"bitrate\",\n    \"framerate\",\n    \"samplingrate\",\n    \"channels\",\n    \"duration\",\n    \"height\",\n    \"width\",\n];\n/**\n * Get all media elements of a feed item.\n *\n * @param where Nodes to search in.\n * @returns Media elements.\n */\nfunction getMediaElements(where) {\n    return (0, legacy_js_1.getElementsByTagName)(\"media:content\", where).map(function (elem) {\n        var attribs = elem.attribs;\n        var media = {\n            medium: attribs[\"medium\"],\n            isDefault: !!attribs[\"isDefault\"],\n        };\n        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {\n            var attrib = MEDIA_KEYS_STRING_1[_i];\n            if (attribs[attrib]) {\n                media[attrib] = attribs[attrib];\n            }\n        }\n        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {\n            var attrib = MEDIA_KEYS_INT_1[_a];\n            if (attribs[attrib]) {\n                media[attrib] = parseInt(attribs[attrib], 10);\n            }\n        }\n        if (attribs[\"expression\"]) {\n            media.expression = attribs[\"expression\"];\n        }\n        return media;\n    });\n}\n/**\n * Get one element by tag name.\n *\n * @param tagName Tag name to look for\n * @param node Node to search in\n * @returns The element or null\n */\nfunction getOneElement(tagName, node) {\n    return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];\n}\n/**\n * Get the text content of an element with a certain tag name.\n *\n * @param tagName Tag name to look for.\n * @param where Node to search in.\n * @param recurse Whether to recurse into child nodes.\n * @returns The text content of the element.\n */\nfunction fetch(tagName, where, recurse) {\n    if (recurse === void 0) { recurse = false; }\n    return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();\n}\n/**\n * Adds a property to an object if it has a value.\n *\n * @param obj Object to be extended\n * @param prop Property name\n * @param tagName Tag name that contains the conditionally added property\n * @param where Element to search for the property\n * @param recurse Whether to recurse into child nodes.\n */\nfunction addConditionally(obj, prop, tagName, where, recurse) {\n    if (recurse === void 0) { recurse = false; }\n    var val = fetch(tagName, where, recurse);\n    if (val)\n        obj[prop] = val;\n}\n/**\n * Checks if an element is a feed root node.\n *\n * @param value The name of the element to check.\n * @returns Whether an element is a feed root node.\n */\nfunction isValidFeed(value) {\n    return value === \"rss\" || value === \"feed\" || value === \"rdf:RDF\";\n}\n\n},{\"./legacy.js\":10,\"./stringify.js\":13}],8:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uniqueSort = exports.compareDocumentPosition = exports.DocumentPosition = exports.removeSubsets = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Given an array of nodes, remove any member that is contained by another\n * member.\n *\n * @category Helpers\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't contained by other nodes.\n */\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    /*\n     * Check if each node (or one of its ancestors) is already contained in the\n     * array.\n     */\n    while (--idx >= 0) {\n        var node = nodes[idx];\n        /*\n         * Remove the node if it is not unique.\n         * We are going through the array from the end, so we only\n         * have to check nodes that preceed the node under consideration in the array.\n         */\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.includes(ancestor)) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/**\n * @category Helpers\n * @see {@link http://dom.spec.whatwg.org/#dom-node-comparedocumentposition}\n */\nvar DocumentPosition;\n(function (DocumentPosition) {\n    DocumentPosition[DocumentPosition[\"DISCONNECTED\"] = 1] = \"DISCONNECTED\";\n    DocumentPosition[DocumentPosition[\"PRECEDING\"] = 2] = \"PRECEDING\";\n    DocumentPosition[DocumentPosition[\"FOLLOWING\"] = 4] = \"FOLLOWING\";\n    DocumentPosition[DocumentPosition[\"CONTAINS\"] = 8] = \"CONTAINS\";\n    DocumentPosition[DocumentPosition[\"CONTAINED_BY\"] = 16] = \"CONTAINED_BY\";\n})(DocumentPosition = exports.DocumentPosition || (exports.DocumentPosition = {}));\n/**\n * Compare the position of one node against another node in any other document,\n * returning a bitmask with the values from {@link DocumentPosition}.\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent.\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @category Helpers\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    var maxIdx = Math.min(aParents.length, bParents.length);\n    var idx = 0;\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return DocumentPosition.DISCONNECTED;\n    }\n    var sharedParent = aParents[idx - 1];\n    var siblings = sharedParent.children;\n    var aSibling = aParents[idx];\n    var bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;\n        }\n        return DocumentPosition.FOLLOWING;\n    }\n    if (sharedParent === nodeA) {\n        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;\n    }\n    return DocumentPosition.PRECEDING;\n}\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document,\n * removing any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @category Helpers\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nfunction uniqueSort(nodes) {\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\n    nodes.sort(function (a, b) {\n        var relative = compareDocumentPosition(a, b);\n        if (relative & DocumentPosition.PRECEDING) {\n            return -1;\n        }\n        else if (relative & DocumentPosition.FOLLOWING) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\nexports.uniqueSort = uniqueSort;\n\n},{\"domhandler\":5}],9:[function(require,module,exports){\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasChildren = exports.isDocument = exports.isComment = exports.isText = exports.isCDATA = exports.isTag = void 0;\n__exportStar(require(\"./stringify.js\"), exports);\n__exportStar(require(\"./traversal.js\"), exports);\n__exportStar(require(\"./manipulation.js\"), exports);\n__exportStar(require(\"./querying.js\"), exports);\n__exportStar(require(\"./legacy.js\"), exports);\n__exportStar(require(\"./helpers.js\"), exports);\n__exportStar(require(\"./feeds.js\"), exports);\n/** @deprecated Use these methods from `domhandler` directly. */\nvar domhandler_1 = require(\"domhandler\");\nObject.defineProperty(exports, \"isTag\", { enumerable: true, get: function () { return domhandler_1.isTag; } });\nObject.defineProperty(exports, \"isCDATA\", { enumerable: true, get: function () { return domhandler_1.isCDATA; } });\nObject.defineProperty(exports, \"isText\", { enumerable: true, get: function () { return domhandler_1.isText; } });\nObject.defineProperty(exports, \"isComment\", { enumerable: true, get: function () { return domhandler_1.isComment; } });\nObject.defineProperty(exports, \"isDocument\", { enumerable: true, get: function () { return domhandler_1.isDocument; } });\nObject.defineProperty(exports, \"hasChildren\", { enumerable: true, get: function () { return domhandler_1.hasChildren; } });\n\n},{\"./feeds.js\":7,\"./helpers.js\":8,\"./legacy.js\":10,\"./manipulation.js\":11,\"./querying.js\":12,\"./stringify.js\":13,\"./traversal.js\":14,\"domhandler\":5}],10:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getElementsByTagType = exports.getElementsByTagName = exports.getElementById = exports.getElements = exports.testElement = void 0;\nvar domhandler_1 = require(\"domhandler\");\nvar querying_js_1 = require(\"./querying.js\");\n/**\n * A map of functions to check nodes against.\n */\nvar Checks = {\n    tag_name: function (name) {\n        if (typeof name === \"function\") {\n            return function (elem) { return (0, domhandler_1.isTag)(elem) && name(elem.name); };\n        }\n        else if (name === \"*\") {\n            return domhandler_1.isTag;\n        }\n        return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.name === name; };\n    },\n    tag_type: function (type) {\n        if (typeof type === \"function\") {\n            return function (elem) { return type(elem.type); };\n        }\n        return function (elem) { return elem.type === type; };\n    },\n    tag_contains: function (data) {\n        if (typeof data === \"function\") {\n            return function (elem) { return (0, domhandler_1.isText)(elem) && data(elem.data); };\n        }\n        return function (elem) { return (0, domhandler_1.isText)(elem) && elem.data === data; };\n    },\n};\n/**\n * Returns a function to check whether a node has an attribute with a particular\n * value.\n *\n * @param attrib Attribute to check.\n * @param value Attribute value to look for.\n * @returns A function to check whether the a node has an attribute with a\n *   particular value.\n */\nfunction getAttribCheck(attrib, value) {\n    if (typeof value === \"function\") {\n        return function (elem) { return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]); };\n    }\n    return function (elem) { return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value; };\n}\n/**\n * Returns a function that returns `true` if either of the input functions\n * returns `true` for a node.\n *\n * @param a First function to combine.\n * @param b Second function to combine.\n * @returns A function taking a node and returning `true` if either of the input\n *   functions returns `true` for the node.\n */\nfunction combineFuncs(a, b) {\n    return function (elem) { return a(elem) || b(elem); };\n}\n/**\n * Returns a function that executes all checks in `options` and returns `true`\n * if any of them match a node.\n *\n * @param options An object describing nodes to look for.\n * @returns A function that executes all checks in `options` and returns `true`\n *   if any of them match a node.\n */\nfunction compileTest(options) {\n    var funcs = Object.keys(options).map(function (key) {\n        var value = options[key];\n        return Object.prototype.hasOwnProperty.call(Checks, key)\n            ? Checks[key](value)\n            : getAttribCheck(key, value);\n    });\n    return funcs.length === 0 ? null : funcs.reduce(combineFuncs);\n}\n/**\n * Checks whether a node matches the description in `options`.\n *\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param node The element to test.\n * @returns Whether the element matches the description in `options`.\n */\nfunction testElement(options, node) {\n    var test = compileTest(options);\n    return test ? test(node) : true;\n}\nexports.testElement = testElement;\n/**\n * Returns all nodes that match `options`.\n *\n * @category Legacy Query Functions\n * @param options An object describing nodes to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes that match `options`.\n */\nfunction getElements(options, nodes, recurse, limit) {\n    if (limit === void 0) { limit = Infinity; }\n    var test = compileTest(options);\n    return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];\n}\nexports.getElements = getElements;\n/**\n * Returns the node with the supplied ID.\n *\n * @category Legacy Query Functions\n * @param id The unique ID attribute value to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @returns The node with the supplied ID.\n */\nfunction getElementById(id, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    if (!Array.isArray(nodes))\n        nodes = [nodes];\n    return (0, querying_js_1.findOne)(getAttribCheck(\"id\", id), nodes, recurse);\n}\nexports.getElementById = getElementById;\n/**\n * Returns all nodes with the supplied `tagName`.\n *\n * @category Legacy Query Functions\n * @param tagName Tag name to search for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `tagName`.\n */\nfunction getElementsByTagName(tagName, nodes, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return (0, querying_js_1.filter)(Checks[\"tag_name\"](tagName), nodes, recurse, limit);\n}\nexports.getElementsByTagName = getElementsByTagName;\n/**\n * Returns all nodes with the supplied `type`.\n *\n * @category Legacy Query Functions\n * @param type Element type to look for.\n * @param nodes Nodes to search through.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes with the supplied `type`.\n */\nfunction getElementsByTagType(type, nodes, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return (0, querying_js_1.filter)(Checks[\"tag_type\"](type), nodes, recurse, limit);\n}\nexports.getElementsByTagType = getElementsByTagType;\n\n},{\"./querying.js\":12,\"domhandler\":5}],11:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepend = exports.prependChild = exports.append = exports.appendChild = exports.replaceElement = exports.removeElement = void 0;\n/**\n * Remove an element from the dom\n *\n * @category Manipulation\n * @param elem The element to be removed\n */\nfunction removeElement(elem) {\n    if (elem.prev)\n        elem.prev.next = elem.next;\n    if (elem.next)\n        elem.next.prev = elem.prev;\n    if (elem.parent) {\n        var childs = elem.parent.children;\n        var childsIndex = childs.lastIndexOf(elem);\n        if (childsIndex >= 0) {\n            childs.splice(childsIndex, 1);\n        }\n    }\n    elem.next = null;\n    elem.prev = null;\n    elem.parent = null;\n}\nexports.removeElement = removeElement;\n/**\n * Replace an element in the dom\n *\n * @category Manipulation\n * @param elem The element to be replaced\n * @param replacement The element to be added\n */\nfunction replaceElement(elem, replacement) {\n    var prev = (replacement.prev = elem.prev);\n    if (prev) {\n        prev.next = replacement;\n    }\n    var next = (replacement.next = elem.next);\n    if (next) {\n        next.prev = replacement;\n    }\n    var parent = (replacement.parent = elem.parent);\n    if (parent) {\n        var childs = parent.children;\n        childs[childs.lastIndexOf(elem)] = replacement;\n        elem.parent = null;\n    }\n}\nexports.replaceElement = replaceElement;\n/**\n * Append a child to an element.\n *\n * @category Manipulation\n * @param parent The element to append to.\n * @param child The element to be added as a child.\n */\nfunction appendChild(parent, child) {\n    removeElement(child);\n    child.next = null;\n    child.parent = parent;\n    if (parent.children.push(child) > 1) {\n        var sibling = parent.children[parent.children.length - 2];\n        sibling.next = child;\n        child.prev = sibling;\n    }\n    else {\n        child.prev = null;\n    }\n}\nexports.appendChild = appendChild;\n/**\n * Append an element after another.\n *\n * @category Manipulation\n * @param elem The element to append after.\n * @param next The element be added.\n */\nfunction append(elem, next) {\n    removeElement(next);\n    var parent = elem.parent;\n    var currNext = elem.next;\n    next.next = currNext;\n    next.prev = elem;\n    elem.next = next;\n    next.parent = parent;\n    if (currNext) {\n        currNext.prev = next;\n        if (parent) {\n            var childs = parent.children;\n            childs.splice(childs.lastIndexOf(currNext), 0, next);\n        }\n    }\n    else if (parent) {\n        parent.children.push(next);\n    }\n}\nexports.append = append;\n/**\n * Prepend a child to an element.\n *\n * @category Manipulation\n * @param parent The element to prepend before.\n * @param child The element to be added as a child.\n */\nfunction prependChild(parent, child) {\n    removeElement(child);\n    child.parent = parent;\n    child.prev = null;\n    if (parent.children.unshift(child) !== 1) {\n        var sibling = parent.children[1];\n        sibling.prev = child;\n        child.next = sibling;\n    }\n    else {\n        child.next = null;\n    }\n}\nexports.prependChild = prependChild;\n/**\n * Prepend an element before another.\n *\n * @category Manipulation\n * @param elem The element to prepend before.\n * @param prev The element be added.\n */\nfunction prepend(elem, prev) {\n    removeElement(prev);\n    var parent = elem.parent;\n    if (parent) {\n        var childs = parent.children;\n        childs.splice(childs.indexOf(elem), 0, prev);\n    }\n    if (elem.prev) {\n        elem.prev.next = prev;\n    }\n    prev.parent = parent;\n    prev.prev = elem.prev;\n    prev.next = elem;\n    elem.prev = prev;\n}\nexports.prepend = prepend;\n\n},{}],12:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findAll = exports.existsOne = exports.findOne = exports.findOneChild = exports.find = exports.filter = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Search a node and its children for nodes passing a test function. If `node` is not an array, it will be wrapped in one.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param node Node to search. Will be included in the result set if it matches.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction filter(test, node, recurse, limit) {\n    if (recurse === void 0) { recurse = true; }\n    if (limit === void 0) { limit = Infinity; }\n    return find(test, Array.isArray(node) ? node : [node], recurse, limit);\n}\nexports.filter = filter;\n/**\n * Search an array of nodes and their children for nodes passing a test function.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @param recurse Also consider child nodes.\n * @param limit Maximum number of nodes to return.\n * @returns All nodes passing `test`.\n */\nfunction find(test, nodes, recurse, limit) {\n    var result = [];\n    /** Stack of the arrays we are looking at. */\n    var nodeStack = [nodes];\n    /** Stack of the indices within the arrays. */\n    var indexStack = [0];\n    for (;;) {\n        // First, check if the current array has any more elements to look at.\n        if (indexStack[0] >= nodeStack[0].length) {\n            // If we have no more arrays to look at, we are done.\n            if (indexStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        var elem = nodeStack[0][indexStack[0]++];\n        if (test(elem)) {\n            result.push(elem);\n            if (--limit <= 0)\n                return result;\n        }\n        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {\n            /*\n             * Add the children to the stack. We are depth-first, so this is\n             * the next array we look at.\n             */\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\nexports.find = find;\n/**\n * Finds the first element inside of an array that matches a test function. This is an alias for `Array.prototype.find`.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns The first node in the array that passes `test`.\n * @deprecated Use `Array.prototype.find` directly.\n */\nfunction findOneChild(test, nodes) {\n    return nodes.find(test);\n}\nexports.findOneChild = findOneChild;\n/**\n * Finds one element in a tree that passes a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Node or array of nodes to search.\n * @param recurse Also consider child nodes.\n * @returns The first node that passes `test`.\n */\nfunction findOne(test, nodes, recurse) {\n    if (recurse === void 0) { recurse = true; }\n    var elem = null;\n    for (var i = 0; i < nodes.length && !elem; i++) {\n        var node = nodes[i];\n        if (!(0, domhandler_1.isTag)(node)) {\n            continue;\n        }\n        else if (test(node)) {\n            elem = node;\n        }\n        else if (recurse && node.children.length > 0) {\n            elem = findOne(test, node.children, true);\n        }\n    }\n    return elem;\n}\nexports.findOne = findOne;\n/**\n * Checks if a tree of nodes contains at least one node passing a test.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns Whether a tree of nodes contains at least one node passing the test.\n */\nfunction existsOne(test, nodes) {\n    return nodes.some(function (checked) {\n        return (0, domhandler_1.isTag)(checked) &&\n            (test(checked) || existsOne(test, checked.children));\n    });\n}\nexports.existsOne = existsOne;\n/**\n * Search an array of nodes and their children for elements passing a test function.\n *\n * Same as `find`, but limited to elements and with less options, leading to reduced complexity.\n *\n * @category Querying\n * @param test Function to test nodes on.\n * @param nodes Array of nodes to search.\n * @returns All nodes passing `test`.\n */\nfunction findAll(test, nodes) {\n    var result = [];\n    var nodeStack = [nodes];\n    var indexStack = [0];\n    for (;;) {\n        if (indexStack[0] >= nodeStack[0].length) {\n            if (nodeStack.length === 1) {\n                return result;\n            }\n            // Otherwise, remove the current array from the stack.\n            nodeStack.shift();\n            indexStack.shift();\n            // Loop back to the start to continue with the next array.\n            continue;\n        }\n        var elem = nodeStack[0][indexStack[0]++];\n        if (!(0, domhandler_1.isTag)(elem))\n            continue;\n        if (test(elem))\n            result.push(elem);\n        if (elem.children.length > 0) {\n            indexStack.unshift(0);\n            nodeStack.unshift(elem.children);\n        }\n    }\n}\nexports.findAll = findAll;\n\n},{\"domhandler\":5}],13:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.innerText = exports.textContent = exports.getText = exports.getInnerHTML = exports.getOuterHTML = void 0;\nvar domhandler_1 = require(\"domhandler\");\nvar dom_serializer_1 = __importDefault(require(\"dom-serializer\"));\nvar domelementtype_1 = require(\"domelementtype\");\n/**\n * @category Stringify\n * @deprecated Use the `dom-serializer` module directly.\n * @param node Node to get the outer HTML of.\n * @param options Options for serialization.\n * @returns `node`'s outer HTML.\n */\nfunction getOuterHTML(node, options) {\n    return (0, dom_serializer_1.default)(node, options);\n}\nexports.getOuterHTML = getOuterHTML;\n/**\n * @category Stringify\n * @deprecated Use the `dom-serializer` module directly.\n * @param node Node to get the inner HTML of.\n * @param options Options for serialization.\n * @returns `node`'s inner HTML.\n */\nfunction getInnerHTML(node, options) {\n    return (0, domhandler_1.hasChildren)(node)\n        ? node.children.map(function (node) { return getOuterHTML(node, options); }).join(\"\")\n        : \"\";\n}\nexports.getInnerHTML = getInnerHTML;\n/**\n * Get a node's inner text. Same as `textContent`, but inserts newlines for `<br>` tags. Ignores comments.\n *\n * @category Stringify\n * @deprecated Use `textContent` instead.\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n */\nfunction getText(node) {\n    if (Array.isArray(node))\n        return node.map(getText).join(\"\");\n    if ((0, domhandler_1.isTag)(node))\n        return node.name === \"br\" ? \"\\n\" : getText(node.children);\n    if ((0, domhandler_1.isCDATA)(node))\n        return getText(node.children);\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.getText = getText;\n/**\n * Get a node's text content. Ignores comments.\n *\n * @category Stringify\n * @param node Node to get the text content of.\n * @returns `node`'s text content.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/textContent}\n */\nfunction textContent(node) {\n    if (Array.isArray(node))\n        return node.map(textContent).join(\"\");\n    if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {\n        return textContent(node.children);\n    }\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.textContent = textContent;\n/**\n * Get a node's inner text, ignoring `<script>` and `<style>` tags. Ignores comments.\n *\n * @category Stringify\n * @param node Node to get the inner text of.\n * @returns `node`'s inner text.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Node/innerText}\n */\nfunction innerText(node) {\n    if (Array.isArray(node))\n        return node.map(innerText).join(\"\");\n    if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {\n        return innerText(node.children);\n    }\n    if ((0, domhandler_1.isText)(node))\n        return node.data;\n    return \"\";\n}\nexports.innerText = innerText;\n\n},{\"dom-serializer\":3,\"domelementtype\":4,\"domhandler\":5}],14:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prevElementSibling = exports.nextElementSibling = exports.getName = exports.hasAttrib = exports.getAttributeValue = exports.getSiblings = exports.getParent = exports.getChildren = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Get a node's children.\n *\n * @category Traversal\n * @param elem Node to get the children of.\n * @returns `elem`'s children, or an empty array.\n */\nfunction getChildren(elem) {\n    return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];\n}\nexports.getChildren = getChildren;\n/**\n * Get a node's parent.\n *\n * @category Traversal\n * @param elem Node to get the parent of.\n * @returns `elem`'s parent node, or `null` if `elem` is a root node.\n */\nfunction getParent(elem) {\n    return elem.parent || null;\n}\nexports.getParent = getParent;\n/**\n * Gets an elements siblings, including the element itself.\n *\n * Attempts to get the children through the element's parent first. If we don't\n * have a parent (the element is a root node), we walk the element's `prev` &\n * `next` to get all remaining nodes.\n *\n * @category Traversal\n * @param elem Element to get the siblings of.\n * @returns `elem`'s siblings, including `elem`.\n */\nfunction getSiblings(elem) {\n    var _a, _b;\n    var parent = getParent(elem);\n    if (parent != null)\n        return getChildren(parent);\n    var siblings = [elem];\n    var prev = elem.prev, next = elem.next;\n    while (prev != null) {\n        siblings.unshift(prev);\n        (_a = prev, prev = _a.prev);\n    }\n    while (next != null) {\n        siblings.push(next);\n        (_b = next, next = _b.next);\n    }\n    return siblings;\n}\nexports.getSiblings = getSiblings;\n/**\n * Gets an attribute from an element.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to retrieve.\n * @returns The element's attribute value, or `undefined`.\n */\nfunction getAttributeValue(elem, name) {\n    var _a;\n    return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];\n}\nexports.getAttributeValue = getAttributeValue;\n/**\n * Checks whether an element has an attribute.\n *\n * @category Traversal\n * @param elem Element to check.\n * @param name Attribute name to look for.\n * @returns Returns whether `elem` has the attribute `name`.\n */\nfunction hasAttrib(elem, name) {\n    return (elem.attribs != null &&\n        Object.prototype.hasOwnProperty.call(elem.attribs, name) &&\n        elem.attribs[name] != null);\n}\nexports.hasAttrib = hasAttrib;\n/**\n * Get the tag name of an element.\n *\n * @category Traversal\n * @param elem The element to get the name for.\n * @returns The tag name of `elem`.\n */\nfunction getName(elem) {\n    return elem.name;\n}\nexports.getName = getName;\n/**\n * Returns the next element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the next sibling of.\n * @returns `elem`'s next sibling that is a tag, or `null` if there is no next\n * sibling.\n */\nfunction nextElementSibling(elem) {\n    var _a;\n    var next = elem.next;\n    while (next !== null && !(0, domhandler_1.isTag)(next))\n        (_a = next, next = _a.next);\n    return next;\n}\nexports.nextElementSibling = nextElementSibling;\n/**\n * Returns the previous element sibling of a node.\n *\n * @category Traversal\n * @param elem The element to get the previous sibling of.\n * @returns `elem`'s previous sibling that is a tag, or `null` if there is no\n * previous sibling.\n */\nfunction prevElementSibling(elem) {\n    var _a;\n    var prev = elem.prev;\n    while (prev !== null && !(0, domhandler_1.isTag)(prev))\n        (_a = prev, prev = _a.prev);\n    return prev;\n}\nexports.prevElementSibling = prevElementSibling;\n\n},{\"domhandler\":5}],15:[function(require,module,exports){\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTMLAttribute = exports.decodeHTML = exports.determineBranch = exports.EntityDecoder = exports.DecodingMode = exports.BinTrieFlags = exports.fromCodePoint = exports.replaceCodePoint = exports.decodeCodePoint = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;\nvar decode_data_html_js_1 = __importDefault(require(\"./generated/decode-data-html.js\"));\nexports.htmlDecodeTree = decode_data_html_js_1.default;\nvar decode_data_xml_js_1 = __importDefault(require(\"./generated/decode-data-xml.js\"));\nexports.xmlDecodeTree = decode_data_xml_js_1.default;\nvar decode_codepoint_js_1 = __importStar(require(\"./decode_codepoint.js\"));\nexports.decodeCodePoint = decode_codepoint_js_1.default;\nvar decode_codepoint_js_2 = require(\"./decode_codepoint.js\");\nObject.defineProperty(exports, \"replaceCodePoint\", { enumerable: true, get: function () { return decode_codepoint_js_2.replaceCodePoint; } });\nObject.defineProperty(exports, \"fromCodePoint\", { enumerable: true, get: function () { return decode_codepoint_js_2.fromCodePoint; } });\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"NUM\"] = 35] = \"NUM\";\n    CharCodes[CharCodes[\"SEMI\"] = 59] = \"SEMI\";\n    CharCodes[CharCodes[\"EQUALS\"] = 61] = \"EQUALS\";\n    CharCodes[CharCodes[\"ZERO\"] = 48] = \"ZERO\";\n    CharCodes[CharCodes[\"NINE\"] = 57] = \"NINE\";\n    CharCodes[CharCodes[\"LOWER_A\"] = 97] = \"LOWER_A\";\n    CharCodes[CharCodes[\"LOWER_F\"] = 102] = \"LOWER_F\";\n    CharCodes[CharCodes[\"LOWER_X\"] = 120] = \"LOWER_X\";\n    CharCodes[CharCodes[\"LOWER_Z\"] = 122] = \"LOWER_Z\";\n    CharCodes[CharCodes[\"UPPER_A\"] = 65] = \"UPPER_A\";\n    CharCodes[CharCodes[\"UPPER_F\"] = 70] = \"UPPER_F\";\n    CharCodes[CharCodes[\"UPPER_Z\"] = 90] = \"UPPER_Z\";\n})(CharCodes || (CharCodes = {}));\n/** Bit that needs to be set to convert an upper case ASCII character to lower case */\nvar TO_LOWER_BIT = 32;\nvar BinTrieFlags;\n(function (BinTrieFlags) {\n    BinTrieFlags[BinTrieFlags[\"VALUE_LENGTH\"] = 49152] = \"VALUE_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"BRANCH_LENGTH\"] = 16256] = \"BRANCH_LENGTH\";\n    BinTrieFlags[BinTrieFlags[\"JUMP_TABLE\"] = 127] = \"JUMP_TABLE\";\n})(BinTrieFlags = exports.BinTrieFlags || (exports.BinTrieFlags = {}));\nfunction isNumber(code) {\n    return code >= CharCodes.ZERO && code <= CharCodes.NINE;\n}\nfunction isHexadecimalCharacter(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F));\n}\nfunction isAsciiAlphaNumeric(code) {\n    return ((code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z) ||\n        (code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z) ||\n        isNumber(code));\n}\n/**\n * Checks if the given character is a valid end character for an entity in an attribute.\n *\n * Attribute values that aren't terminated properly aren't parsed, and shouldn't lead to a parser error.\n * See the example in https://html.spec.whatwg.org/multipage/parsing.html#named-character-reference-state\n */\nfunction isEntityInAttributeInvalidEnd(code) {\n    return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);\n}\nvar EntityDecoderState;\n(function (EntityDecoderState) {\n    EntityDecoderState[EntityDecoderState[\"EntityStart\"] = 0] = \"EntityStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericStart\"] = 1] = \"NumericStart\";\n    EntityDecoderState[EntityDecoderState[\"NumericDecimal\"] = 2] = \"NumericDecimal\";\n    EntityDecoderState[EntityDecoderState[\"NumericHex\"] = 3] = \"NumericHex\";\n    EntityDecoderState[EntityDecoderState[\"NamedEntity\"] = 4] = \"NamedEntity\";\n})(EntityDecoderState || (EntityDecoderState = {}));\nvar DecodingMode;\n(function (DecodingMode) {\n    /** Entities in text nodes that can end with any character. */\n    DecodingMode[DecodingMode[\"Legacy\"] = 0] = \"Legacy\";\n    /** Only allow entities terminated with a semicolon. */\n    DecodingMode[DecodingMode[\"Strict\"] = 1] = \"Strict\";\n    /** Entities in attributes have limitations on ending characters. */\n    DecodingMode[DecodingMode[\"Attribute\"] = 2] = \"Attribute\";\n})(DecodingMode = exports.DecodingMode || (exports.DecodingMode = {}));\n/**\n * Token decoder with support of writing partial entities.\n */\nvar EntityDecoder = /** @class */ (function () {\n    function EntityDecoder(\n    /** The tree used to decode entities. */\n    decodeTree, \n    /**\n     * The function that is called when a codepoint is decoded.\n     *\n     * For multi-byte named entities, this will be called multiple times,\n     * with the second codepoint, and the same `consumed` value.\n     *\n     * @param codepoint The decoded codepoint.\n     * @param consumed The number of bytes consumed by the decoder.\n     */\n    emitCodePoint, \n    /** An object that is used to produce errors. */\n    errors) {\n        this.decodeTree = decodeTree;\n        this.emitCodePoint = emitCodePoint;\n        this.errors = errors;\n        /** The current state of the decoder. */\n        this.state = EntityDecoderState.EntityStart;\n        /** Characters that were consumed while parsing an entity. */\n        this.consumed = 1;\n        /**\n         * The result of the entity.\n         *\n         * Either the result index of a numeric entity, or the codepoint of a\n         * numeric entity.\n         */\n        this.result = 0;\n        /** The current index in the decode tree. */\n        this.treeIndex = 0;\n        /** The number of characters that were consumed in excess. */\n        this.excess = 1;\n        /** The mode in which the decoder is operating. */\n        this.decodeMode = DecodingMode.Strict;\n    }\n    /** Resets the instance to make it reusable. */\n    EntityDecoder.prototype.startEntity = function (decodeMode) {\n        this.decodeMode = decodeMode;\n        this.state = EntityDecoderState.EntityStart;\n        this.result = 0;\n        this.treeIndex = 0;\n        this.excess = 1;\n        this.consumed = 1;\n    };\n    /**\n     * Write an entity to the decoder. This can be called multiple times with partial entities.\n     * If the entity is incomplete, the decoder will return -1.\n     *\n     * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the\n     * entity is incomplete, and resume when the next string is written.\n     *\n     * @param string The string containing the entity (or a continuation of the entity).\n     * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.write = function (str, offset) {\n        switch (this.state) {\n            case EntityDecoderState.EntityStart: {\n                if (str.charCodeAt(offset) === CharCodes.NUM) {\n                    this.state = EntityDecoderState.NumericStart;\n                    this.consumed += 1;\n                    return this.stateNumericStart(str, offset + 1);\n                }\n                this.state = EntityDecoderState.NamedEntity;\n                return this.stateNamedEntity(str, offset);\n            }\n            case EntityDecoderState.NumericStart: {\n                return this.stateNumericStart(str, offset);\n            }\n            case EntityDecoderState.NumericDecimal: {\n                return this.stateNumericDecimal(str, offset);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.stateNumericHex(str, offset);\n            }\n            case EntityDecoderState.NamedEntity: {\n                return this.stateNamedEntity(str, offset);\n            }\n        }\n    };\n    /**\n     * Switches between the numeric decimal and hexadecimal states.\n     *\n     * Equivalent to the `Numeric character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNumericStart = function (str, offset) {\n        if (offset >= str.length) {\n            return -1;\n        }\n        if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {\n            this.state = EntityDecoderState.NumericHex;\n            this.consumed += 1;\n            return this.stateNumericHex(str, offset + 1);\n        }\n        this.state = EntityDecoderState.NumericDecimal;\n        return this.stateNumericDecimal(str, offset);\n    };\n    EntityDecoder.prototype.addToNumericResult = function (str, start, end, base) {\n        if (start !== end) {\n            var digitCount = end - start;\n            this.result =\n                this.result * Math.pow(base, digitCount) +\n                    parseInt(str.substr(start, digitCount), base);\n            this.consumed += digitCount;\n        }\n    };\n    /**\n     * Parses a hexadecimal numeric entity.\n     *\n     * Equivalent to the `Hexademical character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNumericHex = function (str, offset) {\n        var startIdx = offset;\n        while (offset < str.length) {\n            var char = str.charCodeAt(offset);\n            if (isNumber(char) || isHexadecimalCharacter(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 16);\n                return this.emitNumericEntity(char, 3);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 16);\n        return -1;\n    };\n    /**\n     * Parses a decimal numeric entity.\n     *\n     * Equivalent to the `Decimal character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNumericDecimal = function (str, offset) {\n        var startIdx = offset;\n        while (offset < str.length) {\n            var char = str.charCodeAt(offset);\n            if (isNumber(char)) {\n                offset += 1;\n            }\n            else {\n                this.addToNumericResult(str, startIdx, offset, 10);\n                return this.emitNumericEntity(char, 2);\n            }\n        }\n        this.addToNumericResult(str, startIdx, offset, 10);\n        return -1;\n    };\n    /**\n     * Validate and emit a numeric entity.\n     *\n     * Implements the logic from the `Hexademical character reference start\n     * state` and `Numeric character reference end state` in the HTML spec.\n     *\n     * @param lastCp The last code point of the entity. Used to see if the\n     *               entity was terminated with a semicolon.\n     * @param expectedLength The minimum number of characters that should be\n     *                       consumed. Used to validate that at least one digit\n     *                       was consumed.\n     * @returns The number of characters that were consumed.\n     */\n    EntityDecoder.prototype.emitNumericEntity = function (lastCp, expectedLength) {\n        var _a;\n        // Ensure we consumed at least one digit.\n        if (this.consumed <= expectedLength) {\n            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n            return 0;\n        }\n        // Figure out if this is a legit end of the entity\n        if (lastCp === CharCodes.SEMI) {\n            this.consumed += 1;\n        }\n        else if (this.decodeMode === DecodingMode.Strict) {\n            return 0;\n        }\n        this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);\n        if (this.errors) {\n            if (lastCp !== CharCodes.SEMI) {\n                this.errors.missingSemicolonAfterCharacterReference();\n            }\n            this.errors.validateNumericCharacterReference(this.result);\n        }\n        return this.consumed;\n    };\n    /**\n     * Parses a named entity.\n     *\n     * Equivalent to the `Named character reference state` in the HTML spec.\n     *\n     * @param str The string containing the entity (or a continuation of the entity).\n     * @param offset The current offset.\n     * @returns The number of characters that were consumed, or -1 if the entity is incomplete.\n     */\n    EntityDecoder.prototype.stateNamedEntity = function (str, offset) {\n        var decodeTree = this.decodeTree;\n        var current = decodeTree[this.treeIndex];\n        // The mask is the number of bytes of the value, including the current byte.\n        var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n        for (; offset < str.length; offset++, this.excess++) {\n            var char = str.charCodeAt(offset);\n            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);\n            if (this.treeIndex < 0) {\n                return this.result === 0 ||\n                    // If we are parsing an attribute\n                    (this.decodeMode === DecodingMode.Attribute &&\n                        // We shouldn't have consumed any characters after the entity,\n                        (valueLength === 0 ||\n                            // And there should be no invalid characters.\n                            isEntityInAttributeInvalidEnd(char)))\n                    ? 0\n                    : this.emitNotTerminatedNamedEntity();\n            }\n            current = decodeTree[this.treeIndex];\n            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;\n            // If the branch is a value, store it and continue\n            if (valueLength !== 0) {\n                // If the entity is terminated by a semicolon, we are done.\n                if (char === CharCodes.SEMI) {\n                    return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);\n                }\n                // If we encounter a non-terminated (legacy) entity while parsing strictly, then ignore it.\n                if (this.decodeMode !== DecodingMode.Strict) {\n                    this.result = this.treeIndex;\n                    this.consumed += this.excess;\n                    this.excess = 0;\n                }\n            }\n        }\n        return -1;\n    };\n    /**\n     * Emit a named entity that was not terminated with a semicolon.\n     *\n     * @returns The number of characters consumed.\n     */\n    EntityDecoder.prototype.emitNotTerminatedNamedEntity = function () {\n        var _a;\n        var _b = this, result = _b.result, decodeTree = _b.decodeTree;\n        var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;\n        this.emitNamedEntityData(result, valueLength, this.consumed);\n        (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();\n        return this.consumed;\n    };\n    /**\n     * Emit a named entity.\n     *\n     * @param result The index of the entity in the decode tree.\n     * @param valueLength The number of bytes in the entity.\n     * @param consumed The number of characters consumed.\n     *\n     * @returns The number of characters consumed.\n     */\n    EntityDecoder.prototype.emitNamedEntityData = function (result, valueLength, consumed) {\n        var decodeTree = this.decodeTree;\n        this.emitCodePoint(valueLength === 1\n            ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH\n            : decodeTree[result + 1], consumed);\n        if (valueLength === 3) {\n            // For multi-byte values, we need to emit the second byte.\n            this.emitCodePoint(decodeTree[result + 2], consumed);\n        }\n        return consumed;\n    };\n    /**\n     * Signal to the parser that the end of the input was reached.\n     *\n     * Remaining data will be emitted and relevant errors will be produced.\n     *\n     * @returns The number of characters consumed.\n     */\n    EntityDecoder.prototype.end = function () {\n        var _a;\n        switch (this.state) {\n            case EntityDecoderState.NamedEntity: {\n                // Emit a named entity if we have one.\n                return this.result !== 0 &&\n                    (this.decodeMode !== DecodingMode.Attribute ||\n                        this.result === this.treeIndex)\n                    ? this.emitNotTerminatedNamedEntity()\n                    : 0;\n            }\n            // Otherwise, emit a numeric entity if we have one.\n            case EntityDecoderState.NumericDecimal: {\n                return this.emitNumericEntity(0, 2);\n            }\n            case EntityDecoderState.NumericHex: {\n                return this.emitNumericEntity(0, 3);\n            }\n            case EntityDecoderState.NumericStart: {\n                (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);\n                return 0;\n            }\n            case EntityDecoderState.EntityStart: {\n                // Return 0 if we have no entity.\n                return 0;\n            }\n        }\n    };\n    return EntityDecoder;\n}());\nexports.EntityDecoder = EntityDecoder;\n/**\n * Creates a function that decodes entities in a string.\n *\n * @param decodeTree The decode tree.\n * @returns A function that decodes entities in a string.\n */\nfunction getDecoder(decodeTree) {\n    var ret = \"\";\n    var decoder = new EntityDecoder(decodeTree, function (str) { return (ret += (0, decode_codepoint_js_1.fromCodePoint)(str)); });\n    return function decodeWithTrie(str, decodeMode) {\n        var lastIndex = 0;\n        var offset = 0;\n        while ((offset = str.indexOf(\"&\", offset)) >= 0) {\n            ret += str.slice(lastIndex, offset);\n            decoder.startEntity(decodeMode);\n            var len = decoder.write(str, \n            // Skip the \"&\"\n            offset + 1);\n            if (len < 0) {\n                lastIndex = offset + decoder.end();\n                break;\n            }\n            lastIndex = offset + len;\n            // If `len` is 0, skip the current `&` and continue.\n            offset = len === 0 ? lastIndex + 1 : lastIndex;\n        }\n        var result = ret + str.slice(lastIndex);\n        // Make sure we don't keep a reference to the final string.\n        ret = \"\";\n        return result;\n    };\n}\n/**\n * Determines the branch of the current node that is taken given the current\n * character. This function is used to traverse the trie.\n *\n * @param decodeTree The trie.\n * @param current The current node.\n * @param nodeIdx The index right after the current node and its value.\n * @param char The current character.\n * @returns The index of the next node, or -1 if no branch is taken.\n */\nfunction determineBranch(decodeTree, current, nodeIdx, char) {\n    var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;\n    var jumpOffset = current & BinTrieFlags.JUMP_TABLE;\n    // Case 1: Single branch encoded in jump offset\n    if (branchCount === 0) {\n        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;\n    }\n    // Case 2: Multiple branches encoded in jump table\n    if (jumpOffset) {\n        var value = char - jumpOffset;\n        return value < 0 || value >= branchCount\n            ? -1\n            : decodeTree[nodeIdx + value] - 1;\n    }\n    // Case 3: Multiple branches encoded in dictionary\n    // Binary search for the character.\n    var lo = nodeIdx;\n    var hi = lo + branchCount - 1;\n    while (lo <= hi) {\n        var mid = (lo + hi) >>> 1;\n        var midVal = decodeTree[mid];\n        if (midVal < char) {\n            lo = mid + 1;\n        }\n        else if (midVal > char) {\n            hi = mid - 1;\n        }\n        else {\n            return decodeTree[mid + branchCount];\n        }\n    }\n    return -1;\n}\nexports.determineBranch = determineBranch;\nvar htmlDecoder = getDecoder(decode_data_html_js_1.default);\nvar xmlDecoder = getDecoder(decode_data_xml_js_1.default);\n/**\n * Decodes an HTML string.\n *\n * @param str The string to decode.\n * @param mode The decoding mode.\n * @returns The decoded string.\n */\nfunction decodeHTML(str, mode) {\n    if (mode === void 0) { mode = DecodingMode.Legacy; }\n    return htmlDecoder(str, mode);\n}\nexports.decodeHTML = decodeHTML;\n/**\n * Decodes an HTML string in an attribute.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLAttribute(str) {\n    return htmlDecoder(str, DecodingMode.Attribute);\n}\nexports.decodeHTMLAttribute = decodeHTMLAttribute;\n/**\n * Decodes an HTML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeHTMLStrict(str) {\n    return htmlDecoder(str, DecodingMode.Strict);\n}\nexports.decodeHTMLStrict = decodeHTMLStrict;\n/**\n * Decodes an XML string, requiring all entities to be terminated by a semicolon.\n *\n * @param str The string to decode.\n * @returns The decoded string.\n */\nfunction decodeXML(str) {\n    return xmlDecoder(str, DecodingMode.Strict);\n}\nexports.decodeXML = decodeXML;\n\n},{\"./decode_codepoint.js\":16,\"./generated/decode-data-html.js\":19,\"./generated/decode-data-xml.js\":20}],16:[function(require,module,exports){\n\"use strict\";\n// Adapted from https://github.com/mathiasbynens/he/blob/36afe179392226cf1b6ccdb16ebbb7a5a844d93a/src/he.js#L106-L134\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replaceCodePoint = exports.fromCodePoint = void 0;\nvar decodeMap = new Map([\n    [0, 65533],\n    // C1 Unicode control character reference replacements\n    [128, 8364],\n    [130, 8218],\n    [131, 402],\n    [132, 8222],\n    [133, 8230],\n    [134, 8224],\n    [135, 8225],\n    [136, 710],\n    [137, 8240],\n    [138, 352],\n    [139, 8249],\n    [140, 338],\n    [142, 381],\n    [145, 8216],\n    [146, 8217],\n    [147, 8220],\n    [148, 8221],\n    [149, 8226],\n    [150, 8211],\n    [151, 8212],\n    [152, 732],\n    [153, 8482],\n    [154, 353],\n    [155, 8250],\n    [156, 339],\n    [158, 382],\n    [159, 376],\n]);\n/**\n * Polyfill for `String.fromCodePoint`. It is used to create a string from a Unicode code point.\n */\nexports.fromCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins\n(_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function (codePoint) {\n    var output = \"\";\n    if (codePoint > 0xffff) {\n        codePoint -= 0x10000;\n        output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);\n        codePoint = 0xdc00 | (codePoint & 0x3ff);\n    }\n    output += String.fromCharCode(codePoint);\n    return output;\n};\n/**\n * Replace the given code point with a replacement character if it is a\n * surrogate or is outside the valid range. Otherwise return the code\n * point unchanged.\n */\nfunction replaceCodePoint(codePoint) {\n    var _a;\n    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {\n        return 0xfffd;\n    }\n    return (_a = decodeMap.get(codePoint)) !== null && _a !== void 0 ? _a : codePoint;\n}\nexports.replaceCodePoint = replaceCodePoint;\n/**\n * Replace the code point if relevant, then convert it to a string.\n *\n * @deprecated Use `fromCodePoint(replaceCodePoint(codePoint))` instead.\n * @param codePoint The code point to decode.\n * @returns The decoded code point.\n */\nfunction decodeCodePoint(codePoint) {\n    return (0, exports.fromCodePoint)(replaceCodePoint(codePoint));\n}\nexports.default = decodeCodePoint;\n\n},{}],17:[function(require,module,exports){\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.encodeNonAsciiHTML = exports.encodeHTML = void 0;\nvar encode_html_js_1 = __importDefault(require(\"./generated/encode-html.js\"));\nvar escape_js_1 = require(\"./escape.js\");\nvar htmlReplacer = /[\\t\\n!-,./:-@[-`\\f{-}$\\x80-\\uFFFF]/g;\n/**\n * Encodes all characters in the input using HTML entities. This includes\n * characters that are valid ASCII characters in HTML documents, such as `#`.\n *\n * To get a more compact output, consider using the `encodeNonAsciiHTML`\n * function, which will only encode characters that are not valid in HTML\n * documents, as well as non-ASCII characters.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nfunction encodeHTML(data) {\n    return encodeHTMLTrieRe(htmlReplacer, data);\n}\nexports.encodeHTML = encodeHTML;\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in HTML\n * documents using HTML entities. This function will not encode characters that\n * are valid in HTML documents, such as `#`.\n *\n * If a character has no equivalent entity, a numeric hexadecimal reference\n * (eg. `&#xfc;`) will be used.\n */\nfunction encodeNonAsciiHTML(data) {\n    return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);\n}\nexports.encodeNonAsciiHTML = encodeNonAsciiHTML;\nfunction encodeHTMLTrieRe(regExp, str) {\n    var ret = \"\";\n    var lastIdx = 0;\n    var match;\n    while ((match = regExp.exec(str)) !== null) {\n        var i = match.index;\n        ret += str.substring(lastIdx, i);\n        var char = str.charCodeAt(i);\n        var next = encode_html_js_1.default.get(char);\n        if (typeof next === \"object\") {\n            // We are in a branch. Try to match the next char.\n            if (i + 1 < str.length) {\n                var nextChar = str.charCodeAt(i + 1);\n                var value = typeof next.n === \"number\"\n                    ? next.n === nextChar\n                        ? next.o\n                        : undefined\n                    : next.n.get(nextChar);\n                if (value !== undefined) {\n                    ret += value;\n                    lastIdx = regExp.lastIndex += 1;\n                    continue;\n                }\n            }\n            next = next.v;\n        }\n        // We might have a tree node without a value; skip and use a numeric entity.\n        if (next !== undefined) {\n            ret += next;\n            lastIdx = i + 1;\n        }\n        else {\n            var cp = (0, escape_js_1.getCodePoint)(str, i);\n            ret += \"&#x\".concat(cp.toString(16), \";\");\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = regExp.lastIndex += Number(cp !== char);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\n\n},{\"./escape.js\":18,\"./generated/encode-html.js\":21}],18:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.getCodePoint = exports.xmlReplacer = void 0;\nexports.xmlReplacer = /[\"&'<>$\\x80-\\uFFFF]/g;\nvar xmlCodeMap = new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [39, \"&apos;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n]);\n// For compatibility with node < 4, we wrap `codePointAt`\nexports.getCodePoint = \n// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nString.prototype.codePointAt != null\n    ? function (str, index) { return str.codePointAt(index); }\n    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        function (c, index) {\n            return (c.charCodeAt(index) & 0xfc00) === 0xd800\n                ? (c.charCodeAt(index) - 0xd800) * 0x400 +\n                    c.charCodeAt(index + 1) -\n                    0xdc00 +\n                    0x10000\n                : c.charCodeAt(index);\n        };\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using XML entities.\n *\n * If a character has no equivalent entity, a\n * numeric hexadecimal reference (eg. `&#xfc;`) will be used.\n */\nfunction encodeXML(str) {\n    var ret = \"\";\n    var lastIdx = 0;\n    var match;\n    while ((match = exports.xmlReplacer.exec(str)) !== null) {\n        var i = match.index;\n        var char = str.charCodeAt(i);\n        var next = xmlCodeMap.get(char);\n        if (next !== undefined) {\n            ret += str.substring(lastIdx, i) + next;\n            lastIdx = i + 1;\n        }\n        else {\n            ret += \"\".concat(str.substring(lastIdx, i), \"&#x\").concat((0, exports.getCodePoint)(str, i).toString(16), \";\");\n            // Increase by 1 if we have a surrogate pair\n            lastIdx = exports.xmlReplacer.lastIndex += Number((char & 0xfc00) === 0xd800);\n        }\n    }\n    return ret + str.substr(lastIdx);\n}\nexports.encodeXML = encodeXML;\n/**\n * Encodes all non-ASCII characters, as well as characters not valid in XML\n * documents using numeric hexadecimal reference (eg. `&#xfc;`).\n *\n * Have a look at `escapeUTF8` if you want a more concise output at the expense\n * of reduced transportability.\n *\n * @param data String to escape.\n */\nexports.escape = encodeXML;\n/**\n * Creates a function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n *\n * @param regex Regular expression to match characters to escape.\n * @param map Map of characters to escape to their entities.\n *\n * @returns Function that escapes all characters matched by the given regular\n * expression using the given map of characters to escape to their entities.\n */\nfunction getEscaper(regex, map) {\n    return function escape(data) {\n        var match;\n        var lastIdx = 0;\n        var result = \"\";\n        while ((match = regex.exec(data))) {\n            if (lastIdx !== match.index) {\n                result += data.substring(lastIdx, match.index);\n            }\n            // We know that this character will be in the map.\n            result += map.get(match[0].charCodeAt(0));\n            // Every match will be of length 1\n            lastIdx = match.index + 1;\n        }\n        return result + data.substring(lastIdx);\n    };\n}\n/**\n * Encodes all characters not valid in XML documents using XML entities.\n *\n * Note that the output will be character-set dependent.\n *\n * @param data String to escape.\n */\nexports.escapeUTF8 = getEscaper(/[&<>'\"]/g, xmlCodeMap);\n/**\n * Encodes all characters that have to be escaped in HTML attributes,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexports.escapeAttribute = getEscaper(/[\"&\\u00A0]/g, new Map([\n    [34, \"&quot;\"],\n    [38, \"&amp;\"],\n    [160, \"&nbsp;\"],\n]));\n/**\n * Encodes all characters that have to be escaped in HTML text,\n * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n *\n * @param data String to escape.\n */\nexports.escapeText = getEscaper(/[&<>\\u00A0]/g, new Map([\n    [38, \"&amp;\"],\n    [60, \"&lt;\"],\n    [62, \"&gt;\"],\n    [160, \"&nbsp;\"],\n]));\n\n},{}],19:[function(require,module,exports){\n\"use strict\";\n// Generated using scripts/write-decode-map.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = new Uint16Array(\n// prettier-ignore\n\"\\u1d41<\\xd5\\u0131\\u028a\\u049d\\u057b\\u05d0\\u0675\\u06de\\u07a2\\u07d6\\u080f\\u0a4a\\u0a91\\u0da1\\u0e6d\\u0f09\\u0f26\\u10ca\\u1228\\u12e1\\u1415\\u149d\\u14c3\\u14df\\u1525\\0\\0\\0\\0\\0\\0\\u156b\\u16cd\\u198d\\u1c12\\u1ddd\\u1f7e\\u2060\\u21b0\\u228d\\u23c0\\u23fb\\u2442\\u2824\\u2912\\u2d08\\u2e48\\u2fce\\u3016\\u32ba\\u3639\\u37ac\\u38fe\\u3a28\\u3a71\\u3ae0\\u3b2e\\u0800EMabcfglmnoprstu\\\\bfms\\x7f\\x84\\x8b\\x90\\x95\\x98\\xa6\\xb3\\xb9\\xc8\\xcflig\\u803b\\xc6\\u40c6P\\u803b&\\u4026cute\\u803b\\xc1\\u40c1reve;\\u4102\\u0100iyx}rc\\u803b\\xc2\\u40c2;\\u4410r;\\uc000\\ud835\\udd04rave\\u803b\\xc0\\u40c0pha;\\u4391acr;\\u4100d;\\u6a53\\u0100gp\\x9d\\xa1on;\\u4104f;\\uc000\\ud835\\udd38plyFunction;\\u6061ing\\u803b\\xc5\\u40c5\\u0100cs\\xbe\\xc3r;\\uc000\\ud835\\udc9cign;\\u6254ilde\\u803b\\xc3\\u40c3ml\\u803b\\xc4\\u40c4\\u0400aceforsu\\xe5\\xfb\\xfe\\u0117\\u011c\\u0122\\u0127\\u012a\\u0100cr\\xea\\xf2kslash;\\u6216\\u0176\\xf6\\xf8;\\u6ae7ed;\\u6306y;\\u4411\\u0180crt\\u0105\\u010b\\u0114ause;\\u6235noullis;\\u612ca;\\u4392r;\\uc000\\ud835\\udd05pf;\\uc000\\ud835\\udd39eve;\\u42d8c\\xf2\\u0113mpeq;\\u624e\\u0700HOacdefhilorsu\\u014d\\u0151\\u0156\\u0180\\u019e\\u01a2\\u01b5\\u01b7\\u01ba\\u01dc\\u0215\\u0273\\u0278\\u027ecy;\\u4427PY\\u803b\\xa9\\u40a9\\u0180cpy\\u015d\\u0162\\u017aute;\\u4106\\u0100;i\\u0167\\u0168\\u62d2talDifferentialD;\\u6145leys;\\u612d\\u0200aeio\\u0189\\u018e\\u0194\\u0198ron;\\u410cdil\\u803b\\xc7\\u40c7rc;\\u4108nint;\\u6230ot;\\u410a\\u0100dn\\u01a7\\u01adilla;\\u40b8terDot;\\u40b7\\xf2\\u017fi;\\u43a7rcle\\u0200DMPT\\u01c7\\u01cb\\u01d1\\u01d6ot;\\u6299inus;\\u6296lus;\\u6295imes;\\u6297o\\u0100cs\\u01e2\\u01f8kwiseContourIntegral;\\u6232eCurly\\u0100DQ\\u0203\\u020foubleQuote;\\u601duote;\\u6019\\u0200lnpu\\u021e\\u0228\\u0247\\u0255on\\u0100;e\\u0225\\u0226\\u6237;\\u6a74\\u0180git\\u022f\\u0236\\u023aruent;\\u6261nt;\\u622fourIntegral;\\u622e\\u0100fr\\u024c\\u024e;\\u6102oduct;\\u6210nterClockwiseContourIntegral;\\u6233oss;\\u6a2fcr;\\uc000\\ud835\\udc9ep\\u0100;C\\u0284\\u0285\\u62d3ap;\\u624d\\u0580DJSZacefios\\u02a0\\u02ac\\u02b0\\u02b4\\u02b8\\u02cb\\u02d7\\u02e1\\u02e6\\u0333\\u048d\\u0100;o\\u0179\\u02a5trahd;\\u6911cy;\\u4402cy;\\u4405cy;\\u440f\\u0180grs\\u02bf\\u02c4\\u02c7ger;\\u6021r;\\u61a1hv;\\u6ae4\\u0100ay\\u02d0\\u02d5ron;\\u410e;\\u4414l\\u0100;t\\u02dd\\u02de\\u6207a;\\u4394r;\\uc000\\ud835\\udd07\\u0100af\\u02eb\\u0327\\u0100cm\\u02f0\\u0322ritical\\u0200ADGT\\u0300\\u0306\\u0316\\u031ccute;\\u40b4o\\u0174\\u030b\\u030d;\\u42d9bleAcute;\\u42ddrave;\\u4060ilde;\\u42dcond;\\u62c4ferentialD;\\u6146\\u0470\\u033d\\0\\0\\0\\u0342\\u0354\\0\\u0405f;\\uc000\\ud835\\udd3b\\u0180;DE\\u0348\\u0349\\u034d\\u40a8ot;\\u60dcqual;\\u6250ble\\u0300CDLRUV\\u0363\\u0372\\u0382\\u03cf\\u03e2\\u03f8ontourIntegra\\xec\\u0239o\\u0274\\u0379\\0\\0\\u037b\\xbb\\u0349nArrow;\\u61d3\\u0100eo\\u0387\\u03a4ft\\u0180ART\\u0390\\u0396\\u03a1rrow;\\u61d0ightArrow;\\u61d4e\\xe5\\u02cang\\u0100LR\\u03ab\\u03c4eft\\u0100AR\\u03b3\\u03b9rrow;\\u67f8ightArrow;\\u67faightArrow;\\u67f9ight\\u0100AT\\u03d8\\u03derrow;\\u61d2ee;\\u62a8p\\u0241\\u03e9\\0\\0\\u03efrrow;\\u61d1ownArrow;\\u61d5erticalBar;\\u6225n\\u0300ABLRTa\\u0412\\u042a\\u0430\\u045e\\u047f\\u037crrow\\u0180;BU\\u041d\\u041e\\u0422\\u6193ar;\\u6913pArrow;\\u61f5reve;\\u4311eft\\u02d2\\u043a\\0\\u0446\\0\\u0450ightVector;\\u6950eeVector;\\u695eector\\u0100;B\\u0459\\u045a\\u61bdar;\\u6956ight\\u01d4\\u0467\\0\\u0471eeVector;\\u695fector\\u0100;B\\u047a\\u047b\\u61c1ar;\\u6957ee\\u0100;A\\u0486\\u0487\\u62a4rrow;\\u61a7\\u0100ct\\u0492\\u0497r;\\uc000\\ud835\\udc9frok;\\u4110\\u0800NTacdfglmopqstux\\u04bd\\u04c0\\u04c4\\u04cb\\u04de\\u04e2\\u04e7\\u04ee\\u04f5\\u0521\\u052f\\u0536\\u0552\\u055d\\u0560\\u0565G;\\u414aH\\u803b\\xd0\\u40d0cute\\u803b\\xc9\\u40c9\\u0180aiy\\u04d2\\u04d7\\u04dcron;\\u411arc\\u803b\\xca\\u40ca;\\u442dot;\\u4116r;\\uc000\\ud835\\udd08rave\\u803b\\xc8\\u40c8ement;\\u6208\\u0100ap\\u04fa\\u04fecr;\\u4112ty\\u0253\\u0506\\0\\0\\u0512mallSquare;\\u65fberySmallSquare;\\u65ab\\u0100gp\\u0526\\u052aon;\\u4118f;\\uc000\\ud835\\udd3csilon;\\u4395u\\u0100ai\\u053c\\u0549l\\u0100;T\\u0542\\u0543\\u6a75ilde;\\u6242librium;\\u61cc\\u0100ci\\u0557\\u055ar;\\u6130m;\\u6a73a;\\u4397ml\\u803b\\xcb\\u40cb\\u0100ip\\u056a\\u056fsts;\\u6203onentialE;\\u6147\\u0280cfios\\u0585\\u0588\\u058d\\u05b2\\u05ccy;\\u4424r;\\uc000\\ud835\\udd09lled\\u0253\\u0597\\0\\0\\u05a3mallSquare;\\u65fcerySmallSquare;\\u65aa\\u0370\\u05ba\\0\\u05bf\\0\\0\\u05c4f;\\uc000\\ud835\\udd3dAll;\\u6200riertrf;\\u6131c\\xf2\\u05cb\\u0600JTabcdfgorst\\u05e8\\u05ec\\u05ef\\u05fa\\u0600\\u0612\\u0616\\u061b\\u061d\\u0623\\u066c\\u0672cy;\\u4403\\u803b>\\u403emma\\u0100;d\\u05f7\\u05f8\\u4393;\\u43dcreve;\\u411e\\u0180eiy\\u0607\\u060c\\u0610dil;\\u4122rc;\\u411c;\\u4413ot;\\u4120r;\\uc000\\ud835\\udd0a;\\u62d9pf;\\uc000\\ud835\\udd3eeater\\u0300EFGLST\\u0635\\u0644\\u064e\\u0656\\u065b\\u0666qual\\u0100;L\\u063e\\u063f\\u6265ess;\\u62dbullEqual;\\u6267reater;\\u6aa2ess;\\u6277lantEqual;\\u6a7eilde;\\u6273cr;\\uc000\\ud835\\udca2;\\u626b\\u0400Aacfiosu\\u0685\\u068b\\u0696\\u069b\\u069e\\u06aa\\u06be\\u06caRDcy;\\u442a\\u0100ct\\u0690\\u0694ek;\\u42c7;\\u405eirc;\\u4124r;\\u610clbertSpace;\\u610b\\u01f0\\u06af\\0\\u06b2f;\\u610dizontalLine;\\u6500\\u0100ct\\u06c3\\u06c5\\xf2\\u06a9rok;\\u4126mp\\u0144\\u06d0\\u06d8ownHum\\xf0\\u012fqual;\\u624f\\u0700EJOacdfgmnostu\\u06fa\\u06fe\\u0703\\u0707\\u070e\\u071a\\u071e\\u0721\\u0728\\u0744\\u0778\\u078b\\u078f\\u0795cy;\\u4415lig;\\u4132cy;\\u4401cute\\u803b\\xcd\\u40cd\\u0100iy\\u0713\\u0718rc\\u803b\\xce\\u40ce;\\u4418ot;\\u4130r;\\u6111rave\\u803b\\xcc\\u40cc\\u0180;ap\\u0720\\u072f\\u073f\\u0100cg\\u0734\\u0737r;\\u412ainaryI;\\u6148lie\\xf3\\u03dd\\u01f4\\u0749\\0\\u0762\\u0100;e\\u074d\\u074e\\u622c\\u0100gr\\u0753\\u0758ral;\\u622bsection;\\u62c2isible\\u0100CT\\u076c\\u0772omma;\\u6063imes;\\u6062\\u0180gpt\\u077f\\u0783\\u0788on;\\u412ef;\\uc000\\ud835\\udd40a;\\u4399cr;\\u6110ilde;\\u4128\\u01eb\\u079a\\0\\u079ecy;\\u4406l\\u803b\\xcf\\u40cf\\u0280cfosu\\u07ac\\u07b7\\u07bc\\u07c2\\u07d0\\u0100iy\\u07b1\\u07b5rc;\\u4134;\\u4419r;\\uc000\\ud835\\udd0dpf;\\uc000\\ud835\\udd41\\u01e3\\u07c7\\0\\u07ccr;\\uc000\\ud835\\udca5rcy;\\u4408kcy;\\u4404\\u0380HJacfos\\u07e4\\u07e8\\u07ec\\u07f1\\u07fd\\u0802\\u0808cy;\\u4425cy;\\u440cppa;\\u439a\\u0100ey\\u07f6\\u07fbdil;\\u4136;\\u441ar;\\uc000\\ud835\\udd0epf;\\uc000\\ud835\\udd42cr;\\uc000\\ud835\\udca6\\u0580JTaceflmost\\u0825\\u0829\\u082c\\u0850\\u0863\\u09b3\\u09b8\\u09c7\\u09cd\\u0a37\\u0a47cy;\\u4409\\u803b<\\u403c\\u0280cmnpr\\u0837\\u083c\\u0841\\u0844\\u084dute;\\u4139bda;\\u439bg;\\u67ealacetrf;\\u6112r;\\u619e\\u0180aey\\u0857\\u085c\\u0861ron;\\u413ddil;\\u413b;\\u441b\\u0100fs\\u0868\\u0970t\\u0500ACDFRTUVar\\u087e\\u08a9\\u08b1\\u08e0\\u08e6\\u08fc\\u092f\\u095b\\u0390\\u096a\\u0100nr\\u0883\\u088fgleBracket;\\u67e8row\\u0180;BR\\u0899\\u089a\\u089e\\u6190ar;\\u61e4ightArrow;\\u61c6eiling;\\u6308o\\u01f5\\u08b7\\0\\u08c3bleBracket;\\u67e6n\\u01d4\\u08c8\\0\\u08d2eeVector;\\u6961ector\\u0100;B\\u08db\\u08dc\\u61c3ar;\\u6959loor;\\u630aight\\u0100AV\\u08ef\\u08f5rrow;\\u6194ector;\\u694e\\u0100er\\u0901\\u0917e\\u0180;AV\\u0909\\u090a\\u0910\\u62a3rrow;\\u61a4ector;\\u695aiangle\\u0180;BE\\u0924\\u0925\\u0929\\u62b2ar;\\u69cfqual;\\u62b4p\\u0180DTV\\u0937\\u0942\\u094cownVector;\\u6951eeVector;\\u6960ector\\u0100;B\\u0956\\u0957\\u61bfar;\\u6958ector\\u0100;B\\u0965\\u0966\\u61bcar;\\u6952ight\\xe1\\u039cs\\u0300EFGLST\\u097e\\u098b\\u0995\\u099d\\u09a2\\u09adqualGreater;\\u62daullEqual;\\u6266reater;\\u6276ess;\\u6aa1lantEqual;\\u6a7dilde;\\u6272r;\\uc000\\ud835\\udd0f\\u0100;e\\u09bd\\u09be\\u62d8ftarrow;\\u61daidot;\\u413f\\u0180npw\\u09d4\\u0a16\\u0a1bg\\u0200LRlr\\u09de\\u09f7\\u0a02\\u0a10eft\\u0100AR\\u09e6\\u09ecrrow;\\u67f5ightArrow;\\u67f7ightArrow;\\u67f6eft\\u0100ar\\u03b3\\u0a0aight\\xe1\\u03bfight\\xe1\\u03caf;\\uc000\\ud835\\udd43er\\u0100LR\\u0a22\\u0a2ceftArrow;\\u6199ightArrow;\\u6198\\u0180cht\\u0a3e\\u0a40\\u0a42\\xf2\\u084c;\\u61b0rok;\\u4141;\\u626a\\u0400acefiosu\\u0a5a\\u0a5d\\u0a60\\u0a77\\u0a7c\\u0a85\\u0a8b\\u0a8ep;\\u6905y;\\u441c\\u0100dl\\u0a65\\u0a6fiumSpace;\\u605flintrf;\\u6133r;\\uc000\\ud835\\udd10nusPlus;\\u6213pf;\\uc000\\ud835\\udd44c\\xf2\\u0a76;\\u439c\\u0480Jacefostu\\u0aa3\\u0aa7\\u0aad\\u0ac0\\u0b14\\u0b19\\u0d91\\u0d97\\u0d9ecy;\\u440acute;\\u4143\\u0180aey\\u0ab4\\u0ab9\\u0aberon;\\u4147dil;\\u4145;\\u441d\\u0180gsw\\u0ac7\\u0af0\\u0b0eative\\u0180MTV\\u0ad3\\u0adf\\u0ae8ediumSpace;\\u600bhi\\u0100cn\\u0ae6\\u0ad8\\xeb\\u0ad9eryThi\\xee\\u0ad9ted\\u0100GL\\u0af8\\u0b06reaterGreate\\xf2\\u0673essLes\\xf3\\u0a48Line;\\u400ar;\\uc000\\ud835\\udd11\\u0200Bnpt\\u0b22\\u0b28\\u0b37\\u0b3areak;\\u6060BreakingSpace;\\u40a0f;\\u6115\\u0680;CDEGHLNPRSTV\\u0b55\\u0b56\\u0b6a\\u0b7c\\u0ba1\\u0beb\\u0c04\\u0c5e\\u0c84\\u0ca6\\u0cd8\\u0d61\\u0d85\\u6aec\\u0100ou\\u0b5b\\u0b64ngruent;\\u6262pCap;\\u626doubleVerticalBar;\\u6226\\u0180lqx\\u0b83\\u0b8a\\u0b9bement;\\u6209ual\\u0100;T\\u0b92\\u0b93\\u6260ilde;\\uc000\\u2242\\u0338ists;\\u6204reater\\u0380;EFGLST\\u0bb6\\u0bb7\\u0bbd\\u0bc9\\u0bd3\\u0bd8\\u0be5\\u626fqual;\\u6271ullEqual;\\uc000\\u2267\\u0338reater;\\uc000\\u226b\\u0338ess;\\u6279lantEqual;\\uc000\\u2a7e\\u0338ilde;\\u6275ump\\u0144\\u0bf2\\u0bfdownHump;\\uc000\\u224e\\u0338qual;\\uc000\\u224f\\u0338e\\u0100fs\\u0c0a\\u0c27tTriangle\\u0180;BE\\u0c1a\\u0c1b\\u0c21\\u62eaar;\\uc000\\u29cf\\u0338qual;\\u62ecs\\u0300;EGLST\\u0c35\\u0c36\\u0c3c\\u0c44\\u0c4b\\u0c58\\u626equal;\\u6270reater;\\u6278ess;\\uc000\\u226a\\u0338lantEqual;\\uc000\\u2a7d\\u0338ilde;\\u6274ested\\u0100GL\\u0c68\\u0c79reaterGreater;\\uc000\\u2aa2\\u0338essLess;\\uc000\\u2aa1\\u0338recedes\\u0180;ES\\u0c92\\u0c93\\u0c9b\\u6280qual;\\uc000\\u2aaf\\u0338lantEqual;\\u62e0\\u0100ei\\u0cab\\u0cb9verseElement;\\u620cghtTriangle\\u0180;BE\\u0ccb\\u0ccc\\u0cd2\\u62ebar;\\uc000\\u29d0\\u0338qual;\\u62ed\\u0100qu\\u0cdd\\u0d0cuareSu\\u0100bp\\u0ce8\\u0cf9set\\u0100;E\\u0cf0\\u0cf3\\uc000\\u228f\\u0338qual;\\u62e2erset\\u0100;E\\u0d03\\u0d06\\uc000\\u2290\\u0338qual;\\u62e3\\u0180bcp\\u0d13\\u0d24\\u0d4eset\\u0100;E\\u0d1b\\u0d1e\\uc000\\u2282\\u20d2qual;\\u6288ceeds\\u0200;EST\\u0d32\\u0d33\\u0d3b\\u0d46\\u6281qual;\\uc000\\u2ab0\\u0338lantEqual;\\u62e1ilde;\\uc000\\u227f\\u0338erset\\u0100;E\\u0d58\\u0d5b\\uc000\\u2283\\u20d2qual;\\u6289ilde\\u0200;EFT\\u0d6e\\u0d6f\\u0d75\\u0d7f\\u6241qual;\\u6244ullEqual;\\u6247ilde;\\u6249erticalBar;\\u6224cr;\\uc000\\ud835\\udca9ilde\\u803b\\xd1\\u40d1;\\u439d\\u0700Eacdfgmoprstuv\\u0dbd\\u0dc2\\u0dc9\\u0dd5\\u0ddb\\u0de0\\u0de7\\u0dfc\\u0e02\\u0e20\\u0e22\\u0e32\\u0e3f\\u0e44lig;\\u4152cute\\u803b\\xd3\\u40d3\\u0100iy\\u0dce\\u0dd3rc\\u803b\\xd4\\u40d4;\\u441eblac;\\u4150r;\\uc000\\ud835\\udd12rave\\u803b\\xd2\\u40d2\\u0180aei\\u0dee\\u0df2\\u0df6cr;\\u414cga;\\u43a9cron;\\u439fpf;\\uc000\\ud835\\udd46enCurly\\u0100DQ\\u0e0e\\u0e1aoubleQuote;\\u601cuote;\\u6018;\\u6a54\\u0100cl\\u0e27\\u0e2cr;\\uc000\\ud835\\udcaaash\\u803b\\xd8\\u40d8i\\u016c\\u0e37\\u0e3cde\\u803b\\xd5\\u40d5es;\\u6a37ml\\u803b\\xd6\\u40d6er\\u0100BP\\u0e4b\\u0e60\\u0100ar\\u0e50\\u0e53r;\\u603eac\\u0100ek\\u0e5a\\u0e5c;\\u63deet;\\u63b4arenthesis;\\u63dc\\u0480acfhilors\\u0e7f\\u0e87\\u0e8a\\u0e8f\\u0e92\\u0e94\\u0e9d\\u0eb0\\u0efcrtialD;\\u6202y;\\u441fr;\\uc000\\ud835\\udd13i;\\u43a6;\\u43a0usMinus;\\u40b1\\u0100ip\\u0ea2\\u0eadncareplan\\xe5\\u069df;\\u6119\\u0200;eio\\u0eb9\\u0eba\\u0ee0\\u0ee4\\u6abbcedes\\u0200;EST\\u0ec8\\u0ec9\\u0ecf\\u0eda\\u627aqual;\\u6aaflantEqual;\\u627cilde;\\u627eme;\\u6033\\u0100dp\\u0ee9\\u0eeeuct;\\u620fortion\\u0100;a\\u0225\\u0ef9l;\\u621d\\u0100ci\\u0f01\\u0f06r;\\uc000\\ud835\\udcab;\\u43a8\\u0200Ufos\\u0f11\\u0f16\\u0f1b\\u0f1fOT\\u803b\\\"\\u4022r;\\uc000\\ud835\\udd14pf;\\u611acr;\\uc000\\ud835\\udcac\\u0600BEacefhiorsu\\u0f3e\\u0f43\\u0f47\\u0f60\\u0f73\\u0fa7\\u0faa\\u0fad\\u1096\\u10a9\\u10b4\\u10bearr;\\u6910G\\u803b\\xae\\u40ae\\u0180cnr\\u0f4e\\u0f53\\u0f56ute;\\u4154g;\\u67ebr\\u0100;t\\u0f5c\\u0f5d\\u61a0l;\\u6916\\u0180aey\\u0f67\\u0f6c\\u0f71ron;\\u4158dil;\\u4156;\\u4420\\u0100;v\\u0f78\\u0f79\\u611cerse\\u0100EU\\u0f82\\u0f99\\u0100lq\\u0f87\\u0f8eement;\\u620builibrium;\\u61cbpEquilibrium;\\u696fr\\xbb\\u0f79o;\\u43a1ght\\u0400ACDFTUVa\\u0fc1\\u0feb\\u0ff3\\u1022\\u1028\\u105b\\u1087\\u03d8\\u0100nr\\u0fc6\\u0fd2gleBracket;\\u67e9row\\u0180;BL\\u0fdc\\u0fdd\\u0fe1\\u6192ar;\\u61e5eftArrow;\\u61c4eiling;\\u6309o\\u01f5\\u0ff9\\0\\u1005bleBracket;\\u67e7n\\u01d4\\u100a\\0\\u1014eeVector;\\u695dector\\u0100;B\\u101d\\u101e\\u61c2ar;\\u6955loor;\\u630b\\u0100er\\u102d\\u1043e\\u0180;AV\\u1035\\u1036\\u103c\\u62a2rrow;\\u61a6ector;\\u695biangle\\u0180;BE\\u1050\\u1051\\u1055\\u62b3ar;\\u69d0qual;\\u62b5p\\u0180DTV\\u1063\\u106e\\u1078ownVector;\\u694feeVector;\\u695cector\\u0100;B\\u1082\\u1083\\u61bear;\\u6954ector\\u0100;B\\u1091\\u1092\\u61c0ar;\\u6953\\u0100pu\\u109b\\u109ef;\\u611dndImplies;\\u6970ightarrow;\\u61db\\u0100ch\\u10b9\\u10bcr;\\u611b;\\u61b1leDelayed;\\u69f4\\u0680HOacfhimoqstu\\u10e4\\u10f1\\u10f7\\u10fd\\u1119\\u111e\\u1151\\u1156\\u1161\\u1167\\u11b5\\u11bb\\u11bf\\u0100Cc\\u10e9\\u10eeHcy;\\u4429y;\\u4428FTcy;\\u442ccute;\\u415a\\u0280;aeiy\\u1108\\u1109\\u110e\\u1113\\u1117\\u6abcron;\\u4160dil;\\u415erc;\\u415c;\\u4421r;\\uc000\\ud835\\udd16ort\\u0200DLRU\\u112a\\u1134\\u113e\\u1149ownArrow\\xbb\\u041eeftArrow\\xbb\\u089aightArrow\\xbb\\u0fddpArrow;\\u6191gma;\\u43a3allCircle;\\u6218pf;\\uc000\\ud835\\udd4a\\u0272\\u116d\\0\\0\\u1170t;\\u621aare\\u0200;ISU\\u117b\\u117c\\u1189\\u11af\\u65a1ntersection;\\u6293u\\u0100bp\\u118f\\u119eset\\u0100;E\\u1197\\u1198\\u628fqual;\\u6291erset\\u0100;E\\u11a8\\u11a9\\u6290qual;\\u6292nion;\\u6294cr;\\uc000\\ud835\\udcaear;\\u62c6\\u0200bcmp\\u11c8\\u11db\\u1209\\u120b\\u0100;s\\u11cd\\u11ce\\u62d0et\\u0100;E\\u11cd\\u11d5qual;\\u6286\\u0100ch\\u11e0\\u1205eeds\\u0200;EST\\u11ed\\u11ee\\u11f4\\u11ff\\u627bqual;\\u6ab0lantEqual;\\u627dilde;\\u627fTh\\xe1\\u0f8c;\\u6211\\u0180;es\\u1212\\u1213\\u1223\\u62d1rset\\u0100;E\\u121c\\u121d\\u6283qual;\\u6287et\\xbb\\u1213\\u0580HRSacfhiors\\u123e\\u1244\\u1249\\u1255\\u125e\\u1271\\u1276\\u129f\\u12c2\\u12c8\\u12d1ORN\\u803b\\xde\\u40deADE;\\u6122\\u0100Hc\\u124e\\u1252cy;\\u440by;\\u4426\\u0100bu\\u125a\\u125c;\\u4009;\\u43a4\\u0180aey\\u1265\\u126a\\u126fron;\\u4164dil;\\u4162;\\u4422r;\\uc000\\ud835\\udd17\\u0100ei\\u127b\\u1289\\u01f2\\u1280\\0\\u1287efore;\\u6234a;\\u4398\\u0100cn\\u128e\\u1298kSpace;\\uc000\\u205f\\u200aSpace;\\u6009lde\\u0200;EFT\\u12ab\\u12ac\\u12b2\\u12bc\\u623cqual;\\u6243ullEqual;\\u6245ilde;\\u6248pf;\\uc000\\ud835\\udd4bipleDot;\\u60db\\u0100ct\\u12d6\\u12dbr;\\uc000\\ud835\\udcafrok;\\u4166\\u0ae1\\u12f7\\u130e\\u131a\\u1326\\0\\u132c\\u1331\\0\\0\\0\\0\\0\\u1338\\u133d\\u1377\\u1385\\0\\u13ff\\u1404\\u140a\\u1410\\u0100cr\\u12fb\\u1301ute\\u803b\\xda\\u40dar\\u0100;o\\u1307\\u1308\\u619fcir;\\u6949r\\u01e3\\u1313\\0\\u1316y;\\u440eve;\\u416c\\u0100iy\\u131e\\u1323rc\\u803b\\xdb\\u40db;\\u4423blac;\\u4170r;\\uc000\\ud835\\udd18rave\\u803b\\xd9\\u40d9acr;\\u416a\\u0100di\\u1341\\u1369er\\u0100BP\\u1348\\u135d\\u0100ar\\u134d\\u1350r;\\u405fac\\u0100ek\\u1357\\u1359;\\u63dfet;\\u63b5arenthesis;\\u63ddon\\u0100;P\\u1370\\u1371\\u62c3lus;\\u628e\\u0100gp\\u137b\\u137fon;\\u4172f;\\uc000\\ud835\\udd4c\\u0400ADETadps\\u1395\\u13ae\\u13b8\\u13c4\\u03e8\\u13d2\\u13d7\\u13f3rrow\\u0180;BD\\u1150\\u13a0\\u13a4ar;\\u6912ownArrow;\\u61c5ownArrow;\\u6195quilibrium;\\u696eee\\u0100;A\\u13cb\\u13cc\\u62a5rrow;\\u61a5own\\xe1\\u03f3er\\u0100LR\\u13de\\u13e8eftArrow;\\u6196ightArrow;\\u6197i\\u0100;l\\u13f9\\u13fa\\u43d2on;\\u43a5ing;\\u416ecr;\\uc000\\ud835\\udcb0ilde;\\u4168ml\\u803b\\xdc\\u40dc\\u0480Dbcdefosv\\u1427\\u142c\\u1430\\u1433\\u143e\\u1485\\u148a\\u1490\\u1496ash;\\u62abar;\\u6aeby;\\u4412ash\\u0100;l\\u143b\\u143c\\u62a9;\\u6ae6\\u0100er\\u1443\\u1445;\\u62c1\\u0180bty\\u144c\\u1450\\u147aar;\\u6016\\u0100;i\\u144f\\u1455cal\\u0200BLST\\u1461\\u1465\\u146a\\u1474ar;\\u6223ine;\\u407ceparator;\\u6758ilde;\\u6240ThinSpace;\\u600ar;\\uc000\\ud835\\udd19pf;\\uc000\\ud835\\udd4dcr;\\uc000\\ud835\\udcb1dash;\\u62aa\\u0280cefos\\u14a7\\u14ac\\u14b1\\u14b6\\u14bcirc;\\u4174dge;\\u62c0r;\\uc000\\ud835\\udd1apf;\\uc000\\ud835\\udd4ecr;\\uc000\\ud835\\udcb2\\u0200fios\\u14cb\\u14d0\\u14d2\\u14d8r;\\uc000\\ud835\\udd1b;\\u439epf;\\uc000\\ud835\\udd4fcr;\\uc000\\ud835\\udcb3\\u0480AIUacfosu\\u14f1\\u14f5\\u14f9\\u14fd\\u1504\\u150f\\u1514\\u151a\\u1520cy;\\u442fcy;\\u4407cy;\\u442ecute\\u803b\\xdd\\u40dd\\u0100iy\\u1509\\u150drc;\\u4176;\\u442br;\\uc000\\ud835\\udd1cpf;\\uc000\\ud835\\udd50cr;\\uc000\\ud835\\udcb4ml;\\u4178\\u0400Hacdefos\\u1535\\u1539\\u153f\\u154b\\u154f\\u155d\\u1560\\u1564cy;\\u4416cute;\\u4179\\u0100ay\\u1544\\u1549ron;\\u417d;\\u4417ot;\\u417b\\u01f2\\u1554\\0\\u155boWidt\\xe8\\u0ad9a;\\u4396r;\\u6128pf;\\u6124cr;\\uc000\\ud835\\udcb5\\u0be1\\u1583\\u158a\\u1590\\0\\u15b0\\u15b6\\u15bf\\0\\0\\0\\0\\u15c6\\u15db\\u15eb\\u165f\\u166d\\0\\u1695\\u169b\\u16b2\\u16b9\\0\\u16becute\\u803b\\xe1\\u40e1reve;\\u4103\\u0300;Ediuy\\u159c\\u159d\\u15a1\\u15a3\\u15a8\\u15ad\\u623e;\\uc000\\u223e\\u0333;\\u623frc\\u803b\\xe2\\u40e2te\\u80bb\\xb4\\u0306;\\u4430lig\\u803b\\xe6\\u40e6\\u0100;r\\xb2\\u15ba;\\uc000\\ud835\\udd1erave\\u803b\\xe0\\u40e0\\u0100ep\\u15ca\\u15d6\\u0100fp\\u15cf\\u15d4sym;\\u6135\\xe8\\u15d3ha;\\u43b1\\u0100ap\\u15dfc\\u0100cl\\u15e4\\u15e7r;\\u4101g;\\u6a3f\\u0264\\u15f0\\0\\0\\u160a\\u0280;adsv\\u15fa\\u15fb\\u15ff\\u1601\\u1607\\u6227nd;\\u6a55;\\u6a5clope;\\u6a58;\\u6a5a\\u0380;elmrsz\\u1618\\u1619\\u161b\\u161e\\u163f\\u164f\\u1659\\u6220;\\u69a4e\\xbb\\u1619sd\\u0100;a\\u1625\\u1626\\u6221\\u0461\\u1630\\u1632\\u1634\\u1636\\u1638\\u163a\\u163c\\u163e;\\u69a8;\\u69a9;\\u69aa;\\u69ab;\\u69ac;\\u69ad;\\u69ae;\\u69aft\\u0100;v\\u1645\\u1646\\u621fb\\u0100;d\\u164c\\u164d\\u62be;\\u699d\\u0100pt\\u1654\\u1657h;\\u6222\\xbb\\xb9arr;\\u637c\\u0100gp\\u1663\\u1667on;\\u4105f;\\uc000\\ud835\\udd52\\u0380;Eaeiop\\u12c1\\u167b\\u167d\\u1682\\u1684\\u1687\\u168a;\\u6a70cir;\\u6a6f;\\u624ad;\\u624bs;\\u4027rox\\u0100;e\\u12c1\\u1692\\xf1\\u1683ing\\u803b\\xe5\\u40e5\\u0180cty\\u16a1\\u16a6\\u16a8r;\\uc000\\ud835\\udcb6;\\u402amp\\u0100;e\\u12c1\\u16af\\xf1\\u0288ilde\\u803b\\xe3\\u40e3ml\\u803b\\xe4\\u40e4\\u0100ci\\u16c2\\u16c8onin\\xf4\\u0272nt;\\u6a11\\u0800Nabcdefiklnoprsu\\u16ed\\u16f1\\u1730\\u173c\\u1743\\u1748\\u1778\\u177d\\u17e0\\u17e6\\u1839\\u1850\\u170d\\u193d\\u1948\\u1970ot;\\u6aed\\u0100cr\\u16f6\\u171ek\\u0200ceps\\u1700\\u1705\\u170d\\u1713ong;\\u624cpsilon;\\u43f6rime;\\u6035im\\u0100;e\\u171a\\u171b\\u623dq;\\u62cd\\u0176\\u1722\\u1726ee;\\u62bded\\u0100;g\\u172c\\u172d\\u6305e\\xbb\\u172drk\\u0100;t\\u135c\\u1737brk;\\u63b6\\u0100oy\\u1701\\u1741;\\u4431quo;\\u601e\\u0280cmprt\\u1753\\u175b\\u1761\\u1764\\u1768aus\\u0100;e\\u010a\\u0109ptyv;\\u69b0s\\xe9\\u170cno\\xf5\\u0113\\u0180ahw\\u176f\\u1771\\u1773;\\u43b2;\\u6136een;\\u626cr;\\uc000\\ud835\\udd1fg\\u0380costuvw\\u178d\\u179d\\u17b3\\u17c1\\u17d5\\u17db\\u17de\\u0180aiu\\u1794\\u1796\\u179a\\xf0\\u0760rc;\\u65efp\\xbb\\u1371\\u0180dpt\\u17a4\\u17a8\\u17adot;\\u6a00lus;\\u6a01imes;\\u6a02\\u0271\\u17b9\\0\\0\\u17becup;\\u6a06ar;\\u6605riangle\\u0100du\\u17cd\\u17d2own;\\u65bdp;\\u65b3plus;\\u6a04e\\xe5\\u1444\\xe5\\u14adarow;\\u690d\\u0180ako\\u17ed\\u1826\\u1835\\u0100cn\\u17f2\\u1823k\\u0180lst\\u17fa\\u05ab\\u1802ozenge;\\u69ebriangle\\u0200;dlr\\u1812\\u1813\\u1818\\u181d\\u65b4own;\\u65beeft;\\u65c2ight;\\u65b8k;\\u6423\\u01b1\\u182b\\0\\u1833\\u01b2\\u182f\\0\\u1831;\\u6592;\\u65914;\\u6593ck;\\u6588\\u0100eo\\u183e\\u184d\\u0100;q\\u1843\\u1846\\uc000=\\u20e5uiv;\\uc000\\u2261\\u20e5t;\\u6310\\u0200ptwx\\u1859\\u185e\\u1867\\u186cf;\\uc000\\ud835\\udd53\\u0100;t\\u13cb\\u1863om\\xbb\\u13cctie;\\u62c8\\u0600DHUVbdhmptuv\\u1885\\u1896\\u18aa\\u18bb\\u18d7\\u18db\\u18ec\\u18ff\\u1905\\u190a\\u1910\\u1921\\u0200LRlr\\u188e\\u1890\\u1892\\u1894;\\u6557;\\u6554;\\u6556;\\u6553\\u0280;DUdu\\u18a1\\u18a2\\u18a4\\u18a6\\u18a8\\u6550;\\u6566;\\u6569;\\u6564;\\u6567\\u0200LRlr\\u18b3\\u18b5\\u18b7\\u18b9;\\u655d;\\u655a;\\u655c;\\u6559\\u0380;HLRhlr\\u18ca\\u18cb\\u18cd\\u18cf\\u18d1\\u18d3\\u18d5\\u6551;\\u656c;\\u6563;\\u6560;\\u656b;\\u6562;\\u655fox;\\u69c9\\u0200LRlr\\u18e4\\u18e6\\u18e8\\u18ea;\\u6555;\\u6552;\\u6510;\\u650c\\u0280;DUdu\\u06bd\\u18f7\\u18f9\\u18fb\\u18fd;\\u6565;\\u6568;\\u652c;\\u6534inus;\\u629flus;\\u629eimes;\\u62a0\\u0200LRlr\\u1919\\u191b\\u191d\\u191f;\\u655b;\\u6558;\\u6518;\\u6514\\u0380;HLRhlr\\u1930\\u1931\\u1933\\u1935\\u1937\\u1939\\u193b\\u6502;\\u656a;\\u6561;\\u655e;\\u653c;\\u6524;\\u651c\\u0100ev\\u0123\\u1942bar\\u803b\\xa6\\u40a6\\u0200ceio\\u1951\\u1956\\u195a\\u1960r;\\uc000\\ud835\\udcb7mi;\\u604fm\\u0100;e\\u171a\\u171cl\\u0180;bh\\u1968\\u1969\\u196b\\u405c;\\u69c5sub;\\u67c8\\u016c\\u1974\\u197el\\u0100;e\\u1979\\u197a\\u6022t\\xbb\\u197ap\\u0180;Ee\\u012f\\u1985\\u1987;\\u6aae\\u0100;q\\u06dc\\u06db\\u0ce1\\u19a7\\0\\u19e8\\u1a11\\u1a15\\u1a32\\0\\u1a37\\u1a50\\0\\0\\u1ab4\\0\\0\\u1ac1\\0\\0\\u1b21\\u1b2e\\u1b4d\\u1b52\\0\\u1bfd\\0\\u1c0c\\u0180cpr\\u19ad\\u19b2\\u19ddute;\\u4107\\u0300;abcds\\u19bf\\u19c0\\u19c4\\u19ca\\u19d5\\u19d9\\u6229nd;\\u6a44rcup;\\u6a49\\u0100au\\u19cf\\u19d2p;\\u6a4bp;\\u6a47ot;\\u6a40;\\uc000\\u2229\\ufe00\\u0100eo\\u19e2\\u19e5t;\\u6041\\xee\\u0693\\u0200aeiu\\u19f0\\u19fb\\u1a01\\u1a05\\u01f0\\u19f5\\0\\u19f8s;\\u6a4don;\\u410ddil\\u803b\\xe7\\u40e7rc;\\u4109ps\\u0100;s\\u1a0c\\u1a0d\\u6a4cm;\\u6a50ot;\\u410b\\u0180dmn\\u1a1b\\u1a20\\u1a26il\\u80bb\\xb8\\u01adptyv;\\u69b2t\\u8100\\xa2;e\\u1a2d\\u1a2e\\u40a2r\\xe4\\u01b2r;\\uc000\\ud835\\udd20\\u0180cei\\u1a3d\\u1a40\\u1a4dy;\\u4447ck\\u0100;m\\u1a47\\u1a48\\u6713ark\\xbb\\u1a48;\\u43c7r\\u0380;Ecefms\\u1a5f\\u1a60\\u1a62\\u1a6b\\u1aa4\\u1aaa\\u1aae\\u65cb;\\u69c3\\u0180;el\\u1a69\\u1a6a\\u1a6d\\u42c6q;\\u6257e\\u0261\\u1a74\\0\\0\\u1a88rrow\\u0100lr\\u1a7c\\u1a81eft;\\u61baight;\\u61bb\\u0280RSacd\\u1a92\\u1a94\\u1a96\\u1a9a\\u1a9f\\xbb\\u0f47;\\u64c8st;\\u629birc;\\u629aash;\\u629dnint;\\u6a10id;\\u6aefcir;\\u69c2ubs\\u0100;u\\u1abb\\u1abc\\u6663it\\xbb\\u1abc\\u02ec\\u1ac7\\u1ad4\\u1afa\\0\\u1b0aon\\u0100;e\\u1acd\\u1ace\\u403a\\u0100;q\\xc7\\xc6\\u026d\\u1ad9\\0\\0\\u1ae2a\\u0100;t\\u1ade\\u1adf\\u402c;\\u4040\\u0180;fl\\u1ae8\\u1ae9\\u1aeb\\u6201\\xee\\u1160e\\u0100mx\\u1af1\\u1af6ent\\xbb\\u1ae9e\\xf3\\u024d\\u01e7\\u1afe\\0\\u1b07\\u0100;d\\u12bb\\u1b02ot;\\u6a6dn\\xf4\\u0246\\u0180fry\\u1b10\\u1b14\\u1b17;\\uc000\\ud835\\udd54o\\xe4\\u0254\\u8100\\xa9;s\\u0155\\u1b1dr;\\u6117\\u0100ao\\u1b25\\u1b29rr;\\u61b5ss;\\u6717\\u0100cu\\u1b32\\u1b37r;\\uc000\\ud835\\udcb8\\u0100bp\\u1b3c\\u1b44\\u0100;e\\u1b41\\u1b42\\u6acf;\\u6ad1\\u0100;e\\u1b49\\u1b4a\\u6ad0;\\u6ad2dot;\\u62ef\\u0380delprvw\\u1b60\\u1b6c\\u1b77\\u1b82\\u1bac\\u1bd4\\u1bf9arr\\u0100lr\\u1b68\\u1b6a;\\u6938;\\u6935\\u0270\\u1b72\\0\\0\\u1b75r;\\u62dec;\\u62dfarr\\u0100;p\\u1b7f\\u1b80\\u61b6;\\u693d\\u0300;bcdos\\u1b8f\\u1b90\\u1b96\\u1ba1\\u1ba5\\u1ba8\\u622arcap;\\u6a48\\u0100au\\u1b9b\\u1b9ep;\\u6a46p;\\u6a4aot;\\u628dr;\\u6a45;\\uc000\\u222a\\ufe00\\u0200alrv\\u1bb5\\u1bbf\\u1bde\\u1be3rr\\u0100;m\\u1bbc\\u1bbd\\u61b7;\\u693cy\\u0180evw\\u1bc7\\u1bd4\\u1bd8q\\u0270\\u1bce\\0\\0\\u1bd2re\\xe3\\u1b73u\\xe3\\u1b75ee;\\u62ceedge;\\u62cfen\\u803b\\xa4\\u40a4earrow\\u0100lr\\u1bee\\u1bf3eft\\xbb\\u1b80ight\\xbb\\u1bbde\\xe4\\u1bdd\\u0100ci\\u1c01\\u1c07onin\\xf4\\u01f7nt;\\u6231lcty;\\u632d\\u0980AHabcdefhijlorstuwz\\u1c38\\u1c3b\\u1c3f\\u1c5d\\u1c69\\u1c75\\u1c8a\\u1c9e\\u1cac\\u1cb7\\u1cfb\\u1cff\\u1d0d\\u1d7b\\u1d91\\u1dab\\u1dbb\\u1dc6\\u1dcdr\\xf2\\u0381ar;\\u6965\\u0200glrs\\u1c48\\u1c4d\\u1c52\\u1c54ger;\\u6020eth;\\u6138\\xf2\\u1133h\\u0100;v\\u1c5a\\u1c5b\\u6010\\xbb\\u090a\\u016b\\u1c61\\u1c67arow;\\u690fa\\xe3\\u0315\\u0100ay\\u1c6e\\u1c73ron;\\u410f;\\u4434\\u0180;ao\\u0332\\u1c7c\\u1c84\\u0100gr\\u02bf\\u1c81r;\\u61catseq;\\u6a77\\u0180glm\\u1c91\\u1c94\\u1c98\\u803b\\xb0\\u40b0ta;\\u43b4ptyv;\\u69b1\\u0100ir\\u1ca3\\u1ca8sht;\\u697f;\\uc000\\ud835\\udd21ar\\u0100lr\\u1cb3\\u1cb5\\xbb\\u08dc\\xbb\\u101e\\u0280aegsv\\u1cc2\\u0378\\u1cd6\\u1cdc\\u1ce0m\\u0180;os\\u0326\\u1cca\\u1cd4nd\\u0100;s\\u0326\\u1cd1uit;\\u6666amma;\\u43ddin;\\u62f2\\u0180;io\\u1ce7\\u1ce8\\u1cf8\\u40f7de\\u8100\\xf7;o\\u1ce7\\u1cf0ntimes;\\u62c7n\\xf8\\u1cf7cy;\\u4452c\\u026f\\u1d06\\0\\0\\u1d0arn;\\u631eop;\\u630d\\u0280lptuw\\u1d18\\u1d1d\\u1d22\\u1d49\\u1d55lar;\\u4024f;\\uc000\\ud835\\udd55\\u0280;emps\\u030b\\u1d2d\\u1d37\\u1d3d\\u1d42q\\u0100;d\\u0352\\u1d33ot;\\u6251inus;\\u6238lus;\\u6214quare;\\u62a1blebarwedg\\xe5\\xfan\\u0180adh\\u112e\\u1d5d\\u1d67ownarrow\\xf3\\u1c83arpoon\\u0100lr\\u1d72\\u1d76ef\\xf4\\u1cb4igh\\xf4\\u1cb6\\u0162\\u1d7f\\u1d85karo\\xf7\\u0f42\\u026f\\u1d8a\\0\\0\\u1d8ern;\\u631fop;\\u630c\\u0180cot\\u1d98\\u1da3\\u1da6\\u0100ry\\u1d9d\\u1da1;\\uc000\\ud835\\udcb9;\\u4455l;\\u69f6rok;\\u4111\\u0100dr\\u1db0\\u1db4ot;\\u62f1i\\u0100;f\\u1dba\\u1816\\u65bf\\u0100ah\\u1dc0\\u1dc3r\\xf2\\u0429a\\xf2\\u0fa6angle;\\u69a6\\u0100ci\\u1dd2\\u1dd5y;\\u445fgrarr;\\u67ff\\u0900Dacdefglmnopqrstux\\u1e01\\u1e09\\u1e19\\u1e38\\u0578\\u1e3c\\u1e49\\u1e61\\u1e7e\\u1ea5\\u1eaf\\u1ebd\\u1ee1\\u1f2a\\u1f37\\u1f44\\u1f4e\\u1f5a\\u0100Do\\u1e06\\u1d34o\\xf4\\u1c89\\u0100cs\\u1e0e\\u1e14ute\\u803b\\xe9\\u40e9ter;\\u6a6e\\u0200aioy\\u1e22\\u1e27\\u1e31\\u1e36ron;\\u411br\\u0100;c\\u1e2d\\u1e2e\\u6256\\u803b\\xea\\u40ealon;\\u6255;\\u444dot;\\u4117\\u0100Dr\\u1e41\\u1e45ot;\\u6252;\\uc000\\ud835\\udd22\\u0180;rs\\u1e50\\u1e51\\u1e57\\u6a9aave\\u803b\\xe8\\u40e8\\u0100;d\\u1e5c\\u1e5d\\u6a96ot;\\u6a98\\u0200;ils\\u1e6a\\u1e6b\\u1e72\\u1e74\\u6a99nters;\\u63e7;\\u6113\\u0100;d\\u1e79\\u1e7a\\u6a95ot;\\u6a97\\u0180aps\\u1e85\\u1e89\\u1e97cr;\\u4113ty\\u0180;sv\\u1e92\\u1e93\\u1e95\\u6205et\\xbb\\u1e93p\\u01001;\\u1e9d\\u1ea4\\u0133\\u1ea1\\u1ea3;\\u6004;\\u6005\\u6003\\u0100gs\\u1eaa\\u1eac;\\u414bp;\\u6002\\u0100gp\\u1eb4\\u1eb8on;\\u4119f;\\uc000\\ud835\\udd56\\u0180als\\u1ec4\\u1ece\\u1ed2r\\u0100;s\\u1eca\\u1ecb\\u62d5l;\\u69e3us;\\u6a71i\\u0180;lv\\u1eda\\u1edb\\u1edf\\u43b5on\\xbb\\u1edb;\\u43f5\\u0200csuv\\u1eea\\u1ef3\\u1f0b\\u1f23\\u0100io\\u1eef\\u1e31rc\\xbb\\u1e2e\\u0269\\u1ef9\\0\\0\\u1efb\\xed\\u0548ant\\u0100gl\\u1f02\\u1f06tr\\xbb\\u1e5dess\\xbb\\u1e7a\\u0180aei\\u1f12\\u1f16\\u1f1als;\\u403dst;\\u625fv\\u0100;D\\u0235\\u1f20D;\\u6a78parsl;\\u69e5\\u0100Da\\u1f2f\\u1f33ot;\\u6253rr;\\u6971\\u0180cdi\\u1f3e\\u1f41\\u1ef8r;\\u612fo\\xf4\\u0352\\u0100ah\\u1f49\\u1f4b;\\u43b7\\u803b\\xf0\\u40f0\\u0100mr\\u1f53\\u1f57l\\u803b\\xeb\\u40ebo;\\u60ac\\u0180cip\\u1f61\\u1f64\\u1f67l;\\u4021s\\xf4\\u056e\\u0100eo\\u1f6c\\u1f74ctatio\\xee\\u0559nential\\xe5\\u0579\\u09e1\\u1f92\\0\\u1f9e\\0\\u1fa1\\u1fa7\\0\\0\\u1fc6\\u1fcc\\0\\u1fd3\\0\\u1fe6\\u1fea\\u2000\\0\\u2008\\u205allingdotse\\xf1\\u1e44y;\\u4444male;\\u6640\\u0180ilr\\u1fad\\u1fb3\\u1fc1lig;\\u8000\\ufb03\\u0269\\u1fb9\\0\\0\\u1fbdg;\\u8000\\ufb00ig;\\u8000\\ufb04;\\uc000\\ud835\\udd23lig;\\u8000\\ufb01lig;\\uc000fj\\u0180alt\\u1fd9\\u1fdc\\u1fe1t;\\u666dig;\\u8000\\ufb02ns;\\u65b1of;\\u4192\\u01f0\\u1fee\\0\\u1ff3f;\\uc000\\ud835\\udd57\\u0100ak\\u05bf\\u1ff7\\u0100;v\\u1ffc\\u1ffd\\u62d4;\\u6ad9artint;\\u6a0d\\u0100ao\\u200c\\u2055\\u0100cs\\u2011\\u2052\\u03b1\\u201a\\u2030\\u2038\\u2045\\u2048\\0\\u2050\\u03b2\\u2022\\u2025\\u2027\\u202a\\u202c\\0\\u202e\\u803b\\xbd\\u40bd;\\u6153\\u803b\\xbc\\u40bc;\\u6155;\\u6159;\\u615b\\u01b3\\u2034\\0\\u2036;\\u6154;\\u6156\\u02b4\\u203e\\u2041\\0\\0\\u2043\\u803b\\xbe\\u40be;\\u6157;\\u615c5;\\u6158\\u01b6\\u204c\\0\\u204e;\\u615a;\\u615d8;\\u615el;\\u6044wn;\\u6322cr;\\uc000\\ud835\\udcbb\\u0880Eabcdefgijlnorstv\\u2082\\u2089\\u209f\\u20a5\\u20b0\\u20b4\\u20f0\\u20f5\\u20fa\\u20ff\\u2103\\u2112\\u2138\\u0317\\u213e\\u2152\\u219e\\u0100;l\\u064d\\u2087;\\u6a8c\\u0180cmp\\u2090\\u2095\\u209dute;\\u41f5ma\\u0100;d\\u209c\\u1cda\\u43b3;\\u6a86reve;\\u411f\\u0100iy\\u20aa\\u20aerc;\\u411d;\\u4433ot;\\u4121\\u0200;lqs\\u063e\\u0642\\u20bd\\u20c9\\u0180;qs\\u063e\\u064c\\u20c4lan\\xf4\\u0665\\u0200;cdl\\u0665\\u20d2\\u20d5\\u20e5c;\\u6aa9ot\\u0100;o\\u20dc\\u20dd\\u6a80\\u0100;l\\u20e2\\u20e3\\u6a82;\\u6a84\\u0100;e\\u20ea\\u20ed\\uc000\\u22db\\ufe00s;\\u6a94r;\\uc000\\ud835\\udd24\\u0100;g\\u0673\\u061bmel;\\u6137cy;\\u4453\\u0200;Eaj\\u065a\\u210c\\u210e\\u2110;\\u6a92;\\u6aa5;\\u6aa4\\u0200Eaes\\u211b\\u211d\\u2129\\u2134;\\u6269p\\u0100;p\\u2123\\u2124\\u6a8arox\\xbb\\u2124\\u0100;q\\u212e\\u212f\\u6a88\\u0100;q\\u212e\\u211bim;\\u62e7pf;\\uc000\\ud835\\udd58\\u0100ci\\u2143\\u2146r;\\u610am\\u0180;el\\u066b\\u214e\\u2150;\\u6a8e;\\u6a90\\u8300>;cdlqr\\u05ee\\u2160\\u216a\\u216e\\u2173\\u2179\\u0100ci\\u2165\\u2167;\\u6aa7r;\\u6a7aot;\\u62d7Par;\\u6995uest;\\u6a7c\\u0280adels\\u2184\\u216a\\u2190\\u0656\\u219b\\u01f0\\u2189\\0\\u218epro\\xf8\\u209er;\\u6978q\\u0100lq\\u063f\\u2196les\\xf3\\u2088i\\xed\\u066b\\u0100en\\u21a3\\u21adrtneqq;\\uc000\\u2269\\ufe00\\xc5\\u21aa\\u0500Aabcefkosy\\u21c4\\u21c7\\u21f1\\u21f5\\u21fa\\u2218\\u221d\\u222f\\u2268\\u227dr\\xf2\\u03a0\\u0200ilmr\\u21d0\\u21d4\\u21d7\\u21dbrs\\xf0\\u1484f\\xbb\\u2024il\\xf4\\u06a9\\u0100dr\\u21e0\\u21e4cy;\\u444a\\u0180;cw\\u08f4\\u21eb\\u21efir;\\u6948;\\u61adar;\\u610firc;\\u4125\\u0180alr\\u2201\\u220e\\u2213rts\\u0100;u\\u2209\\u220a\\u6665it\\xbb\\u220alip;\\u6026con;\\u62b9r;\\uc000\\ud835\\udd25s\\u0100ew\\u2223\\u2229arow;\\u6925arow;\\u6926\\u0280amopr\\u223a\\u223e\\u2243\\u225e\\u2263rr;\\u61fftht;\\u623bk\\u0100lr\\u2249\\u2253eftarrow;\\u61a9ightarrow;\\u61aaf;\\uc000\\ud835\\udd59bar;\\u6015\\u0180clt\\u226f\\u2274\\u2278r;\\uc000\\ud835\\udcbdas\\xe8\\u21f4rok;\\u4127\\u0100bp\\u2282\\u2287ull;\\u6043hen\\xbb\\u1c5b\\u0ae1\\u22a3\\0\\u22aa\\0\\u22b8\\u22c5\\u22ce\\0\\u22d5\\u22f3\\0\\0\\u22f8\\u2322\\u2367\\u2362\\u237f\\0\\u2386\\u23aa\\u23b4cute\\u803b\\xed\\u40ed\\u0180;iy\\u0771\\u22b0\\u22b5rc\\u803b\\xee\\u40ee;\\u4438\\u0100cx\\u22bc\\u22bfy;\\u4435cl\\u803b\\xa1\\u40a1\\u0100fr\\u039f\\u22c9;\\uc000\\ud835\\udd26rave\\u803b\\xec\\u40ec\\u0200;ino\\u073e\\u22dd\\u22e9\\u22ee\\u0100in\\u22e2\\u22e6nt;\\u6a0ct;\\u622dfin;\\u69dcta;\\u6129lig;\\u4133\\u0180aop\\u22fe\\u231a\\u231d\\u0180cgt\\u2305\\u2308\\u2317r;\\u412b\\u0180elp\\u071f\\u230f\\u2313in\\xe5\\u078ear\\xf4\\u0720h;\\u4131f;\\u62b7ed;\\u41b5\\u0280;cfot\\u04f4\\u232c\\u2331\\u233d\\u2341are;\\u6105in\\u0100;t\\u2338\\u2339\\u621eie;\\u69dddo\\xf4\\u2319\\u0280;celp\\u0757\\u234c\\u2350\\u235b\\u2361al;\\u62ba\\u0100gr\\u2355\\u2359er\\xf3\\u1563\\xe3\\u234darhk;\\u6a17rod;\\u6a3c\\u0200cgpt\\u236f\\u2372\\u2376\\u237by;\\u4451on;\\u412ff;\\uc000\\ud835\\udd5aa;\\u43b9uest\\u803b\\xbf\\u40bf\\u0100ci\\u238a\\u238fr;\\uc000\\ud835\\udcben\\u0280;Edsv\\u04f4\\u239b\\u239d\\u23a1\\u04f3;\\u62f9ot;\\u62f5\\u0100;v\\u23a6\\u23a7\\u62f4;\\u62f3\\u0100;i\\u0777\\u23aelde;\\u4129\\u01eb\\u23b8\\0\\u23bccy;\\u4456l\\u803b\\xef\\u40ef\\u0300cfmosu\\u23cc\\u23d7\\u23dc\\u23e1\\u23e7\\u23f5\\u0100iy\\u23d1\\u23d5rc;\\u4135;\\u4439r;\\uc000\\ud835\\udd27ath;\\u4237pf;\\uc000\\ud835\\udd5b\\u01e3\\u23ec\\0\\u23f1r;\\uc000\\ud835\\udcbfrcy;\\u4458kcy;\\u4454\\u0400acfghjos\\u240b\\u2416\\u2422\\u2427\\u242d\\u2431\\u2435\\u243bppa\\u0100;v\\u2413\\u2414\\u43ba;\\u43f0\\u0100ey\\u241b\\u2420dil;\\u4137;\\u443ar;\\uc000\\ud835\\udd28reen;\\u4138cy;\\u4445cy;\\u445cpf;\\uc000\\ud835\\udd5ccr;\\uc000\\ud835\\udcc0\\u0b80ABEHabcdefghjlmnoprstuv\\u2470\\u2481\\u2486\\u248d\\u2491\\u250e\\u253d\\u255a\\u2580\\u264e\\u265e\\u2665\\u2679\\u267d\\u269a\\u26b2\\u26d8\\u275d\\u2768\\u278b\\u27c0\\u2801\\u2812\\u0180art\\u2477\\u247a\\u247cr\\xf2\\u09c6\\xf2\\u0395ail;\\u691barr;\\u690e\\u0100;g\\u0994\\u248b;\\u6a8bar;\\u6962\\u0963\\u24a5\\0\\u24aa\\0\\u24b1\\0\\0\\0\\0\\0\\u24b5\\u24ba\\0\\u24c6\\u24c8\\u24cd\\0\\u24f9ute;\\u413amptyv;\\u69b4ra\\xee\\u084cbda;\\u43bbg\\u0180;dl\\u088e\\u24c1\\u24c3;\\u6991\\xe5\\u088e;\\u6a85uo\\u803b\\xab\\u40abr\\u0400;bfhlpst\\u0899\\u24de\\u24e6\\u24e9\\u24eb\\u24ee\\u24f1\\u24f5\\u0100;f\\u089d\\u24e3s;\\u691fs;\\u691d\\xeb\\u2252p;\\u61abl;\\u6939im;\\u6973l;\\u61a2\\u0180;ae\\u24ff\\u2500\\u2504\\u6aabil;\\u6919\\u0100;s\\u2509\\u250a\\u6aad;\\uc000\\u2aad\\ufe00\\u0180abr\\u2515\\u2519\\u251drr;\\u690crk;\\u6772\\u0100ak\\u2522\\u252cc\\u0100ek\\u2528\\u252a;\\u407b;\\u405b\\u0100es\\u2531\\u2533;\\u698bl\\u0100du\\u2539\\u253b;\\u698f;\\u698d\\u0200aeuy\\u2546\\u254b\\u2556\\u2558ron;\\u413e\\u0100di\\u2550\\u2554il;\\u413c\\xec\\u08b0\\xe2\\u2529;\\u443b\\u0200cqrs\\u2563\\u2566\\u256d\\u257da;\\u6936uo\\u0100;r\\u0e19\\u1746\\u0100du\\u2572\\u2577har;\\u6967shar;\\u694bh;\\u61b2\\u0280;fgqs\\u258b\\u258c\\u0989\\u25f3\\u25ff\\u6264t\\u0280ahlrt\\u2598\\u25a4\\u25b7\\u25c2\\u25e8rrow\\u0100;t\\u0899\\u25a1a\\xe9\\u24f6arpoon\\u0100du\\u25af\\u25b4own\\xbb\\u045ap\\xbb\\u0966eftarrows;\\u61c7ight\\u0180ahs\\u25cd\\u25d6\\u25derrow\\u0100;s\\u08f4\\u08a7arpoon\\xf3\\u0f98quigarro\\xf7\\u21f0hreetimes;\\u62cb\\u0180;qs\\u258b\\u0993\\u25falan\\xf4\\u09ac\\u0280;cdgs\\u09ac\\u260a\\u260d\\u261d\\u2628c;\\u6aa8ot\\u0100;o\\u2614\\u2615\\u6a7f\\u0100;r\\u261a\\u261b\\u6a81;\\u6a83\\u0100;e\\u2622\\u2625\\uc000\\u22da\\ufe00s;\\u6a93\\u0280adegs\\u2633\\u2639\\u263d\\u2649\\u264bppro\\xf8\\u24c6ot;\\u62d6q\\u0100gq\\u2643\\u2645\\xf4\\u0989gt\\xf2\\u248c\\xf4\\u099bi\\xed\\u09b2\\u0180ilr\\u2655\\u08e1\\u265asht;\\u697c;\\uc000\\ud835\\udd29\\u0100;E\\u099c\\u2663;\\u6a91\\u0161\\u2669\\u2676r\\u0100du\\u25b2\\u266e\\u0100;l\\u0965\\u2673;\\u696alk;\\u6584cy;\\u4459\\u0280;acht\\u0a48\\u2688\\u268b\\u2691\\u2696r\\xf2\\u25c1orne\\xf2\\u1d08ard;\\u696bri;\\u65fa\\u0100io\\u269f\\u26a4dot;\\u4140ust\\u0100;a\\u26ac\\u26ad\\u63b0che\\xbb\\u26ad\\u0200Eaes\\u26bb\\u26bd\\u26c9\\u26d4;\\u6268p\\u0100;p\\u26c3\\u26c4\\u6a89rox\\xbb\\u26c4\\u0100;q\\u26ce\\u26cf\\u6a87\\u0100;q\\u26ce\\u26bbim;\\u62e6\\u0400abnoptwz\\u26e9\\u26f4\\u26f7\\u271a\\u272f\\u2741\\u2747\\u2750\\u0100nr\\u26ee\\u26f1g;\\u67ecr;\\u61fdr\\xeb\\u08c1g\\u0180lmr\\u26ff\\u270d\\u2714eft\\u0100ar\\u09e6\\u2707ight\\xe1\\u09f2apsto;\\u67fcight\\xe1\\u09fdparrow\\u0100lr\\u2725\\u2729ef\\xf4\\u24edight;\\u61ac\\u0180afl\\u2736\\u2739\\u273dr;\\u6985;\\uc000\\ud835\\udd5dus;\\u6a2dimes;\\u6a34\\u0161\\u274b\\u274fst;\\u6217\\xe1\\u134e\\u0180;ef\\u2757\\u2758\\u1800\\u65cange\\xbb\\u2758ar\\u0100;l\\u2764\\u2765\\u4028t;\\u6993\\u0280achmt\\u2773\\u2776\\u277c\\u2785\\u2787r\\xf2\\u08a8orne\\xf2\\u1d8car\\u0100;d\\u0f98\\u2783;\\u696d;\\u600eri;\\u62bf\\u0300achiqt\\u2798\\u279d\\u0a40\\u27a2\\u27ae\\u27bbquo;\\u6039r;\\uc000\\ud835\\udcc1m\\u0180;eg\\u09b2\\u27aa\\u27ac;\\u6a8d;\\u6a8f\\u0100bu\\u252a\\u27b3o\\u0100;r\\u0e1f\\u27b9;\\u601arok;\\u4142\\u8400<;cdhilqr\\u082b\\u27d2\\u2639\\u27dc\\u27e0\\u27e5\\u27ea\\u27f0\\u0100ci\\u27d7\\u27d9;\\u6aa6r;\\u6a79re\\xe5\\u25f2mes;\\u62c9arr;\\u6976uest;\\u6a7b\\u0100Pi\\u27f5\\u27f9ar;\\u6996\\u0180;ef\\u2800\\u092d\\u181b\\u65c3r\\u0100du\\u2807\\u280dshar;\\u694ahar;\\u6966\\u0100en\\u2817\\u2821rtneqq;\\uc000\\u2268\\ufe00\\xc5\\u281e\\u0700Dacdefhilnopsu\\u2840\\u2845\\u2882\\u288e\\u2893\\u28a0\\u28a5\\u28a8\\u28da\\u28e2\\u28e4\\u0a83\\u28f3\\u2902Dot;\\u623a\\u0200clpr\\u284e\\u2852\\u2863\\u287dr\\u803b\\xaf\\u40af\\u0100et\\u2857\\u2859;\\u6642\\u0100;e\\u285e\\u285f\\u6720se\\xbb\\u285f\\u0100;s\\u103b\\u2868to\\u0200;dlu\\u103b\\u2873\\u2877\\u287bow\\xee\\u048cef\\xf4\\u090f\\xf0\\u13d1ker;\\u65ae\\u0100oy\\u2887\\u288cmma;\\u6a29;\\u443cash;\\u6014asuredangle\\xbb\\u1626r;\\uc000\\ud835\\udd2ao;\\u6127\\u0180cdn\\u28af\\u28b4\\u28c9ro\\u803b\\xb5\\u40b5\\u0200;acd\\u1464\\u28bd\\u28c0\\u28c4s\\xf4\\u16a7ir;\\u6af0ot\\u80bb\\xb7\\u01b5us\\u0180;bd\\u28d2\\u1903\\u28d3\\u6212\\u0100;u\\u1d3c\\u28d8;\\u6a2a\\u0163\\u28de\\u28e1p;\\u6adb\\xf2\\u2212\\xf0\\u0a81\\u0100dp\\u28e9\\u28eeels;\\u62a7f;\\uc000\\ud835\\udd5e\\u0100ct\\u28f8\\u28fdr;\\uc000\\ud835\\udcc2pos\\xbb\\u159d\\u0180;lm\\u2909\\u290a\\u290d\\u43bctimap;\\u62b8\\u0c00GLRVabcdefghijlmoprstuvw\\u2942\\u2953\\u297e\\u2989\\u2998\\u29da\\u29e9\\u2a15\\u2a1a\\u2a58\\u2a5d\\u2a83\\u2a95\\u2aa4\\u2aa8\\u2b04\\u2b07\\u2b44\\u2b7f\\u2bae\\u2c34\\u2c67\\u2c7c\\u2ce9\\u0100gt\\u2947\\u294b;\\uc000\\u22d9\\u0338\\u0100;v\\u2950\\u0bcf\\uc000\\u226b\\u20d2\\u0180elt\\u295a\\u2972\\u2976ft\\u0100ar\\u2961\\u2967rrow;\\u61cdightarrow;\\u61ce;\\uc000\\u22d8\\u0338\\u0100;v\\u297b\\u0c47\\uc000\\u226a\\u20d2ightarrow;\\u61cf\\u0100Dd\\u298e\\u2993ash;\\u62afash;\\u62ae\\u0280bcnpt\\u29a3\\u29a7\\u29ac\\u29b1\\u29ccla\\xbb\\u02deute;\\u4144g;\\uc000\\u2220\\u20d2\\u0280;Eiop\\u0d84\\u29bc\\u29c0\\u29c5\\u29c8;\\uc000\\u2a70\\u0338d;\\uc000\\u224b\\u0338s;\\u4149ro\\xf8\\u0d84ur\\u0100;a\\u29d3\\u29d4\\u666el\\u0100;s\\u29d3\\u0b38\\u01f3\\u29df\\0\\u29e3p\\u80bb\\xa0\\u0b37mp\\u0100;e\\u0bf9\\u0c00\\u0280aeouy\\u29f4\\u29fe\\u2a03\\u2a10\\u2a13\\u01f0\\u29f9\\0\\u29fb;\\u6a43on;\\u4148dil;\\u4146ng\\u0100;d\\u0d7e\\u2a0aot;\\uc000\\u2a6d\\u0338p;\\u6a42;\\u443dash;\\u6013\\u0380;Aadqsx\\u0b92\\u2a29\\u2a2d\\u2a3b\\u2a41\\u2a45\\u2a50rr;\\u61d7r\\u0100hr\\u2a33\\u2a36k;\\u6924\\u0100;o\\u13f2\\u13f0ot;\\uc000\\u2250\\u0338ui\\xf6\\u0b63\\u0100ei\\u2a4a\\u2a4ear;\\u6928\\xed\\u0b98ist\\u0100;s\\u0ba0\\u0b9fr;\\uc000\\ud835\\udd2b\\u0200Eest\\u0bc5\\u2a66\\u2a79\\u2a7c\\u0180;qs\\u0bbc\\u2a6d\\u0be1\\u0180;qs\\u0bbc\\u0bc5\\u2a74lan\\xf4\\u0be2i\\xed\\u0bea\\u0100;r\\u0bb6\\u2a81\\xbb\\u0bb7\\u0180Aap\\u2a8a\\u2a8d\\u2a91r\\xf2\\u2971rr;\\u61aear;\\u6af2\\u0180;sv\\u0f8d\\u2a9c\\u0f8c\\u0100;d\\u2aa1\\u2aa2\\u62fc;\\u62facy;\\u445a\\u0380AEadest\\u2ab7\\u2aba\\u2abe\\u2ac2\\u2ac5\\u2af6\\u2af9r\\xf2\\u2966;\\uc000\\u2266\\u0338rr;\\u619ar;\\u6025\\u0200;fqs\\u0c3b\\u2ace\\u2ae3\\u2aeft\\u0100ar\\u2ad4\\u2ad9rro\\xf7\\u2ac1ightarro\\xf7\\u2a90\\u0180;qs\\u0c3b\\u2aba\\u2aealan\\xf4\\u0c55\\u0100;s\\u0c55\\u2af4\\xbb\\u0c36i\\xed\\u0c5d\\u0100;r\\u0c35\\u2afei\\u0100;e\\u0c1a\\u0c25i\\xe4\\u0d90\\u0100pt\\u2b0c\\u2b11f;\\uc000\\ud835\\udd5f\\u8180\\xac;in\\u2b19\\u2b1a\\u2b36\\u40acn\\u0200;Edv\\u0b89\\u2b24\\u2b28\\u2b2e;\\uc000\\u22f9\\u0338ot;\\uc000\\u22f5\\u0338\\u01e1\\u0b89\\u2b33\\u2b35;\\u62f7;\\u62f6i\\u0100;v\\u0cb8\\u2b3c\\u01e1\\u0cb8\\u2b41\\u2b43;\\u62fe;\\u62fd\\u0180aor\\u2b4b\\u2b63\\u2b69r\\u0200;ast\\u0b7b\\u2b55\\u2b5a\\u2b5flle\\xec\\u0b7bl;\\uc000\\u2afd\\u20e5;\\uc000\\u2202\\u0338lint;\\u6a14\\u0180;ce\\u0c92\\u2b70\\u2b73u\\xe5\\u0ca5\\u0100;c\\u0c98\\u2b78\\u0100;e\\u0c92\\u2b7d\\xf1\\u0c98\\u0200Aait\\u2b88\\u2b8b\\u2b9d\\u2ba7r\\xf2\\u2988rr\\u0180;cw\\u2b94\\u2b95\\u2b99\\u619b;\\uc000\\u2933\\u0338;\\uc000\\u219d\\u0338ghtarrow\\xbb\\u2b95ri\\u0100;e\\u0ccb\\u0cd6\\u0380chimpqu\\u2bbd\\u2bcd\\u2bd9\\u2b04\\u0b78\\u2be4\\u2bef\\u0200;cer\\u0d32\\u2bc6\\u0d37\\u2bc9u\\xe5\\u0d45;\\uc000\\ud835\\udcc3ort\\u026d\\u2b05\\0\\0\\u2bd6ar\\xe1\\u2b56m\\u0100;e\\u0d6e\\u2bdf\\u0100;q\\u0d74\\u0d73su\\u0100bp\\u2beb\\u2bed\\xe5\\u0cf8\\xe5\\u0d0b\\u0180bcp\\u2bf6\\u2c11\\u2c19\\u0200;Ees\\u2bff\\u2c00\\u0d22\\u2c04\\u6284;\\uc000\\u2ac5\\u0338et\\u0100;e\\u0d1b\\u2c0bq\\u0100;q\\u0d23\\u2c00c\\u0100;e\\u0d32\\u2c17\\xf1\\u0d38\\u0200;Ees\\u2c22\\u2c23\\u0d5f\\u2c27\\u6285;\\uc000\\u2ac6\\u0338et\\u0100;e\\u0d58\\u2c2eq\\u0100;q\\u0d60\\u2c23\\u0200gilr\\u2c3d\\u2c3f\\u2c45\\u2c47\\xec\\u0bd7lde\\u803b\\xf1\\u40f1\\xe7\\u0c43iangle\\u0100lr\\u2c52\\u2c5ceft\\u0100;e\\u0c1a\\u2c5a\\xf1\\u0c26ight\\u0100;e\\u0ccb\\u2c65\\xf1\\u0cd7\\u0100;m\\u2c6c\\u2c6d\\u43bd\\u0180;es\\u2c74\\u2c75\\u2c79\\u4023ro;\\u6116p;\\u6007\\u0480DHadgilrs\\u2c8f\\u2c94\\u2c99\\u2c9e\\u2ca3\\u2cb0\\u2cb6\\u2cd3\\u2ce3ash;\\u62adarr;\\u6904p;\\uc000\\u224d\\u20d2ash;\\u62ac\\u0100et\\u2ca8\\u2cac;\\uc000\\u2265\\u20d2;\\uc000>\\u20d2nfin;\\u69de\\u0180Aet\\u2cbd\\u2cc1\\u2cc5rr;\\u6902;\\uc000\\u2264\\u20d2\\u0100;r\\u2cca\\u2ccd\\uc000<\\u20d2ie;\\uc000\\u22b4\\u20d2\\u0100At\\u2cd8\\u2cdcrr;\\u6903rie;\\uc000\\u22b5\\u20d2im;\\uc000\\u223c\\u20d2\\u0180Aan\\u2cf0\\u2cf4\\u2d02rr;\\u61d6r\\u0100hr\\u2cfa\\u2cfdk;\\u6923\\u0100;o\\u13e7\\u13e5ear;\\u6927\\u1253\\u1a95\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\u2d2d\\0\\u2d38\\u2d48\\u2d60\\u2d65\\u2d72\\u2d84\\u1b07\\0\\0\\u2d8d\\u2dab\\0\\u2dc8\\u2dce\\0\\u2ddc\\u2e19\\u2e2b\\u2e3e\\u2e43\\u0100cs\\u2d31\\u1a97ute\\u803b\\xf3\\u40f3\\u0100iy\\u2d3c\\u2d45r\\u0100;c\\u1a9e\\u2d42\\u803b\\xf4\\u40f4;\\u443e\\u0280abios\\u1aa0\\u2d52\\u2d57\\u01c8\\u2d5alac;\\u4151v;\\u6a38old;\\u69bclig;\\u4153\\u0100cr\\u2d69\\u2d6dir;\\u69bf;\\uc000\\ud835\\udd2c\\u036f\\u2d79\\0\\0\\u2d7c\\0\\u2d82n;\\u42dbave\\u803b\\xf2\\u40f2;\\u69c1\\u0100bm\\u2d88\\u0df4ar;\\u69b5\\u0200acit\\u2d95\\u2d98\\u2da5\\u2da8r\\xf2\\u1a80\\u0100ir\\u2d9d\\u2da0r;\\u69beoss;\\u69bbn\\xe5\\u0e52;\\u69c0\\u0180aei\\u2db1\\u2db5\\u2db9cr;\\u414dga;\\u43c9\\u0180cdn\\u2dc0\\u2dc5\\u01cdron;\\u43bf;\\u69b6pf;\\uc000\\ud835\\udd60\\u0180ael\\u2dd4\\u2dd7\\u01d2r;\\u69b7rp;\\u69b9\\u0380;adiosv\\u2dea\\u2deb\\u2dee\\u2e08\\u2e0d\\u2e10\\u2e16\\u6228r\\xf2\\u1a86\\u0200;efm\\u2df7\\u2df8\\u2e02\\u2e05\\u6a5dr\\u0100;o\\u2dfe\\u2dff\\u6134f\\xbb\\u2dff\\u803b\\xaa\\u40aa\\u803b\\xba\\u40bagof;\\u62b6r;\\u6a56lope;\\u6a57;\\u6a5b\\u0180clo\\u2e1f\\u2e21\\u2e27\\xf2\\u2e01ash\\u803b\\xf8\\u40f8l;\\u6298i\\u016c\\u2e2f\\u2e34de\\u803b\\xf5\\u40f5es\\u0100;a\\u01db\\u2e3as;\\u6a36ml\\u803b\\xf6\\u40f6bar;\\u633d\\u0ae1\\u2e5e\\0\\u2e7d\\0\\u2e80\\u2e9d\\0\\u2ea2\\u2eb9\\0\\0\\u2ecb\\u0e9c\\0\\u2f13\\0\\0\\u2f2b\\u2fbc\\0\\u2fc8r\\u0200;ast\\u0403\\u2e67\\u2e72\\u0e85\\u8100\\xb6;l\\u2e6d\\u2e6e\\u40b6le\\xec\\u0403\\u0269\\u2e78\\0\\0\\u2e7bm;\\u6af3;\\u6afdy;\\u443fr\\u0280cimpt\\u2e8b\\u2e8f\\u2e93\\u1865\\u2e97nt;\\u4025od;\\u402eil;\\u6030enk;\\u6031r;\\uc000\\ud835\\udd2d\\u0180imo\\u2ea8\\u2eb0\\u2eb4\\u0100;v\\u2ead\\u2eae\\u43c6;\\u43d5ma\\xf4\\u0a76ne;\\u660e\\u0180;tv\\u2ebf\\u2ec0\\u2ec8\\u43c0chfork\\xbb\\u1ffd;\\u43d6\\u0100au\\u2ecf\\u2edfn\\u0100ck\\u2ed5\\u2eddk\\u0100;h\\u21f4\\u2edb;\\u610e\\xf6\\u21f4s\\u0480;abcdemst\\u2ef3\\u2ef4\\u1908\\u2ef9\\u2efd\\u2f04\\u2f06\\u2f0a\\u2f0e\\u402bcir;\\u6a23ir;\\u6a22\\u0100ou\\u1d40\\u2f02;\\u6a25;\\u6a72n\\u80bb\\xb1\\u0e9dim;\\u6a26wo;\\u6a27\\u0180ipu\\u2f19\\u2f20\\u2f25ntint;\\u6a15f;\\uc000\\ud835\\udd61nd\\u803b\\xa3\\u40a3\\u0500;Eaceinosu\\u0ec8\\u2f3f\\u2f41\\u2f44\\u2f47\\u2f81\\u2f89\\u2f92\\u2f7e\\u2fb6;\\u6ab3p;\\u6ab7u\\xe5\\u0ed9\\u0100;c\\u0ece\\u2f4c\\u0300;acens\\u0ec8\\u2f59\\u2f5f\\u2f66\\u2f68\\u2f7eppro\\xf8\\u2f43urlye\\xf1\\u0ed9\\xf1\\u0ece\\u0180aes\\u2f6f\\u2f76\\u2f7approx;\\u6ab9qq;\\u6ab5im;\\u62e8i\\xed\\u0edfme\\u0100;s\\u2f88\\u0eae\\u6032\\u0180Eas\\u2f78\\u2f90\\u2f7a\\xf0\\u2f75\\u0180dfp\\u0eec\\u2f99\\u2faf\\u0180als\\u2fa0\\u2fa5\\u2faalar;\\u632eine;\\u6312urf;\\u6313\\u0100;t\\u0efb\\u2fb4\\xef\\u0efbrel;\\u62b0\\u0100ci\\u2fc0\\u2fc5r;\\uc000\\ud835\\udcc5;\\u43c8ncsp;\\u6008\\u0300fiopsu\\u2fda\\u22e2\\u2fdf\\u2fe5\\u2feb\\u2ff1r;\\uc000\\ud835\\udd2epf;\\uc000\\ud835\\udd62rime;\\u6057cr;\\uc000\\ud835\\udcc6\\u0180aeo\\u2ff8\\u3009\\u3013t\\u0100ei\\u2ffe\\u3005rnion\\xf3\\u06b0nt;\\u6a16st\\u0100;e\\u3010\\u3011\\u403f\\xf1\\u1f19\\xf4\\u0f14\\u0a80ABHabcdefhilmnoprstux\\u3040\\u3051\\u3055\\u3059\\u30e0\\u310e\\u312b\\u3147\\u3162\\u3172\\u318e\\u3206\\u3215\\u3224\\u3229\\u3258\\u326e\\u3272\\u3290\\u32b0\\u32b7\\u0180art\\u3047\\u304a\\u304cr\\xf2\\u10b3\\xf2\\u03ddail;\\u691car\\xf2\\u1c65ar;\\u6964\\u0380cdenqrt\\u3068\\u3075\\u3078\\u307f\\u308f\\u3094\\u30cc\\u0100eu\\u306d\\u3071;\\uc000\\u223d\\u0331te;\\u4155i\\xe3\\u116emptyv;\\u69b3g\\u0200;del\\u0fd1\\u3089\\u308b\\u308d;\\u6992;\\u69a5\\xe5\\u0fd1uo\\u803b\\xbb\\u40bbr\\u0580;abcfhlpstw\\u0fdc\\u30ac\\u30af\\u30b7\\u30b9\\u30bc\\u30be\\u30c0\\u30c3\\u30c7\\u30cap;\\u6975\\u0100;f\\u0fe0\\u30b4s;\\u6920;\\u6933s;\\u691e\\xeb\\u225d\\xf0\\u272el;\\u6945im;\\u6974l;\\u61a3;\\u619d\\u0100ai\\u30d1\\u30d5il;\\u691ao\\u0100;n\\u30db\\u30dc\\u6236al\\xf3\\u0f1e\\u0180abr\\u30e7\\u30ea\\u30eer\\xf2\\u17e5rk;\\u6773\\u0100ak\\u30f3\\u30fdc\\u0100ek\\u30f9\\u30fb;\\u407d;\\u405d\\u0100es\\u3102\\u3104;\\u698cl\\u0100du\\u310a\\u310c;\\u698e;\\u6990\\u0200aeuy\\u3117\\u311c\\u3127\\u3129ron;\\u4159\\u0100di\\u3121\\u3125il;\\u4157\\xec\\u0ff2\\xe2\\u30fa;\\u4440\\u0200clqs\\u3134\\u3137\\u313d\\u3144a;\\u6937dhar;\\u6969uo\\u0100;r\\u020e\\u020dh;\\u61b3\\u0180acg\\u314e\\u315f\\u0f44l\\u0200;ips\\u0f78\\u3158\\u315b\\u109cn\\xe5\\u10bbar\\xf4\\u0fa9t;\\u65ad\\u0180ilr\\u3169\\u1023\\u316esht;\\u697d;\\uc000\\ud835\\udd2f\\u0100ao\\u3177\\u3186r\\u0100du\\u317d\\u317f\\xbb\\u047b\\u0100;l\\u1091\\u3184;\\u696c\\u0100;v\\u318b\\u318c\\u43c1;\\u43f1\\u0180gns\\u3195\\u31f9\\u31fcht\\u0300ahlrst\\u31a4\\u31b0\\u31c2\\u31d8\\u31e4\\u31eerrow\\u0100;t\\u0fdc\\u31ada\\xe9\\u30c8arpoon\\u0100du\\u31bb\\u31bfow\\xee\\u317ep\\xbb\\u1092eft\\u0100ah\\u31ca\\u31d0rrow\\xf3\\u0feaarpoon\\xf3\\u0551ightarrows;\\u61c9quigarro\\xf7\\u30cbhreetimes;\\u62ccg;\\u42daingdotse\\xf1\\u1f32\\u0180ahm\\u320d\\u3210\\u3213r\\xf2\\u0feaa\\xf2\\u0551;\\u600foust\\u0100;a\\u321e\\u321f\\u63b1che\\xbb\\u321fmid;\\u6aee\\u0200abpt\\u3232\\u323d\\u3240\\u3252\\u0100nr\\u3237\\u323ag;\\u67edr;\\u61fer\\xeb\\u1003\\u0180afl\\u3247\\u324a\\u324er;\\u6986;\\uc000\\ud835\\udd63us;\\u6a2eimes;\\u6a35\\u0100ap\\u325d\\u3267r\\u0100;g\\u3263\\u3264\\u4029t;\\u6994olint;\\u6a12ar\\xf2\\u31e3\\u0200achq\\u327b\\u3280\\u10bc\\u3285quo;\\u603ar;\\uc000\\ud835\\udcc7\\u0100bu\\u30fb\\u328ao\\u0100;r\\u0214\\u0213\\u0180hir\\u3297\\u329b\\u32a0re\\xe5\\u31f8mes;\\u62cai\\u0200;efl\\u32aa\\u1059\\u1821\\u32ab\\u65b9tri;\\u69celuhar;\\u6968;\\u611e\\u0d61\\u32d5\\u32db\\u32df\\u332c\\u3338\\u3371\\0\\u337a\\u33a4\\0\\0\\u33ec\\u33f0\\0\\u3428\\u3448\\u345a\\u34ad\\u34b1\\u34ca\\u34f1\\0\\u3616\\0\\0\\u3633cute;\\u415bqu\\xef\\u27ba\\u0500;Eaceinpsy\\u11ed\\u32f3\\u32f5\\u32ff\\u3302\\u330b\\u330f\\u331f\\u3326\\u3329;\\u6ab4\\u01f0\\u32fa\\0\\u32fc;\\u6ab8on;\\u4161u\\xe5\\u11fe\\u0100;d\\u11f3\\u3307il;\\u415frc;\\u415d\\u0180Eas\\u3316\\u3318\\u331b;\\u6ab6p;\\u6abaim;\\u62e9olint;\\u6a13i\\xed\\u1204;\\u4441ot\\u0180;be\\u3334\\u1d47\\u3335\\u62c5;\\u6a66\\u0380Aacmstx\\u3346\\u334a\\u3357\\u335b\\u335e\\u3363\\u336drr;\\u61d8r\\u0100hr\\u3350\\u3352\\xeb\\u2228\\u0100;o\\u0a36\\u0a34t\\u803b\\xa7\\u40a7i;\\u403bwar;\\u6929m\\u0100in\\u3369\\xf0nu\\xf3\\xf1t;\\u6736r\\u0100;o\\u3376\\u2055\\uc000\\ud835\\udd30\\u0200acoy\\u3382\\u3386\\u3391\\u33a0rp;\\u666f\\u0100hy\\u338b\\u338fcy;\\u4449;\\u4448rt\\u026d\\u3399\\0\\0\\u339ci\\xe4\\u1464ara\\xec\\u2e6f\\u803b\\xad\\u40ad\\u0100gm\\u33a8\\u33b4ma\\u0180;fv\\u33b1\\u33b2\\u33b2\\u43c3;\\u43c2\\u0400;deglnpr\\u12ab\\u33c5\\u33c9\\u33ce\\u33d6\\u33de\\u33e1\\u33e6ot;\\u6a6a\\u0100;q\\u12b1\\u12b0\\u0100;E\\u33d3\\u33d4\\u6a9e;\\u6aa0\\u0100;E\\u33db\\u33dc\\u6a9d;\\u6a9fe;\\u6246lus;\\u6a24arr;\\u6972ar\\xf2\\u113d\\u0200aeit\\u33f8\\u3408\\u340f\\u3417\\u0100ls\\u33fd\\u3404lsetm\\xe9\\u336ahp;\\u6a33parsl;\\u69e4\\u0100dl\\u1463\\u3414e;\\u6323\\u0100;e\\u341c\\u341d\\u6aaa\\u0100;s\\u3422\\u3423\\u6aac;\\uc000\\u2aac\\ufe00\\u0180flp\\u342e\\u3433\\u3442tcy;\\u444c\\u0100;b\\u3438\\u3439\\u402f\\u0100;a\\u343e\\u343f\\u69c4r;\\u633ff;\\uc000\\ud835\\udd64a\\u0100dr\\u344d\\u0402es\\u0100;u\\u3454\\u3455\\u6660it\\xbb\\u3455\\u0180csu\\u3460\\u3479\\u349f\\u0100au\\u3465\\u346fp\\u0100;s\\u1188\\u346b;\\uc000\\u2293\\ufe00p\\u0100;s\\u11b4\\u3475;\\uc000\\u2294\\ufe00u\\u0100bp\\u347f\\u348f\\u0180;es\\u1197\\u119c\\u3486et\\u0100;e\\u1197\\u348d\\xf1\\u119d\\u0180;es\\u11a8\\u11ad\\u3496et\\u0100;e\\u11a8\\u349d\\xf1\\u11ae\\u0180;af\\u117b\\u34a6\\u05b0r\\u0165\\u34ab\\u05b1\\xbb\\u117car\\xf2\\u1148\\u0200cemt\\u34b9\\u34be\\u34c2\\u34c5r;\\uc000\\ud835\\udcc8tm\\xee\\xf1i\\xec\\u3415ar\\xe6\\u11be\\u0100ar\\u34ce\\u34d5r\\u0100;f\\u34d4\\u17bf\\u6606\\u0100an\\u34da\\u34edight\\u0100ep\\u34e3\\u34eapsilo\\xee\\u1ee0h\\xe9\\u2eafs\\xbb\\u2852\\u0280bcmnp\\u34fb\\u355e\\u1209\\u358b\\u358e\\u0480;Edemnprs\\u350e\\u350f\\u3511\\u3515\\u351e\\u3523\\u352c\\u3531\\u3536\\u6282;\\u6ac5ot;\\u6abd\\u0100;d\\u11da\\u351aot;\\u6ac3ult;\\u6ac1\\u0100Ee\\u3528\\u352a;\\u6acb;\\u628alus;\\u6abfarr;\\u6979\\u0180eiu\\u353d\\u3552\\u3555t\\u0180;en\\u350e\\u3545\\u354bq\\u0100;q\\u11da\\u350feq\\u0100;q\\u352b\\u3528m;\\u6ac7\\u0100bp\\u355a\\u355c;\\u6ad5;\\u6ad3c\\u0300;acens\\u11ed\\u356c\\u3572\\u3579\\u357b\\u3326ppro\\xf8\\u32faurlye\\xf1\\u11fe\\xf1\\u11f3\\u0180aes\\u3582\\u3588\\u331bppro\\xf8\\u331aq\\xf1\\u3317g;\\u666a\\u0680123;Edehlmnps\\u35a9\\u35ac\\u35af\\u121c\\u35b2\\u35b4\\u35c0\\u35c9\\u35d5\\u35da\\u35df\\u35e8\\u35ed\\u803b\\xb9\\u40b9\\u803b\\xb2\\u40b2\\u803b\\xb3\\u40b3;\\u6ac6\\u0100os\\u35b9\\u35bct;\\u6abeub;\\u6ad8\\u0100;d\\u1222\\u35c5ot;\\u6ac4s\\u0100ou\\u35cf\\u35d2l;\\u67c9b;\\u6ad7arr;\\u697bult;\\u6ac2\\u0100Ee\\u35e4\\u35e6;\\u6acc;\\u628blus;\\u6ac0\\u0180eiu\\u35f4\\u3609\\u360ct\\u0180;en\\u121c\\u35fc\\u3602q\\u0100;q\\u1222\\u35b2eq\\u0100;q\\u35e7\\u35e4m;\\u6ac8\\u0100bp\\u3611\\u3613;\\u6ad4;\\u6ad6\\u0180Aan\\u361c\\u3620\\u362drr;\\u61d9r\\u0100hr\\u3626\\u3628\\xeb\\u222e\\u0100;o\\u0a2b\\u0a29war;\\u692alig\\u803b\\xdf\\u40df\\u0be1\\u3651\\u365d\\u3660\\u12ce\\u3673\\u3679\\0\\u367e\\u36c2\\0\\0\\0\\0\\0\\u36db\\u3703\\0\\u3709\\u376c\\0\\0\\0\\u3787\\u0272\\u3656\\0\\0\\u365bget;\\u6316;\\u43c4r\\xeb\\u0e5f\\u0180aey\\u3666\\u366b\\u3670ron;\\u4165dil;\\u4163;\\u4442lrec;\\u6315r;\\uc000\\ud835\\udd31\\u0200eiko\\u3686\\u369d\\u36b5\\u36bc\\u01f2\\u368b\\0\\u3691e\\u01004f\\u1284\\u1281a\\u0180;sv\\u3698\\u3699\\u369b\\u43b8ym;\\u43d1\\u0100cn\\u36a2\\u36b2k\\u0100as\\u36a8\\u36aeppro\\xf8\\u12c1im\\xbb\\u12acs\\xf0\\u129e\\u0100as\\u36ba\\u36ae\\xf0\\u12c1rn\\u803b\\xfe\\u40fe\\u01ec\\u031f\\u36c6\\u22e7es\\u8180\\xd7;bd\\u36cf\\u36d0\\u36d8\\u40d7\\u0100;a\\u190f\\u36d5r;\\u6a31;\\u6a30\\u0180eps\\u36e1\\u36e3\\u3700\\xe1\\u2a4d\\u0200;bcf\\u0486\\u36ec\\u36f0\\u36f4ot;\\u6336ir;\\u6af1\\u0100;o\\u36f9\\u36fc\\uc000\\ud835\\udd65rk;\\u6ada\\xe1\\u3362rime;\\u6034\\u0180aip\\u370f\\u3712\\u3764d\\xe5\\u1248\\u0380adempst\\u3721\\u374d\\u3740\\u3751\\u3757\\u375c\\u375fngle\\u0280;dlqr\\u3730\\u3731\\u3736\\u3740\\u3742\\u65b5own\\xbb\\u1dbbeft\\u0100;e\\u2800\\u373e\\xf1\\u092e;\\u625cight\\u0100;e\\u32aa\\u374b\\xf1\\u105aot;\\u65ecinus;\\u6a3alus;\\u6a39b;\\u69cdime;\\u6a3bezium;\\u63e2\\u0180cht\\u3772\\u377d\\u3781\\u0100ry\\u3777\\u377b;\\uc000\\ud835\\udcc9;\\u4446cy;\\u445brok;\\u4167\\u0100io\\u378b\\u378ex\\xf4\\u1777head\\u0100lr\\u3797\\u37a0eftarro\\xf7\\u084fightarrow\\xbb\\u0f5d\\u0900AHabcdfghlmoprstuw\\u37d0\\u37d3\\u37d7\\u37e4\\u37f0\\u37fc\\u380e\\u381c\\u3823\\u3834\\u3851\\u385d\\u386b\\u38a9\\u38cc\\u38d2\\u38ea\\u38f6r\\xf2\\u03edar;\\u6963\\u0100cr\\u37dc\\u37e2ute\\u803b\\xfa\\u40fa\\xf2\\u1150r\\u01e3\\u37ea\\0\\u37edy;\\u445eve;\\u416d\\u0100iy\\u37f5\\u37farc\\u803b\\xfb\\u40fb;\\u4443\\u0180abh\\u3803\\u3806\\u380br\\xf2\\u13adlac;\\u4171a\\xf2\\u13c3\\u0100ir\\u3813\\u3818sht;\\u697e;\\uc000\\ud835\\udd32rave\\u803b\\xf9\\u40f9\\u0161\\u3827\\u3831r\\u0100lr\\u382c\\u382e\\xbb\\u0957\\xbb\\u1083lk;\\u6580\\u0100ct\\u3839\\u384d\\u026f\\u383f\\0\\0\\u384arn\\u0100;e\\u3845\\u3846\\u631cr\\xbb\\u3846op;\\u630fri;\\u65f8\\u0100al\\u3856\\u385acr;\\u416b\\u80bb\\xa8\\u0349\\u0100gp\\u3862\\u3866on;\\u4173f;\\uc000\\ud835\\udd66\\u0300adhlsu\\u114b\\u3878\\u387d\\u1372\\u3891\\u38a0own\\xe1\\u13b3arpoon\\u0100lr\\u3888\\u388cef\\xf4\\u382digh\\xf4\\u382fi\\u0180;hl\\u3899\\u389a\\u389c\\u43c5\\xbb\\u13faon\\xbb\\u389aparrows;\\u61c8\\u0180cit\\u38b0\\u38c4\\u38c8\\u026f\\u38b6\\0\\0\\u38c1rn\\u0100;e\\u38bc\\u38bd\\u631dr\\xbb\\u38bdop;\\u630eng;\\u416fri;\\u65f9cr;\\uc000\\ud835\\udcca\\u0180dir\\u38d9\\u38dd\\u38e2ot;\\u62f0lde;\\u4169i\\u0100;f\\u3730\\u38e8\\xbb\\u1813\\u0100am\\u38ef\\u38f2r\\xf2\\u38a8l\\u803b\\xfc\\u40fcangle;\\u69a7\\u0780ABDacdeflnoprsz\\u391c\\u391f\\u3929\\u392d\\u39b5\\u39b8\\u39bd\\u39df\\u39e4\\u39e8\\u39f3\\u39f9\\u39fd\\u3a01\\u3a20r\\xf2\\u03f7ar\\u0100;v\\u3926\\u3927\\u6ae8;\\u6ae9as\\xe8\\u03e1\\u0100nr\\u3932\\u3937grt;\\u699c\\u0380eknprst\\u34e3\\u3946\\u394b\\u3952\\u395d\\u3964\\u3996app\\xe1\\u2415othin\\xe7\\u1e96\\u0180hir\\u34eb\\u2ec8\\u3959op\\xf4\\u2fb5\\u0100;h\\u13b7\\u3962\\xef\\u318d\\u0100iu\\u3969\\u396dgm\\xe1\\u33b3\\u0100bp\\u3972\\u3984setneq\\u0100;q\\u397d\\u3980\\uc000\\u228a\\ufe00;\\uc000\\u2acb\\ufe00setneq\\u0100;q\\u398f\\u3992\\uc000\\u228b\\ufe00;\\uc000\\u2acc\\ufe00\\u0100hr\\u399b\\u399fet\\xe1\\u369ciangle\\u0100lr\\u39aa\\u39afeft\\xbb\\u0925ight\\xbb\\u1051y;\\u4432ash\\xbb\\u1036\\u0180elr\\u39c4\\u39d2\\u39d7\\u0180;be\\u2dea\\u39cb\\u39cfar;\\u62bbq;\\u625alip;\\u62ee\\u0100bt\\u39dc\\u1468a\\xf2\\u1469r;\\uc000\\ud835\\udd33tr\\xe9\\u39aesu\\u0100bp\\u39ef\\u39f1\\xbb\\u0d1c\\xbb\\u0d59pf;\\uc000\\ud835\\udd67ro\\xf0\\u0efbtr\\xe9\\u39b4\\u0100cu\\u3a06\\u3a0br;\\uc000\\ud835\\udccb\\u0100bp\\u3a10\\u3a18n\\u0100Ee\\u3980\\u3a16\\xbb\\u397en\\u0100Ee\\u3992\\u3a1e\\xbb\\u3990igzag;\\u699a\\u0380cefoprs\\u3a36\\u3a3b\\u3a56\\u3a5b\\u3a54\\u3a61\\u3a6airc;\\u4175\\u0100di\\u3a40\\u3a51\\u0100bg\\u3a45\\u3a49ar;\\u6a5fe\\u0100;q\\u15fa\\u3a4f;\\u6259erp;\\u6118r;\\uc000\\ud835\\udd34pf;\\uc000\\ud835\\udd68\\u0100;e\\u1479\\u3a66at\\xe8\\u1479cr;\\uc000\\ud835\\udccc\\u0ae3\\u178e\\u3a87\\0\\u3a8b\\0\\u3a90\\u3a9b\\0\\0\\u3a9d\\u3aa8\\u3aab\\u3aaf\\0\\0\\u3ac3\\u3ace\\0\\u3ad8\\u17dc\\u17dftr\\xe9\\u17d1r;\\uc000\\ud835\\udd35\\u0100Aa\\u3a94\\u3a97r\\xf2\\u03c3r\\xf2\\u09f6;\\u43be\\u0100Aa\\u3aa1\\u3aa4r\\xf2\\u03b8r\\xf2\\u09eba\\xf0\\u2713is;\\u62fb\\u0180dpt\\u17a4\\u3ab5\\u3abe\\u0100fl\\u3aba\\u17a9;\\uc000\\ud835\\udd69im\\xe5\\u17b2\\u0100Aa\\u3ac7\\u3acar\\xf2\\u03cer\\xf2\\u0a01\\u0100cq\\u3ad2\\u17b8r;\\uc000\\ud835\\udccd\\u0100pt\\u17d6\\u3adcr\\xe9\\u17d4\\u0400acefiosu\\u3af0\\u3afd\\u3b08\\u3b0c\\u3b11\\u3b15\\u3b1b\\u3b21c\\u0100uy\\u3af6\\u3afbte\\u803b\\xfd\\u40fd;\\u444f\\u0100iy\\u3b02\\u3b06rc;\\u4177;\\u444bn\\u803b\\xa5\\u40a5r;\\uc000\\ud835\\udd36cy;\\u4457pf;\\uc000\\ud835\\udd6acr;\\uc000\\ud835\\udcce\\u0100cm\\u3b26\\u3b29y;\\u444el\\u803b\\xff\\u40ff\\u0500acdefhiosw\\u3b42\\u3b48\\u3b54\\u3b58\\u3b64\\u3b69\\u3b6d\\u3b74\\u3b7a\\u3b80cute;\\u417a\\u0100ay\\u3b4d\\u3b52ron;\\u417e;\\u4437ot;\\u417c\\u0100et\\u3b5d\\u3b61tr\\xe6\\u155fa;\\u43b6r;\\uc000\\ud835\\udd37cy;\\u4436grarr;\\u61ddpf;\\uc000\\ud835\\udd6bcr;\\uc000\\ud835\\udccf\\u0100jn\\u3b85\\u3b87;\\u600dj;\\u600c\"\n    .split(\"\")\n    .map(function (c) { return c.charCodeAt(0); }));\n\n},{}],20:[function(require,module,exports){\n\"use strict\";\n// Generated using scripts/write-decode-map.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = new Uint16Array(\n// prettier-ignore\n\"\\u0200aglq\\t\\x15\\x18\\x1b\\u026d\\x0f\\0\\0\\x12p;\\u4026os;\\u4027t;\\u403et;\\u403cuot;\\u4022\"\n    .split(\"\")\n    .map(function (c) { return c.charCodeAt(0); }));\n\n},{}],21:[function(require,module,exports){\n\"use strict\";\n// Generated using scripts/write-encode-map.ts\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction restoreDiff(arr) {\n    for (var i = 1; i < arr.length; i++) {\n        arr[i][0] += arr[i - 1][0] + 1;\n    }\n    return arr;\n}\n// prettier-ignore\nexports.default = new Map(/* #__PURE__ */ restoreDiff([[9, \"&Tab;\"], [0, \"&NewLine;\"], [22, \"&excl;\"], [0, \"&quot;\"], [0, \"&num;\"], [0, \"&dollar;\"], [0, \"&percnt;\"], [0, \"&amp;\"], [0, \"&apos;\"], [0, \"&lpar;\"], [0, \"&rpar;\"], [0, \"&ast;\"], [0, \"&plus;\"], [0, \"&comma;\"], [1, \"&period;\"], [0, \"&sol;\"], [10, \"&colon;\"], [0, \"&semi;\"], [0, { v: \"&lt;\", n: 8402, o: \"&nvlt;\" }], [0, { v: \"&equals;\", n: 8421, o: \"&bne;\" }], [0, { v: \"&gt;\", n: 8402, o: \"&nvgt;\" }], [0, \"&quest;\"], [0, \"&commat;\"], [26, \"&lbrack;\"], [0, \"&bsol;\"], [0, \"&rbrack;\"], [0, \"&Hat;\"], [0, \"&lowbar;\"], [0, \"&DiacriticalGrave;\"], [5, { n: 106, o: \"&fjlig;\" }], [20, \"&lbrace;\"], [0, \"&verbar;\"], [0, \"&rbrace;\"], [34, \"&nbsp;\"], [0, \"&iexcl;\"], [0, \"&cent;\"], [0, \"&pound;\"], [0, \"&curren;\"], [0, \"&yen;\"], [0, \"&brvbar;\"], [0, \"&sect;\"], [0, \"&die;\"], [0, \"&copy;\"], [0, \"&ordf;\"], [0, \"&laquo;\"], [0, \"&not;\"], [0, \"&shy;\"], [0, \"&circledR;\"], [0, \"&macr;\"], [0, \"&deg;\"], [0, \"&PlusMinus;\"], [0, \"&sup2;\"], [0, \"&sup3;\"], [0, \"&acute;\"], [0, \"&micro;\"], [0, \"&para;\"], [0, \"&centerdot;\"], [0, \"&cedil;\"], [0, \"&sup1;\"], [0, \"&ordm;\"], [0, \"&raquo;\"], [0, \"&frac14;\"], [0, \"&frac12;\"], [0, \"&frac34;\"], [0, \"&iquest;\"], [0, \"&Agrave;\"], [0, \"&Aacute;\"], [0, \"&Acirc;\"], [0, \"&Atilde;\"], [0, \"&Auml;\"], [0, \"&angst;\"], [0, \"&AElig;\"], [0, \"&Ccedil;\"], [0, \"&Egrave;\"], [0, \"&Eacute;\"], [0, \"&Ecirc;\"], [0, \"&Euml;\"], [0, \"&Igrave;\"], [0, \"&Iacute;\"], [0, \"&Icirc;\"], [0, \"&Iuml;\"], [0, \"&ETH;\"], [0, \"&Ntilde;\"], [0, \"&Ograve;\"], [0, \"&Oacute;\"], [0, \"&Ocirc;\"], [0, \"&Otilde;\"], [0, \"&Ouml;\"], [0, \"&times;\"], [0, \"&Oslash;\"], [0, \"&Ugrave;\"], [0, \"&Uacute;\"], [0, \"&Ucirc;\"], [0, \"&Uuml;\"], [0, \"&Yacute;\"], [0, \"&THORN;\"], [0, \"&szlig;\"], [0, \"&agrave;\"], [0, \"&aacute;\"], [0, \"&acirc;\"], [0, \"&atilde;\"], [0, \"&auml;\"], [0, \"&aring;\"], [0, \"&aelig;\"], [0, \"&ccedil;\"], [0, \"&egrave;\"], [0, \"&eacute;\"], [0, \"&ecirc;\"], [0, \"&euml;\"], [0, \"&igrave;\"], [0, \"&iacute;\"], [0, \"&icirc;\"], [0, \"&iuml;\"], [0, \"&eth;\"], [0, \"&ntilde;\"], [0, \"&ograve;\"], [0, \"&oacute;\"], [0, \"&ocirc;\"], [0, \"&otilde;\"], [0, \"&ouml;\"], [0, \"&div;\"], [0, \"&oslash;\"], [0, \"&ugrave;\"], [0, \"&uacute;\"], [0, \"&ucirc;\"], [0, \"&uuml;\"], [0, \"&yacute;\"], [0, \"&thorn;\"], [0, \"&yuml;\"], [0, \"&Amacr;\"], [0, \"&amacr;\"], [0, \"&Abreve;\"], [0, \"&abreve;\"], [0, \"&Aogon;\"], [0, \"&aogon;\"], [0, \"&Cacute;\"], [0, \"&cacute;\"], [0, \"&Ccirc;\"], [0, \"&ccirc;\"], [0, \"&Cdot;\"], [0, \"&cdot;\"], [0, \"&Ccaron;\"], [0, \"&ccaron;\"], [0, \"&Dcaron;\"], [0, \"&dcaron;\"], [0, \"&Dstrok;\"], [0, \"&dstrok;\"], [0, \"&Emacr;\"], [0, \"&emacr;\"], [2, \"&Edot;\"], [0, \"&edot;\"], [0, \"&Eogon;\"], [0, \"&eogon;\"], [0, \"&Ecaron;\"], [0, \"&ecaron;\"], [0, \"&Gcirc;\"], [0, \"&gcirc;\"], [0, \"&Gbreve;\"], [0, \"&gbreve;\"], [0, \"&Gdot;\"], [0, \"&gdot;\"], [0, \"&Gcedil;\"], [1, \"&Hcirc;\"], [0, \"&hcirc;\"], [0, \"&Hstrok;\"], [0, \"&hstrok;\"], [0, \"&Itilde;\"], [0, \"&itilde;\"], [0, \"&Imacr;\"], [0, \"&imacr;\"], [2, \"&Iogon;\"], [0, \"&iogon;\"], [0, \"&Idot;\"], [0, \"&imath;\"], [0, \"&IJlig;\"], [0, \"&ijlig;\"], [0, \"&Jcirc;\"], [0, \"&jcirc;\"], [0, \"&Kcedil;\"], [0, \"&kcedil;\"], [0, \"&kgreen;\"], [0, \"&Lacute;\"], [0, \"&lacute;\"], [0, \"&Lcedil;\"], [0, \"&lcedil;\"], [0, \"&Lcaron;\"], [0, \"&lcaron;\"], [0, \"&Lmidot;\"], [0, \"&lmidot;\"], [0, \"&Lstrok;\"], [0, \"&lstrok;\"], [0, \"&Nacute;\"], [0, \"&nacute;\"], [0, \"&Ncedil;\"], [0, \"&ncedil;\"], [0, \"&Ncaron;\"], [0, \"&ncaron;\"], [0, \"&napos;\"], [0, \"&ENG;\"], [0, \"&eng;\"], [0, \"&Omacr;\"], [0, \"&omacr;\"], [2, \"&Odblac;\"], [0, \"&odblac;\"], [0, \"&OElig;\"], [0, \"&oelig;\"], [0, \"&Racute;\"], [0, \"&racute;\"], [0, \"&Rcedil;\"], [0, \"&rcedil;\"], [0, \"&Rcaron;\"], [0, \"&rcaron;\"], [0, \"&Sacute;\"], [0, \"&sacute;\"], [0, \"&Scirc;\"], [0, \"&scirc;\"], [0, \"&Scedil;\"], [0, \"&scedil;\"], [0, \"&Scaron;\"], [0, \"&scaron;\"], [0, \"&Tcedil;\"], [0, \"&tcedil;\"], [0, \"&Tcaron;\"], [0, \"&tcaron;\"], [0, \"&Tstrok;\"], [0, \"&tstrok;\"], [0, \"&Utilde;\"], [0, \"&utilde;\"], [0, \"&Umacr;\"], [0, \"&umacr;\"], [0, \"&Ubreve;\"], [0, \"&ubreve;\"], [0, \"&Uring;\"], [0, \"&uring;\"], [0, \"&Udblac;\"], [0, \"&udblac;\"], [0, \"&Uogon;\"], [0, \"&uogon;\"], [0, \"&Wcirc;\"], [0, \"&wcirc;\"], [0, \"&Ycirc;\"], [0, \"&ycirc;\"], [0, \"&Yuml;\"], [0, \"&Zacute;\"], [0, \"&zacute;\"], [0, \"&Zdot;\"], [0, \"&zdot;\"], [0, \"&Zcaron;\"], [0, \"&zcaron;\"], [19, \"&fnof;\"], [34, \"&imped;\"], [63, \"&gacute;\"], [65, \"&jmath;\"], [142, \"&circ;\"], [0, \"&caron;\"], [16, \"&breve;\"], [0, \"&DiacriticalDot;\"], [0, \"&ring;\"], [0, \"&ogon;\"], [0, \"&DiacriticalTilde;\"], [0, \"&dblac;\"], [51, \"&DownBreve;\"], [127, \"&Alpha;\"], [0, \"&Beta;\"], [0, \"&Gamma;\"], [0, \"&Delta;\"], [0, \"&Epsilon;\"], [0, \"&Zeta;\"], [0, \"&Eta;\"], [0, \"&Theta;\"], [0, \"&Iota;\"], [0, \"&Kappa;\"], [0, \"&Lambda;\"], [0, \"&Mu;\"], [0, \"&Nu;\"], [0, \"&Xi;\"], [0, \"&Omicron;\"], [0, \"&Pi;\"], [0, \"&Rho;\"], [1, \"&Sigma;\"], [0, \"&Tau;\"], [0, \"&Upsilon;\"], [0, \"&Phi;\"], [0, \"&Chi;\"], [0, \"&Psi;\"], [0, \"&ohm;\"], [7, \"&alpha;\"], [0, \"&beta;\"], [0, \"&gamma;\"], [0, \"&delta;\"], [0, \"&epsi;\"], [0, \"&zeta;\"], [0, \"&eta;\"], [0, \"&theta;\"], [0, \"&iota;\"], [0, \"&kappa;\"], [0, \"&lambda;\"], [0, \"&mu;\"], [0, \"&nu;\"], [0, \"&xi;\"], [0, \"&omicron;\"], [0, \"&pi;\"], [0, \"&rho;\"], [0, \"&sigmaf;\"], [0, \"&sigma;\"], [0, \"&tau;\"], [0, \"&upsi;\"], [0, \"&phi;\"], [0, \"&chi;\"], [0, \"&psi;\"], [0, \"&omega;\"], [7, \"&thetasym;\"], [0, \"&Upsi;\"], [2, \"&phiv;\"], [0, \"&piv;\"], [5, \"&Gammad;\"], [0, \"&digamma;\"], [18, \"&kappav;\"], [0, \"&rhov;\"], [3, \"&epsiv;\"], [0, \"&backepsilon;\"], [10, \"&IOcy;\"], [0, \"&DJcy;\"], [0, \"&GJcy;\"], [0, \"&Jukcy;\"], [0, \"&DScy;\"], [0, \"&Iukcy;\"], [0, \"&YIcy;\"], [0, \"&Jsercy;\"], [0, \"&LJcy;\"], [0, \"&NJcy;\"], [0, \"&TSHcy;\"], [0, \"&KJcy;\"], [1, \"&Ubrcy;\"], [0, \"&DZcy;\"], [0, \"&Acy;\"], [0, \"&Bcy;\"], [0, \"&Vcy;\"], [0, \"&Gcy;\"], [0, \"&Dcy;\"], [0, \"&IEcy;\"], [0, \"&ZHcy;\"], [0, \"&Zcy;\"], [0, \"&Icy;\"], [0, \"&Jcy;\"], [0, \"&Kcy;\"], [0, \"&Lcy;\"], [0, \"&Mcy;\"], [0, \"&Ncy;\"], [0, \"&Ocy;\"], [0, \"&Pcy;\"], [0, \"&Rcy;\"], [0, \"&Scy;\"], [0, \"&Tcy;\"], [0, \"&Ucy;\"], [0, \"&Fcy;\"], [0, \"&KHcy;\"], [0, \"&TScy;\"], [0, \"&CHcy;\"], [0, \"&SHcy;\"], [0, \"&SHCHcy;\"], [0, \"&HARDcy;\"], [0, \"&Ycy;\"], [0, \"&SOFTcy;\"], [0, \"&Ecy;\"], [0, \"&YUcy;\"], [0, \"&YAcy;\"], [0, \"&acy;\"], [0, \"&bcy;\"], [0, \"&vcy;\"], [0, \"&gcy;\"], [0, \"&dcy;\"], [0, \"&iecy;\"], [0, \"&zhcy;\"], [0, \"&zcy;\"], [0, \"&icy;\"], [0, \"&jcy;\"], [0, \"&kcy;\"], [0, \"&lcy;\"], [0, \"&mcy;\"], [0, \"&ncy;\"], [0, \"&ocy;\"], [0, \"&pcy;\"], [0, \"&rcy;\"], [0, \"&scy;\"], [0, \"&tcy;\"], [0, \"&ucy;\"], [0, \"&fcy;\"], [0, \"&khcy;\"], [0, \"&tscy;\"], [0, \"&chcy;\"], [0, \"&shcy;\"], [0, \"&shchcy;\"], [0, \"&hardcy;\"], [0, \"&ycy;\"], [0, \"&softcy;\"], [0, \"&ecy;\"], [0, \"&yucy;\"], [0, \"&yacy;\"], [1, \"&iocy;\"], [0, \"&djcy;\"], [0, \"&gjcy;\"], [0, \"&jukcy;\"], [0, \"&dscy;\"], [0, \"&iukcy;\"], [0, \"&yicy;\"], [0, \"&jsercy;\"], [0, \"&ljcy;\"], [0, \"&njcy;\"], [0, \"&tshcy;\"], [0, \"&kjcy;\"], [1, \"&ubrcy;\"], [0, \"&dzcy;\"], [7074, \"&ensp;\"], [0, \"&emsp;\"], [0, \"&emsp13;\"], [0, \"&emsp14;\"], [1, \"&numsp;\"], [0, \"&puncsp;\"], [0, \"&ThinSpace;\"], [0, \"&hairsp;\"], [0, \"&NegativeMediumSpace;\"], [0, \"&zwnj;\"], [0, \"&zwj;\"], [0, \"&lrm;\"], [0, \"&rlm;\"], [0, \"&dash;\"], [2, \"&ndash;\"], [0, \"&mdash;\"], [0, \"&horbar;\"], [0, \"&Verbar;\"], [1, \"&lsquo;\"], [0, \"&CloseCurlyQuote;\"], [0, \"&lsquor;\"], [1, \"&ldquo;\"], [0, \"&CloseCurlyDoubleQuote;\"], [0, \"&bdquo;\"], [1, \"&dagger;\"], [0, \"&Dagger;\"], [0, \"&bull;\"], [2, \"&nldr;\"], [0, \"&hellip;\"], [9, \"&permil;\"], [0, \"&pertenk;\"], [0, \"&prime;\"], [0, \"&Prime;\"], [0, \"&tprime;\"], [0, \"&backprime;\"], [3, \"&lsaquo;\"], [0, \"&rsaquo;\"], [3, \"&oline;\"], [2, \"&caret;\"], [1, \"&hybull;\"], [0, \"&frasl;\"], [10, \"&bsemi;\"], [7, \"&qprime;\"], [7, { v: \"&MediumSpace;\", n: 8202, o: \"&ThickSpace;\" }], [0, \"&NoBreak;\"], [0, \"&af;\"], [0, \"&InvisibleTimes;\"], [0, \"&ic;\"], [72, \"&euro;\"], [46, \"&tdot;\"], [0, \"&DotDot;\"], [37, \"&complexes;\"], [2, \"&incare;\"], [4, \"&gscr;\"], [0, \"&hamilt;\"], [0, \"&Hfr;\"], [0, \"&Hopf;\"], [0, \"&planckh;\"], [0, \"&hbar;\"], [0, \"&imagline;\"], [0, \"&Ifr;\"], [0, \"&lagran;\"], [0, \"&ell;\"], [1, \"&naturals;\"], [0, \"&numero;\"], [0, \"&copysr;\"], [0, \"&weierp;\"], [0, \"&Popf;\"], [0, \"&Qopf;\"], [0, \"&realine;\"], [0, \"&real;\"], [0, \"&reals;\"], [0, \"&rx;\"], [3, \"&trade;\"], [1, \"&integers;\"], [2, \"&mho;\"], [0, \"&zeetrf;\"], [0, \"&iiota;\"], [2, \"&bernou;\"], [0, \"&Cayleys;\"], [1, \"&escr;\"], [0, \"&Escr;\"], [0, \"&Fouriertrf;\"], [1, \"&Mellintrf;\"], [0, \"&order;\"], [0, \"&alefsym;\"], [0, \"&beth;\"], [0, \"&gimel;\"], [0, \"&daleth;\"], [12, \"&CapitalDifferentialD;\"], [0, \"&dd;\"], [0, \"&ee;\"], [0, \"&ii;\"], [10, \"&frac13;\"], [0, \"&frac23;\"], [0, \"&frac15;\"], [0, \"&frac25;\"], [0, \"&frac35;\"], [0, \"&frac45;\"], [0, \"&frac16;\"], [0, \"&frac56;\"], [0, \"&frac18;\"], [0, \"&frac38;\"], [0, \"&frac58;\"], [0, \"&frac78;\"], [49, \"&larr;\"], [0, \"&ShortUpArrow;\"], [0, \"&rarr;\"], [0, \"&darr;\"], [0, \"&harr;\"], [0, \"&updownarrow;\"], [0, \"&nwarr;\"], [0, \"&nearr;\"], [0, \"&LowerRightArrow;\"], [0, \"&LowerLeftArrow;\"], [0, \"&nlarr;\"], [0, \"&nrarr;\"], [1, { v: \"&rarrw;\", n: 824, o: \"&nrarrw;\" }], [0, \"&Larr;\"], [0, \"&Uarr;\"], [0, \"&Rarr;\"], [0, \"&Darr;\"], [0, \"&larrtl;\"], [0, \"&rarrtl;\"], [0, \"&LeftTeeArrow;\"], [0, \"&mapstoup;\"], [0, \"&map;\"], [0, \"&DownTeeArrow;\"], [1, \"&hookleftarrow;\"], [0, \"&hookrightarrow;\"], [0, \"&larrlp;\"], [0, \"&looparrowright;\"], [0, \"&harrw;\"], [0, \"&nharr;\"], [1, \"&lsh;\"], [0, \"&rsh;\"], [0, \"&ldsh;\"], [0, \"&rdsh;\"], [1, \"&crarr;\"], [0, \"&cularr;\"], [0, \"&curarr;\"], [2, \"&circlearrowleft;\"], [0, \"&circlearrowright;\"], [0, \"&leftharpoonup;\"], [0, \"&DownLeftVector;\"], [0, \"&RightUpVector;\"], [0, \"&LeftUpVector;\"], [0, \"&rharu;\"], [0, \"&DownRightVector;\"], [0, \"&dharr;\"], [0, \"&dharl;\"], [0, \"&RightArrowLeftArrow;\"], [0, \"&udarr;\"], [0, \"&LeftArrowRightArrow;\"], [0, \"&leftleftarrows;\"], [0, \"&upuparrows;\"], [0, \"&rightrightarrows;\"], [0, \"&ddarr;\"], [0, \"&leftrightharpoons;\"], [0, \"&Equilibrium;\"], [0, \"&nlArr;\"], [0, \"&nhArr;\"], [0, \"&nrArr;\"], [0, \"&DoubleLeftArrow;\"], [0, \"&DoubleUpArrow;\"], [0, \"&DoubleRightArrow;\"], [0, \"&dArr;\"], [0, \"&DoubleLeftRightArrow;\"], [0, \"&DoubleUpDownArrow;\"], [0, \"&nwArr;\"], [0, \"&neArr;\"], [0, \"&seArr;\"], [0, \"&swArr;\"], [0, \"&lAarr;\"], [0, \"&rAarr;\"], [1, \"&zigrarr;\"], [6, \"&larrb;\"], [0, \"&rarrb;\"], [15, \"&DownArrowUpArrow;\"], [7, \"&loarr;\"], [0, \"&roarr;\"], [0, \"&hoarr;\"], [0, \"&forall;\"], [0, \"&comp;\"], [0, { v: \"&part;\", n: 824, o: \"&npart;\" }], [0, \"&exist;\"], [0, \"&nexist;\"], [0, \"&empty;\"], [1, \"&Del;\"], [0, \"&Element;\"], [0, \"&NotElement;\"], [1, \"&ni;\"], [0, \"&notni;\"], [2, \"&prod;\"], [0, \"&coprod;\"], [0, \"&sum;\"], [0, \"&minus;\"], [0, \"&MinusPlus;\"], [0, \"&dotplus;\"], [1, \"&Backslash;\"], [0, \"&lowast;\"], [0, \"&compfn;\"], [1, \"&radic;\"], [2, \"&prop;\"], [0, \"&infin;\"], [0, \"&angrt;\"], [0, { v: \"&ang;\", n: 8402, o: \"&nang;\" }], [0, \"&angmsd;\"], [0, \"&angsph;\"], [0, \"&mid;\"], [0, \"&nmid;\"], [0, \"&DoubleVerticalBar;\"], [0, \"&NotDoubleVerticalBar;\"], [0, \"&and;\"], [0, \"&or;\"], [0, { v: \"&cap;\", n: 65024, o: \"&caps;\" }], [0, { v: \"&cup;\", n: 65024, o: \"&cups;\" }], [0, \"&int;\"], [0, \"&Int;\"], [0, \"&iiint;\"], [0, \"&conint;\"], [0, \"&Conint;\"], [0, \"&Cconint;\"], [0, \"&cwint;\"], [0, \"&ClockwiseContourIntegral;\"], [0, \"&awconint;\"], [0, \"&there4;\"], [0, \"&becaus;\"], [0, \"&ratio;\"], [0, \"&Colon;\"], [0, \"&dotminus;\"], [1, \"&mDDot;\"], [0, \"&homtht;\"], [0, { v: \"&sim;\", n: 8402, o: \"&nvsim;\" }], [0, { v: \"&backsim;\", n: 817, o: \"&race;\" }], [0, { v: \"&ac;\", n: 819, o: \"&acE;\" }], [0, \"&acd;\"], [0, \"&VerticalTilde;\"], [0, \"&NotTilde;\"], [0, { v: \"&eqsim;\", n: 824, o: \"&nesim;\" }], [0, \"&sime;\"], [0, \"&NotTildeEqual;\"], [0, \"&cong;\"], [0, \"&simne;\"], [0, \"&ncong;\"], [0, \"&ap;\"], [0, \"&nap;\"], [0, \"&ape;\"], [0, { v: \"&apid;\", n: 824, o: \"&napid;\" }], [0, \"&backcong;\"], [0, { v: \"&asympeq;\", n: 8402, o: \"&nvap;\" }], [0, { v: \"&bump;\", n: 824, o: \"&nbump;\" }], [0, { v: \"&bumpe;\", n: 824, o: \"&nbumpe;\" }], [0, { v: \"&doteq;\", n: 824, o: \"&nedot;\" }], [0, \"&doteqdot;\"], [0, \"&efDot;\"], [0, \"&erDot;\"], [0, \"&Assign;\"], [0, \"&ecolon;\"], [0, \"&ecir;\"], [0, \"&circeq;\"], [1, \"&wedgeq;\"], [0, \"&veeeq;\"], [1, \"&triangleq;\"], [2, \"&equest;\"], [0, \"&ne;\"], [0, { v: \"&Congruent;\", n: 8421, o: \"&bnequiv;\" }], [0, \"&nequiv;\"], [1, { v: \"&le;\", n: 8402, o: \"&nvle;\" }], [0, { v: \"&ge;\", n: 8402, o: \"&nvge;\" }], [0, { v: \"&lE;\", n: 824, o: \"&nlE;\" }], [0, { v: \"&gE;\", n: 824, o: \"&ngE;\" }], [0, { v: \"&lnE;\", n: 65024, o: \"&lvertneqq;\" }], [0, { v: \"&gnE;\", n: 65024, o: \"&gvertneqq;\" }], [0, { v: \"&ll;\", n: new Map(/* #__PURE__ */ restoreDiff([[824, \"&nLtv;\"], [7577, \"&nLt;\"]])) }], [0, { v: \"&gg;\", n: new Map(/* #__PURE__ */ restoreDiff([[824, \"&nGtv;\"], [7577, \"&nGt;\"]])) }], [0, \"&between;\"], [0, \"&NotCupCap;\"], [0, \"&nless;\"], [0, \"&ngt;\"], [0, \"&nle;\"], [0, \"&nge;\"], [0, \"&lesssim;\"], [0, \"&GreaterTilde;\"], [0, \"&nlsim;\"], [0, \"&ngsim;\"], [0, \"&LessGreater;\"], [0, \"&gl;\"], [0, \"&NotLessGreater;\"], [0, \"&NotGreaterLess;\"], [0, \"&pr;\"], [0, \"&sc;\"], [0, \"&prcue;\"], [0, \"&sccue;\"], [0, \"&PrecedesTilde;\"], [0, { v: \"&scsim;\", n: 824, o: \"&NotSucceedsTilde;\" }], [0, \"&NotPrecedes;\"], [0, \"&NotSucceeds;\"], [0, { v: \"&sub;\", n: 8402, o: \"&NotSubset;\" }], [0, { v: \"&sup;\", n: 8402, o: \"&NotSuperset;\" }], [0, \"&nsub;\"], [0, \"&nsup;\"], [0, \"&sube;\"], [0, \"&supe;\"], [0, \"&NotSubsetEqual;\"], [0, \"&NotSupersetEqual;\"], [0, { v: \"&subne;\", n: 65024, o: \"&varsubsetneq;\" }], [0, { v: \"&supne;\", n: 65024, o: \"&varsupsetneq;\" }], [1, \"&cupdot;\"], [0, \"&UnionPlus;\"], [0, { v: \"&sqsub;\", n: 824, o: \"&NotSquareSubset;\" }], [0, { v: \"&sqsup;\", n: 824, o: \"&NotSquareSuperset;\" }], [0, \"&sqsube;\"], [0, \"&sqsupe;\"], [0, { v: \"&sqcap;\", n: 65024, o: \"&sqcaps;\" }], [0, { v: \"&sqcup;\", n: 65024, o: \"&sqcups;\" }], [0, \"&CirclePlus;\"], [0, \"&CircleMinus;\"], [0, \"&CircleTimes;\"], [0, \"&osol;\"], [0, \"&CircleDot;\"], [0, \"&circledcirc;\"], [0, \"&circledast;\"], [1, \"&circleddash;\"], [0, \"&boxplus;\"], [0, \"&boxminus;\"], [0, \"&boxtimes;\"], [0, \"&dotsquare;\"], [0, \"&RightTee;\"], [0, \"&dashv;\"], [0, \"&DownTee;\"], [0, \"&bot;\"], [1, \"&models;\"], [0, \"&DoubleRightTee;\"], [0, \"&Vdash;\"], [0, \"&Vvdash;\"], [0, \"&VDash;\"], [0, \"&nvdash;\"], [0, \"&nvDash;\"], [0, \"&nVdash;\"], [0, \"&nVDash;\"], [0, \"&prurel;\"], [1, \"&LeftTriangle;\"], [0, \"&RightTriangle;\"], [0, { v: \"&LeftTriangleEqual;\", n: 8402, o: \"&nvltrie;\" }], [0, { v: \"&RightTriangleEqual;\", n: 8402, o: \"&nvrtrie;\" }], [0, \"&origof;\"], [0, \"&imof;\"], [0, \"&multimap;\"], [0, \"&hercon;\"], [0, \"&intcal;\"], [0, \"&veebar;\"], [1, \"&barvee;\"], [0, \"&angrtvb;\"], [0, \"&lrtri;\"], [0, \"&bigwedge;\"], [0, \"&bigvee;\"], [0, \"&bigcap;\"], [0, \"&bigcup;\"], [0, \"&diam;\"], [0, \"&sdot;\"], [0, \"&sstarf;\"], [0, \"&divideontimes;\"], [0, \"&bowtie;\"], [0, \"&ltimes;\"], [0, \"&rtimes;\"], [0, \"&leftthreetimes;\"], [0, \"&rightthreetimes;\"], [0, \"&backsimeq;\"], [0, \"&curlyvee;\"], [0, \"&curlywedge;\"], [0, \"&Sub;\"], [0, \"&Sup;\"], [0, \"&Cap;\"], [0, \"&Cup;\"], [0, \"&fork;\"], [0, \"&epar;\"], [0, \"&lessdot;\"], [0, \"&gtdot;\"], [0, { v: \"&Ll;\", n: 824, o: \"&nLl;\" }], [0, { v: \"&Gg;\", n: 824, o: \"&nGg;\" }], [0, { v: \"&leg;\", n: 65024, o: \"&lesg;\" }], [0, { v: \"&gel;\", n: 65024, o: \"&gesl;\" }], [2, \"&cuepr;\"], [0, \"&cuesc;\"], [0, \"&NotPrecedesSlantEqual;\"], [0, \"&NotSucceedsSlantEqual;\"], [0, \"&NotSquareSubsetEqual;\"], [0, \"&NotSquareSupersetEqual;\"], [2, \"&lnsim;\"], [0, \"&gnsim;\"], [0, \"&precnsim;\"], [0, \"&scnsim;\"], [0, \"&nltri;\"], [0, \"&NotRightTriangle;\"], [0, \"&nltrie;\"], [0, \"&NotRightTriangleEqual;\"], [0, \"&vellip;\"], [0, \"&ctdot;\"], [0, \"&utdot;\"], [0, \"&dtdot;\"], [0, \"&disin;\"], [0, \"&isinsv;\"], [0, \"&isins;\"], [0, { v: \"&isindot;\", n: 824, o: \"&notindot;\" }], [0, \"&notinvc;\"], [0, \"&notinvb;\"], [1, { v: \"&isinE;\", n: 824, o: \"&notinE;\" }], [0, \"&nisd;\"], [0, \"&xnis;\"], [0, \"&nis;\"], [0, \"&notnivc;\"], [0, \"&notnivb;\"], [6, \"&barwed;\"], [0, \"&Barwed;\"], [1, \"&lceil;\"], [0, \"&rceil;\"], [0, \"&LeftFloor;\"], [0, \"&rfloor;\"], [0, \"&drcrop;\"], [0, \"&dlcrop;\"], [0, \"&urcrop;\"], [0, \"&ulcrop;\"], [0, \"&bnot;\"], [1, \"&profline;\"], [0, \"&profsurf;\"], [1, \"&telrec;\"], [0, \"&target;\"], [5, \"&ulcorn;\"], [0, \"&urcorn;\"], [0, \"&dlcorn;\"], [0, \"&drcorn;\"], [2, \"&frown;\"], [0, \"&smile;\"], [9, \"&cylcty;\"], [0, \"&profalar;\"], [7, \"&topbot;\"], [6, \"&ovbar;\"], [1, \"&solbar;\"], [60, \"&angzarr;\"], [51, \"&lmoustache;\"], [0, \"&rmoustache;\"], [2, \"&OverBracket;\"], [0, \"&bbrk;\"], [0, \"&bbrktbrk;\"], [37, \"&OverParenthesis;\"], [0, \"&UnderParenthesis;\"], [0, \"&OverBrace;\"], [0, \"&UnderBrace;\"], [2, \"&trpezium;\"], [4, \"&elinters;\"], [59, \"&blank;\"], [164, \"&circledS;\"], [55, \"&boxh;\"], [1, \"&boxv;\"], [9, \"&boxdr;\"], [3, \"&boxdl;\"], [3, \"&boxur;\"], [3, \"&boxul;\"], [3, \"&boxvr;\"], [7, \"&boxvl;\"], [7, \"&boxhd;\"], [7, \"&boxhu;\"], [7, \"&boxvh;\"], [19, \"&boxH;\"], [0, \"&boxV;\"], [0, \"&boxdR;\"], [0, \"&boxDr;\"], [0, \"&boxDR;\"], [0, \"&boxdL;\"], [0, \"&boxDl;\"], [0, \"&boxDL;\"], [0, \"&boxuR;\"], [0, \"&boxUr;\"], [0, \"&boxUR;\"], [0, \"&boxuL;\"], [0, \"&boxUl;\"], [0, \"&boxUL;\"], [0, \"&boxvR;\"], [0, \"&boxVr;\"], [0, \"&boxVR;\"], [0, \"&boxvL;\"], [0, \"&boxVl;\"], [0, \"&boxVL;\"], [0, \"&boxHd;\"], [0, \"&boxhD;\"], [0, \"&boxHD;\"], [0, \"&boxHu;\"], [0, \"&boxhU;\"], [0, \"&boxHU;\"], [0, \"&boxvH;\"], [0, \"&boxVh;\"], [0, \"&boxVH;\"], [19, \"&uhblk;\"], [3, \"&lhblk;\"], [3, \"&block;\"], [8, \"&blk14;\"], [0, \"&blk12;\"], [0, \"&blk34;\"], [13, \"&square;\"], [8, \"&blacksquare;\"], [0, \"&EmptyVerySmallSquare;\"], [1, \"&rect;\"], [0, \"&marker;\"], [2, \"&fltns;\"], [1, \"&bigtriangleup;\"], [0, \"&blacktriangle;\"], [0, \"&triangle;\"], [2, \"&blacktriangleright;\"], [0, \"&rtri;\"], [3, \"&bigtriangledown;\"], [0, \"&blacktriangledown;\"], [0, \"&dtri;\"], [2, \"&blacktriangleleft;\"], [0, \"&ltri;\"], [6, \"&loz;\"], [0, \"&cir;\"], [32, \"&tridot;\"], [2, \"&bigcirc;\"], [8, \"&ultri;\"], [0, \"&urtri;\"], [0, \"&lltri;\"], [0, \"&EmptySmallSquare;\"], [0, \"&FilledSmallSquare;\"], [8, \"&bigstar;\"], [0, \"&star;\"], [7, \"&phone;\"], [49, \"&female;\"], [1, \"&male;\"], [29, \"&spades;\"], [2, \"&clubs;\"], [1, \"&hearts;\"], [0, \"&diamondsuit;\"], [3, \"&sung;\"], [2, \"&flat;\"], [0, \"&natural;\"], [0, \"&sharp;\"], [163, \"&check;\"], [3, \"&cross;\"], [8, \"&malt;\"], [21, \"&sext;\"], [33, \"&VerticalSeparator;\"], [25, \"&lbbrk;\"], [0, \"&rbbrk;\"], [84, \"&bsolhsub;\"], [0, \"&suphsol;\"], [28, \"&LeftDoubleBracket;\"], [0, \"&RightDoubleBracket;\"], [0, \"&lang;\"], [0, \"&rang;\"], [0, \"&Lang;\"], [0, \"&Rang;\"], [0, \"&loang;\"], [0, \"&roang;\"], [7, \"&longleftarrow;\"], [0, \"&longrightarrow;\"], [0, \"&longleftrightarrow;\"], [0, \"&DoubleLongLeftArrow;\"], [0, \"&DoubleLongRightArrow;\"], [0, \"&DoubleLongLeftRightArrow;\"], [1, \"&longmapsto;\"], [2, \"&dzigrarr;\"], [258, \"&nvlArr;\"], [0, \"&nvrArr;\"], [0, \"&nvHarr;\"], [0, \"&Map;\"], [6, \"&lbarr;\"], [0, \"&bkarow;\"], [0, \"&lBarr;\"], [0, \"&dbkarow;\"], [0, \"&drbkarow;\"], [0, \"&DDotrahd;\"], [0, \"&UpArrowBar;\"], [0, \"&DownArrowBar;\"], [2, \"&Rarrtl;\"], [2, \"&latail;\"], [0, \"&ratail;\"], [0, \"&lAtail;\"], [0, \"&rAtail;\"], [0, \"&larrfs;\"], [0, \"&rarrfs;\"], [0, \"&larrbfs;\"], [0, \"&rarrbfs;\"], [2, \"&nwarhk;\"], [0, \"&nearhk;\"], [0, \"&hksearow;\"], [0, \"&hkswarow;\"], [0, \"&nwnear;\"], [0, \"&nesear;\"], [0, \"&seswar;\"], [0, \"&swnwar;\"], [8, { v: \"&rarrc;\", n: 824, o: \"&nrarrc;\" }], [1, \"&cudarrr;\"], [0, \"&ldca;\"], [0, \"&rdca;\"], [0, \"&cudarrl;\"], [0, \"&larrpl;\"], [2, \"&curarrm;\"], [0, \"&cularrp;\"], [7, \"&rarrpl;\"], [2, \"&harrcir;\"], [0, \"&Uarrocir;\"], [0, \"&lurdshar;\"], [0, \"&ldrushar;\"], [2, \"&LeftRightVector;\"], [0, \"&RightUpDownVector;\"], [0, \"&DownLeftRightVector;\"], [0, \"&LeftUpDownVector;\"], [0, \"&LeftVectorBar;\"], [0, \"&RightVectorBar;\"], [0, \"&RightUpVectorBar;\"], [0, \"&RightDownVectorBar;\"], [0, \"&DownLeftVectorBar;\"], [0, \"&DownRightVectorBar;\"], [0, \"&LeftUpVectorBar;\"], [0, \"&LeftDownVectorBar;\"], [0, \"&LeftTeeVector;\"], [0, \"&RightTeeVector;\"], [0, \"&RightUpTeeVector;\"], [0, \"&RightDownTeeVector;\"], [0, \"&DownLeftTeeVector;\"], [0, \"&DownRightTeeVector;\"], [0, \"&LeftUpTeeVector;\"], [0, \"&LeftDownTeeVector;\"], [0, \"&lHar;\"], [0, \"&uHar;\"], [0, \"&rHar;\"], [0, \"&dHar;\"], [0, \"&luruhar;\"], [0, \"&ldrdhar;\"], [0, \"&ruluhar;\"], [0, \"&rdldhar;\"], [0, \"&lharul;\"], [0, \"&llhard;\"], [0, \"&rharul;\"], [0, \"&lrhard;\"], [0, \"&udhar;\"], [0, \"&duhar;\"], [0, \"&RoundImplies;\"], [0, \"&erarr;\"], [0, \"&simrarr;\"], [0, \"&larrsim;\"], [0, \"&rarrsim;\"], [0, \"&rarrap;\"], [0, \"&ltlarr;\"], [1, \"&gtrarr;\"], [0, \"&subrarr;\"], [1, \"&suplarr;\"], [0, \"&lfisht;\"], [0, \"&rfisht;\"], [0, \"&ufisht;\"], [0, \"&dfisht;\"], [5, \"&lopar;\"], [0, \"&ropar;\"], [4, \"&lbrke;\"], [0, \"&rbrke;\"], [0, \"&lbrkslu;\"], [0, \"&rbrksld;\"], [0, \"&lbrksld;\"], [0, \"&rbrkslu;\"], [0, \"&langd;\"], [0, \"&rangd;\"], [0, \"&lparlt;\"], [0, \"&rpargt;\"], [0, \"&gtlPar;\"], [0, \"&ltrPar;\"], [3, \"&vzigzag;\"], [1, \"&vangrt;\"], [0, \"&angrtvbd;\"], [6, \"&ange;\"], [0, \"&range;\"], [0, \"&dwangle;\"], [0, \"&uwangle;\"], [0, \"&angmsdaa;\"], [0, \"&angmsdab;\"], [0, \"&angmsdac;\"], [0, \"&angmsdad;\"], [0, \"&angmsdae;\"], [0, \"&angmsdaf;\"], [0, \"&angmsdag;\"], [0, \"&angmsdah;\"], [0, \"&bemptyv;\"], [0, \"&demptyv;\"], [0, \"&cemptyv;\"], [0, \"&raemptyv;\"], [0, \"&laemptyv;\"], [0, \"&ohbar;\"], [0, \"&omid;\"], [0, \"&opar;\"], [1, \"&operp;\"], [1, \"&olcross;\"], [0, \"&odsold;\"], [1, \"&olcir;\"], [0, \"&ofcir;\"], [0, \"&olt;\"], [0, \"&ogt;\"], [0, \"&cirscir;\"], [0, \"&cirE;\"], [0, \"&solb;\"], [0, \"&bsolb;\"], [3, \"&boxbox;\"], [3, \"&trisb;\"], [0, \"&rtriltri;\"], [0, { v: \"&LeftTriangleBar;\", n: 824, o: \"&NotLeftTriangleBar;\" }], [0, { v: \"&RightTriangleBar;\", n: 824, o: \"&NotRightTriangleBar;\" }], [11, \"&iinfin;\"], [0, \"&infintie;\"], [0, \"&nvinfin;\"], [4, \"&eparsl;\"], [0, \"&smeparsl;\"], [0, \"&eqvparsl;\"], [5, \"&blacklozenge;\"], [8, \"&RuleDelayed;\"], [1, \"&dsol;\"], [9, \"&bigodot;\"], [0, \"&bigoplus;\"], [0, \"&bigotimes;\"], [1, \"&biguplus;\"], [1, \"&bigsqcup;\"], [5, \"&iiiint;\"], [0, \"&fpartint;\"], [2, \"&cirfnint;\"], [0, \"&awint;\"], [0, \"&rppolint;\"], [0, \"&scpolint;\"], [0, \"&npolint;\"], [0, \"&pointint;\"], [0, \"&quatint;\"], [0, \"&intlarhk;\"], [10, \"&pluscir;\"], [0, \"&plusacir;\"], [0, \"&simplus;\"], [0, \"&plusdu;\"], [0, \"&plussim;\"], [0, \"&plustwo;\"], [1, \"&mcomma;\"], [0, \"&minusdu;\"], [2, \"&loplus;\"], [0, \"&roplus;\"], [0, \"&Cross;\"], [0, \"&timesd;\"], [0, \"&timesbar;\"], [1, \"&smashp;\"], [0, \"&lotimes;\"], [0, \"&rotimes;\"], [0, \"&otimesas;\"], [0, \"&Otimes;\"], [0, \"&odiv;\"], [0, \"&triplus;\"], [0, \"&triminus;\"], [0, \"&tritime;\"], [0, \"&intprod;\"], [2, \"&amalg;\"], [0, \"&capdot;\"], [1, \"&ncup;\"], [0, \"&ncap;\"], [0, \"&capand;\"], [0, \"&cupor;\"], [0, \"&cupcap;\"], [0, \"&capcup;\"], [0, \"&cupbrcap;\"], [0, \"&capbrcup;\"], [0, \"&cupcup;\"], [0, \"&capcap;\"], [0, \"&ccups;\"], [0, \"&ccaps;\"], [2, \"&ccupssm;\"], [2, \"&And;\"], [0, \"&Or;\"], [0, \"&andand;\"], [0, \"&oror;\"], [0, \"&orslope;\"], [0, \"&andslope;\"], [1, \"&andv;\"], [0, \"&orv;\"], [0, \"&andd;\"], [0, \"&ord;\"], [1, \"&wedbar;\"], [6, \"&sdote;\"], [3, \"&simdot;\"], [2, { v: \"&congdot;\", n: 824, o: \"&ncongdot;\" }], [0, \"&easter;\"], [0, \"&apacir;\"], [0, { v: \"&apE;\", n: 824, o: \"&napE;\" }], [0, \"&eplus;\"], [0, \"&pluse;\"], [0, \"&Esim;\"], [0, \"&Colone;\"], [0, \"&Equal;\"], [1, \"&ddotseq;\"], [0, \"&equivDD;\"], [0, \"&ltcir;\"], [0, \"&gtcir;\"], [0, \"&ltquest;\"], [0, \"&gtquest;\"], [0, { v: \"&leqslant;\", n: 824, o: \"&nleqslant;\" }], [0, { v: \"&geqslant;\", n: 824, o: \"&ngeqslant;\" }], [0, \"&lesdot;\"], [0, \"&gesdot;\"], [0, \"&lesdoto;\"], [0, \"&gesdoto;\"], [0, \"&lesdotor;\"], [0, \"&gesdotol;\"], [0, \"&lap;\"], [0, \"&gap;\"], [0, \"&lne;\"], [0, \"&gne;\"], [0, \"&lnap;\"], [0, \"&gnap;\"], [0, \"&lEg;\"], [0, \"&gEl;\"], [0, \"&lsime;\"], [0, \"&gsime;\"], [0, \"&lsimg;\"], [0, \"&gsiml;\"], [0, \"&lgE;\"], [0, \"&glE;\"], [0, \"&lesges;\"], [0, \"&gesles;\"], [0, \"&els;\"], [0, \"&egs;\"], [0, \"&elsdot;\"], [0, \"&egsdot;\"], [0, \"&el;\"], [0, \"&eg;\"], [2, \"&siml;\"], [0, \"&simg;\"], [0, \"&simlE;\"], [0, \"&simgE;\"], [0, { v: \"&LessLess;\", n: 824, o: \"&NotNestedLessLess;\" }], [0, { v: \"&GreaterGreater;\", n: 824, o: \"&NotNestedGreaterGreater;\" }], [1, \"&glj;\"], [0, \"&gla;\"], [0, \"&ltcc;\"], [0, \"&gtcc;\"], [0, \"&lescc;\"], [0, \"&gescc;\"], [0, \"&smt;\"], [0, \"&lat;\"], [0, { v: \"&smte;\", n: 65024, o: \"&smtes;\" }], [0, { v: \"&late;\", n: 65024, o: \"&lates;\" }], [0, \"&bumpE;\"], [0, { v: \"&PrecedesEqual;\", n: 824, o: \"&NotPrecedesEqual;\" }], [0, { v: \"&sce;\", n: 824, o: \"&NotSucceedsEqual;\" }], [2, \"&prE;\"], [0, \"&scE;\"], [0, \"&precneqq;\"], [0, \"&scnE;\"], [0, \"&prap;\"], [0, \"&scap;\"], [0, \"&precnapprox;\"], [0, \"&scnap;\"], [0, \"&Pr;\"], [0, \"&Sc;\"], [0, \"&subdot;\"], [0, \"&supdot;\"], [0, \"&subplus;\"], [0, \"&supplus;\"], [0, \"&submult;\"], [0, \"&supmult;\"], [0, \"&subedot;\"], [0, \"&supedot;\"], [0, { v: \"&subE;\", n: 824, o: \"&nsubE;\" }], [0, { v: \"&supE;\", n: 824, o: \"&nsupE;\" }], [0, \"&subsim;\"], [0, \"&supsim;\"], [2, { v: \"&subnE;\", n: 65024, o: \"&varsubsetneqq;\" }], [0, { v: \"&supnE;\", n: 65024, o: \"&varsupsetneqq;\" }], [2, \"&csub;\"], [0, \"&csup;\"], [0, \"&csube;\"], [0, \"&csupe;\"], [0, \"&subsup;\"], [0, \"&supsub;\"], [0, \"&subsub;\"], [0, \"&supsup;\"], [0, \"&suphsub;\"], [0, \"&supdsub;\"], [0, \"&forkv;\"], [0, \"&topfork;\"], [0, \"&mlcp;\"], [8, \"&Dashv;\"], [1, \"&Vdashl;\"], [0, \"&Barv;\"], [0, \"&vBar;\"], [0, \"&vBarv;\"], [1, \"&Vbar;\"], [0, \"&Not;\"], [0, \"&bNot;\"], [0, \"&rnmid;\"], [0, \"&cirmid;\"], [0, \"&midcir;\"], [0, \"&topcir;\"], [0, \"&nhpar;\"], [0, \"&parsim;\"], [9, { v: \"&parsl;\", n: 8421, o: \"&nparsl;\" }], [44343, { n: new Map(/* #__PURE__ */ restoreDiff([[56476, \"&Ascr;\"], [1, \"&Cscr;\"], [0, \"&Dscr;\"], [2, \"&Gscr;\"], [2, \"&Jscr;\"], [0, \"&Kscr;\"], [2, \"&Nscr;\"], [0, \"&Oscr;\"], [0, \"&Pscr;\"], [0, \"&Qscr;\"], [1, \"&Sscr;\"], [0, \"&Tscr;\"], [0, \"&Uscr;\"], [0, \"&Vscr;\"], [0, \"&Wscr;\"], [0, \"&Xscr;\"], [0, \"&Yscr;\"], [0, \"&Zscr;\"], [0, \"&ascr;\"], [0, \"&bscr;\"], [0, \"&cscr;\"], [0, \"&dscr;\"], [1, \"&fscr;\"], [1, \"&hscr;\"], [0, \"&iscr;\"], [0, \"&jscr;\"], [0, \"&kscr;\"], [0, \"&lscr;\"], [0, \"&mscr;\"], [0, \"&nscr;\"], [1, \"&pscr;\"], [0, \"&qscr;\"], [0, \"&rscr;\"], [0, \"&sscr;\"], [0, \"&tscr;\"], [0, \"&uscr;\"], [0, \"&vscr;\"], [0, \"&wscr;\"], [0, \"&xscr;\"], [0, \"&yscr;\"], [0, \"&zscr;\"], [52, \"&Afr;\"], [0, \"&Bfr;\"], [1, \"&Dfr;\"], [0, \"&Efr;\"], [0, \"&Ffr;\"], [0, \"&Gfr;\"], [2, \"&Jfr;\"], [0, \"&Kfr;\"], [0, \"&Lfr;\"], [0, \"&Mfr;\"], [0, \"&Nfr;\"], [0, \"&Ofr;\"], [0, \"&Pfr;\"], [0, \"&Qfr;\"], [1, \"&Sfr;\"], [0, \"&Tfr;\"], [0, \"&Ufr;\"], [0, \"&Vfr;\"], [0, \"&Wfr;\"], [0, \"&Xfr;\"], [0, \"&Yfr;\"], [1, \"&afr;\"], [0, \"&bfr;\"], [0, \"&cfr;\"], [0, \"&dfr;\"], [0, \"&efr;\"], [0, \"&ffr;\"], [0, \"&gfr;\"], [0, \"&hfr;\"], [0, \"&ifr;\"], [0, \"&jfr;\"], [0, \"&kfr;\"], [0, \"&lfr;\"], [0, \"&mfr;\"], [0, \"&nfr;\"], [0, \"&ofr;\"], [0, \"&pfr;\"], [0, \"&qfr;\"], [0, \"&rfr;\"], [0, \"&sfr;\"], [0, \"&tfr;\"], [0, \"&ufr;\"], [0, \"&vfr;\"], [0, \"&wfr;\"], [0, \"&xfr;\"], [0, \"&yfr;\"], [0, \"&zfr;\"], [0, \"&Aopf;\"], [0, \"&Bopf;\"], [1, \"&Dopf;\"], [0, \"&Eopf;\"], [0, \"&Fopf;\"], [0, \"&Gopf;\"], [1, \"&Iopf;\"], [0, \"&Jopf;\"], [0, \"&Kopf;\"], [0, \"&Lopf;\"], [0, \"&Mopf;\"], [1, \"&Oopf;\"], [3, \"&Sopf;\"], [0, \"&Topf;\"], [0, \"&Uopf;\"], [0, \"&Vopf;\"], [0, \"&Wopf;\"], [0, \"&Xopf;\"], [0, \"&Yopf;\"], [1, \"&aopf;\"], [0, \"&bopf;\"], [0, \"&copf;\"], [0, \"&dopf;\"], [0, \"&eopf;\"], [0, \"&fopf;\"], [0, \"&gopf;\"], [0, \"&hopf;\"], [0, \"&iopf;\"], [0, \"&jopf;\"], [0, \"&kopf;\"], [0, \"&lopf;\"], [0, \"&mopf;\"], [0, \"&nopf;\"], [0, \"&oopf;\"], [0, \"&popf;\"], [0, \"&qopf;\"], [0, \"&ropf;\"], [0, \"&sopf;\"], [0, \"&topf;\"], [0, \"&uopf;\"], [0, \"&vopf;\"], [0, \"&wopf;\"], [0, \"&xopf;\"], [0, \"&yopf;\"], [0, \"&zopf;\"]])) }], [8906, \"&fflig;\"], [0, \"&filig;\"], [0, \"&fllig;\"], [0, \"&ffilig;\"], [0, \"&ffllig;\"]]));\n\n},{}],22:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLAttribute = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.DecodingMode = exports.EntityDecoder = exports.encodeHTML5 = exports.encodeHTML4 = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.escapeText = exports.escapeAttribute = exports.escapeUTF8 = exports.escape = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = exports.EncodingMode = exports.EntityLevel = void 0;\nvar decode_js_1 = require(\"./decode.js\");\nvar encode_js_1 = require(\"./encode.js\");\nvar escape_js_1 = require(\"./escape.js\");\n/** The level of entities to support. */\nvar EntityLevel;\n(function (EntityLevel) {\n    /** Support only XML entities. */\n    EntityLevel[EntityLevel[\"XML\"] = 0] = \"XML\";\n    /** Support HTML entities, which are a superset of XML entities. */\n    EntityLevel[EntityLevel[\"HTML\"] = 1] = \"HTML\";\n})(EntityLevel = exports.EntityLevel || (exports.EntityLevel = {}));\nvar EncodingMode;\n(function (EncodingMode) {\n    /**\n     * The output is UTF-8 encoded. Only characters that need escaping within\n     * XML will be escaped.\n     */\n    EncodingMode[EncodingMode[\"UTF8\"] = 0] = \"UTF8\";\n    /**\n     * The output consists only of ASCII characters. Characters that need\n     * escaping within HTML, and characters that aren't ASCII characters will\n     * be escaped.\n     */\n    EncodingMode[EncodingMode[\"ASCII\"] = 1] = \"ASCII\";\n    /**\n     * Encode all characters that have an equivalent entity, as well as all\n     * characters that are not ASCII characters.\n     */\n    EncodingMode[EncodingMode[\"Extensive\"] = 2] = \"Extensive\";\n    /**\n     * Encode all characters that have to be escaped in HTML attributes,\n     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n     */\n    EncodingMode[EncodingMode[\"Attribute\"] = 3] = \"Attribute\";\n    /**\n     * Encode all characters that have to be escaped in HTML text,\n     * following {@link https://html.spec.whatwg.org/multipage/parsing.html#escapingString}.\n     */\n    EncodingMode[EncodingMode[\"Text\"] = 4] = \"Text\";\n})(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));\n/**\n * Decodes a string with entities.\n *\n * @param data String to decode.\n * @param options Decoding options.\n */\nfunction decode(data, options) {\n    if (options === void 0) { options = EntityLevel.XML; }\n    var level = typeof options === \"number\" ? options : options.level;\n    if (level === EntityLevel.HTML) {\n        var mode = typeof options === \"object\" ? options.mode : undefined;\n        return (0, decode_js_1.decodeHTML)(data, mode);\n    }\n    return (0, decode_js_1.decodeXML)(data);\n}\nexports.decode = decode;\n/**\n * Decodes a string with entities. Does not allow missing trailing semicolons for entities.\n *\n * @param data String to decode.\n * @param options Decoding options.\n * @deprecated Use `decode` with the `mode` set to `Strict`.\n */\nfunction decodeStrict(data, options) {\n    var _a;\n    if (options === void 0) { options = EntityLevel.XML; }\n    var opts = typeof options === \"number\" ? { level: options } : options;\n    (_a = opts.mode) !== null && _a !== void 0 ? _a : (opts.mode = decode_js_1.DecodingMode.Strict);\n    return decode(data, opts);\n}\nexports.decodeStrict = decodeStrict;\n/**\n * Encodes a string with entities.\n *\n * @param data String to encode.\n * @param options Encoding options.\n */\nfunction encode(data, options) {\n    if (options === void 0) { options = EntityLevel.XML; }\n    var opts = typeof options === \"number\" ? { level: options } : options;\n    // Mode `UTF8` just escapes XML entities\n    if (opts.mode === EncodingMode.UTF8)\n        return (0, escape_js_1.escapeUTF8)(data);\n    if (opts.mode === EncodingMode.Attribute)\n        return (0, escape_js_1.escapeAttribute)(data);\n    if (opts.mode === EncodingMode.Text)\n        return (0, escape_js_1.escapeText)(data);\n    if (opts.level === EntityLevel.HTML) {\n        if (opts.mode === EncodingMode.ASCII) {\n            return (0, encode_js_1.encodeNonAsciiHTML)(data);\n        }\n        return (0, encode_js_1.encodeHTML)(data);\n    }\n    // ASCII and Extensive are equivalent\n    return (0, escape_js_1.encodeXML)(data);\n}\nexports.encode = encode;\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"encodeXML\", { enumerable: true, get: function () { return escape_js_2.encodeXML; } });\nObject.defineProperty(exports, \"escape\", { enumerable: true, get: function () { return escape_js_2.escape; } });\nObject.defineProperty(exports, \"escapeUTF8\", { enumerable: true, get: function () { return escape_js_2.escapeUTF8; } });\nObject.defineProperty(exports, \"escapeAttribute\", { enumerable: true, get: function () { return escape_js_2.escapeAttribute; } });\nObject.defineProperty(exports, \"escapeText\", { enumerable: true, get: function () { return escape_js_2.escapeText; } });\nvar encode_js_2 = require(\"./encode.js\");\nObject.defineProperty(exports, \"encodeHTML\", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeNonAsciiHTML\", { enumerable: true, get: function () { return encode_js_2.encodeNonAsciiHTML; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"encodeHTML4\", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });\nObject.defineProperty(exports, \"encodeHTML5\", { enumerable: true, get: function () { return encode_js_2.encodeHTML; } });\nvar decode_js_2 = require(\"./decode.js\");\nObject.defineProperty(exports, \"EntityDecoder\", { enumerable: true, get: function () { return decode_js_2.EntityDecoder; } });\nObject.defineProperty(exports, \"DecodingMode\", { enumerable: true, get: function () { return decode_js_2.DecodingMode; } });\nObject.defineProperty(exports, \"decodeXML\", { enumerable: true, get: function () { return decode_js_2.decodeXML; } });\nObject.defineProperty(exports, \"decodeHTML\", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTMLStrict\", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeHTMLAttribute\", { enumerable: true, get: function () { return decode_js_2.decodeHTMLAttribute; } });\n// Legacy aliases (deprecated)\nObject.defineProperty(exports, \"decodeHTML4\", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML5\", { enumerable: true, get: function () { return decode_js_2.decodeHTML; } });\nObject.defineProperty(exports, \"decodeHTML4Strict\", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeHTML5Strict\", { enumerable: true, get: function () { return decode_js_2.decodeHTMLStrict; } });\nObject.defineProperty(exports, \"decodeXMLStrict\", { enumerable: true, get: function () { return decode_js_2.decodeXML; } });\n\n},{\"./decode.js\":15,\"./encode.js\":17,\"./escape.js\":18}],23:[function(require,module,exports){\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nvar Tokenizer_js_1 = __importStar(require(\"./Tokenizer.js\"));\nvar decode_js_1 = require(\"entities/lib/decode.js\");\nvar formTags = new Set([\n    \"input\",\n    \"option\",\n    \"optgroup\",\n    \"select\",\n    \"button\",\n    \"datalist\",\n    \"textarea\",\n]);\nvar pTag = new Set([\"p\"]);\nvar tableSectionTags = new Set([\"thead\", \"tbody\"]);\nvar ddtTags = new Set([\"dd\", \"dt\"]);\nvar rtpTags = new Set([\"rt\", \"rp\"]);\nvar openImpliesClose = new Map([\n    [\"tr\", new Set([\"tr\", \"th\", \"td\"])],\n    [\"th\", new Set([\"th\"])],\n    [\"td\", new Set([\"thead\", \"th\", \"td\"])],\n    [\"body\", new Set([\"head\", \"link\", \"script\"])],\n    [\"li\", new Set([\"li\"])],\n    [\"p\", pTag],\n    [\"h1\", pTag],\n    [\"h2\", pTag],\n    [\"h3\", pTag],\n    [\"h4\", pTag],\n    [\"h5\", pTag],\n    [\"h6\", pTag],\n    [\"select\", formTags],\n    [\"input\", formTags],\n    [\"output\", formTags],\n    [\"button\", formTags],\n    [\"datalist\", formTags],\n    [\"textarea\", formTags],\n    [\"option\", new Set([\"option\"])],\n    [\"optgroup\", new Set([\"optgroup\", \"option\"])],\n    [\"dd\", ddtTags],\n    [\"dt\", ddtTags],\n    [\"address\", pTag],\n    [\"article\", pTag],\n    [\"aside\", pTag],\n    [\"blockquote\", pTag],\n    [\"details\", pTag],\n    [\"div\", pTag],\n    [\"dl\", pTag],\n    [\"fieldset\", pTag],\n    [\"figcaption\", pTag],\n    [\"figure\", pTag],\n    [\"footer\", pTag],\n    [\"form\", pTag],\n    [\"header\", pTag],\n    [\"hr\", pTag],\n    [\"main\", pTag],\n    [\"nav\", pTag],\n    [\"ol\", pTag],\n    [\"pre\", pTag],\n    [\"section\", pTag],\n    [\"table\", pTag],\n    [\"ul\", pTag],\n    [\"rt\", rtpTags],\n    [\"rp\", rtpTags],\n    [\"tbody\", tableSectionTags],\n    [\"tfoot\", tableSectionTags],\n]);\nvar voidElements = new Set([\n    \"area\",\n    \"base\",\n    \"basefont\",\n    \"br\",\n    \"col\",\n    \"command\",\n    \"embed\",\n    \"frame\",\n    \"hr\",\n    \"img\",\n    \"input\",\n    \"isindex\",\n    \"keygen\",\n    \"link\",\n    \"meta\",\n    \"param\",\n    \"source\",\n    \"track\",\n    \"wbr\",\n]);\nvar foreignContextElements = new Set([\"math\", \"svg\"]);\nvar htmlIntegrationElements = new Set([\n    \"mi\",\n    \"mo\",\n    \"mn\",\n    \"ms\",\n    \"mtext\",\n    \"annotation-xml\",\n    \"foreignobject\",\n    \"desc\",\n    \"title\",\n]);\nvar reNameEnd = /\\s|\\//;\nvar Parser = /** @class */ (function () {\n    function Parser(cbs, options) {\n        if (options === void 0) { options = {}; }\n        var _a, _b, _c, _d, _e;\n        this.options = options;\n        /** The start index of the last event. */\n        this.startIndex = 0;\n        /** The end index of the last event. */\n        this.endIndex = 0;\n        /**\n         * Store the start index of the current open tag,\n         * so we can update the start index for attributes.\n         */\n        this.openTagStart = 0;\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribvalue = \"\";\n        this.attribs = null;\n        this.stack = [];\n        this.buffers = [];\n        this.bufferOffset = 0;\n        /** The index of the last written buffer. Used when resuming after a `pause()`. */\n        this.writeIndex = 0;\n        /** Indicates whether the parser has finished running / `.end` has been called. */\n        this.ended = false;\n        this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};\n        this.htmlMode = !this.options.xmlMode;\n        this.lowerCaseTagNames = (_a = options.lowerCaseTags) !== null && _a !== void 0 ? _a : this.htmlMode;\n        this.lowerCaseAttributeNames =\n            (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : this.htmlMode;\n        this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_js_1.default)(this.options, this);\n        this.foreignContext = [!this.htmlMode];\n        (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n    }\n    // Tokenizer event handlers\n    /** @internal */\n    Parser.prototype.ontext = function (start, endIndex) {\n        var _a, _b;\n        var data = this.getSlice(start, endIndex);\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, data);\n        this.startIndex = endIndex;\n    };\n    /** @internal */\n    Parser.prototype.ontextentity = function (cp, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex - 1;\n        (_b = (_a = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a, (0, decode_js_1.fromCodePoint)(cp));\n        this.startIndex = endIndex;\n    };\n    /**\n     * Checks if the current tag is a void element. Override this if you want\n     * to specify your own additional void elements.\n     */\n    Parser.prototype.isVoidElement = function (name) {\n        return this.htmlMode && voidElements.has(name);\n    };\n    /** @internal */\n    Parser.prototype.onopentagname = function (start, endIndex) {\n        this.endIndex = endIndex;\n        var name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        this.emitOpenTag(name);\n    };\n    Parser.prototype.emitOpenTag = function (name) {\n        var _a, _b, _c, _d;\n        this.openTagStart = this.startIndex;\n        this.tagname = name;\n        var impliesClose = this.htmlMode && openImpliesClose.get(name);\n        if (impliesClose) {\n            while (this.stack.length > 0 && impliesClose.has(this.stack[0])) {\n                var element = this.stack.shift();\n                (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, true);\n            }\n        }\n        if (!this.isVoidElement(name)) {\n            this.stack.unshift(name);\n            if (this.htmlMode) {\n                if (foreignContextElements.has(name)) {\n                    this.foreignContext.unshift(true);\n                }\n                else if (htmlIntegrationElements.has(name)) {\n                    this.foreignContext.unshift(false);\n                }\n            }\n        }\n        (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);\n        if (this.cbs.onopentag)\n            this.attribs = {};\n    };\n    Parser.prototype.endOpenTag = function (isImplied) {\n        var _a, _b;\n        this.startIndex = this.openTagStart;\n        if (this.attribs) {\n            (_b = (_a = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a, this.tagname, this.attribs, isImplied);\n            this.attribs = null;\n        }\n        if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {\n            this.cbs.onclosetag(this.tagname, true);\n        }\n        this.tagname = \"\";\n    };\n    /** @internal */\n    Parser.prototype.onopentagend = function (endIndex) {\n        this.endIndex = endIndex;\n        this.endOpenTag(false);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onclosetag = function (start, endIndex) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        this.endIndex = endIndex;\n        var name = this.getSlice(start, endIndex);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        if (this.htmlMode &&\n            (foreignContextElements.has(name) ||\n                htmlIntegrationElements.has(name))) {\n            this.foreignContext.shift();\n        }\n        if (!this.isVoidElement(name)) {\n            var pos = this.stack.indexOf(name);\n            if (pos !== -1) {\n                for (var index = 0; index <= pos; index++) {\n                    var element = this.stack.shift();\n                    // We know the stack has sufficient elements.\n                    (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, element, index !== pos);\n                }\n            }\n            else if (this.htmlMode && name === \"p\") {\n                // Implicit open before close\n                this.emitOpenTag(\"p\");\n                this.closeCurrentTag(true);\n            }\n        }\n        else if (this.htmlMode && name === \"br\") {\n            // We can't use `emitOpenTag` for implicit open, as `br` would be implicitly closed.\n            (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, \"br\");\n            (_f = (_e = this.cbs).onopentag) === null || _f === void 0 ? void 0 : _f.call(_e, \"br\", {}, true);\n            (_h = (_g = this.cbs).onclosetag) === null || _h === void 0 ? void 0 : _h.call(_g, \"br\", false);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onselfclosingtag = function (endIndex) {\n        this.endIndex = endIndex;\n        if (this.options.recognizeSelfClosing || this.foreignContext[0]) {\n            this.closeCurrentTag(false);\n            // Set `startIndex` for next node\n            this.startIndex = endIndex + 1;\n        }\n        else {\n            // Ignore the fact that the tag is self-closing.\n            this.onopentagend(endIndex);\n        }\n    };\n    Parser.prototype.closeCurrentTag = function (isOpenImplied) {\n        var _a, _b;\n        var name = this.tagname;\n        this.endOpenTag(isOpenImplied);\n        // Self-closing tags will be on the top of the stack\n        if (this.stack[0] === name) {\n            // If the opening tag isn't implied, the closing tag has to be implied.\n            (_b = (_a = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a, name, !isOpenImplied);\n            this.stack.shift();\n        }\n    };\n    /** @internal */\n    Parser.prototype.onattribname = function (start, endIndex) {\n        this.startIndex = start;\n        var name = this.getSlice(start, endIndex);\n        this.attribname = this.lowerCaseAttributeNames\n            ? name.toLowerCase()\n            : name;\n    };\n    /** @internal */\n    Parser.prototype.onattribdata = function (start, endIndex) {\n        this.attribvalue += this.getSlice(start, endIndex);\n    };\n    /** @internal */\n    Parser.prototype.onattribentity = function (cp) {\n        this.attribvalue += (0, decode_js_1.fromCodePoint)(cp);\n    };\n    /** @internal */\n    Parser.prototype.onattribend = function (quote, endIndex) {\n        var _a, _b;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a, this.attribname, this.attribvalue, quote === Tokenizer_js_1.QuoteType.Double\n            ? '\"'\n            : quote === Tokenizer_js_1.QuoteType.Single\n                ? \"'\"\n                : quote === Tokenizer_js_1.QuoteType.NoValue\n                    ? undefined\n                    : null);\n        if (this.attribs &&\n            !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {\n            this.attribs[this.attribname] = this.attribvalue;\n        }\n        this.attribvalue = \"\";\n    };\n    Parser.prototype.getInstructionName = function (value) {\n        var index = value.search(reNameEnd);\n        var name = index < 0 ? value : value.substr(0, index);\n        if (this.lowerCaseTagNames) {\n            name = name.toLowerCase();\n        }\n        return name;\n    };\n    /** @internal */\n    Parser.prototype.ondeclaration = function (start, endIndex) {\n        this.endIndex = endIndex;\n        var value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            var name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"!\".concat(name), \"!\".concat(value));\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onprocessinginstruction = function (start, endIndex) {\n        this.endIndex = endIndex;\n        var value = this.getSlice(start, endIndex);\n        if (this.cbs.onprocessinginstruction) {\n            var name = this.getInstructionName(value);\n            this.cbs.onprocessinginstruction(\"?\".concat(name), \"?\".concat(value));\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.oncomment = function (start, endIndex, offset) {\n        var _a, _b, _c, _d;\n        this.endIndex = endIndex;\n        (_b = (_a = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a, this.getSlice(start, endIndex - offset));\n        (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.oncdata = function (start, endIndex, offset) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        this.endIndex = endIndex;\n        var value = this.getSlice(start, endIndex - offset);\n        if (!this.htmlMode || this.options.recognizeCDATA) {\n            (_b = (_a = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);\n            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);\n        }\n        else {\n            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, \"[CDATA[\".concat(value, \"]]\"));\n            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);\n        }\n        // Set `startIndex` for next node\n        this.startIndex = endIndex + 1;\n    };\n    /** @internal */\n    Parser.prototype.onend = function () {\n        var _a, _b;\n        if (this.cbs.onclosetag) {\n            // Set the end index for all remaining tags\n            this.endIndex = this.startIndex;\n            for (var index = 0; index < this.stack.length; index++) {\n                this.cbs.onclosetag(this.stack[index], true);\n            }\n        }\n        (_b = (_a = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    /**\n     * Resets the parser to a blank state, ready to parse a new HTML document\n     */\n    Parser.prototype.reset = function () {\n        var _a, _b, _c, _d;\n        (_b = (_a = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.tokenizer.reset();\n        this.tagname = \"\";\n        this.attribname = \"\";\n        this.attribs = null;\n        this.stack.length = 0;\n        this.startIndex = 0;\n        this.endIndex = 0;\n        (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n        this.buffers.length = 0;\n        this.foreignContext.length = 0;\n        this.foreignContext.unshift(!this.htmlMode);\n        this.bufferOffset = 0;\n        this.writeIndex = 0;\n        this.ended = false;\n    };\n    /**\n     * Resets the parser, then parses a complete document and\n     * pushes it to the handler.\n     *\n     * @param data Document to parse.\n     */\n    Parser.prototype.parseComplete = function (data) {\n        this.reset();\n        this.end(data);\n    };\n    Parser.prototype.getSlice = function (start, end) {\n        while (start - this.bufferOffset >= this.buffers[0].length) {\n            this.shiftBuffer();\n        }\n        var slice = this.buffers[0].slice(start - this.bufferOffset, end - this.bufferOffset);\n        while (end - this.bufferOffset > this.buffers[0].length) {\n            this.shiftBuffer();\n            slice += this.buffers[0].slice(0, end - this.bufferOffset);\n        }\n        return slice;\n    };\n    Parser.prototype.shiftBuffer = function () {\n        this.bufferOffset += this.buffers[0].length;\n        this.writeIndex--;\n        this.buffers.shift();\n    };\n    /**\n     * Parses a chunk of data and calls the corresponding callbacks.\n     *\n     * @param chunk Chunk to parse.\n     */\n    Parser.prototype.write = function (chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".write() after done!\"));\n            return;\n        }\n        this.buffers.push(chunk);\n        if (this.tokenizer.running) {\n            this.tokenizer.write(chunk);\n            this.writeIndex++;\n        }\n    };\n    /**\n     * Parses the end of the buffer and clears the stack, calls onend.\n     *\n     * @param chunk Optional final chunk to parse.\n     */\n    Parser.prototype.end = function (chunk) {\n        var _a, _b;\n        if (this.ended) {\n            (_b = (_a = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a, new Error(\".end() after done!\"));\n            return;\n        }\n        if (chunk)\n            this.write(chunk);\n        this.ended = true;\n        this.tokenizer.end();\n    };\n    /**\n     * Pauses parsing. The parser won't emit events until `resume` is called.\n     */\n    Parser.prototype.pause = function () {\n        this.tokenizer.pause();\n    };\n    /**\n     * Resumes parsing after `pause` was called.\n     */\n    Parser.prototype.resume = function () {\n        this.tokenizer.resume();\n        while (this.tokenizer.running &&\n            this.writeIndex < this.buffers.length) {\n            this.tokenizer.write(this.buffers[this.writeIndex++]);\n        }\n        if (this.ended)\n            this.tokenizer.end();\n    };\n    /**\n     * Alias of `write`, for backwards compatibility.\n     *\n     * @param chunk Chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.parseChunk = function (chunk) {\n        this.write(chunk);\n    };\n    /**\n     * Alias of `end`, for backwards compatibility.\n     *\n     * @param chunk Optional final chunk to parse.\n     * @deprecated\n     */\n    Parser.prototype.done = function (chunk) {\n        this.end(chunk);\n    };\n    return Parser;\n}());\nexports.Parser = Parser;\n\n},{\"./Tokenizer.js\":24,\"entities/lib/decode.js\":15}],24:[function(require,module,exports){\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QuoteType = void 0;\nvar decode_js_1 = require(\"entities/lib/decode.js\");\nvar CharCodes;\n(function (CharCodes) {\n    CharCodes[CharCodes[\"Tab\"] = 9] = \"Tab\";\n    CharCodes[CharCodes[\"NewLine\"] = 10] = \"NewLine\";\n    CharCodes[CharCodes[\"FormFeed\"] = 12] = \"FormFeed\";\n    CharCodes[CharCodes[\"CarriageReturn\"] = 13] = \"CarriageReturn\";\n    CharCodes[CharCodes[\"Space\"] = 32] = \"Space\";\n    CharCodes[CharCodes[\"ExclamationMark\"] = 33] = \"ExclamationMark\";\n    CharCodes[CharCodes[\"Number\"] = 35] = \"Number\";\n    CharCodes[CharCodes[\"Amp\"] = 38] = \"Amp\";\n    CharCodes[CharCodes[\"SingleQuote\"] = 39] = \"SingleQuote\";\n    CharCodes[CharCodes[\"DoubleQuote\"] = 34] = \"DoubleQuote\";\n    CharCodes[CharCodes[\"Dash\"] = 45] = \"Dash\";\n    CharCodes[CharCodes[\"Slash\"] = 47] = \"Slash\";\n    CharCodes[CharCodes[\"Zero\"] = 48] = \"Zero\";\n    CharCodes[CharCodes[\"Nine\"] = 57] = \"Nine\";\n    CharCodes[CharCodes[\"Semi\"] = 59] = \"Semi\";\n    CharCodes[CharCodes[\"Lt\"] = 60] = \"Lt\";\n    CharCodes[CharCodes[\"Eq\"] = 61] = \"Eq\";\n    CharCodes[CharCodes[\"Gt\"] = 62] = \"Gt\";\n    CharCodes[CharCodes[\"Questionmark\"] = 63] = \"Questionmark\";\n    CharCodes[CharCodes[\"UpperA\"] = 65] = \"UpperA\";\n    CharCodes[CharCodes[\"LowerA\"] = 97] = \"LowerA\";\n    CharCodes[CharCodes[\"UpperF\"] = 70] = \"UpperF\";\n    CharCodes[CharCodes[\"LowerF\"] = 102] = \"LowerF\";\n    CharCodes[CharCodes[\"UpperZ\"] = 90] = \"UpperZ\";\n    CharCodes[CharCodes[\"LowerZ\"] = 122] = \"LowerZ\";\n    CharCodes[CharCodes[\"LowerX\"] = 120] = \"LowerX\";\n    CharCodes[CharCodes[\"OpeningSquareBracket\"] = 91] = \"OpeningSquareBracket\";\n})(CharCodes || (CharCodes = {}));\n/** All the states the tokenizer can be in. */\nvar State;\n(function (State) {\n    State[State[\"Text\"] = 1] = \"Text\";\n    State[State[\"BeforeTagName\"] = 2] = \"BeforeTagName\";\n    State[State[\"InTagName\"] = 3] = \"InTagName\";\n    State[State[\"InSelfClosingTag\"] = 4] = \"InSelfClosingTag\";\n    State[State[\"BeforeClosingTagName\"] = 5] = \"BeforeClosingTagName\";\n    State[State[\"InClosingTagName\"] = 6] = \"InClosingTagName\";\n    State[State[\"AfterClosingTagName\"] = 7] = \"AfterClosingTagName\";\n    // Attributes\n    State[State[\"BeforeAttributeName\"] = 8] = \"BeforeAttributeName\";\n    State[State[\"InAttributeName\"] = 9] = \"InAttributeName\";\n    State[State[\"AfterAttributeName\"] = 10] = \"AfterAttributeName\";\n    State[State[\"BeforeAttributeValue\"] = 11] = \"BeforeAttributeValue\";\n    State[State[\"InAttributeValueDq\"] = 12] = \"InAttributeValueDq\";\n    State[State[\"InAttributeValueSq\"] = 13] = \"InAttributeValueSq\";\n    State[State[\"InAttributeValueNq\"] = 14] = \"InAttributeValueNq\";\n    // Declarations\n    State[State[\"BeforeDeclaration\"] = 15] = \"BeforeDeclaration\";\n    State[State[\"InDeclaration\"] = 16] = \"InDeclaration\";\n    // Processing instructions\n    State[State[\"InProcessingInstruction\"] = 17] = \"InProcessingInstruction\";\n    // Comments & CDATA\n    State[State[\"BeforeComment\"] = 18] = \"BeforeComment\";\n    State[State[\"CDATASequence\"] = 19] = \"CDATASequence\";\n    State[State[\"InSpecialComment\"] = 20] = \"InSpecialComment\";\n    State[State[\"InCommentLike\"] = 21] = \"InCommentLike\";\n    // Special tags\n    State[State[\"BeforeSpecialS\"] = 22] = \"BeforeSpecialS\";\n    State[State[\"SpecialStartSequence\"] = 23] = \"SpecialStartSequence\";\n    State[State[\"InSpecialTag\"] = 24] = \"InSpecialTag\";\n    State[State[\"InEntity\"] = 25] = \"InEntity\";\n})(State || (State = {}));\nfunction isWhitespace(c) {\n    return (c === CharCodes.Space ||\n        c === CharCodes.NewLine ||\n        c === CharCodes.Tab ||\n        c === CharCodes.FormFeed ||\n        c === CharCodes.CarriageReturn);\n}\nfunction isEndOfTagSection(c) {\n    return c === CharCodes.Slash || c === CharCodes.Gt || isWhitespace(c);\n}\nfunction isASCIIAlpha(c) {\n    return ((c >= CharCodes.LowerA && c <= CharCodes.LowerZ) ||\n        (c >= CharCodes.UpperA && c <= CharCodes.UpperZ));\n}\nvar QuoteType;\n(function (QuoteType) {\n    QuoteType[QuoteType[\"NoValue\"] = 0] = \"NoValue\";\n    QuoteType[QuoteType[\"Unquoted\"] = 1] = \"Unquoted\";\n    QuoteType[QuoteType[\"Single\"] = 2] = \"Single\";\n    QuoteType[QuoteType[\"Double\"] = 3] = \"Double\";\n})(QuoteType = exports.QuoteType || (exports.QuoteType = {}));\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\nvar Sequences = {\n    Cdata: new Uint8Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),\n    CdataEnd: new Uint8Array([0x5d, 0x5d, 0x3e]),\n    CommentEnd: new Uint8Array([0x2d, 0x2d, 0x3e]),\n    ScriptEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),\n    StyleEnd: new Uint8Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),\n    TitleEnd: new Uint8Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]), // `</title`\n};\nvar Tokenizer = /** @class */ (function () {\n    function Tokenizer(_a, cbs) {\n        var _b = _a.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a.decodeEntities, decodeEntities = _c === void 0 ? true : _c;\n        var _this = this;\n        this.cbs = cbs;\n        /** The current state the tokenizer is in. */\n        this.state = State.Text;\n        /** The read buffer. */\n        this.buffer = \"\";\n        /** The beginning of the section that is currently being read. */\n        this.sectionStart = 0;\n        /** The index within the buffer that we are currently looking at. */\n        this.index = 0;\n        /** The start of the last entity. */\n        this.entityStart = 0;\n        /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n        this.baseState = State.Text;\n        /** For special parsing behavior inside of script and style tags. */\n        this.isSpecial = false;\n        /** Indicates whether the tokenizer has been paused. */\n        this.running = true;\n        /** The offset of the current buffer. */\n        this.offset = 0;\n        this.currentSequence = undefined;\n        this.sequenceIndex = 0;\n        this.xmlMode = xmlMode;\n        this.decodeEntities = decodeEntities;\n        this.entityDecoder = new decode_js_1.EntityDecoder(xmlMode ? decode_js_1.xmlDecodeTree : decode_js_1.htmlDecodeTree, function (cp, consumed) { return _this.emitCodePoint(cp, consumed); });\n    }\n    Tokenizer.prototype.reset = function () {\n        this.state = State.Text;\n        this.buffer = \"\";\n        this.sectionStart = 0;\n        this.index = 0;\n        this.baseState = State.Text;\n        this.currentSequence = undefined;\n        this.running = true;\n        this.offset = 0;\n    };\n    Tokenizer.prototype.write = function (chunk) {\n        this.offset += this.buffer.length;\n        this.buffer = chunk;\n        this.parse();\n    };\n    Tokenizer.prototype.end = function () {\n        if (this.running)\n            this.finish();\n    };\n    Tokenizer.prototype.pause = function () {\n        this.running = false;\n    };\n    Tokenizer.prototype.resume = function () {\n        this.running = true;\n        if (this.index < this.buffer.length + this.offset) {\n            this.parse();\n        }\n    };\n    Tokenizer.prototype.stateText = function (c) {\n        if (c === CharCodes.Lt ||\n            (!this.decodeEntities && this.fastForwardTo(CharCodes.Lt))) {\n            if (this.index > this.sectionStart) {\n                this.cbs.ontext(this.sectionStart, this.index);\n            }\n            this.state = State.BeforeTagName;\n            this.sectionStart = this.index;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    };\n    Tokenizer.prototype.stateSpecialStartSequence = function (c) {\n        var isEnd = this.sequenceIndex === this.currentSequence.length;\n        var isMatch = isEnd\n            ? // If we are at the end of the sequence, make sure the tag name has ended\n                isEndOfTagSection(c)\n            : // Otherwise, do a case-insensitive comparison\n                (c | 0x20) === this.currentSequence[this.sequenceIndex];\n        if (!isMatch) {\n            this.isSpecial = false;\n        }\n        else if (!isEnd) {\n            this.sequenceIndex++;\n            return;\n        }\n        this.sequenceIndex = 0;\n        this.state = State.InTagName;\n        this.stateInTagName(c);\n    };\n    /** Look for an end tag. For <title> tags, also decode entities. */\n    Tokenizer.prototype.stateInSpecialTag = function (c) {\n        if (this.sequenceIndex === this.currentSequence.length) {\n            if (c === CharCodes.Gt || isWhitespace(c)) {\n                var endOfText = this.index - this.currentSequence.length;\n                if (this.sectionStart < endOfText) {\n                    // Spoof the index so that reported locations match up.\n                    var actualIndex = this.index;\n                    this.index = endOfText;\n                    this.cbs.ontext(this.sectionStart, endOfText);\n                    this.index = actualIndex;\n                }\n                this.isSpecial = false;\n                this.sectionStart = endOfText + 2; // Skip over the `</`\n                this.stateInClosingTagName(c);\n                return; // We are done; skip the rest of the function.\n            }\n            this.sequenceIndex = 0;\n        }\n        if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n            this.sequenceIndex += 1;\n        }\n        else if (this.sequenceIndex === 0) {\n            if (this.currentSequence === Sequences.TitleEnd) {\n                // We have to parse entities in <title> tags.\n                if (this.decodeEntities && c === CharCodes.Amp) {\n                    this.startEntity();\n                }\n            }\n            else if (this.fastForwardTo(CharCodes.Lt)) {\n                // Outside of <title> tags, we can fast-forward.\n                this.sequenceIndex = 1;\n            }\n        }\n        else {\n            // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n            this.sequenceIndex = Number(c === CharCodes.Lt);\n        }\n    };\n    Tokenizer.prototype.stateCDATASequence = function (c) {\n        if (c === Sequences.Cdata[this.sequenceIndex]) {\n            if (++this.sequenceIndex === Sequences.Cdata.length) {\n                this.state = State.InCommentLike;\n                this.currentSequence = Sequences.CdataEnd;\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n            }\n        }\n        else {\n            this.sequenceIndex = 0;\n            this.state = State.InDeclaration;\n            this.stateInDeclaration(c); // Reconsume the character\n        }\n    };\n    /**\n     * When we wait for one specific character, we can speed things up\n     * by skipping through the buffer until we find it.\n     *\n     * @returns Whether the character was found.\n     */\n    Tokenizer.prototype.fastForwardTo = function (c) {\n        while (++this.index < this.buffer.length + this.offset) {\n            if (this.buffer.charCodeAt(this.index - this.offset) === c) {\n                return true;\n            }\n        }\n        /*\n         * We increment the index at the end of the `parse` loop,\n         * so set it to `buffer.length - 1` here.\n         *\n         * TODO: Refactor `parse` to increment index before calling states.\n         */\n        this.index = this.buffer.length + this.offset - 1;\n        return false;\n    };\n    /**\n     * Comments and CDATA end with `-->` and `]]>`.\n     *\n     * Their common qualities are:\n     * - Their end sequences have a distinct character they start with.\n     * - That character is then repeated, so we have to check multiple repeats.\n     * - All characters but the start character of the sequence can be skipped.\n     */\n    Tokenizer.prototype.stateInCommentLike = function (c) {\n        if (c === this.currentSequence[this.sequenceIndex]) {\n            if (++this.sequenceIndex === this.currentSequence.length) {\n                if (this.currentSequence === Sequences.CdataEnd) {\n                    this.cbs.oncdata(this.sectionStart, this.index, 2);\n                }\n                else {\n                    this.cbs.oncomment(this.sectionStart, this.index, 2);\n                }\n                this.sequenceIndex = 0;\n                this.sectionStart = this.index + 1;\n                this.state = State.Text;\n            }\n        }\n        else if (this.sequenceIndex === 0) {\n            // Fast-forward to the first character of the sequence\n            if (this.fastForwardTo(this.currentSequence[0])) {\n                this.sequenceIndex = 1;\n            }\n        }\n        else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n            // Allow long sequences, eg. --->, ]]]>\n            this.sequenceIndex = 0;\n        }\n    };\n    /**\n     * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n     *\n     * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n     * We allow anything that wouldn't end the tag.\n     */\n    Tokenizer.prototype.isTagStartChar = function (c) {\n        return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n    };\n    Tokenizer.prototype.startSpecial = function (sequence, offset) {\n        this.isSpecial = true;\n        this.currentSequence = sequence;\n        this.sequenceIndex = offset;\n        this.state = State.SpecialStartSequence;\n    };\n    Tokenizer.prototype.stateBeforeTagName = function (c) {\n        if (c === CharCodes.ExclamationMark) {\n            this.state = State.BeforeDeclaration;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Questionmark) {\n            this.state = State.InProcessingInstruction;\n            this.sectionStart = this.index + 1;\n        }\n        else if (this.isTagStartChar(c)) {\n            var lower = c | 0x20;\n            this.sectionStart = this.index;\n            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {\n                this.startSpecial(Sequences.TitleEnd, 3);\n            }\n            else {\n                this.state =\n                    !this.xmlMode && lower === Sequences.ScriptEnd[2]\n                        ? State.BeforeSpecialS\n                        : State.InTagName;\n            }\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.BeforeClosingTagName;\n        }\n        else {\n            this.state = State.Text;\n            this.stateText(c);\n        }\n    };\n    Tokenizer.prototype.stateInTagName = function (c) {\n        if (isEndOfTagSection(c)) {\n            this.cbs.onopentagname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateBeforeClosingTagName = function (c) {\n        if (isWhitespace(c)) {\n            // Ignore\n        }\n        else if (c === CharCodes.Gt) {\n            this.state = State.Text;\n        }\n        else {\n            this.state = this.isTagStartChar(c)\n                ? State.InClosingTagName\n                : State.InSpecialComment;\n            this.sectionStart = this.index;\n        }\n    };\n    Tokenizer.prototype.stateInClosingTagName = function (c) {\n        if (c === CharCodes.Gt || isWhitespace(c)) {\n            this.cbs.onclosetag(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterClosingTagName;\n            this.stateAfterClosingTagName(c);\n        }\n    };\n    Tokenizer.prototype.stateAfterClosingTagName = function (c) {\n        // Skip everything until \">\"\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeName = function (c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onopentagend(this.index);\n            if (this.isSpecial) {\n                this.state = State.InSpecialTag;\n                this.sequenceIndex = 0;\n            }\n            else {\n                this.state = State.Text;\n            }\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.Slash) {\n            this.state = State.InSelfClosingTag;\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    };\n    Tokenizer.prototype.stateInSelfClosingTag = function (c) {\n        if (c === CharCodes.Gt) {\n            this.cbs.onselfclosingtag(this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n            this.isSpecial = false; // Reset special state, in case of self-closing special tags\n        }\n        else if (!isWhitespace(c)) {\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateInAttributeName = function (c) {\n        if (c === CharCodes.Eq || isEndOfTagSection(c)) {\n            this.cbs.onattribname(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.state = State.AfterAttributeName;\n            this.stateAfterAttributeName(c);\n        }\n    };\n    Tokenizer.prototype.stateAfterAttributeName = function (c) {\n        if (c === CharCodes.Eq) {\n            this.state = State.BeforeAttributeValue;\n        }\n        else if (c === CharCodes.Slash || c === CharCodes.Gt) {\n            this.cbs.onattribend(QuoteType.NoValue, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (!isWhitespace(c)) {\n            this.cbs.onattribend(QuoteType.NoValue, this.index);\n            this.state = State.InAttributeName;\n            this.sectionStart = this.index;\n        }\n    };\n    Tokenizer.prototype.stateBeforeAttributeValue = function (c) {\n        if (c === CharCodes.DoubleQuote) {\n            this.state = State.InAttributeValueDq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (c === CharCodes.SingleQuote) {\n            this.state = State.InAttributeValueSq;\n            this.sectionStart = this.index + 1;\n        }\n        else if (!isWhitespace(c)) {\n            this.sectionStart = this.index;\n            this.state = State.InAttributeValueNq;\n            this.stateInAttributeValueNoQuotes(c); // Reconsume token\n        }\n    };\n    Tokenizer.prototype.handleInAttributeValue = function (c, quote) {\n        if (c === quote ||\n            (!this.decodeEntities && this.fastForwardTo(quote))) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(quote === CharCodes.DoubleQuote\n                ? QuoteType.Double\n                : QuoteType.Single, this.index);\n            this.state = State.BeforeAttributeName;\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    };\n    Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {\n        this.handleInAttributeValue(c, CharCodes.DoubleQuote);\n    };\n    Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {\n        this.handleInAttributeValue(c, CharCodes.SingleQuote);\n    };\n    Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {\n        if (isWhitespace(c) || c === CharCodes.Gt) {\n            this.cbs.onattribdata(this.sectionStart, this.index);\n            this.sectionStart = -1;\n            this.cbs.onattribend(QuoteType.Unquoted, this.index);\n            this.state = State.BeforeAttributeName;\n            this.stateBeforeAttributeName(c);\n        }\n        else if (this.decodeEntities && c === CharCodes.Amp) {\n            this.startEntity();\n        }\n    };\n    Tokenizer.prototype.stateBeforeDeclaration = function (c) {\n        if (c === CharCodes.OpeningSquareBracket) {\n            this.state = State.CDATASequence;\n            this.sequenceIndex = 0;\n        }\n        else {\n            this.state =\n                c === CharCodes.Dash\n                    ? State.BeforeComment\n                    : State.InDeclaration;\n        }\n    };\n    Tokenizer.prototype.stateInDeclaration = function (c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.ondeclaration(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateInProcessingInstruction = function (c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.onprocessinginstruction(this.sectionStart, this.index);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeComment = function (c) {\n        if (c === CharCodes.Dash) {\n            this.state = State.InCommentLike;\n            this.currentSequence = Sequences.CommentEnd;\n            // Allow short comments (eg. <!-->)\n            this.sequenceIndex = 2;\n            this.sectionStart = this.index + 1;\n        }\n        else {\n            this.state = State.InDeclaration;\n        }\n    };\n    Tokenizer.prototype.stateInSpecialComment = function (c) {\n        if (c === CharCodes.Gt || this.fastForwardTo(CharCodes.Gt)) {\n            this.cbs.oncomment(this.sectionStart, this.index, 0);\n            this.state = State.Text;\n            this.sectionStart = this.index + 1;\n        }\n    };\n    Tokenizer.prototype.stateBeforeSpecialS = function (c) {\n        var lower = c | 0x20;\n        if (lower === Sequences.ScriptEnd[3]) {\n            this.startSpecial(Sequences.ScriptEnd, 4);\n        }\n        else if (lower === Sequences.StyleEnd[3]) {\n            this.startSpecial(Sequences.StyleEnd, 4);\n        }\n        else {\n            this.state = State.InTagName;\n            this.stateInTagName(c); // Consume the token again\n        }\n    };\n    Tokenizer.prototype.startEntity = function () {\n        this.baseState = this.state;\n        this.state = State.InEntity;\n        this.entityStart = this.index;\n        this.entityDecoder.startEntity(this.xmlMode\n            ? decode_js_1.DecodingMode.Strict\n            : this.baseState === State.Text ||\n                this.baseState === State.InSpecialTag\n                ? decode_js_1.DecodingMode.Legacy\n                : decode_js_1.DecodingMode.Attribute);\n    };\n    Tokenizer.prototype.stateInEntity = function () {\n        var length = this.entityDecoder.write(this.buffer, this.index - this.offset);\n        // If `length` is positive, we are done with the entity.\n        if (length >= 0) {\n            this.state = this.baseState;\n            if (length === 0) {\n                this.index = this.entityStart;\n            }\n        }\n        else {\n            // Mark buffer as consumed.\n            this.index = this.offset + this.buffer.length - 1;\n        }\n    };\n    /**\n     * Remove data that has already been consumed from the buffer.\n     */\n    Tokenizer.prototype.cleanup = function () {\n        // If we are inside of text or attributes, emit what we already have.\n        if (this.running && this.sectionStart !== this.index) {\n            if (this.state === State.Text ||\n                (this.state === State.InSpecialTag && this.sequenceIndex === 0)) {\n                this.cbs.ontext(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n            else if (this.state === State.InAttributeValueDq ||\n                this.state === State.InAttributeValueSq ||\n                this.state === State.InAttributeValueNq) {\n                this.cbs.onattribdata(this.sectionStart, this.index);\n                this.sectionStart = this.index;\n            }\n        }\n    };\n    Tokenizer.prototype.shouldContinue = function () {\n        return this.index < this.buffer.length + this.offset && this.running;\n    };\n    /**\n     * Iterates through the buffer, calling the function corresponding to the current state.\n     *\n     * States that are more likely to be hit are higher up, as a performance improvement.\n     */\n    Tokenizer.prototype.parse = function () {\n        while (this.shouldContinue()) {\n            var c = this.buffer.charCodeAt(this.index - this.offset);\n            switch (this.state) {\n                case State.Text: {\n                    this.stateText(c);\n                    break;\n                }\n                case State.SpecialStartSequence: {\n                    this.stateSpecialStartSequence(c);\n                    break;\n                }\n                case State.InSpecialTag: {\n                    this.stateInSpecialTag(c);\n                    break;\n                }\n                case State.CDATASequence: {\n                    this.stateCDATASequence(c);\n                    break;\n                }\n                case State.InAttributeValueDq: {\n                    this.stateInAttributeValueDoubleQuotes(c);\n                    break;\n                }\n                case State.InAttributeName: {\n                    this.stateInAttributeName(c);\n                    break;\n                }\n                case State.InCommentLike: {\n                    this.stateInCommentLike(c);\n                    break;\n                }\n                case State.InSpecialComment: {\n                    this.stateInSpecialComment(c);\n                    break;\n                }\n                case State.BeforeAttributeName: {\n                    this.stateBeforeAttributeName(c);\n                    break;\n                }\n                case State.InTagName: {\n                    this.stateInTagName(c);\n                    break;\n                }\n                case State.InClosingTagName: {\n                    this.stateInClosingTagName(c);\n                    break;\n                }\n                case State.BeforeTagName: {\n                    this.stateBeforeTagName(c);\n                    break;\n                }\n                case State.AfterAttributeName: {\n                    this.stateAfterAttributeName(c);\n                    break;\n                }\n                case State.InAttributeValueSq: {\n                    this.stateInAttributeValueSingleQuotes(c);\n                    break;\n                }\n                case State.BeforeAttributeValue: {\n                    this.stateBeforeAttributeValue(c);\n                    break;\n                }\n                case State.BeforeClosingTagName: {\n                    this.stateBeforeClosingTagName(c);\n                    break;\n                }\n                case State.AfterClosingTagName: {\n                    this.stateAfterClosingTagName(c);\n                    break;\n                }\n                case State.BeforeSpecialS: {\n                    this.stateBeforeSpecialS(c);\n                    break;\n                }\n                case State.InAttributeValueNq: {\n                    this.stateInAttributeValueNoQuotes(c);\n                    break;\n                }\n                case State.InSelfClosingTag: {\n                    this.stateInSelfClosingTag(c);\n                    break;\n                }\n                case State.InDeclaration: {\n                    this.stateInDeclaration(c);\n                    break;\n                }\n                case State.BeforeDeclaration: {\n                    this.stateBeforeDeclaration(c);\n                    break;\n                }\n                case State.BeforeComment: {\n                    this.stateBeforeComment(c);\n                    break;\n                }\n                case State.InProcessingInstruction: {\n                    this.stateInProcessingInstruction(c);\n                    break;\n                }\n                case State.InEntity: {\n                    this.stateInEntity();\n                    break;\n                }\n            }\n            this.index++;\n        }\n        this.cleanup();\n    };\n    Tokenizer.prototype.finish = function () {\n        if (this.state === State.InEntity) {\n            this.entityDecoder.end();\n            this.state = this.baseState;\n        }\n        this.handleTrailingData();\n        this.cbs.onend();\n    };\n    /** Handle any trailing data. */\n    Tokenizer.prototype.handleTrailingData = function () {\n        var endIndex = this.buffer.length + this.offset;\n        // If there is no remaining data, we are done.\n        if (this.sectionStart >= endIndex) {\n            return;\n        }\n        if (this.state === State.InCommentLike) {\n            if (this.currentSequence === Sequences.CdataEnd) {\n                this.cbs.oncdata(this.sectionStart, endIndex, 0);\n            }\n            else {\n                this.cbs.oncomment(this.sectionStart, endIndex, 0);\n            }\n        }\n        else if (this.state === State.InTagName ||\n            this.state === State.BeforeAttributeName ||\n            this.state === State.BeforeAttributeValue ||\n            this.state === State.AfterAttributeName ||\n            this.state === State.InAttributeName ||\n            this.state === State.InAttributeValueSq ||\n            this.state === State.InAttributeValueDq ||\n            this.state === State.InAttributeValueNq ||\n            this.state === State.InClosingTagName) {\n            /*\n             * If we are currently in an opening or closing tag, us not calling the\n             * respective callback signals that the tag should be ignored.\n             */\n        }\n        else {\n            this.cbs.ontext(this.sectionStart, endIndex);\n        }\n    };\n    Tokenizer.prototype.emitCodePoint = function (cp, consumed) {\n        if (this.baseState !== State.Text &&\n            this.baseState !== State.InSpecialTag) {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.onattribdata(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.onattribentity(cp);\n        }\n        else {\n            if (this.sectionStart < this.entityStart) {\n                this.cbs.ontext(this.sectionStart, this.entityStart);\n            }\n            this.sectionStart = this.entityStart + consumed;\n            this.index = this.sectionStart - 1;\n            this.cbs.ontextentity(cp, this.sectionStart);\n        }\n    };\n    return Tokenizer;\n}());\nexports.default = Tokenizer;\n\n},{\"entities/lib/decode.js\":15}],25:[function(require,module,exports){\n\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DomUtils = exports.parseFeed = exports.getFeed = exports.ElementType = exports.Tokenizer = exports.createDomStream = exports.createDocumentStream = exports.parseDOM = exports.parseDocument = exports.DefaultHandler = exports.DomHandler = exports.Parser = void 0;\nvar Parser_js_1 = require(\"./Parser.js\");\nvar Parser_js_2 = require(\"./Parser.js\");\nObject.defineProperty(exports, \"Parser\", { enumerable: true, get: function () { return Parser_js_2.Parser; } });\nvar domhandler_1 = require(\"domhandler\");\nvar domhandler_2 = require(\"domhandler\");\nObject.defineProperty(exports, \"DomHandler\", { enumerable: true, get: function () { return domhandler_2.DomHandler; } });\n// Old name for DomHandler\nObject.defineProperty(exports, \"DefaultHandler\", { enumerable: true, get: function () { return domhandler_2.DomHandler; } });\n// Helper methods\n/**\n * Parses the data, returns the resulting document.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n */\nfunction parseDocument(data, options) {\n    var handler = new domhandler_1.DomHandler(undefined, options);\n    new Parser_js_1.Parser(handler, options).end(data);\n    return handler.root;\n}\nexports.parseDocument = parseDocument;\n/**\n * Parses data, returns an array of the root nodes.\n *\n * Note that the root nodes still have a `Document` node as their parent.\n * Use `parseDocument` to get the `Document` node instead.\n *\n * @param data The data that should be parsed.\n * @param options Optional options for the parser and DOM handler.\n * @deprecated Use `parseDocument` instead.\n */\nfunction parseDOM(data, options) {\n    return parseDocument(data, options).children;\n}\nexports.parseDOM = parseDOM;\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with the resulting document.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n */\nfunction createDocumentStream(callback, options, elementCallback) {\n    var handler = new domhandler_1.DomHandler(function (error) { return callback(error, handler.root); }, options, elementCallback);\n    return new Parser_js_1.Parser(handler, options);\n}\nexports.createDocumentStream = createDocumentStream;\n/**\n * Creates a parser instance, with an attached DOM handler.\n *\n * @param callback A callback that will be called once parsing has been completed, with an array of root nodes.\n * @param options Optional options for the parser and DOM handler.\n * @param elementCallback An optional callback that will be called every time a tag has been completed inside of the DOM.\n * @deprecated Use `createDocumentStream` instead.\n */\nfunction createDomStream(callback, options, elementCallback) {\n    var handler = new domhandler_1.DomHandler(callback, options, elementCallback);\n    return new Parser_js_1.Parser(handler, options);\n}\nexports.createDomStream = createDomStream;\nvar Tokenizer_js_1 = require(\"./Tokenizer.js\");\nObject.defineProperty(exports, \"Tokenizer\", { enumerable: true, get: function () { return __importDefault(Tokenizer_js_1).default; } });\n/*\n * All of the following exports exist for backwards-compatibility.\n * They should probably be removed eventually.\n */\nexports.ElementType = __importStar(require(\"domelementtype\"));\nvar domutils_1 = require(\"domutils\");\nvar domutils_2 = require(\"domutils\");\nObject.defineProperty(exports, \"getFeed\", { enumerable: true, get: function () { return domutils_2.getFeed; } });\nvar parseFeedDefaultOptions = { xmlMode: true };\n/**\n * Parse a feed.\n *\n * @param feed The feed that should be parsed, as a string.\n * @param options Optionally, options for parsing. When using this, you should set `xmlMode` to `true`.\n */\nfunction parseFeed(feed, options) {\n    if (options === void 0) { options = parseFeedDefaultOptions; }\n    return (0, domutils_1.getFeed)(parseDOM(feed, options));\n}\nexports.parseFeed = parseFeed;\nexports.DomUtils = __importStar(require(\"domutils\"));\n\n},{\"./Parser.js\":23,\"./Tokenizer.js\":24,\"domelementtype\":4,\"domhandler\":5,\"domutils\":9}]},{},[1]);\n",
  "wVrtX/Zrvk1smfMLak5Omwj6tQcn9qEZg/xM/ZuC4ZU=": "\n/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n/******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./entry.js\":\n/*!******************!*\\\n  !*** ./entry.js ***!\n  \\******************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \\\"../../node_modules/stream/index.js\\\");\\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(stream__WEBPACK_IMPORTED_MODULE_0__);\\n \\nwindow.stream = stream__WEBPACK_IMPORTED_MODULE_0__;\\n\\n\\n//# sourceURL=webpack:///./entry.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/emitter-component/index.js\":\n/*!*****************************************************!*\\\n  !*** ../../node_modules/emitter-component/index.js ***!\n  \\*****************************************************/\n/***/ ((module) => {\n\neval(\"\\n/**\\n * Expose `Emitter`.\\n */\\n\\nmodule.exports = Emitter;\\n\\n/**\\n * Initialize a new `Emitter`.\\n *\\n * @api public\\n */\\n\\nfunction Emitter(obj) {\\n  if (obj) return mixin(obj);\\n};\\n\\n/**\\n * Mixin the emitter properties.\\n *\\n * @param {Object} obj\\n * @return {Object}\\n * @api private\\n */\\n\\nfunction mixin(obj) {\\n  for (var key in Emitter.prototype) {\\n    obj[key] = Emitter.prototype[key];\\n  }\\n  return obj;\\n}\\n\\n/**\\n * Listen on the given `event` with `fn`.\\n *\\n * @param {String} event\\n * @param {Function} fn\\n * @return {Emitter}\\n * @api public\\n */\\n\\nEmitter.prototype.on =\\nEmitter.prototype.addEventListener = function(event, fn){\\n  this._callbacks = this._callbacks || {};\\n  (this._callbacks[event] = this._callbacks[event] || [])\\n    .push(fn);\\n  return this;\\n};\\n\\n/**\\n * Adds an `event` listener that will be invoked a single\\n * time then automatically removed.\\n *\\n * @param {String} event\\n * @param {Function} fn\\n * @return {Emitter}\\n * @api public\\n */\\n\\nEmitter.prototype.once = function(event, fn){\\n  var self = this;\\n  this._callbacks = this._callbacks || {};\\n\\n  function on() {\\n    self.off(event, on);\\n    fn.apply(this, arguments);\\n  }\\n\\n  on.fn = fn;\\n  this.on(event, on);\\n  return this;\\n};\\n\\n/**\\n * Remove the given callback for `event` or all\\n * registered callbacks.\\n *\\n * @param {String} event\\n * @param {Function} fn\\n * @return {Emitter}\\n * @api public\\n */\\n\\nEmitter.prototype.off =\\nEmitter.prototype.removeListener =\\nEmitter.prototype.removeAllListeners =\\nEmitter.prototype.removeEventListener = function(event, fn){\\n  this._callbacks = this._callbacks || {};\\n\\n  // all\\n  if (0 == arguments.length) {\\n    this._callbacks = {};\\n    return this;\\n  }\\n\\n  // specific event\\n  var callbacks = this._callbacks[event];\\n  if (!callbacks) return this;\\n\\n  // remove all handlers\\n  if (1 == arguments.length) {\\n    delete this._callbacks[event];\\n    return this;\\n  }\\n\\n  // remove specific handler\\n  var cb;\\n  for (var i = 0; i < callbacks.length; i++) {\\n    cb = callbacks[i];\\n    if (cb === fn || cb.fn === fn) {\\n      callbacks.splice(i, 1);\\n      break;\\n    }\\n  }\\n  return this;\\n};\\n\\n/**\\n * Emit `event` with the given args.\\n *\\n * @param {String} event\\n * @param {Mixed} ...\\n * @return {Emitter}\\n */\\n\\nEmitter.prototype.emit = function(event){\\n  this._callbacks = this._callbacks || {};\\n  var args = [].slice.call(arguments, 1)\\n    , callbacks = this._callbacks[event];\\n\\n  if (callbacks) {\\n    callbacks = callbacks.slice(0);\\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\\n      callbacks[i].apply(this, args);\\n    }\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n * Return array of callbacks for `event`.\\n *\\n * @param {String} event\\n * @return {Array}\\n * @api public\\n */\\n\\nEmitter.prototype.listeners = function(event){\\n  this._callbacks = this._callbacks || {};\\n  return this._callbacks[event] || [];\\n};\\n\\n/**\\n * Check if this emitter has `event` handlers.\\n *\\n * @param {String} event\\n * @return {Boolean}\\n * @api public\\n */\\n\\nEmitter.prototype.hasListeners = function(event){\\n  return !! this.listeners(event).length;\\n};\\n\\n\\n//# sourceURL=webpack:///../../node_modules/emitter-component/index.js?\");\n\n/***/ }),\n\n/***/ \"../../node_modules/stream/index.js\":\n/*!******************************************!*\\\n  !*** ../../node_modules/stream/index.js ***!\n  \\******************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\nvar Emitter = __webpack_require__(/*! emitter */ \\\"../../node_modules/emitter-component/index.js\\\");\\n\\nfunction Stream() {\\n  Emitter.call(this);\\n}\\nStream.prototype = new Emitter();\\nmodule.exports = Stream;\\n// Backwards-compat with node 0.4.x\\nStream.Stream = Stream;\\n\\nStream.prototype.pipe = function(dest, options) {\\n  var source = this;\\n\\n  function ondata(chunk) {\\n    if (dest.writable) {\\n      if (false === dest.write(chunk) && source.pause) {\\n        source.pause();\\n      }\\n    }\\n  }\\n\\n  source.on('data', ondata);\\n\\n  function ondrain() {\\n    if (source.readable && source.resume) {\\n      source.resume();\\n    }\\n  }\\n\\n  dest.on('drain', ondrain);\\n\\n  // If the 'end' option is not supplied, dest.end() will be called when\\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\\n  if (!dest._isStdio && (!options || options.end !== false)) {\\n    source.on('end', onend);\\n    source.on('close', onclose);\\n  }\\n\\n  var didOnEnd = false;\\n  function onend() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    dest.end();\\n  }\\n\\n\\n  function onclose() {\\n    if (didOnEnd) return;\\n    didOnEnd = true;\\n\\n    if (typeof dest.destroy === 'function') dest.destroy();\\n  }\\n\\n  // don't leave dangling pipes when there are errors.\\n  function onerror(er) {\\n    cleanup();\\n    if (!this.hasListeners('error')) {\\n      throw er; // Unhandled stream error in pipe.\\n    }\\n  }\\n\\n  source.on('error', onerror);\\n  dest.on('error', onerror);\\n\\n  // remove all the event listeners that were added.\\n  function cleanup() {\\n    source.off('data', ondata);\\n    dest.off('drain', ondrain);\\n\\n    source.off('end', onend);\\n    source.off('close', onclose);\\n\\n    source.off('error', onerror);\\n    dest.off('error', onerror);\\n\\n    source.off('end', cleanup);\\n    source.off('close', cleanup);\\n\\n    dest.off('end', cleanup);\\n    dest.off('close', cleanup);\\n  }\\n\\n  source.on('end', cleanup);\\n  source.on('close', cleanup);\\n\\n  dest.on('end', cleanup);\\n  dest.on('close', cleanup);\\n\\n  dest.emit('pipe', source);\\n\\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\\n  return dest;\\n}\\n\\n\\n//# sourceURL=webpack:///../../node_modules/stream/index.js?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__webpack_require__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __webpack_require__(\"./entry.js\");\n/******/ \t\n/******/ })()\n;\n\nwindow.Stream = stream;\n",
  "IoQjGsJg92SEekGCWYckx4OkU0eyvUKLSVzLADmR26k=": "getGlobalThis().clarinet = {};\nvar exports = clarinet;\n\n//var Stream = stream;\n\n;(function (clarinet) {\n  \"use strict\";\n\n  // non node-js needs to set clarinet debug on root\n  var env =(typeof process === 'object' && process.env)\n    ? process.env\n    : self;\n\n  clarinet.parser            = function (opt) { return new CParser(opt);};\n  clarinet.CParser           = CParser;\n  clarinet.CStream           = CStream;\n  clarinet.createStream      = createStream;\n  clarinet.MAX_BUFFER_LENGTH = 64 * 1024;\n  clarinet.DEBUG             = (env.CDEBUG==='debug');\n  clarinet.INFO              = (env.CDEBUG==='debug' || env.CDEBUG==='info');\n  clarinet.EVENTS            =\n    [ \"value\"\n    , \"string\"\n    , \"key\"\n    , \"openobject\"\n    , \"closeobject\"\n    , \"openarray\"\n    , \"closearray\"\n    , \"error\"\n    , \"end\"\n    , \"ready\"\n    ];\n\n  var buffers     = {\n        textNode: undefined,\n        numberNode: \"\"\n    }\n    , streamWraps = clarinet.EVENTS.filter(function (ev) {\n          return ev !== \"error\" && ev !== \"end\";\n        })\n    , S           = 0\n    , Stream\n    ;\n\n  clarinet.STATE =\n    { BEGIN                             : S++\n    , VALUE                             : S++ // general stuff\n    , OPEN_OBJECT                       : S++ // {\n    , CLOSE_OBJECT                      : S++ // }\n    , OPEN_ARRAY                        : S++ // [\n    , CLOSE_ARRAY                       : S++ // ]\n    , TEXT_ESCAPE                       : S++ // \\ stuff\n    , STRING                            : S++ // \"\"\n    , BACKSLASH                         : S++\n    , END                               : S++ // No more stack\n    , OPEN_KEY                          : S++ // , \"a\"\n    , CLOSE_KEY                         : S++ // :\n    , TRUE                              : S++ // r\n    , TRUE2                             : S++ // u\n    , TRUE3                             : S++ // e\n    , FALSE                             : S++ // a\n    , FALSE2                            : S++ // l\n    , FALSE3                            : S++ // s\n    , FALSE4                            : S++ // e\n    , NULL                              : S++ // u\n    , NULL2                             : S++ // l\n    , NULL3                             : S++ // l\n    , NUMBER_DECIMAL_POINT              : S++ // .\n    , NUMBER_DIGIT                      : S++ // [0-9]\n    };\n\n  for (var s_ in clarinet.STATE) clarinet.STATE[clarinet.STATE[s_]] = s_;\n\n  // switcharoo\n  S = clarinet.STATE;\n\n  const Char = {\n    tab                 : 0x09,     // \\t\n    lineFeed            : 0x0A,     // \\n\n    carriageReturn      : 0x0D,     // \\r\n    space               : 0x20,     // \" \"\n\n    doubleQuote         : 0x22,     // \"\n    plus                : 0x2B,     // +\n    comma               : 0x2C,     // ,\n    minus               : 0x2D,     // -\n    period              : 0x2E,     // .\n\n    _0                  : 0x30,     // 0\n    _9                  : 0x39,     // 9\n\n    colon               : 0x3A,     // :\n\n    E                   : 0x45,     // E\n\n    openBracket         : 0x5B,     // [\n    backslash           : 0x5C,     // \\\n    closeBracket        : 0x5D,     // ]\n\n    a                   : 0x61,     // a\n    b                   : 0x62,     // b\n    e                   : 0x65,     // e \n    f                   : 0x66,     // f\n    l                   : 0x6C,     // l\n    n                   : 0x6E,     // n\n    r                   : 0x72,     // r\n    s                   : 0x73,     // s\n    t                   : 0x74,     // t\n    u                   : 0x75,     // u\n\n    openBrace           : 0x7B,     // {\n    closeBrace          : 0x7D,     // }\n  }\n\n  if (!Object.create) {\n    Object.create = function (o) {\n      function f () { this[\"__proto__\"] = o; }\n      f.prototype = o;\n      return new f;\n    };\n  }\n\n  if (!Object.getPrototypeOf) {\n    Object.getPrototypeOf = function (o) {\n      return o[\"__proto__\"];\n    };\n  }\n\n  if (!Object.keys) {\n    Object.keys = function (o) {\n      var a = [];\n      for (var i in o) if (o.hasOwnProperty(i)) a.push(i);\n      return a;\n    };\n  }\n\n  function checkBufferLength (parser) {\n    var maxAllowed = Math.max(clarinet.MAX_BUFFER_LENGTH, 10)\n      , maxActual = 0\n      ;\n    for (var buffer in buffers) {\n      var len = parser[buffer] === undefined ? 0 : parser[buffer].length;\n      if (len > maxAllowed) {\n        switch (buffer) {\n          case \"text\":\n            closeText(parser);\n          break;\n\n          default:\n            error(parser, \"Max buffer length exceeded: \"+ buffer);\n        }\n      }\n      maxActual = Math.max(maxActual, len);\n    }\n    parser.bufferCheckPosition = (clarinet.MAX_BUFFER_LENGTH - maxActual)\n                               + parser.position;\n  }\n\n  function clearBuffers (parser) {\n    for (var buffer in buffers) {\n      parser[buffer] = buffers[buffer];\n    }\n  }\n\n  var stringTokenPattern = /[\\\\\"\\n]/g;\n\n  function CParser (opt) {\n    if (!(this instanceof CParser)) return new CParser (opt);\n\n    var parser = this;\n    clearBuffers(parser);\n    parser.bufferCheckPosition = clarinet.MAX_BUFFER_LENGTH;\n    parser.q        = parser.c = parser.p = \"\";\n    parser.opt      = opt || {};\n    parser.closed   = parser.closedRoot = parser.sawRoot = false;\n    parser.tag      = parser.error = null;\n    parser.state    = S.BEGIN;\n    parser.stack    = new Array();\n    // mostly just for error reporting\n    parser.position = parser.column = 0;\n    parser.line     = 1;\n    parser.slashed  = false;\n    parser.unicodeI = 0;\n    parser.unicodeS = null;\n    parser.depth    = 0;\n    emit(parser, \"onready\");\n  }\n\n  CParser.prototype =\n    { end    : function () { end(this); }\n    , write  : write\n    , resume : function () { this.error = null; return this; }\n    , close  : function () { return this.write(null); }\n    };\n\n    /*\n  try        { Stream = Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'stream'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()); }\n  catch (ex) { Stream = function () {}; }\n  */\n\n  Stream = function () {};\n\n\n  function createStream (opt) { return new CStream(opt); }\n\n  function CStream (opt) {\n    if (!(this instanceof CStream)) return new CStream(opt);\n\n    this._parser = new CParser(opt);\n    this.writable = true;\n    this.readable = true;\n\n    //var Buffer = this.Buffer || function Buffer () {}; // if we don't have Buffers, fake it so we can do `var instanceof Buffer` and not throw an error\n    this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary\n    this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read\n    this.temp_buffs = { \"2\": new Buffer(2), \"3\": new Buffer(3), \"4\": new Buffer(4) }; // for rebuilding chars split before boundary is reached\n    this.string = '';\n\n    var me = this;\n    Stream.apply(me);\n\n    this._parser.onend = function () { me.emit(\"end\"); };\n    this._parser.onerror = function (er) {\n      me.emit(\"error\", er);\n      me._parser.error = null;\n    };\n\n    streamWraps.forEach(function (ev) {\n      Object.defineProperty(me, \"on\" + ev,\n        { get          : function () { return me._parser[\"on\" + ev]; }\n        , set          : function (h) {\n            if (!h) {\n              me.removeAllListeners(ev);\n              me._parser[\"on\"+ev] = h;\n              return h;\n            }\n            me.on(ev, h);\n          }\n        , enumerable   : true\n        , configurable : false\n        });\n    });\n  }\n\n  CStream.prototype = Object.create(Stream.prototype,\n    { constructor: { value: CStream } });\n\n  CStream.prototype.write = function (data) {\n    data = new Buffer(data);\n    for (var i = 0; i < data.length; i++) {\n      var n = data[i];\n\n      // check for carry over of a multi byte char split between data chunks\n      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration\n      if (this.bytes_remaining > 0) {\n        for (var j = 0; j < this.bytes_remaining; j++) {\n          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = data[j];\n        }\n        this.string = this.temp_buffs[this.bytes_in_sequence].toString();\n        this.bytes_in_sequence = this.bytes_remaining = 0;\n\n        // move iterator forward by number of byte read during sequencing\n        i = i + j - 1;\n\n        // pass data to parser and move forward to parse rest of data\n        this._parser.write(this.string);\n        this.emit(\"data\", this.string);\n        continue;\n      }\n\n      // if no remainder bytes carried over, parse multi byte (>=128) chars one at a time\n      if (this.bytes_remaining === 0 && n >= 128) {\n        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;\n        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;\n        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;\n        if ((this.bytes_in_sequence + i) > data.length) { // if bytes needed to complete char fall outside data length, we have a boundary split\n\n          for (var k = 0; k <= (data.length - 1 - i); k++) {\n            this.temp_buffs[this.bytes_in_sequence][k] = data[i + k]; // fill temp data of correct size with bytes available in this chunk\n          }\n          this.bytes_remaining = (i + this.bytes_in_sequence) - data.length;\n\n          // immediately return as we need another chunk to sequence the character\n          return true;\n        } else {\n          this.string = data.slice(i, (i + this.bytes_in_sequence)).toString();\n          i = i + this.bytes_in_sequence - 1;\n\n          this._parser.write(this.string);\n          this.emit(\"data\", this.string);\n          continue;\n        }\n      }\n\n      // is there a range of characters that are immediately parsable?\n      for (var p = i; p < data.length; p++) {\n        if (data[p] >= 128) break;\n      }\n      this.string = data.slice(i, p).toString();\n      this._parser.write(this.string);\n      this.emit(\"data\", this.string);\n      i = p - 1;\n\n      // handle any remaining characters using multibyte logic\n      continue;\n    }\n  };\n\n  CStream.prototype.end = function (chunk) {\n    if (chunk && chunk.length) this._parser.write(chunk.toString());\n    this._parser.end();\n    return true;\n  };\n\n  CStream.prototype.on = function (ev, handler) {\n    var me = this;\n    if (!me._parser[\"on\"+ev] && streamWraps.indexOf(ev) !== -1) {\n      me._parser[\"on\"+ev] = function () {\n        var args = arguments.length === 1 ? [arguments[0]]\n                 : Array.apply(null, arguments);\n        args.splice(0, 0, ev);\n        me.emit.apply(me, args);\n      };\n    }\n    return Stream.prototype.on.call(me, ev, handler);\n  };\n\n  CStream.prototype.destroy = function () {\n    clearBuffers(this._parser);\n    this.emit(\"close\");\n  };\n\n  function emit(parser, event, data) {\n    if(clarinet.INFO) console.log('-- emit', event, data);\n    if (parser[event]) parser[event](data);\n  }\n\n  function emitNode(parser, event, data) {\n    closeValue(parser);\n    emit(parser, event, data);\n  }\n\n  function closeValue(parser, event) {\n    parser.textNode = textopts(parser.opt, parser.textNode);\n    if (parser.textNode !== undefined) {\n      emit(parser, (event ? event : \"onvalue\"), parser.textNode);\n    }\n    parser.textNode = undefined;\n  }\n\n  function closeNumber(parser) {\n    if (parser.numberNode)\n      emit(parser, \"onvalue\", parseFloat(parser.numberNode));\n    parser.numberNode = \"\";\n  }\n\n  function textopts (opt, text) {\n    if (text === undefined) {\n      return text;\n    }\n    if (opt.trim) text = text.trim();\n    if (opt.normalize) text = text.replace(/\\s+/g, \" \");\n    return text;\n  }\n\n  function error (parser, er) {\n    closeValue(parser);\n    er += \"\\nLine: \"+parser.line+\n          \"\\nColumn: \"+parser.column+\n          \"\\nChar: \"+parser.c;\n    er = new Error(er);\n    parser.error = er;\n    emit(parser, \"onerror\", er);\n    return parser;\n  }\n\n  function end(parser) {\n    if (parser.state !== S.VALUE || parser.depth !== 0)\n      error(parser, \"Unexpected end\");\n\n    closeValue(parser);\n    parser.c      = \"\";\n    parser.closed = true;\n    emit(parser, \"onend\");\n    CParser.call(parser, parser.opt);\n    return parser;\n  }\n\n  function isWhitespace(c) {\n    return c === Char.carriageReturn || c === Char.lineFeed || c === Char.space || c === Char.tab;\n  }\n\n  function write (chunk) {\n    var parser = this;\n    if (this.error) throw this.error;\n    if (parser.closed) return error(parser,\n      \"Cannot write after close. Assign an onready handler.\");\n    if (chunk === null) return end(parser);\n    var i = 0, c = chunk.charCodeAt(0), p = parser.p;\n    var lockIncrements = false;\n    if (clarinet.DEBUG) console.log('write -> [' + chunk + ']');\n    while (c) {\n      p = c;\n      parser.c = c = chunk.charCodeAt(i++);\n      // if chunk doesnt have next, like streaming char by char\n      // this way we need to check if previous is really previous\n      // if not we need to reset to what the parser says is the previous\n      // from buffer\n      if(p !== c ) parser.p = p;\n      else p = parser.p;\n\n      if(!c) break;\n\n      if (clarinet.DEBUG) console.log(i,c,clarinet.STATE[parser.state]);\n      if (!lockIncrements) {\n        parser.position ++;\n        if (c === Char.lineFeed) {\n          parser.line ++;\n          parser.column = 0;\n        } else parser.column ++;\n      } else {\n        lockIncrements = false;\n      }\n      switch (parser.state) {\n\n        case S.BEGIN:\n          if (c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if (c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if (!isWhitespace(c))\n            error(parser, \"Non-whitespace before {[.\");\n        continue;\n\n        case S.OPEN_KEY:\n        case S.OPEN_OBJECT:\n          if (isWhitespace(c)) continue;\n          if(parser.state === S.OPEN_KEY) parser.stack.push(S.CLOSE_KEY);\n          else {\n            if(c === Char.closeBrace) {\n              emit(parser, 'onopenobject');\n              this.depth++;\n              emit(parser, 'oncloseobject');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else  parser.stack.push(S.CLOSE_OBJECT);\n          }\n          if(c === Char.doubleQuote) parser.state = S.STRING;\n          else error(parser, \"Malformed object key should start with \\\"\");\n        continue;\n\n        case S.CLOSE_KEY:\n        case S.CLOSE_OBJECT:\n          if (isWhitespace(c)) continue;\n          var event = (parser.state === S.CLOSE_KEY) ? 'key' : 'object';\n          if(c === Char.colon) {\n            if(parser.state === S.CLOSE_OBJECT) {\n              parser.stack.push(S.CLOSE_OBJECT);\n              closeValue(parser, 'onopenobject');\n               this.depth++;\n            } else closeValue(parser, 'onkey');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBrace) {\n            emitNode(parser, 'oncloseobject');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if(c === Char.comma) {\n            if(parser.state === S.CLOSE_OBJECT)\n              parser.stack.push(S.CLOSE_OBJECT);\n            closeValue(parser);\n            parser.state  = S.OPEN_KEY;\n          } else error(parser, 'Bad object');\n        continue;\n\n        case S.OPEN_ARRAY: // after an array there always a value\n        case S.VALUE:\n          if (isWhitespace(c)) continue;\n          if(parser.state===S.OPEN_ARRAY) {\n            emit(parser, 'onopenarray');\n            this.depth++;\n            parser.state = S.VALUE;\n            if(c === Char.closeBracket) {\n              emit(parser, 'onclosearray');\n              this.depth--;\n              parser.state = parser.stack.pop() || S.VALUE;\n              continue;\n            } else {\n              parser.stack.push(S.CLOSE_ARRAY);\n            }\n          }\n               if(c === Char.doubleQuote) parser.state = S.STRING;\n          else if(c === Char.openBrace) parser.state = S.OPEN_OBJECT;\n          else if(c === Char.openBracket) parser.state = S.OPEN_ARRAY;\n          else if(c === Char.t) parser.state = S.TRUE;\n          else if(c === Char.f) parser.state = S.FALSE;\n          else if(c === Char.n) parser.state = S.NULL;\n          else if(c === Char.minus) { // keep and continue\n            parser.numberNode += \"-\";\n          } else if(Char._0 <= c && c <= Char._9) {\n            parser.numberNode += String.fromCharCode(c);\n            parser.state = S.NUMBER_DIGIT;\n          } else               error(parser, \"Bad value\");\n        continue;\n\n        case S.CLOSE_ARRAY:\n          if(c === Char.comma) {\n            parser.stack.push(S.CLOSE_ARRAY);\n            closeValue(parser, 'onvalue');\n            parser.state  = S.VALUE;\n          } else if (c === Char.closeBracket) {\n            emitNode(parser, 'onclosearray');\n            this.depth--;\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else if (isWhitespace(c))\n              continue;\n          else error(parser, 'Bad array');\n        continue;\n\n        case S.STRING:\n          if (parser.textNode === undefined) {\n            parser.textNode = \"\";\n          }\n\n          // thanks thejh, this is an about 50% performance improvement.\n          var starti              = i-1\n            , slashed = parser.slashed\n            , unicodeI = parser.unicodeI\n            ;\n          STRING_BIGLOOP: while (true) {\n            if (clarinet.DEBUG)\n              console.log(i,c,clarinet.STATE[parser.state]\n                         ,slashed);\n            // zero means \"no unicode active\". 1-4 mean \"parse some more\". end after 4.\n            while (unicodeI > 0) {\n              parser.unicodeS += String.fromCharCode(c);\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (unicodeI === 4) {\n                // TODO this might be slow? well, probably not used too often anyway\n                parser.textNode += String.fromCharCode(parseInt(parser.unicodeS, 16));\n                unicodeI = 0;\n                starti = i-1;\n              } else {\n                unicodeI++;\n              }\n              // we can just break here: no stuff we skipped that still has to be sliced out or so\n              if (!c) break STRING_BIGLOOP;\n            }\n            if (c === Char.doubleQuote && !slashed) {\n              parser.state = parser.stack.pop() || S.VALUE;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            if (c === Char.backslash && !slashed) {\n              slashed = true;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              if (!c) break;\n            }\n            if (slashed) {\n              slashed = false;\n                   if (c === Char.n) { parser.textNode += '\\n'; }\n              else if (c === Char.r) { parser.textNode += '\\r'; }\n              else if (c === Char.t) { parser.textNode += '\\t'; }\n              else if (c === Char.f) { parser.textNode += '\\f'; }\n              else if (c === Char.b) { parser.textNode += '\\b'; }\n              else if (c === Char.u) {\n                // \\uxxxx. meh!\n                unicodeI = 1;\n                parser.unicodeS = '';\n              } else {\n                parser.textNode += String.fromCharCode(c);\n              }\n              c = chunk.charCodeAt(i++);\n              parser.position++;\n              starti = i-1;\n              if (!c) break;\n              else continue;\n            }\n\n            stringTokenPattern.lastIndex = i;\n            var reResult = stringTokenPattern.exec(chunk);\n            if (reResult === null) {\n              i = chunk.length+1;\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n            i = reResult.index+1;\n            c = chunk.charCodeAt(reResult.index);\n            if (!c) {\n              parser.textNode += chunk.substring(starti, i-1);\n              parser.position += i - 1 - starti;\n              break;\n            }\n          }\n          parser.slashed = slashed;\n          parser.unicodeI = unicodeI;\n        continue;\n\n        case S.TRUE:\n          if (c === Char.r) parser.state = S.TRUE2;\n          else error(parser, 'Invalid true started with t'+ c);\n        continue;\n\n        case S.TRUE2:\n          if (c === Char.u) parser.state = S.TRUE3;\n          else error(parser, 'Invalid true started with tr'+ c);\n        continue;\n\n        case S.TRUE3:\n          if(c === Char.e) {\n            emit(parser, \"onvalue\", true);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid true started with tru'+ c);\n        continue;\n\n        case S.FALSE:\n          if (c === Char.a) parser.state = S.FALSE2;\n          else error(parser, 'Invalid false started with f'+ c);\n        continue;\n\n        case S.FALSE2:\n          if (c === Char.l) parser.state = S.FALSE3;\n          else error(parser, 'Invalid false started with fa'+ c);\n        continue;\n\n        case S.FALSE3:\n          if (c === Char.s) parser.state = S.FALSE4;\n          else error(parser, 'Invalid false started with fal'+ c);\n        continue;\n\n        case S.FALSE4:\n          if (c === Char.e) {\n            emit(parser, \"onvalue\", false);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid false started with fals'+ c);\n        continue;\n\n        case S.NULL:\n          if (c === Char.u) parser.state = S.NULL2;\n          else error(parser, 'Invalid null started with n'+ c);\n        continue;\n\n        case S.NULL2:\n          if (c === Char.l) parser.state = S.NULL3;\n          else error(parser, 'Invalid null started with nu'+ c);\n        continue;\n\n        case S.NULL3:\n          if(c === Char.l) {\n            emit(parser, \"onvalue\", null);\n            parser.state = parser.stack.pop() || S.VALUE;\n          } else error(parser, 'Invalid null started with nul'+ c);\n        continue;\n\n        case S.NUMBER_DECIMAL_POINT:\n          if(c === Char.period) {\n            parser.numberNode += \".\";\n            parser.state       = S.NUMBER_DIGIT;\n          } else error(parser, 'Leading zero not followed by .');\n        continue;\n\n        case S.NUMBER_DIGIT:\n          if(Char._0 <= c && c <= Char._9) parser.numberNode += String.fromCharCode(c);\n          else if (c === Char.period) {\n            if(parser.numberNode.indexOf('.')!==-1)\n              error(parser, 'Invalid number has two dots');\n            parser.numberNode += \".\";\n          } else if (c === Char.e || c === Char.E) {\n            if(parser.numberNode.indexOf('e')!==-1 ||\n               parser.numberNode.indexOf('E')!==-1 )\n               error(parser, 'Invalid number has two exponential');\n            parser.numberNode += \"e\";\n          } else if (c === Char.plus || c === Char.minus) {\n            if(!(p === Char.e || p === Char.E))\n              error(parser, 'Invalid symbol in number');\n            parser.numberNode += String.fromCharCode(c);\n          } else {\n            closeNumber(parser);\n            i--; // go back one\n            lockIncrements = true; // do not apply increments for a single cycle\n            parser.state = parser.stack.pop() || S.VALUE;\n          }\n        continue;\n\n        default:\n          error(parser, \"Unknown state: \" + parser.state);\n      }\n    }\n    if (parser.position >= parser.bufferCheckPosition)\n      checkBufferLength(parser);\n    return parser;\n  }\n\n})( false ? 0 : exports);\n\n//debugger;",
  "OYthJbDjyhKJN0BJ5KGzeZKqZeE8vBHXKBngBQGDBnM=": "\n\n\"use strict\";\n\n/*\n\n\tgetGlobalThis()\n\n\tA single function which can be used either from the browser or node.js to get the global object.\n\n\tNotes:\n\n\t\tFrom: https://developer.mozilla.org/en-US/docs/Glossary/Global_object\n\n\t\tconsole.log(globalThis === globalThis.globalThis); // true (everywhere)\n\t\tconsole.log(window === window.window); // true (in a browser)\n\t\tconsole.log(self === self.self); // true (in a browser or a Web Worker)\n\t\tconsole.log(frames === frames.frames); // true (in a browser)\n\t\tconsole.log(global === global.global); // true (in Node.js)\n\n*/\n\nfunction getGlobalThis () {\n\tif (typeof(globalThis) !== 'undefined') {\n\t\t// should word in all modern browsers and node.js\n        return globalThis;\n    }\n\n\n\tif (typeof(self) !== 'undefined') {\n\t\t// for browser and web workers\n        return self;\n    }\n\n\tif (typeof(window) !== 'undefined') { \n\t\t// for older browsers that don't support globalThis\n\t\twindow.global = window; \n\t\treturn window;\n\t}\n\n\tif (typeof(global) !== 'undefined') { \n\t\t// for older node.js versions that don't support globalThis\n\t\tglobal.window = global; \n\t\treturn global;\n\t}\n\n\t// Note: this might still return the wrong result!\n\tif (typeof(this) !== 'undefined' && this.Math === Math) {\n        return this;\n    }\n    \n\tthrow new Error('Unable to locate global `this`');\n  };\n\n  getGlobalThis().getGlobalThis = getGlobalThis; // to make sure we can access this globally",
  "2AtxP/YN+CcAcZDD5UAD0LnlgUV3VPyut/X+oNKyKJk=": "\"use strict\";\n\nObject.defineSlot = function (obj, slotName, slotValue) {\n    const descriptor = {\n        configurable: true,\n        enumerable: false,\n        value: slotValue,\n        writable: true,\n    }\n\n    if (typeof(slotValue) === \"function\") {\n        slotValue.displayName = slotName\n    }\n    \n    Object.defineProperty(obj, slotName, descriptor)\n}\n\nif (!String.prototype.capitalized) {\n    Object.defineSlot(String.prototype, \"capitalized\",\n        function () {\n            return this.replace(/\\b[a-z]/g, function (match) {\n                return match.toUpperCase();\n            });\n        }\n    )\n}\n\n/**\n * Base class with helpful methods for cloning and slot creation.\n */\n(class Base {\n    /**\n     * Checks if the code is running in a browser environment.\n     * @returns {boolean} True if running in a browser, false otherwise.\n     */\n    static isInBrowser () {\n        return (typeof (document) !== 'undefined')\n    }\n\n    /**\n     * Instance method to check if running in a browser environment.\n     * @returns {boolean} True if running in a browser, false otherwise.\n     */\n    isInBrowser () {\n        return (typeof (document) !== 'undefined')\n    }\n\n    /**\n     * Returns a shared instance of the class.\n     * @returns {Base} The shared instance of the class.\n     */\n    static shared () {\n        if (!Object.hasOwn(this, \"_shared\")) {\n            const obj = new this();\n            this._shared = obj;\n            obj.init();\n        }\n        return this._shared\n    }\n\n    /**\n     * Returns the name of the class.\n     * @returns {string} The name of the class.\n     */\n    static type () {\n        return this.name\n    }\n\n    /**\n     * Initializes the class by setting up prototype slots and methods.\n     * @returns {typeof Base} The class itself.\n     */\n    static initThisClass () {\n        // initPrototypeSlots is split from initPrototype as initPrototype may need to \n        // access slots that are created in initPrototypeSlots. We can't just put the slot definitions at the top\n        // as subclasses may *override* the slot definitions.\n        \n        if (this.prototype.hasOwnProperty(\"initPrototypeSlots\")) {\n            // each class inits it's own prototype, so make sure we only call our own initPrototypeSlots()\n            this.prototype.initPrototypeSlots();\n        }\n\n        if (this.prototype.hasOwnProperty(\"initPrototype\")) {\n            // each class inits it's own prototype, so make sure we only call our own initPrototype()\n            this.prototype.initPrototype();\n        }\n\n        getGlobalThis()[this.type()] = this; // This isn't done automatically by JS class deifintions, so we do it here\n        return this;\n    }\n\n    /**\n     * Returns the name of the class.\n     * @returns {string} The name of the class.\n     */\n    type () {\n        return this.constructor.name;\n    }\n\n    /**\n     * Creates and initializes a new instance of the class.\n     * @returns {Base} A new instance of the class.\n     */\n    static clone () {\n        const obj = new this();\n        obj.init();\n        return obj;\n    }\n\n    /**\n     * Initializes the prototype. Subclasses should override this method.\n     */\n    initPrototype () {\n        this.newSlot(\"isDebugging\", false);\n    }\n\n    /**\n     * Initializes the instance. Subclasses should override this method.\n     */\n    init () {\n        // subclasses should override to initialize\n    }\n\n    /**\n     * Creates a new slot with a getter and setter.\n     * @param {string} slotName - The name of the slot to create.\n     * @param {*} [initialValue=null] - The initial value of the slot.\n     * @returns {Base} The instance itself for method chaining.\n     */\n    newSlot (slotName, initialValue) {\n        if (typeof (slotName) !== \"string\") {\n            throw new Error(\"slot name must be a string\");\n        }\n\n        if (initialValue === undefined) {\n            initialValue = null;\n        };\n\n        const privateName = \"_\" + slotName;\n        this[privateName] = initialValue;\n\n        if (!this[slotName]) {\n            this[slotName] = function () {\n                return this[privateName];\n            }\n        }\n\n        const setterName = \"set\" + slotName.capitalized();\n\n        if (!this[setterName]) {\n            this[setterName] = function (newValue) {\n                this[privateName] = newValue;\n                return this;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a string identifier for debugging purposes.\n     * @returns {string} The type of the instance.\n     */\n    debugTypeId () {\n        return this.type()\n    }\n\n    /**\n     * Logs a debug message if debugging is enabled.\n     * @param {string|function} s - The message to log or a function that returns the message.\n     * @returns {Base} The instance itself for method chaining.\n     */\n    debugLog (s) {\n        if (this.isDebugging()) {\n            if (typeof(s) === \"function\") {\n                s = s()\n            }\n            if (arguments.length == 1) {\n                console.log(this.debugTypeId() + \" \" + s)\n            } else {\n                console.log(this.debugTypeId() + \" \", arguments[0], arguments[1])\n            }\n        }\n        return this\n    }\n\n}.initThisClass());\n\ngetGlobalThis().assert = function (v, errorMessage) {\n    if (!Boolean(v)) {\n        if (typeof(errorMessage) === \"function\") {\n            errorMessage = errorMessage();\n        }\n        const m = errorMessage ? errorMessage : \"assert failed - false value\";\n        debugger;\n        throw new Error(m);\n    }\n    return v\n}\n\ngetGlobalThis().debugAssert = function (v, errorMessage) {\n    if (!Boolean(v)) {\n        const m = errorMessage ? errorMessage : \"assert failed - false value\";\n        console.warn(m);\n        debugger;\n        throw new Error(m)\n    }\n    return v\n}",
  "a4i6nBPaMK8jhd+C8rGo4G8X5sOZlyIk56Kf7PuQpwU=": "\"use strict\";\n\n/*\n\n  EnumerableWeakMap\n\n  A Map with WeakRef values internally, but external API looks normal (gets and sets values).\n  Unlike WeakMap, the keys can be strings, and it's entries are enumerable.\n\n  Unlike WeakMap, keys can be primitives such as strings and numbers.\n  All values should be objects (or null, numbers, strings) but cannot be undefined.\n\n*/\n\ngetGlobalThis().EnumerableWeakMap = (class EnumerableWeakMap {\n\n  constructor() {\n    this._refs = new Map()\n  }\n\n  assertValidValue (v) {\n    if (v === undefined) {\n      throw new Error(\"values cannot be undefined as unref returns undefined after collection\")\n      return\n    }\n  }\n\n  clear () {\n    this._refs.clear()\n  }\n\n  has (k) {\n    return this.get(k) !== undefined\n  }\n\n  get (k) {\n    const refs = this._refs\n    const wr = refs.get(k)\n    if (wr) { \n      // make sure it's not collected yet\n      const v = wr.deref()\n      if (v === undefined) {\n        refs.delete(k)\n        return undefined\n      }\n      return v\n    }\n    return undefined\n  }\n\n  set (k, v) {\n    this.assertValidValue(v)\n\n    if (this.get(k) !== v) {\n      this._refs.set(k, new WeakRef(v))\n    }\n    return this\n  }\n\n  delete (k) {\n    const hasKey = this.has(k) // this may delete it if weakref is stale\n    if (hasKey) {\n      this._refs.delete(k)\n    }\n    return hasKey\n  }\n\n  forEach (fn) { // fn (value, key, map)\n    // also removes collected keys\n    const refs = this._refs\n    let keysToRemove = null\n    // fn(value, key, set)\n    if (refs.size) {\n      refs.forEach((wr, k) => {\n        const v = wr.deref()\n        if (v !== undefined) {\n          fn(v, k, this)\n        } else {\n          if (!keysToRemove) {\n            keysToRemove = []\n          }\n          keysToRemove.push(k)\n        }\n      })\n    }\n    if (keysToRemove) {\n      keysToRemove.forEach(k => refs.delete(k))\n    }\n  }\n\n  removeCollectedValues () {\n    const refs = this._refs\n    const keysToRemove = []\n    if (refs.size) {\n      refs.forEach((wr, k) => {\n        const v = wr.deref()\n        if (v === undefined) {\n          keysToRemove.push(k)\n        }\n      })\n    }\n    keysToRemove.forEach(k => refs.delete(k))\n  }\n\n  count () {\n    this.removeCollectedValues()\n    // since weakrefs are only removed after a collection cycle, \n    // actual size of reachable objects may be lower than this \n    return this._refs.size \n  }\n\n  keysArray () {\n    const keys = []\n    this.forEach((v, k) => {\n      keys.push(k)\n    })\n    return keys\n    //return this._refs.keysArray()\n  }\n\n  /*\n  valuesSet () {\n    return new Set(this._refs.values())\n  }\n\n  hasValue (v) {\n    return this.valuesSet().has(v)\n  }\n\n  values () {\n    const weakValues = this._refs.values()\n    const values = weakValues.map(ref => ref.deref())\n    return values.filter(v => v !== undefined)\n  }\n  */\n});\n\n//EnumerableWeakMap.selfTest()\n\n",
  "J/kj84I4c7NFTAjpp+iuXxXyTYQzr3HDQGucLf6p0s4=": "\"use strict\";\n\n/*\n\n  EnumerableWeakSet\n\n  A Set with WeakRef values internally, but external API looks normal (gets and sets values).\n  Unlike WeakSet, it's values are enumerable.\n  \n  Internally, a EnumerableWeakMap of value puuid keys to weakrefs is used so we can\n  implement add(), has(), delete() etc quickly (i.e. without enumerating all weakref values).\n\n*/\n\ngetGlobalThis().EnumerableWeakSet = (class EnumerableWeakSet {\n\n  constructor () {\n    this._refs = new EnumerableWeakMap();\n  }\n\n  assertValidValue (v) {\n    if (v === undefined) {\n      throw new Error(\"values cannot be undefined as unref returns undefined after collection\");\n      return;\n    }\n  }\n\n  add (v) {\n    this.assertValidValue(v);\n\n    const refs = this._refs;\n    const pid = v.puuid();\n    if (!refs.has(pid)) {\n      refs.set(pid, v);\n    }\n\n    return this;\n  }\n\n  clear () {\n    this._refs.clear();\n  }\n\n  delete (v) {\n    this.assertValidValue(v);\n\n    const hadValue = this.has(v)\n    if (hadValue) {\n      this._refs.delete(v.puuid())\n    }\n    return hadValue\n  }\n\n  has (v) {\n    this.assertValidValue(v)\n    return this._refs.has(v.puuid())\n  }\n\n  keys () {\n    return this.valuesArray()\n  }\n\n  values () {\n    return this.valuesArray()\n  }\n\n  count () {\n    return this._refs.count() // IMPORTANT: due to nature of WeakRefs, size may be smaller when actually used\n  }\n\n  forEach (fn) {\n    this._refs.forEach(v => fn(v, v, this))\n  }\n\n  // --- extras ---\n\n  entries () {\n    throw new Error(\"unimplemented\")\n  }\n\n  clearCollected () {\n    this.forEach(v => {}) // forEach will remove any stale weakrefs\n  }\n\n  valuesSet () {\n    const set = new Set()\n    this.forEach(v => set.add(v))\n    return set\n  }\n\n  valuesArray () {\n    const a = new Array()\n    this.forEach(v => a.push(v))\n    return a\n  }\n\n  keysArray () {\n    return this._refs.keysArray()\n  }\n\n});\n\n//EnumerableWeakSet.selfTest()\n\n",
  "SdPNrec84wEFLvy7t9eeixbUtad186dTKDbwDGS2MG8=": "/*\n\n\tAn object wrapper for the Reflect functions\n\n*/\n\n/**\n * An object wrapper for the Reflect functions.\n * @class Mirror\n * @extends Object\n */\ngetGlobalThis().Mirror = class Mirror extends Object {\n\t\n\t/**\n\t * Creates a Mirror instance for the given target.\n\t * @param {*} aTarget - The target object to reflect on.\n\t * @returns {Mirror} A new Mirror instance.\n\t */\n\tstatic reflectOn (aTarget) {\n\t\treturn this.clone().setTarget(aTarget)\n\t}\n\t\n\t/**\n\t * Sets the target object for this Mirror instance.\n\t * @param {*} aTarget - The target object to set.\n\t * @returns {Mirror} This Mirror instance.\n\t */\n\tsetTarget (aTarget) {\n\t\tthis._target = aTarget\n\t\treturn this\n\t}\n\t\n\t/**\n\t * Gets the current target object of this Mirror instance.\n\t * @returns {*} The current target object.\n\t */\n\ttarget () {\n\t\treturn this._target\n\t}\n\n\t/**\n\t * Defines a new property on the target object.\n\t * @param {string|symbol} propertyKey - The property key.\n\t * @param {PropertyDescriptor} attributes - The property attributes.\n\t * @returns {boolean} True if the property was successfully defined, false otherwise.\n\t */\n\tdefineProperty (propertyKey, attributes) {\n\t\treturn Reflect.defineProperty(this.target(), propertyKey, attributes)\t\t\n\t}\n\t\n\t/**\n\t * Deletes a property from the target object.\n\t * @param {string|symbol} propertyKey - The property key to delete.\n\t * @returns {boolean} True if the property was successfully deleted, false otherwise.\n\t */\n\tdeleteProperty (propertyKey) {\n\t\treturn Reflect.deleteProperty(this.target(), propertyKey)\n\t}\n\t\n\t/**\n\t * Gets the value of a property on the target object.\n\t * @param {string|symbol} propertyKey - The property key to get.\n\t * @param {*} [optionalReceiver] - The value of `this` provided for the call to the getter.\n\t * @returns {*} The value of the property.\n\t */\n\tget (propertyKey, optionalReceiver) {\n\t\treturn Reflect.get(this.target(), propertyKey, optionalReceiver)\n\t}\n\n\t/**\n\t * Gets the own property descriptor of a property on the target object.\n\t * @param {string|symbol} propertyKey - The property key to get the descriptor for.\n\t * @returns {PropertyDescriptor|undefined} The property descriptor, or undefined if the property doesn't exist.\n\t */\n\tgetOwnPropertyDescriptor (propertyKey) {\n\t\treturn Reflect.getOwnPropertyDescriptor(this.target(), propertyKey)\n\t}\n\t\n\t/**\n\t * Gets the prototype of the target object.\n\t * @returns {Object|null} The prototype of the target object.\n\t */\n\tgetPrototype () {\n\t\treturn Reflect.getPrototypeOf(this.target())\n\t}\n\n\t/**\n\t * Checks if the target object has a property.\n\t * @param {string|symbol} propertyKey - The property key to check.\n\t * @returns {boolean} True if the property exists, false otherwise.\n\t */\n\thas (propertyKey) {\n\t\treturn Reflect.has(this.target(), propertyKey)\n\t}\n\n\t/**\n\t * Checks if the target object is extensible.\n\t * @returns {boolean} True if the object is extensible, false otherwise.\n\t */\n\tisExtensible () {\n\t\treturn Reflect.isExtensible(this.target())\n\t}\n\n\t/**\n\t * Gets an array of the target object's own property keys.\n\t * @returns {Array<string|symbol>} An array of the target object's own property keys.\n\t */\n\townKeys () {\n\t\treturn Reflect.ownKeys(this.target())\n\t}\n\n\t/**\n\t * Prevents new properties from being added to the target object.\n\t * @returns {boolean} True if the object was made non-extensible, false otherwise.\n\t */\n\tpreventExtensions () {\n\t\treturn Reflect.preventExtensions(this.target())\n\t}\n\n\t/**\n\t * Sets the value of a property on the target object.\n\t * @param {string|symbol} propertyKey - The property key to set.\n\t * @param {*} value - The value to set.\n\t * @param {*} [optionalReceiver] - The value of `this` provided for the call to the setter.\n\t * @returns {boolean} True if the property was set successfully, false otherwise.\n\t */\n\tset (propertyKey, value, optionalReceiver) {\n\t\treturn Reflect.set(this.target(), propertyKey, value, optionalReceiver)\n\t}\n\n\t/**\n\t * Sets the prototype of the target object.\n\t * @param {Object|null} prototype - The object's new prototype or null.\n\t * @returns {boolean} True if the prototype was successfully set, false otherwise.\n\t */\n\tsetPrototype (prototype) {\n\t\treturn Reflect.setPrototypeOf(this.target(), prototype)\n\t}\n\t\n}\n",
  "CmCMeoePtTY8dwBu5CJX0hvd7u8mwINS01Y8cY24lOk=": "\"use strict\";\n\n/** \n * @module ideal\n * @class Type\n * @description Value/reference type related functions.\n\n    Example use:\n\n        if (Type.isNullOrUndefined(value)) { ...}\n\n\n    Known types:\n\n        Literals:\n\n            null\n            undefined\n            string\n            symbol\n            number\n\n        Other types:\n\n            object\n            array\n\n            Int8Array\n            Uint8Array\n            Uint8ClampedArray\n            Int16Array\n            Uint16Array\n            Int32Array\n            Uint32Array\n            Float32Array\n            Float64Array\n            BigInt64Array\n            BigUint64Array\n\n\n    More example uses:\n\n        const i8a = new Int8Array(6);   \n        console.log(\"is a Int8Array: \", Type.isInt8Array(i8a))\n\n*/\n\n\ngetGlobalThis().Type = (class Type extends Object {\n\n    /**\n     * Returns an array of all type names supported by this class.\n     * @returns {string[]} An array of type names.\n     */\n    static allTypeNames () {\n        return [\n            \"Array\",\n            \"Boolean\",\n            \"Blob\",\n            \"Map\",\n            \"Null\",\n            \"Number\",\n            \"Set\",\n            \"String\",\n            \"Symbol\",\n            \"Int8Array\",\n            \"Uint8Array\",\n            \"Uint8ClampedArray\",\n            \"Int16Array\",\n            \"Uint16Array\",\n            \"Int32Array\",\n            \"Uint32Array\",\n            \"Float32Array\",\n            \"Float64Array\",\n            \"BigInt64Array\",\n            \"BigUint64Array\",\n            //\"TypedArray\",\n            \"Undefined\",\n            \"Object\", // put object last so other types have preference\n        ]\n    }\n\n    /**\n     * Returns an array of typed array type names.\n     * @returns {string[]} An array of typed array type names.\n     */\n    static typedArrayTypeNames () {\n        return [\n            \"Int8Array\",\n            \"Uint8Array\",\n            \"Uint8ClampedArray\",\n            \"Int16Array\",\n            \"Uint16Array\",\n            \"Int32Array\",\n            \"Uint32Array\",\n            \"Float32Array\",\n            \"Float64Array\",\n            \"BigInt64Array\",\n            \"BigUint64Array\",\n        ]\n    }\n\n    /**\n     * Checks if the given value is a class.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a class, false otherwise.\n     */\n    static isClass (v) {\n        const result = typeof(v) === \"function\"\n            && /^class\\s/.test(Function.prototype.toString.call(v));\n\n        return result\n    }\n\n    /**\n     * Checks if the given value is a Promise.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Promise, false otherwise.\n     */\n    static isPromise (v) {\n        return v instanceof Promise;\n    }\n\n    /**\n     * Checks if the given value is a literal (string, number, boolean, null, or undefined).\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a literal, false otherwise.\n     */\n    static isLiteral (v) {\n        return  Type.isString(v) ||\n                Type.isNumber(v) ||\n                Type.isBoolean(v) ||\n                Type.isNull(v) ||\n                Type.isUndefined(v);\n    }\n\n    /**\n     * Checks if the given value is an array.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is an array, false otherwise.\n     */\n    static isArray (value) {\n        return !Type.isNull(value) && \n                Type.isObject(value) && \n                value.__proto__ === ([]).__proto__ &&\n                !Type.isUndefined(value.length)\n    }\n\n    /**\n     * Checks if the given value is a Set.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a Set, false otherwise.\n     */\n    static isSet (value) {\n        return !Type.isNull(value) && \n            Type.isObject(value) && \n            value.__proto__ === Set.prototype \n    }\n\n    /**\n     * Checks if the given value is a Map.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a Map, false otherwise.\n     */\n    static isMap (value) {\n        return !Type.isNull(value) && \n            Type.isObject(value) && \n            value.__proto__ === Map.prototype \n    }  \n\n    /**\n     * Checks if the given value is an iterator.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is an iterator, false otherwise.\n     */\n    static isIterator (value) {\n        return !Type.isNull(value) && \n                Type.isObject(value) && \n                typeof(value[Symbol.iterator]) === \"function\";\n    }\n\n    /**\n     * Checks if the given value is a boolean.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a boolean, false otherwise.\n     */\n    static isBoolean (value) {\n        return typeof(value) === \"boolean\"\n    }   \n\n    /**\n     * Checks if the given value is a function.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a function, false otherwise.\n     */\n    static isFunction (value) {\n        return typeof(value) === \"function\"\n    }  \n\n    /**\n     * Checks if the given value is undefined.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is undefined, false otherwise.\n     */\n    static isUndefined (value) {\n        return value === undefined // safe in modern browsers, even safe in older browsers if undefined is not redefined\n    }\n\n    /**\n     * Checks if the given value is null.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is null, false otherwise.\n     */\n    static isNull (value) {\n        return value === null\n    }\n\n    /**\n     * Checks if the given value is null or undefined.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is null or undefined, false otherwise.\n     */\n    static isNullOrUndefined (value) {\n        return this.isUndefined(value) || this.isNull(value)\n    }\n\n    /**\n     * Checks if the given value is NaN.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is NaN, false otherwise.\n     */\n    static isNaN (value) {\n        return isNaN(value)\n    }\n\n    /**\n     * Checks if the given value is a number.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a number, false otherwise.\n     */\n    static isNumber (value) {\n        return typeof(value) === \"number\"\n    }\n\n    /**\n     * Checks if the given value is an integer.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is an integer, false otherwise.\n     */\n    static isInteger (value) {\n        return this.isNumber(value) && (value % 1 === 0);\n    }\n\n    /**\n     * Checks if the given value is an object.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is an object, false otherwise.\n     */\n    static isObject (value) { \n        // WARNING: true for array and dictionary too!\n        return typeof(value) === \"object\" \n    }\n\n    /**\n     * Checks if the given value is a dictionary.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a dictionary, false otherwise.\n     */\n    static isDictionary (value) {\n        if (Type.isNullOrUndefined(value)) {\n            return false;\n        }\n        // WARNING: a good guess for our use cases, but not always correct!\n        // e.g. 3rd party libraries and code may use Object instances as or like Objects instead of as Dictionaries (such as in JSON)\n        return this.isObject(value) && (value.constructor === Object) \n    }\n\n    /**\n     * Checks if the given value is a string.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a string, false otherwise.\n     */\n    static isString (value) {\n        return typeof(value) === \"string\"\n    } \n\n    /**\n     * Checks if the given value is a symbol.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a symbol, false otherwise.\n     */\n    static isSymbol (value) {\n        return typeof(value) === \"symbol\"\n    } \n\n    /**\n     * Checks if the given value is an ArrayBuffer.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is an ArrayBuffer, false otherwise.\n     */\n    static isArrayBuffer (value) {\n        return Type.valueHasConstructor(value, ArrayBuffer);\n    }\n\n    /**\n     * Checks if the given value is a Blob.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a Blob, false otherwise.\n     */\n    static isBlob (value) {\n        return value instanceof Blob;\n    }\n\n    /**\n     * Checks if the given value is a simple type (number, string, boolean, undefined, or null).\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a simple type, false otherwise.\n     */\n    static isSimpleType (v) {\n        return Type.isNumber(v) || Type.isString(v) || Type.isBoolean(v) || Type.isUndefined(v) || Type.isNull(v);\n    }\n\n    // typed arrays \n\n    /**\n     * Checks if the given value has the specified constructor.\n     * @param {*} v - The value to check.\n     * @param {Function} constructor - The constructor to check against.\n     * @returns {boolean} True if the value has the specified constructor, false otherwise.\n     * @private\n     */\n    static valueHasConstructor (v, constructor) {  // private\n        return !Type.isNullOrUndefined(v) && (Object.getPrototypeOf(v) === constructor.prototype);\n    }\n\n    /**\n     * Checks if the given value is an Int8Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is an Int8Array, false otherwise.\n     */\n    static isInt8Array (v) {\n        return Type.valueHasConstructor(v, Int8Array);\n    }\n\n    /**\n     * Checks if the given value is a Uint8Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Uint8Array, false otherwise.\n     */\n    static isUint8Array (v) {\n        return Type.valueHasConstructor(v, Uint8Array);\n    }\n\n    /**\n     * Checks if the given value is a Uint8ClampedArray.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Uint8ClampedArray, false otherwise.\n     */\n    static isUint8ClampedArray (v) {\n        return Type.valueHasConstructor(v, Uint8ClampedArray);\n    }\n\n    /**\n     * Checks if the given value is an Int16Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is an Int16Array, false otherwise.\n     */\n    static isInt16Array (v) {\n        return Type.valueHasConstructor(v, Int16Array);\n    }\n\n    /**\n     * Checks if the given value is a Uint16Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Uint16Array, false otherwise.\n     */\n    static isUint16Array (v) {\n        return Type.valueHasConstructor(v, Uint16Array);\n    }\n\n    /**\n     * Checks if the given value is an Int32Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is an Int32Array, false otherwise.\n     */\n    static isInt32Array (v) {\n        return Type.valueHasConstructor(v, Int32Array);\n    }\n\n    /**\n     * Checks if the given value is a Uint32Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Uint32Array, false otherwise.\n     */\n    static isUint32Array (v) {\n        return Type.valueHasConstructor(v, Uint32Array);\n    }\n    \n    /**\n     * Checks if the given value is a Float32Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Float32Array, false otherwise.\n     */\n    static isFloat32Array (v) {\n        return Type.valueHasConstructor(v, Float32Array);\n    }\n\n    /**\n     * Checks if the given value is a Float64Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a Float64Array, false otherwise.\n     */\n    static isFloat64Array (v) {\n        return Type.valueHasConstructor(v, Float64Array);\n    }\n\n    /**\n     * Checks if the given value is a BigInt64Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a BigInt64Array, false otherwise.\n     */\n    static isBigInt64Array (v) {\n        return Type.valueHasConstructor(v, BigInt64Array);\n    }\n\n    /**\n     * Checks if the given value is a BigUint64Array.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a BigUint64Array, false otherwise.\n     */\n    static isBigUint64Array (v) {\n        return Type.valueHasConstructor(v, BigUint64Array);\n    }\n\n    \n    /**\n     * Checks if the given value is a TypedArray.\n     * @param {*} v - The value to check.\n     * @returns {boolean} True if the value is a TypedArray, false otherwise.\n     */\n    static isTypedArray (v) {\n        return Type.valueHasConstructor(v, TypedArray);\n    }\n    \n\n    // type name\n\n    /**\n     * Returns the type name of the given value.\n     * @param {*} value - The value to get the type name for.\n     * @returns {string} The type name of the value.\n     * @throws {Error} If unable to identify the type of the value.\n     */\n    static typeName (value) {\n        if (value === null) {\n            return \"Null\";\n        }\n\n        if (Type.isObject(value)) {\n            //return value.type()\n            return value.constructor.name;\n        }\n\n        if (Type.isFunction(value)) {\n            return \"function\";\n        }\n\n        /*\n        {\n            const type = Object.prototype.toString.call(value);\n            return type.slice(8, -1);\n        }\n        */\n\n        const typeNames = this.allTypeNames();\n        for (let i = 0; i < typeNames.length; i++) {\n            const typeName = typeNames[i];\n            const methodName = \"is\" + typeName;\n            if (this[methodName].call(this, value)) {\n                return typeName;\n            }\n        }\n        throw new Error(\"unable to identify type for value: \", value);\n    }\n\n    /**\n     * Returns an array of type names that match the given value.\n     * @param {*} value - The value to check.\n     * @returns {string[]} An array of matching type names.\n     */\n    static typeNamesForValue (value) {\n        const matches = [];\n        const typeNames = this.allTypeNames();\n        for (let i = 0; i < typeNames.length; i++) {\n            const typeName = typeNames[i];\n            const methodName = \"is\" + typeName;\n            if (this[methodName].apply(this, [value])) {\n                matches.push(typeName);\n            }\n        }\n        return matches;\n    }\n\n    /**\n     * Asserts that the given value matches the specified valid type names.\n     * @param {*} v - The value to check.\n     * @param {string[]} validTypeNames - An array of valid type names.\n     * @throws {Error} If the value's type names don't match the valid type names.\n     */\n    static assertValueTypeNames (v, validTypeNames) {\n        let doesMatch = true\n        const foundTypeNames = this.typeNamesForValue(v)\n        if (foundTypeNames.length === validTypeNames.length) {\n            for (let i = 0; i < foundTypeNames.length; i ++) {\n                const name = foundTypeNames[i]\n                if (!validTypeNames.includes(name)) {\n                    doesMatch = false;\n                    break;\n                }\n            }\n        } else {\n            doesMatch = false\n        }\n        if (!doesMatch) {\n            throw new Error(JSON.stringify(validTypeNames) + \" != \" + JSON.stringify(foundTypeNames) )\n        }\n    }\n\n    // --- type id ---\n\n    /**\n     * Checks if the given value is a JSON-compatible type.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a JSON-compatible type, false otherwise.\n     */\n    static isJsonType (value) {\n        // Note: this doesn't walk the collection types to see if their values are also JSON\n        const jsonTypes = new Set([\"String\", \"Number\", \"Object\", \"Array\", \"Boolean\", \"Null\"]);\n        return jsonTypes.has(Type.typeName(value));\n    }\n\n    /**\n     * Checks if the given value is a deep JSON-compatible type.\n     * @param {*} value - The value to check.\n     * @returns {boolean} True if the value is a deep JSON-compatible type, false otherwise.\n     */\n    static isDeepJsonType (value) {\n        const seen = new Set();\n      \n        function checkValue(v) {\n          if (v === null) return true;\n      \n          const type = typeof v;\n      \n          if (['string', 'number', 'boolean'].includes(type)) return true;\n      \n          if (type === 'object') {\n            if (seen.has(v)) return false; // Circular reference\n            seen.add(v);\n      \n            if (Array.isArray(v)) {\n              return v.every(checkValue);\n            } else {\n              return Object.keys(v).every(key => {\n                if (typeof key !== 'string') return false;\n                return checkValue(v[key]);\n              });\n            }\n          }\n      \n          return false; // Functions, undefined, symbols, etc.\n        }\n      \n        return checkValue(value);\n    }\n\n\n    /**\n     * Generates a unique identifier for the given value based on its type.\n     * @param {*} value - The value to generate an identifier for.\n     * @returns {string} A unique identifier for the value.\n     * @throws {Error} If the value's type is not handled.\n     */\n    static typeUniqueId (value) {\n\n        if (Type.isUndefined(value)) {\n            return \"u\";\n        }\n\n        if (Type.isNull(value)) {\n            return \"n\";\n        }\n\n        if (Type.isObject(value)) {\n            // Array, Set, {}, Object, etc but not numbers, strings, null, or undefined\n            return \"O\" + value.puuid();\n        }\n\n        if (Type.isNumber(value)) {\n            return \"N\" + value;\n        }\n\n        if (Type.isString(value)) {\n            return \"S\" + value.hashCode64();\n            //return \"S\" + String_simpleHash(value)\n        }\n\n        throw new Error(\"unhandled type '\" + Type.typeName(value) + \"'\");\n    }\n\n    // --- copying ---\n\n    /**\n     * Creates a deep copy of the given value.\n     * @param {*} v - The value to copy.\n     * @param {Map} [refMap=new Map()] - A map to track object references for circular references.\n     * @returns {*} A deep copy of the value.\n     * @throws {Error} If the value is not a simple type or doesn't have a deepCopy method.\n     */\n    static deepCopyForValue (v, refMap = new Map()) {\n        if (refMap.has(v)) {\n            return refMap.get(v);\n        }\n\n        if (Type.isSimpleType(v)) {\n            return v;\n        } else if (Type.isObject(v)) {\n            if (v.deepCopy) {\n                const newValue = v.deepCopy(refMap);\n                refMap.set(v, newValue);\n                return newValue;\n            } else {\n                throw new Error(\"deepCopyForValue() error: value is object but has no deepCopy() method\");\n            }\n        }\n\n        throw new Error(\"deepCopyForValue() error: value is not a simple type: \" + Type.typeName(v));\n    }\n\n\n    // --- testing ---\n\n    /**\n     * Runs tests for the Type class methods.\n     * @private\n     */\n    static test () { // private\n        this.assertValueTypeNames(null, [\"Null\", \"Object\"])\n        this.assertValueTypeNames(undefined, [\"Undefined\"])\n        this.assertValueTypeNames(\"foo\", [\"String\"])\n        this.assertValueTypeNames(1, [\"Number\"])\n        this.assertValueTypeNames([], [\"Array\", \"Object\"])\n        this.assertValueTypeNames({} [\"Object\"])\n        this.assertValueTypeNames(new Int8Array(), [\"Int8Array\", \"Object\"])\n        this.assertValueTypeNames(new Blob(), [\"Blob\", \"Object\"])\n\n        // extras\n        //assert(Type.isNullOrUndefined(undefined))\n        //assert(Type.isNullOrUndefined(null))\n    }\n\n});\n\n\n//Type.test()",
  "G9O1pBlLOKxGBcJw/uQmtO/pQbDIyQa3fUQlEjcrv8c=": "\n\"use strict\"; \n\n/*\n    @module ideal.object\n\n    Weird JS things:\n\n    Some of the primitives such as Array, Set, Map have constructors which \n    do not inherit from Object (they and the Object constructor all inherit \n    from constructor named \"\") but their constructor prototypes *do* inherit \n    from Object.prototype.\n\n    To make this consistent (so we can inherit class methods) we do\n    the following:\n\n*/\n\n{\n    const classesToFix = [\n        Array, \n        Boolean, \n        Blob,\n        Date, \n        Error, \n        Image, \n        Set, \n        Map, \n        Number,\n        Range,\n        String,\n        ArrayBuffer\n    ]\n    classesToFix.forEach(aClass => aClass.__proto__ = Object)\n}\n\n/*\n\n    Object-helpers\n    \n    Some functions to help us implement categories.\n\n*/\n\nObject.defineSlot = function (obj, slotName, slotValue) {\n    if (Object.getOwnPropertyDescriptor(slotName)) {\n        // TODO: raise exception if it exists? Safer for categories?\n        this[slotName] = slotValue\n    } else {\n        const descriptor = {\n            configurable: true,\n            enumerable: false,\n            value: slotValue,\n            writable: true,\n        }\n\n        // this breaks on prototypes\n        /*\n        if (typeof (slotValue) === \"function\") {\n            let objType = null\n            try {\n                //if (obj.type) {\n                    objType = obj.type()\n                //}\n            } catch (e) {\n                //console.warn(\"can't get type on \", obj)\n            }\n\n            if (objType) {\n                //  debugger;\n                slotValue.displayName = objType + \".\" + slotName\n                //console.log(\"slotValue.displayName: \", slotValue.displayName)\n            } else {\n                slotValue.displayName = slotName\n            }\n        }\n        */\n\n        Object.defineProperty(obj, slotName, descriptor)\n    }\n}\n\n/*\nTest = class Test {\n    setup () {\n        this._foo = 123\n    }\n}\n \nObject.defineSlot(Test.prototype, \"_foo\", \"bar\")\n \nlet test = new Test()\ntest.setup()\n \nconsole.log(test)\nlet d = Reflect.getOwnPropertyDescriptor(test, \"_foo\")\nconsole.log(d)\n \nif (d.enumerable) {\n    console.log(\"is enumerable\")\n} else {\n    console.log(\"is not enumberable\")\n}\n*/\n\nObject.defineSlots = function (obj, dict) {\n    Object.keys(dict).forEach((slotName) => {\n        const slotValue = dict[slotName]\n        Object.defineSlot(obj, slotName, slotValue)\n    })\n};\n\nObject.defineSlotSafely = function(obj, slotName, slotValue) {\n    const nameForObj = function (obj) {\n        let name = \"?\";\n        try {\n            if (obj.hasOwnProperty(\"name\")) {\n                name = obj.name + \"\";\n            } else {\n                name = obj.constructor.name + \".prototype\";\n            }\n        } catch (e) {\n            name = \"[error getting name]\";\n        }\n        return name;\n    }\n\n    if (obj.hasOwnProperty(slotName) && !slotName.startsWith(\"_\")) {\n        if(typeof(slotValue) === \"function\" && obj[slotName + \"_isOptional\"] !== undefined) {\n            return null;\n        }\n        const msg = nameForObj(obj) + \".\" + slotName + \" slot already exists\";\n        console.log(msg);\n        throw new Error(msg);\n    } else {\n        //const msg = nameForObj(obj) + \".\" + slotName + \" DEFINED\";\n        //console.log(msg);\n        Object.defineSlot(obj, slotName, slotValue);\n    }\n};\n\nObject.defineSlotsSafelyFromMap = function (obj, aMap) {\n    for (const [slotName, slotValue] of aMap) {\n        Object.defineSlotSafely(obj, slotName, slotValue);\n    }\n};\n\n// --- category related methods --------------------------------------------\n\n\n// --- type ---\n\nObject.defineSlotSafely(Object, \"type\", function () { \n    return this.name;\n});\n\nObject.defineSlotSafely(Object.prototype, \"type\", function () { \n    return this.constructor.name;\n});\n\n// --- isClass ---\n\nObject.defineSlotSafely(Object, \"isClass\", function () { \n    return true;\n});\n\nObject.defineSlotSafely(Object.prototype, \"isClass\", function () { \n    return false;\n});\n\n// --- isPrototype ---\n\nObject.defineSlotSafely(Object, \"isPrototype\", function () { \n    return false;\n});\n\nObject.defineSlotSafely(Object.prototype, \"isPrototype\", function () { \n    return this.constructor.prototype === this;\n});\n\n// --- isInstance ---\n\nObject.defineSlotSafely(Object, \"isInstance\", function () { \n    return false;\n});\n\nObject.defineSlotSafely(Object.prototype, \"isInstance\", function () { \n    return !this.isPrototype();\n});\n\n\n// --- slot enumeration -----------------------------------------------------\n\nObject.defineSlotSafely(Object.prototype, \"forEachPrototype\", function (fn) { \n    let proto = this;\n\n    if (this.isInstance()) {\n        proto = this.__proto__;\n    }\n\n    while (proto) {\n        fn(proto);\n        //console.log(\"proto is \", proto.type())\n        if (proto === proto.__proto__) {\n            throw new Error(\"__proto__ loop detected in \" + proto.type());\n            break;\n        } else {\n            proto = proto.__proto__;\n        }\n    }\n});\n\nObject.defineSlot(Object.prototype, \"forEachSlot\", function (fn) { \n    this.forEachPrototype(proto => {\n        if (Object.hasOwn(proto, \"_slotsMap\")) {\n            proto._slotsMap.forEach((slot, key, map) => {\n                fn(slot);\n            })\n        }\n    });\n});\n\nObject.defineSlot(Object.prototype, \"setupAllSlotsMap\", function () { \n    if (!this.isPrototype()) {\n        throw new Error(\"setupAllSlotsMap called on non-prototype\");\n    }\n\n    const m = this._allSlotsMap;\n    //console.log(\"*** \" + this.type() + \" setupAllSlotsMap\");\n\n    //assert(this.isPrototype())\n    this.forEachSlot(slot => {\n        const k = slot.name();\n        if (!m.has(k)) { // to handle overrides \n            m.set(k, slot);\n        }\n    });\n});\n\nObject.defineSlot(Object.prototype, \"allSlotsMap\", function () { \n    return this._allSlotsMap;\n});\n\nObject.defineSlot(Object.prototype, \"slotsMap\", function () { \n    return this._slotsMap;\n});\n\nObject.defineSlot(Object.prototype, \"initSlots\", function () { // setup property, getter, setter for each slot\n    assert(this.isPrototype());\n    //console.log(this.type() + \" this.slotsMap().size = \" + this.slotsMap().size);\n\n    this.slotsMap().forEach((slot) => {\n        slot.setupInOwner();\n        assert(this.hasOwnProperty([slot.name()]) && this.hasOwnProperty([\"_\" + slot.name()]), this.type() + \" missing \" + slot.name() + \" slot\");\n    });\n});\n\nObject.defineSlot(Object.prototype, \"setupPrototype\", function () { \n\n    if (!this.isPrototype()) {\n        throw new Error(\"setupPrototype called on non-prototype\");\n    }\n\n    /// each proto has it's own set of slots - use justNewSlot as newSlot needs to check the slots list\n    Object.defineSlot(this, \"_slotsMap\", new Map()); // slots for just this proto\n    Object.defineSlot(this, \"_allSlotsMap\", new Map()); // slots for this proto and all protos in the proto chain\n    this.setupAllSlotsMap();\n\n    // We need to separate initPrototypeSlots, initSlots, initPrototype as\n    // initializing some slots may depend on others already existing.\n    \n    // Slot init ordering may be important as well and why slots should be stored in \n    // an array with a name->slot map used as an index.\n\n    \n    if (this.hasOwnProperty(\"initPrototypeSlots\")) {\n        // Only called if method defined on this class.\n        this.initPrototypeSlots();// This method should NOT call super\n    }\n\n    this.initSlots();\n\n    if (this.hasOwnProperty(\"initPrototype\")) {\n        this.initPrototype(); // This method should NOT call super\n\n        if (this.assertProtoSlotsHaveType) {\n            this.assertProtoSlotsHaveType();\n        } else {\n            if (this.type() !== \"Object\") {\n                console.log(this.type() + \" missing assertProtoSlotsHaveType\");\n                debugger;\n            }\n        }\n    } else {\n        //debugger;\n    }\n\n    //console.log(\"\\n\\n\" + this.type() + \" allSlots: \", Array.from(this.allSlotsMap().keys()).sort() + \"\\n\\n\");\n    return this;\n});\n\n\nObject.defineSlot(Object, \"initThisCategory\", function () { \n    // define this first, so we can use it to more cleanly define our\n    // Object categories.\n    //\n    // This is a bit of a hack to implement class categories in Javascript\n    // sanity check: check name to ensure we're only using this on a category\n\n    const hasTwoPartName = this.name.split(\"_\").length === 2;\n    if (!hasTwoPartName) {\n        const msg = \"category class name '\" + this.type() + \"' doesn't match expected pattern of ClassName_categoryName.\";\n        throw new Error(msg);\n    }\n\n    // assert(this.isClass());\n    // setup slots (would normally be done ny initThisClass)\n\n    //////////////////////////////////////////////////////////////////////\n    //this.prototype.setupPrototype(); /////////////////////////////////// FIXME: we should be able to do this and be able to support initPrototypeSlots&initPrototype in categories, right?\n    //////////////////////////////////////////////////////////////////////\n\n    // function to get a map of slots (usefull for copying slots from one object to another)\n\n    const getSlotsMapOn = (obj) => {\n        const keys = Reflect.ownKeys(obj);\n        const map = new Map();\n        keys.forEach(k => {\n            const v = obj[k];\n            map.set(k, v);\n            /*\n            // this doesn't seem to get the correct .name(?)\n            if (typeof (v) === \"function\" && k !== \"constructor\") {\n                //v._categoryName = this.name // add a comment for category source \n            }\n            */\n        })\n        return map;\n    }\n\n    // get the parent class\n    const parentClass = this.__proto__;\n\n    //parentClass.addProtoCategory(this);\n\n    // copy class slots to parent class\n    const classSlotsMap = getSlotsMapOn(this);\n    classSlotsMap.delete(\"length\"); // FIXME: hack for collection types\n    classSlotsMap.delete(\"name\");\n    classSlotsMap.delete(\"prototype\");\n    Object.defineSlotsSafelyFromMap(parentClass, classSlotsMap); // throws if slot already exists\n\n    // copy prototype slots to parent prototype\n    const protoSlotsMap = getSlotsMapOn(this.prototype);\n    protoSlotsMap.delete(\"constructor\");\n    protoSlotsMap.delete(\"prototype\");\n    Object.defineSlotsSafelyFromMap(parentClass.prototype, protoSlotsMap); // throws if slot already exists\n\n    /*\n    console.log(\"this.name = '\" + this.name + \"'\")\n    console.log(\"parentClass.name = '\" + parentClass.name + \"'\")\n    console.log(\"parentClass.__proto__.name = '\" + parentClass.__proto__.name + \"'\")\n    */\n    \n    // bit of a hack to fix super in class and proto methods\n    if (parentClass !== Object) { // don't need to call super on base class\n        // fix super in instance methods\n        Object.setPrototypeOf(this.prototype, parentClass.__proto__.prototype); \n\n        // fix super in static/class methods\n        // need to do this *after* instance methods super fix as it changes __proto__\n        Object.setPrototypeOf(this, parentClass.__proto__); \n\n        // related to super, see:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super\n    }\n\n    return this\n});\n\n\n",
  "4WKkyJeo9YzblW5Y/nW1o0mybPwIKHK2dPX+7SNiaMU=": "\"use strict\";\n\n/**\n * Custom error class for missing slots.\n * @module ideal.object\n * @class MissingSlotError\n * @extends Error\n */\n\ngetGlobalThis().MissingSlotError = (class MissingSlotError extends Error {\n    constructor(message) {\n      super(message);\n      this.name = \"MissingSlotError\";\n    }\n});\n  \n/**\n * Adds copying related behaviors for Object class.\n * @module ideal.object\n * @class Object_copying\n * @extends Object\n */\n\n(class Object_copying extends Object {\n\n    /**\n     * Creates a shallow copy of the object.\n     * @returns {Object} A shallow copy of the object.\n     */\n    shallowCopy () {\n        const copy = Object.assign({}, this);\n        return copy\n    }\n \n    /**\n     * Creates a deep copy of the object.\n     * @returns {Object} A deep copy of the object.\n     */\n    duplicate () {\n        if (this.constructor === Object) {\n            // it's a dictionary!\n            const deepCopyDict = JSON.parse(JSON.stringify(this)); // breaks for non-JSON!\n            return deepCopyDict;\n        } else {\n            assert(this.isInstance());\n            const instance = this.thisClass().clone().copyFrom(this);\n            instance.duplicateSlotValuesFrom(this); // TODO: what about lazy slots?\n            return instance;\n        }\n    }\n \n    /**\n     * Alias for duplicate method.\n     * @returns {Object} A deep copy of the object.\n     */\n    copy () {\n        return this.duplicate()\n    }\n\n    /**\n     * Alias for copy method.\n     * @returns {Object} A deep copy of the object.\n     */\n    deepCopy () {\n        return this.copy();\n    }\n \n    /**\n     * Copies values from another object, ignoring missing slots.\n     * @param {Object} anObject - The object to copy from.\n     * @returns {Object} This object after copying.\n     */\n    copyFromAndIgnoreMissingSlots (anObject) {\n        return this.copyFrom(anObject, true) \n    }\n    \n    /**\n     * Copies values from another object.\n     * @param {Object} anObject - The object to copy from.\n     * @param {boolean} [ignoreMissingSlots=false] - Whether to ignore missing slots.\n     * @returns {Object} This object after copying.\n     */\n    copyFrom (anObject, ignoreMissingSlots = false) { \n        this.duplicateSlotValuesFrom(anObject, ignoreMissingSlots)\n        return this\n    }\n \n    /**\n     * Duplicates slot values from another object.\n     * @param {Object} otherObject - The object to duplicate from.\n     * @param {boolean} [ignoreMissingSlots=false] - Whether to ignore missing slots.\n     * @returns {Object} This object after duplicating slot values.\n     * @throws {MissingSlotError} If a slot is missing and ignoreMissingSlots is false.\n     */\n    duplicateSlotValuesFrom (otherObject, ignoreMissingSlots = false) {\n        this.thisPrototype().allSlotsMap().forEachKV((slotName, mySlot) => {\n            const otherSlot = otherObject.thisPrototype().slotNamed(slotName)\n            const hasSlot = !Type.isNullOrUndefined(otherSlot)\n            if (hasSlot) {\n                const dop = otherSlot.duplicateOp()\n                if (dop === \"nop\") {\n                    // skip\n                } else {\n                    const v = otherSlot.onInstanceGetValue(otherObject) // TODO: what about lazy slots?\n        \n                    if (dop === \"copyValue\") {\n                        mySlot.onInstanceSetValue(this, v)\n                    } else if (dop === \"duplicate\") {\n                        const dup = v === null ? v : v.duplicate()\n                        mySlot.onInstanceSetValue(this, dup)\n                    } else {\n                        throw new Error(\"unsupported slot duplicate operation: '\" +  dop + \"'\")\n                    }\n                }\n            } else if (!ignoreMissingSlots) {\n                throw new MissingSlotError()\n            }\n        })\n        return this\n    }\n \n    /**\n     * Copies slot values from another object.\n     * @param {Object} otherObject - The object to copy from.\n     * @returns {Object} This object after copying slot values.\n     */\n    copySlotValuesFrom (otherObject) {\n        this.thisPrototype().allSlotsMap().forEachKV((slotName, mySlot) => {\n            const otherSlot = otherObject.thisPrototype().slotNamed(slotName)\n            const v = otherSlot.onInstanceGetValue(otherObject)\n            mySlot.onInstanceSetValue(this, v)\n        })\n        return this\n    }\n\n}).initThisCategory();\n\n",
  "wuU32Dupy+KcvkK02SW/rql+NzcJZVDA0nmPuTrJ3yg=": "\"use strict\";\n\n/**\n * Object_class\n * \n * Some added state and behavior on Object class.\n * @module ideal.object\n * @class Object_class\n * @extends Object\n */\n\n(class Object_class extends Object {\n\n    /**\n     * Gets the superclass of this class.\n     * @returns {Function} The superclass.\n     */\n    superClass () {\n        return this.thisClass().superClass();\n    }\n\n    /**\n     * Gets the class of this object.\n     * @returns {Function} The class of this object.\n     */\n    thisClass () {\n        if (this.isPrototype()) {\n            // it's a prototype\n            return this.constructor;\n        }\n\n        // otherwise, it's an instance\n        return this.__proto__.constructor;\n    }\n \n    /**\n     * Gets the prototype of this instance.\n     * @returns {Object} The prototype of this instance.\n     * @throws {Error} If called on a non-instance.\n     */\n    thisPrototype () {\n        assert(this.isInstance());\n        const prototype = this.__proto__;\n        assert(prototype.isPrototype);\n        return prototype;\n    }\n\n    // --- class methods ---\n\n    /**\n     * Creates a new instance of the class, initializes it, and returns it.\n     * @returns {Object} A new instance of the class.\n     */\n    static clone () {\n        const obj = new this();\n        obj.init();\n        obj.finalInit();\n        obj.afterInit();\n        return obj;\n    }\n\n    /**\n     * Gets the class with the given name from the global scope.\n     * @param {string} aName - The name of the class to get.\n     * @returns {Function|undefined} The class with the given name, or undefined if not found.\n     */\n    static getClassNamed (aName) {\n        if (Type.isNullOrUndefined(aName)) {\n            return undefined;\n        }\n        return getGlobalThis()[aName];\n    }\n\n    /**\n     * Gets the parent class of this class.\n     * @returns {Function|null} The parent class, or null if there is no parent.\n     */\n    static parentClass () {\n        const p = this.__proto__;\n\n        if (p && p.type) {\n            return p;\n        }\n\n        return null;\n    }\n\n    /**\n     * Adds a child class to this class.\n     * @param {Function} aClass - The child class to add.\n     * @returns {Function} This class.\n     */\n    static addChildClass (aClass) {\n        this.childClasses().add(aClass);\n        return this;\n    }\n\n    /**\n     * Gets the global object.\n     * @returns {Object} The global object.\n     */\n    static globals () {\n        return getGlobalThis();\n    }\n\n    /**\n     * Initializes class-level properties.\n     */\n    static initClass () {\n        this.newClassSlot(\"allClassesSet\", new Set());\n    }\n\n    /**\n     * Finds all ancestor classes of this class.\n     * @returns {Array<Function>} An array of ancestor classes.\n     */\n    static findAncestorClasses () {\n        const results = [];\n        let aClass = this.parentClass();\n        while (aClass && aClass.parentClass) {\n            results.push(aClass);\n            aClass = aClass.parentClass();\n        }\n        return results;\n    }\n\n    /**\n     * Creates a new class-level slot.\n     * @param {string} slotName - The name of the slot.\n     * @param {*} slotValue - The initial value of the slot.\n     * @returns {Function} This class.\n     */\n    static newClassSlot (slotName, slotValue) {\n        const ivarName = \"_\" + slotName;\n        const assert = function (aBool) {\n            if (!aBool) {\n                throw new Error(\"failed assert\");\n            }\n        }\n\n        // define ivar\n        {\n            const hasIvar = !Type.isUndefined(Object.getOwnPropertyDescriptor(this, ivarName));\n            assert(!hasIvar);\n            const descriptor = {\n                configurable: true,\n                enumerable: false,\n                value: slotValue,\n                writable: true,\n            }\n            Object.defineProperty(this, ivarName, descriptor);\n        }\n\n        // define getter\n        {\n            const hasGetter = !Type.isUndefined(Object.getOwnPropertyDescriptor(this, slotName));\n            assert(!hasGetter);\n            const getterFunc = function () { \n                assert(arguments.length === 0);\n                return this[ivarName]; \n            };\n            const descriptor = {\n                configurable: true,\n                enumerable: false,\n                value: getterFunc,\n                writable: true,\n            }\n            Object.defineProperty(this, slotName, descriptor);\n        }\n\n        // define setter\n        {\n            const setterName = \"set\" + slotName.capitalized();\n            const setterFunc = function (v) { \n                this[ivarName] = v; \n                return this; \n            };\n            const descriptor = {\n                configurable: true,\n                enumerable: false,\n                value: setterFunc,\n                writable: true,\n            }\n            Object.defineProperty(this, setterName, descriptor);\n        }\n\n        return this\n    }\n\n    /**\n     * Initializes this class. Called on every class which we create.\n     * @returns {Function} This class.\n     */\n    static initThisClass () {\n        this.defineClassGlobally();\n\n        // setup ancestor list\n        // could become invalid if class structure dynamically changes\n        this.newClassSlot(\"ancestorClasses\", this.findAncestorClasses());\n        this.newClassSlot(\"childClasses\", new Set());\n\n        // add as class to parent\n        const p = this.parentClass();\n        if (p && p.addChildClass) {\n            p.addChildClass(this);\n        }\n\n        if (this.hasOwnProperty(\"initClass\")) {\n            // Only called if method defined on this class.\n            // This method should *not* call super.initClass().\n            this.initClass();\n        }\n\n        this.prototype.setupPrototype();\n\n        this.addToAllClasses();\n        return this;\n    }\n\n    /**\n     * Iterates over each slot key-value pair.\n     * @param {Function} fn - The function to call for each slot.\n     */\n    forEachSlotKV (fn) {\n        // WARNING: overridden slots may be called multiple times using this method\n        // use allSlotsMap() to avoid this\n\n        this.forEachSlot(slot => {\n            fn(slot.name(), slot); \n        });\n    }\n\n    /**\n     * Initializes the prototype.\n     */\n    initPrototype () {\n        // called after setupInOwner is called on each slot\n        // so we have a chance to initialize things after all slots are set up \n    }\n\n    /**\n     * Defines this class globally.\n     * @throws {Error} If attempting to redefine a class that's not Object.\n     */\n    static defineClassGlobally () {\n        const className = this.type();\n        if (Type.isUndefined(this.globals()[className])) {\n            this.globals()[className] = this;\n        } else if (this.type() !== \"Object\") {\n            const msg = \"WARNING: Attempt to redefine getGlobalThis()['\" + className + \"']\";\n            console.warn(msg);\n            throw new Error(msg);\n        }\n    }\n\n    /**\n     * Gets the superclass of this class.\n     * @returns {Function} The superclass.\n     */\n    static superClass () {\n        return this.__proto__;\n    }\n\n    /**\n     * Adds this class to the set of all classes.\n     * @returns {Function} This class.\n     * @throws {Error} If attempting to call initThisClass twice on the same class.\n     */\n    static addToAllClasses () {\n        if (this.allClassesSet().has(this)) {\n            throw new Error(\"attempt to call initThisClass twice on class '\" + this.type() + \"'\");\n        }\n        this.allClassesSet().add(this);\n        return this;\n    }\n\n    /**\n     * Gets all subclasses of this class.\n     * @returns {Set<Function>} A set of all subclasses.\n     */\n    static allSubclasses () {\n        return this.allClassesSet().select(aClass => aClass.hasAncestorClass(this));\n    }\n\n    /**\n     * Gets direct subclasses of this class.\n     * @returns {Set<Function>} A set of direct subclasses.\n     */\n    static subclasses () {\n        return this.allClassesSet().select(aClass => aClass.superClass() === this);\n    }\n\n    /**\n     * Checks if this class has the given class as an ancestor.\n     * @param {Function} aClass - The class to check.\n     * @returns {boolean} True if aClass is an ancestor, false otherwise.\n     */\n    static hasAncestorClass (aClass) {\n        const sc = this.superClass();\n\n        if (sc === aClass) {\n            return true;\n        }\n\n        if (sc === Object || !sc.hasAncestorClass) {\n            return false;\n        }\n\n        return sc.hasAncestorClass(aClass);\n    }\n\n    /**\n     * Iterates over each slot of an object.\n     * @param {Object} obj - The object to iterate over.\n     * @param {Function} fn - The function to call for each slot.\n     */\n    static eachSlot (obj, fn) {\n        Object.keys(obj).forEach(k => fn(k, obj[k]));\n    }\n\n    /**\n     * Checks if this class is a kind of the given class.\n     * @param {Function} aClass - The class to check against.\n     * @returns {boolean} True if this class is a kind of aClass, false otherwise.\n     */\n    static isKindOf (aClass) {\n        if (this.name === \"\") {\n            // anything touching the root \"\" class seems to crash Chrome,\n            // so let's be careful to leave it alone\n            return false;\n        }\n\n        if (this === aClass) {\n            return true;\n        }\n\n        let proto = this.__proto__;\n        if (proto && proto.name !== \"\") {\n            return proto.isKindOf.call(proto, aClass);\n        }\n\n        return false;\n    }\n\n}).initThisCategory();\n\nObject.initThisClass();\n",
  "LjpqOAs/s+6ahsRtbxp76mHcQs6n0sPngCOB5uIH4XY=": "//\"use strict\";\n\n/**\n * Some added state and behavior on Object prototype.\n * \n * Note:Object keys always get turned into strings.\n * \n * @module ideal.object\n * @class Object_ideal\n * @extends Object\n * \n */\n\n(class Object_ideal extends Object {\n    \n    /**\n     * Initializes prototype slots.\n     */\n    initPrototypeSlots () {\n        Object.defineSlot(this, \"_hasDoneInit\", false); // so object's can distinguish changes from deserialization\n        Object.defineSlot(this, \"_shouldScheduleDidInit\", false);\n        Object.defineSlot(this, \"_mutationObservers\", null);\n        Object.defineSlot(this, \"_shouldStore\", true);\n    }\n\n    /**\n     * Checks if this object is a kind of the given class.\n     * @param {Function} aClass - The class to check against.\n     * @returns {boolean} True if this object is a kind of aClass, false otherwise.\n     */\n    isKindOf (aClass) {\n        return this.thisClass().isKindOf(aClass);\n    }\n\n    /**\n     * Returns the type category of this object.\n     * @returns {string} The type category (\"instance\", \"prototype\", or \"class\").\n     * @throws {Error} If unable to identify the type category.\n     */\n    typeCategory () {\n        if (this.isInstance()) {\n            return \"instance\";\n        } else if (this.isPrototype()) {\n            return \"prototype\";\n        } else if (this.isClass()) {\n            return \"class\";\n        }\n        throw new Error(\"unable to identify\");\n    }\n \n    /**\n     * Returns the full type name of this object.\n     * @returns {string} The full type name.\n     */\n    fullTypeName () {\n        return this.type() + \" \" + this.typeCategory();\n    }\n \n    /**\n     * Performs a method on this object.\n     * @param {string} methodName - The name of the method to perform.\n     * @param {*} arg1 - The first argument to pass to the method.\n     * @param {*} arg2 - The second argument to pass to the method.\n     * @param {*} arg3 - The third argument to pass to the method.\n     * @returns {*} The result of the method call.\n     * @throws {Error} If the object does not respond to the given method.\n     */\n    perform (methodName, arg1, arg2, arg3) {\n        const f = this[methodName];\n        if (f) {\n            return f.call(this, arg1, arg2, arg3);\n        }\n        throw new Error(this.typeId() + \" does not respond to '\" + methodName + \"'\");\n    }\n \n    /**\n     * Performs a method on this object if it responds to it.\n     * @param {string} methodName - The name of the method to perform.\n     * @param {*} arg1 - The first argument to pass to the method.\n     * @param {*} arg2 - The second argument to pass to the method.\n     * @param {*} arg3 - The third argument to pass to the method.\n     * @returns {*} The result of the method call, or undefined if the method doesn't exist.\n     */\n    performIfResponding (methodName, arg1, arg2, arg3) {\n        const f = this[methodName];\n        if (f) {\n            return f.call(this, arg1, arg2, arg3);\n        }\n    }\n \n    /**\n     * Gets the value of a slot.\n     * @param {string|symbol} key - The key of the slot.\n     * @returns {*} The value of the slot.\n     */\n    atSlot (key) {\n        return this[key];\n    }\n \n    /**\n     * Sets the value of a slot.\n     * @param {string|symbol} key - The key of the slot.\n     * @param {*} value - The value to set.\n     * @returns {Object_ideal} This object.\n     */\n    atSlotPut (key, value) {\n        this[key] = value;\n        return this;\n    }\n \n    /**\n     * Removes a slot from this object.\n     * @param {string|symbol} key - The key of the slot to remove.\n     * @returns {Object_ideal} This object.\n     */\n    removeSlotAt (key) {\n        delete this[key];\n        return this;\n    }\n    \n    /**\n     * Maps over the object's own key-value pairs.\n     * @param {Function} fn - The function to call for each key-value pair.\n     * @returns {Array} The results of calling the function on each key-value pair.\n     */\n    ownKVMap (fn) {\n        return Object.entries(this).map(entry => fn(entry[0], entry[1]));\n    }\n \n    /**\n     * Iterates over the object's own values.\n     * @param {Function} fn - The function to call for each value.\n     * @returns {Object_ideal} This object.\n     */\n    ownForEachValue (fn) {\n        Object.entries(this).forEach(entry => fn(entry[1])); \n        return this;\n    }\n \n    /**\n     * Iterates over the object's own keys.\n     * @param {Function} fn - The function to call for each key.\n     * @returns {Object_ideal} This object.\n     */\n    ownForEachKey(fn) {\n        Object.entries(this).forEach(entry => fn(entry[0])); \n        return this;\n    }\n \n    /**\n     * Iterates over the object's own key-value pairs.\n     * @param {Function} fn - The function to call for each key-value pair.\n     * @returns {Object_ideal} This object.\n     */\n    ownForEachKV (fn) {\n        Object.entries(this).forEach(entry => fn(entry[0], entry[1])); \n        return this;\n    }\n \n    /**\n     * Checks if this object is equal to another object.\n     * @param {Object} anObject - The object to compare with.\n     * @returns {boolean} True if the objects are equal, false otherwise.\n     */\n    isEqual (anObject) {\n        const entries = Object.entries(this);\n        const otherEntries = Object.entries(anObject);\n        if (entries.length !== otherEntries.length) {\n            return false;\n        }\n \n        return entries.canDetect(entry => {\n            const k = entry[0];\n            const v = entry[1];\n            return v !== anObject.getOwnProperty(k);\n        });\n    }\n \n    /**\n     * Gets the value of an own property.\n     * @param {string|symbol} key - The key of the property.\n     * @returns {*} The value of the property, or undefined if it doesn't exist.\n     */\n    getOwnProperty (key) {\n        if (this.hasOwnProperty(key)) {\n            return this[key];\n        }\n        return undefined;\n    }\n \n    /**\n     * Gets the slot value path for debugging serialization/deserialization.\n     * @param {string} slotName - The name of the slot.\n     * @param {Array} [entries=[]] - The array to store entries.\n     * @returns {Array} The slot value path.\n     */\n    slotValuePath (slotName, entries = []) {\n        const entry = [this.fullTypeName(), this.getOwnProperty(slotName)];\n        entries.push(entry);\n \n        const proto = this.__proto__;\n        if (proto) {\n            return proto.slotValuePath.apply(proto, [slotName, entries]);\n        }\n \n        return entries;\n    }\n\n    /**\n     * Schedules a method to be called at the end of the event loop.\n     * @param {string} methodName - The name of the method to schedule.\n     * @param {number} priority - The priority of the scheduled method.\n     * @returns {*} The result of scheduling the method.\n     */\n    scheduleMethod (methodName, priority) {\n        return SyncScheduler.shared().scheduleTargetAndMethod(this, methodName, priority);\n    }\n\n}).initThisCategory();\n\nObject.prototype.initPrototypeSlots()\n",
  "Ed0GezsFhewvHI+IhMoadpZNqqW8lyPw6YX3ok+hLHg=": "\"use strict\";\n\n/**\n * Initialization related behavior, and some important notes related to initialization.\n * \n * Some initialization may have to wait until other objects have initialized. \n * \n * These are some states the object may need to wait for, \n * and how to handle completing initialization at those points:\n * \n * - initAfterEventLoop() (end of current event loop)\n *   In your class's init() method, call this.setShouldScheduleDidInit(true) and implement didInit()\n *   This will cause the didInit method called after Object.init() inside Object.clone() to \n *   be scheduled for the end of the current event loop.\n * \n * - initAfterDeserialization of the ObjectPool that created the object is complete (similar to awakeFromNib:)\n *   Implement a didLoadFromStore(aStore) method. \n *   This will be called (on the deserialized objects) after the ObjectPool has finished deserializing.\n *   Deserialization currently takes place synchronously within a single event loop.\n * \n * - appDidInit (when the Application posts an appDidInit notification)\n *   Implement an appDidInit() method, and in init() call this.listenForAppDidInit().\n * \n * @module ideal.object\n * @class Object_init\n * @extends Object\n */\n\n(class Object_init extends Object {\n\n    /**\n     * Sets whether didInit should be scheduled.\n     * @param {boolean} aBool - Whether to schedule didInit.\n     * @returns {Object_init} This object.\n     */\n    setShouldScheduleDidInit (aBool) {\n        this._shouldScheduleDidInit = aBool\n        return this\n    }\n\n    /**\n     * Checks if didInit should be scheduled.\n     * @returns {boolean} Whether didInit should be scheduled.\n     */\n    shouldScheduleDidInit () {\n        return this._shouldScheduleDidInit\n    }\n\n    /**\n     * Initializes the object. Called by Object.clone().\n     * @returns {Object_init} This object.\n     */\n    init () { \n        return this\n    }\n\n    /**\n     * Performs final initialization. Called after deserialization or after init().\n     * @returns {Object_init} This object.\n     */\n    finalInit () {\n        return this\n    }\n\n    /**\n     * Performs actions after initialization.\n     */\n    afterInit () {\n        if (this.thisClass().isSingleton === undefined || !this.thisClass().isSingleton()) {\n            assert(!this.hasDoneInit()) // sanity check\n        }\n\n        if (this.shouldScheduleDidInit()) {\n            this.scheduleDidInit()\n        } else {\n            this.didInit()\n        }\n    }\n\n    /**\n     * Called when initialization is complete.\n     */\n    didInit () {\n        if (this.thisClass().isSingleton === undefined || !this.thisClass().isSingleton()) {\n            assert(!this.hasDoneInit()); \n        }\n        this.setHasDoneInit(true)\n    }\n\n    /**\n     * Checks if initialization has been completed.\n     * @returns {boolean} Whether initialization has been completed.\n     */\n    hasDoneInit () {\n        return this._hasDoneInit === true // hasDoneInit only set after serialization\n    }\n    \n    /**\n     * Sets whether initialization has been completed.\n     * @param {boolean} aBool - Whether initialization has been completed.\n     * @returns {Object_init} This object.\n     */\n    setHasDoneInit (aBool) {\n        this._hasDoneInit = aBool;\n        return this\n    }\n    \n    /**\n     * Schedules the didInit method to be called.\n     */\n    scheduleDidInit () {\n        assert(this.shouldScheduleDidInit())\n        assert(!this.hasDoneInit())\n        this.scheduleMethod(\"didInit\") \n    }\n\n}).initThisCategory();\n",
  "YC8ZaMH1Bp9c/iSZE66l9xKVDzAyzy8DluOjyfpOwOE=": "\"use strict\";\n\n/**\n * Object category to support notification and observation functionality.\n * \n * @module ideal.object\n * @class Object_notification\n * @extends Object\n */\n(class Object_notification extends Object {\n\n    /**\n     * Prepares the object for retirement by removing notification observers and scheduled actions.\n     */\n    prepareToRetire () { \n        // opportunity to remove notification observers, event listeners, etc\n        //this.assertNotRetired()\n        this.removeAllNotificationObservations()\n        this.removeScheduledActions()\n    }\n\n    // -------------------------------------------------\n \n    /**\n     * Removes all notification observations for this object.\n     */\n    removeAllNotificationObservations () {\n        if (getGlobalThis()[\"BMNotificationCenter\"]) {\n            BMNotificationCenter.shared().removeObserver(this)\n        }\n    }\n \n    /**\n     * Removes all scheduled actions for this object.\n     */\n    removeScheduledActions () {\n        if (getGlobalThis()[\"SyncScheduler\"]) {\n            SyncScheduler.shared().unscheduleTarget(this)\n        }\n    }\n\n    // --- notification helpers --- \n\n    /**\n     * Watches a specific sender for all notifications.\n     * @param {Object} sender - The sender to watch.\n     * @returns {Object} The observation object.\n     */\n    watchSender (sender) {\n        const obs = BMNotificationCenter.shared().newObservation()\n        obs.setObserver(this)\n        obs.setIsOneShot(false)\n        obs.setSender(sender)\n        obs.startWatching()\n        return obs\n    }\n\n    /**\n     * Watches for a specific notification from a specific sender.\n     * @param {string} aNoteName - The name of the notification to watch for.\n     * @param {Object} sender - The sender to watch.\n     * @returns {Object} The observation object.\n     */\n    watchForNoteFrom (aNoteName, sender) {\n        const obs = BMNotificationCenter.shared().newObservation()\n        obs.setObserver(this)\n        //obs.setIsOneShot(false)\n        obs.setSender(sender)\n        obs.setName(aNoteName)\n        obs.startWatching()\n        return obs\n    }\n\n    /**\n     * Watches for a specific notification from any sender.\n     * @param {string} aNoteName - The name of the notification to watch for.\n     * @returns {Object} The observation object.\n     */\n    watchForNote (aNoteName) {\n        const obs = BMNotificationCenter.shared().newObservation()\n        obs.setName(aNoteName)\n        obs.setObserver(this)\n        obs.startWatching()\n        return obs\n    }\n\n    // --- watch once ---\n\n    /**\n     * Watches for a specific notification once from any sender.\n     * @param {string} aNoteName - The name of the notification to watch for.\n     * @returns {Object} The observation object.\n     */\n    watchOnceForNote (aNoteName) {\n        return this.watchForNote(aNoteName).setIsOneShot(true)\n    }\n\n    /**\n     * Watches for a specific notification once from a specific sender.\n     * @param {string} aNoteName - The name of the notification to watch for.\n     * @param {Object} sender - The sender to watch.\n     * @returns {Object} The observation object.\n     */\n    watchOnceForNoteFrom (aNoteName, sender) {\n        return this.watchOnceForNote(aNoteName).setSender(sender) // does it work to set sender after it's started watching?\n    }\n\n    /**\n     * Creates a new notification with this object as the sender.\n     * @param {string} aNoteName - The name of the notification.\n     * @returns {Object} The new notification object.\n     */\n    newNoteNamed (aNoteName) {\n        const note = BMNotificationCenter.shared().newNote()\n        note.setSender(this)\n        note.setName(aNoteName)\n        return note\n    }\n\n    /**\n     * Posts a new notification with this object as the sender.\n     * @param {string} aNoteName - The name of the notification.\n     * @returns {Object} The posted notification object.\n     */\n    postNoteNamed (aNoteName) {\n        const note = this.newNoteNamed(aNoteName)\n        note.post()\n        //this.debugLog(\".postNoteNamed('\" + aNoteName + \"')\")\n        return note\n    }\n\n    /**\n     * Schedules a method to be called after a specified delay.\n     * @param {string} aMethodName - The name of the method to schedule.\n     * @param {number} milliseconds - The delay in milliseconds.\n     * @returns {*} The result of scheduling the method.\n     */\n    scheduleSelfFor (aMethodName, milliseconds) {\n        return SyncScheduler.shared().scheduleTargetAndMethod(this, aMethodName, milliseconds)\n    }\n\n    // --- who's watching who ---\n\n    /**\n     * Gets the objects that are watching this object for notifications.\n     * @returns {Array} An array of objects watching this object.\n     */\n    watchers () {\n        // objects we are watching for notifications from \n        return BMNotificationCenter.shared().observersOfSender(this);\n    }\n\n    /**\n     * Gets the observations registered by this object.\n     * @returns {Array} An array of observations registered by this object.\n     */\n    ourObservations () {\n        // observations we have registered\n        return BMNotificationCenter.shared().observationsWithObserver(this);\n    }\n\n    /**\n     * Gets the specific senders this object is watching.\n     * @returns {Array} An array of unique senders this object is watching.\n     */\n    specificSendersWatched () {\n        // senders we are watching\n        return this.ourObservations().map(obs => obs.sender()).unique();\n    }\n\n}).initThisCategory();\n",
  "JDC7EKfvnn8SnwYEI6DJhtt77pXEZD68QQUp3+QLRKc=": "\"use strict\";\n\n/**\n * Extends Object with UUID (Universally Unique Identifier) functionality.\n * @module ideal.object\n * @class Object_puuid\n * @extends Object\n */\n(class Object_puuid extends Object {\n\n    /**\n     * Generates a new UUID.\n     * @returns {string} A new UUID.\n     */\n    static newUuid () {\n        const length = 10\n        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        const charactersLength = characters.length;\n        const randomValues = new Uint8Array(length);\n        window.crypto.getRandomValues(randomValues);\n        const result = new Array(length);\n    \n        for (let i = 0; i < length; i++) {\n            result[i] = characters[randomValues[i] % charactersLength];\n        }\n    \n        return result.join('');\n    }\n\n    /**\n     * Gets the PUUID (Persistent Universally Unique Identifier) of the object.\n     * If the object doesn't have a PUUID, it generates a new one.\n     * @returns {string} The PUUID of the object.\n     */\n    puuid () {\n        if (!this.hasPuuid()) {\n            this.setPuuid(Object.newUuid())\n        }\n\n        return this[\"_puuid\"]\n    }\n\n    /**\n     * Checks if the object has a PUUID.\n     * @returns {boolean} True if the object has a PUUID, false otherwise.\n     */\n    hasPuuid () {\n        return Object.prototype.hasOwnProperty.call(this, \"_puuid\");\n    }\n\n    /**\n     * Sets the PUUID of the object.\n     * @param {string} puuid - The PUUID to set.\n     * @throws {Error} If the provided PUUID is null or undefined.\n     * @returns {Object_puuid} This object.\n     */\n    setPuuid (puuid) {\n        assert(!Type.isNullOrUndefined(puuid));\n        if (this.hasPuuid()) {\n            const oldPid = this[\"_puuid\"];\n            this.defaultStore().onObjectUpdatePid(this, oldPid, puuid);\n        }\n        Object.defineSlot(this, \"_puuid\", puuid); // so _puuid isn't enumerable\n        return this;\n    }\n\n    /**\n     * Gets the type-specific PUUID of the object.\n     * @returns {string} The type-specific PUUID.\n     */\n    typePuuid () {\n        const puuid = this.puuid()\n        if (Type.isFunction(this.type)) {\n            return this.type() + \"_\" + puuid\n        }\n        return Type.typeName(this) + \"_\" + puuid\n    }\n\n    /**\n     * Gets the type ID of the object.\n     * @returns {string} The type ID.\n     */\n    typeId () {\n        return this.typePuuid()\n    }\n\n    /**\n     * Gets a debug-friendly type ID of the object.\n     * @returns {string} A debug-friendly type ID.\n     */\n    debugTypeId () {\n        const puuid = this.puuid().substr(0,3)\n\n        if (Type.isFunction(this.type)) {\n            return this.type() + \"_\" + puuid\n        }\n        return Type.typeName(this) + \"_\" + puuid\n    }\n\n    /**\n     * Gets the spacer used in debug type IDs.\n     * @returns {string} The debug type ID spacer.\n     */\n    debugTypeIdSpacer () {\n        return \" -> \"\n    }\n\n}).initThisCategory();\n",
  "1KsMRs3V0wjV7FacxbDOocpoVhpeRxdnbux3lYhKox8=": "\"use strict\";\n\n/**\n * Object category to support observing slot value changes (i.e. \"mutations\").\n * \n * @module ideal.object\n * @class Object_mutation\n * @extends Object\n */\n(class Object_mutation extends Object {\n\n    /**\n     * Returns a Set of mutator method names that should be hooked.\n     * @throws {Error} If not implemented by the subclass.\n     * @returns {Set<string>} A Set of mutator method names.\n     */\n    mutatorMethodNamesSet () {\n        throw new Error(\"undefined mutatorMethodNamesSet on '\" + this.type() + \"' class\")\n    }\n\n    /**\n     * Sets up mutator hooks for the prototype.\n     * This method copies each slot whose name is in mutatorMethodNamesSet\n     * to unhooked_<slotName>, and implements a slot which calls the\n     * unhooked version after calling this.willMutate(slotName).\n     */\n    setupMutatorHooks () {\n        // this is to be called on a prototype\n        // it copies each slot whose name is in mutatorMethodNamesSet\n        // to unhooked_<slotName>, and implements a slot which calls the\n        // unhooked version after calling this.willMutate(slotName)\n        \n        this.mutatorMethodNamesSet().forEach((slotName) => {\n            const unhookedName = \"unhooked_\" + slotName\n            const unhookedFunction = this[slotName]\n    \n            Object.defineSlot(this, unhookedName, unhookedFunction)\n    \n            const hookedFunction = function () {\n                this.willMutate(slotName, arguments)\n                const result = this[unhookedName].apply(this, arguments)\n                this.didMutate(slotName)\n    \n                //let argsString = []\n                //for (let i=0; i < arguments.length; i++) {\n                //    if (i !== 0) { argsString += \", \" }\n                //    argsString += String(arguments[i])\n                //}\n                //console.log(\"hooked Array \" + slotName + \"(\" + argsString + \")\") \n                //console.log(\"result = \" + result)\n    \n                return result\n            }\n    \n            Object.defineSlot(this, slotName, hookedFunction)\n        })\n    }\n\n    // -----------------------------------------\n\n    /**\n     * Sets the mutation observers for this object.\n     * @param {Set} aSet - A Set of mutation observers.\n     * @returns {Object_mutation} This object.\n     */\n    setMutationObservers (aSet) {\n        this._mutationObservers = aSet\n        return this\n    }\n\n    /**\n     * Gets the mutation observers for this object.\n     * @returns {Set} A Set of mutation observers.\n     */\n    mutationObservers () {\n        if (!this._mutationObservers) {\n            this.setMutationObservers(new Set())\n        }\n        return this._mutationObservers\n    }\n\n    /**\n     * Checks if this object has any mutation observers.\n     * @returns {boolean} True if there are mutation observers, false otherwise.\n     */\n    hasMutationObservers () {\n        const mos = this._mutationObservers\n        return mos && mos.size > 0\n    }\n\n    /**\n     * Adds a mutation observer to this object.\n     * @param {Object} anObserver - The observer to add.\n     * @returns {Object_mutation} This object.\n     */\n    addMutationObserver (anObserver) {\n        this.mutationObservers().add(anObserver)\n        return this\n    }\n\n    /**\n     * Removes a mutation observer from this object.\n     * @param {Object} anObserver - The observer to remove.\n     * @returns {Object_mutation} This object.\n     */\n    removeMutationObserver (anObserver) {\n        assert(anObserver)\n        this.mutationObservers().delete(anObserver)\n        return this\n    }\n\n    // ------\n\n    /**\n     * Called before a mutation occurs.\n     * This method is currently empty but can be overridden or extended.\n     */\n    willMutate () {\n        /*\n        const mos = this._mutationObservers\n        if (mos) {\n            mos.forEach(v => { \n                v.onWillMutateObject(this)\n            })\n        }\n        */\n    }\n\n    /**\n     * Called after a mutation occurs.\n     * Notifies all mutation observers.\n     * @param {string} [optionalSlotName] - The name of the slot that was mutated, if applicable.\n     */\n    didMutate (optionalSlotName) {\n        const mos = this._mutationObservers\n        if (mos) {\n            //console.log(\"\" + this.debugTypeId() + \".didMutate()\")\n            mos.forEach(obs => {\n                obs.onDidMutateObject(this, optionalSlotName)\n            })\n        }\n    }\n\n}).initThisCategory();\n",
  "JCciBEhuVcHPoSCnVAcIEmotkMJcwp0M5v7sc3ppxek=": "\"use strict\";\n\n/**\n * Extends Object with timeout functionality.\n * Sometimes we can't use the SyncScheduler as we have to make sure \n * something happens *after* the current event loop ends (and control is returned to the browser),\n * but scheduler runs while still in (but at the end of) the current event.\n * Also, we sometimes need timeout delays.\n *\n * @module ideal.object\n * @class Object_timeouts\n * @extends Object\n */\n(class Object_timeouts extends Object {\n\n    /**\n     * Gets or creates a Map to store timeout names and their corresponding IDs.\n     * @returns {Map} A Map of timeout names to timeout IDs.\n     */\n    timeoutNameToIdMap () { // the name will be the timeoutId if no name is provided\n        const slotName = \"_timeoutNameToIdMap\"\n        if (Type.isNullOrUndefined(this[slotName])) {\n            Object.defineSlot(this, slotName, new Map())\n        }\n        return this[slotName]\n    }\n    \n    /**\n     * Adds a timeout function to be executed after a specified delay.\n     * @param {Function} aFunc - The function to be executed.\n     * @param {number} msDelay - The delay in milliseconds before the function is executed.\n     * @param {string} [optionalName] - An optional name for the timeout.\n     * @returns {number} The timeout ID.\n     */\n    addTimeout (aFunc, msDelay, optionalName) { \n        // if no optionalName given, use the timeoutId for the name,\n        // as timeout ids should be unique\n        const tids = this.timeoutNameToIdMap()\n\n        if (optionalName && tids.has(optionalName)) {\n            // clear existing timeout with this name, if there is one\n            this.clearTimeoutNamed(optionalName)\n        }\n\n        const tidInfo = new Array(2) // will store [timeoutName, timeoutId] so we can capture returned tid in timeout closure\n        const tid = setTimeout(() => { \n            this.removeTimeoutNamed(tidInfo[0])\n            EventManager.shared().safeWrapEvent(aFunc, \"TimeoutEvent\")\n        }, msDelay)\n        tidInfo[0] = optionalName ? optionalName : tid\n        tidInfo[1] = tid\n        this.timeoutNameToIdMap().set(optionalName, tid)\n        return tid\n    }\n\n    /**\n     * Removes a named timeout from the timeout map.\n     * @param {string} name - The name of the timeout to remove.\n     * @returns {Object_timeouts} This object.\n     */\n    removeTimeoutNamed (name) {\n        const tids = this.timeoutNameToIdMap()\n        tids.delete(name)\n        return this\n    }\n\n    /**\n     * Clears a timeout by its ID.\n     * @param {number} tid - The timeout ID to clear.\n     * @returns {Object_timeouts} This object.\n     */\n    clearTimeout (tid) { \n        // IMPORTANT: (for now) we assume a given timeouts is either referred to by name or tid, but not both\n        // in which case, if the tid is called here, it was used at the key in the timeoutNameToIdMap\n        this.removeTimeoutNamed(tid)\n        clearTimeout(tid)\n        return this\n    }\n\n    /**\n     * Clears a named timeout.\n     * @param {string} name - The name of the timeout to clear.\n     * @returns {Object_timeouts} This object.\n     */\n    clearTimeoutNamed (name) {\n        const tids = this.timeoutNameToIdMap()\n        if (tids.has(name)) {\n            const tid = tids.get(name)\n            this.clearTimeout(tid)\n        }\n        return this\n    }\n\n    /**\n     * Checks if a named timeout exists.\n     * @param {string} name - The name of the timeout to check.\n     * @returns {boolean} True if the named timeout exists, false otherwise.\n     */\n    hasTimeoutNamed (name) {\n        const tids = this.timeoutNameToIdMap()\n        return tids.has(name)\n    }\n    \n    /**\n     * Cancels all timeouts associated with this object.\n     * @returns {Object_timeouts} This object.\n     */\n    cancelAllTimeouts () {\n        const tids = this.timeoutNameToIdMap()\n        tids.forEachKV((name, tid) => this.clearTimeout(tid))\n        return this\n    }\n\n    /*\n    timeoutForName (name) {\n        const tids = this.timeoutNameToIdMap()\n        return tids.get(name)\n    }\n    */\n\n}).initThisCategory();\n",
  "I+IW7cMu7dO/fmVOzcXs2NjFurlqAR/G3u5254Hzs3w=": "\"use strict\";\n\n/**\n * @module ideal\n * @class ArrayBuffer_ideal\n * @extends ArrayBuffer\n * Extends the JavaScript ArrayBuffer primitive with additional methods.\n */\n(class ArrayBuffer_ideal extends ArrayBuffer {\n\n    /**\n     * Converts the ArrayBuffer to a string using UTF-8 encoding.\n     * @returns {string} The decoded string representation of the ArrayBuffer.\n     * @throws {Error} If the bytes in the ArrayBuffer are not valid UTF-8.\n     */\n    asString () {\n        // have to be careful with this.  If the bytes are not valid utf-8, this will throw an error.\n        return new TextDecoder().decode(this);\n    }\n\n}).initThisCategory();\n\n",
  "6Yt+57hKFkcQdBIWxInfL4b1xAZao9WjupEnVjQc3F8=": "\"use strict\";\n\n/**\n * @module ideal\n * @class\n * @extends Array\n * Extends the native Array with additional utility methods.\n */\n(class Array_ideal extends Array {\n    /**\n     * Creates a new instance of Array_ideal and copies the elements from the provided array.\n     * @param {Array} anArray - The array to copy elements from.\n     * @returns {Array_ideal} A new instance of Array_ideal with the copied elements.\n     */\n    static withArray(anArray) {\n        return this.clone().copyFrom(anArray);\n    }\n\n    /**\n     * Creates a new array from an iterator.\n     * @param {Iterator} iterator - The iterator to create the array from.\n     * @returns {Array} A new array containing the values from the iterator.\n     */\n    static fromIterator(iterator) {\n        const results = [];\n        let entry = iterator.next();\n        while (!entry.done) {\n            results.push(entry.value);\n            entry = iterator.next();\n        }\n        return results;\n    }\n\n    /**\n     * Creates a shallow copy of the array.\n     * @returns {Array_ideal} A shallow copy of the array.\n     */\n    duplicate() {\n        return this.shallowCopy();\n    }\n\n    /**\n     * Creates a shallow copy of the array.\n     * @returns {Array_ideal} A shallow copy of the array.\n     */\n    shallowCopy() {\n        return this.slice();\n    }\n\n    /**\n     * Creates a deep copy of the array.\n     * @param {Map} [refMap=new Map()] - A map used to handle circular references.\n     * @returns {Array_ideal} A deep copy of the array.\n     */\n    deepCopy(refMap = new Map()) {\n        const newArray = new this.constructor();\n\n        this.forEachV(v => {\n            newArray.push(Type.deepCopyForValue(v, refMap));\n        });\n\n        assert(this.length === newArray.length, \"deepCopy failed: new array length is different.\");\n        return newArray;\n    }\n\n    /**\n     * Removes all elements from the array.\n     * @returns {Array_ideal} The cleared array.\n     */\n    clear() {\n        while (this.length) {\n            this.pop();\n        }\n        return this;\n    }\n\n    /**\n     * Copies the elements from the provided array into the current array.\n     * @param {Array} anArray - The array to copy elements from.\n     * @returns {Array_ideal} The current array with the copied elements.\n     */\n    copyFrom(anArray) {\n        this.clear();\n        anArray.forEach(v => this.push(v));\n        return this;\n    }\n\n    /**\n     * Iterates over the elements of the array in a safe manner.\n     * @param {Function} func - The function to call for each element.\n     */\n    safeForEach(func) {\n        this.shallowCopy().forEach(v => func(v));\n    }\n\n    /**\n     * Iterates over the elements of the array.\n     * @param {Function} func - The function to call for each element.\n     */\n    forEachV(func) {\n        this.forEach(v => func(v));\n    }\n\n    /**\n     * Iterates over the elements of the array with their indices.\n     * @param {Function} func - The function to call for each element.\n     */\n    forEachKV(func) {\n        let i = 0;\n        this.forEach((v) => {\n            func(i, v);\n            i++;\n        });\n    }\n\n    /**\n     * Iterates over the elements of the array in reverse order with their indices.\n     * @param {Function} func - The function to call for each element.\n     */\n    reverseForEachKV(func) {\n        let i = 0;\n        this.forEach((v) => {\n            func(i, v);\n            i++;\n        });\n    }\n\n    /**\n     * Checks if the array is empty.\n     * @returns {boolean} True if the array is empty, false otherwise.\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n\n    /**\n     * Checks if the array is equal to another array.\n     * @param {Array} otherArray - The array to compare with.\n     * @returns {boolean} True if the arrays are equal, false otherwise.\n     */\n    isEqual(otherArray) {\n        if (this.length !== otherArray.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.length; i++) {\n            if (this[i] !== otherArray[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the number of elements in the array.\n     * @returns {number} The number of elements in the array.\n     */\n    size() {\n        return this.length;\n    }\n\n    /**\n     * Returns the element at the specified index, wrapping around if the index is negative.\n     * @param {number} index - The index of the element to retrieve.\n     * @returns {*} The element at the specified index.\n     */\n    atWrap(index) {\n        if (index < 0) {\n            return this[this.length + index];\n        }\n\n        return this[index];\n    }\n\n    /**\n     * Removes the element at the specified index.\n     * @param {number} index - The index of the element to remove.\n     * @returns {Array_ideal} The current array after removing the element.\n     */\n    removeAt(index) {\n        const v = this[index];\n        this.willMutate(\"removeAt\", v);\n        delete this[index];\n        this.didMutate(\"removeAt\", v);\n        return this;\n    }\n\n    /**\n     * Sets the element at the specified index.\n     * @param {number} index - The index to set the element at.\n     * @param {*} v - The value to set.\n     * @returns {Array_ideal} The current array after setting the element.\n     */\n    atPut(index, v) {\n        this.willMutate(\"atPut\", v);\n        if (v === null && !this._allowsNulls) {\n            throw new Error(\"attempt to add null to Array that does not allow them\");\n        }\n        this[index] = v;\n        this.didMutate(\"atPut\", v);\n        return this;\n    }\n\n    /**\n     * Returns the first element of the array.\n     * @returns {*} The first element of the array.\n     */\n    first() {\n        return this.at(0);\n    }\n\n    /**\n     * Returns the second element of the array.\n     * @returns {*} The second element of the array.\n     */\n    second() {\n        return this.at(1);\n    }\n\n    /**\n     * Returns a new array containing all elements except the first one.\n     * @returns {Array_ideal} A new array containing all elements except the first one.\n     */\n    rest() {\n        return this.slice(1);\n    }\n\n    /**\n     * Returns the last element of the array.\n     * @returns {*} The last element of the array.\n     */\n    last() {\n        return this.at(this.length - 1);\n    }\n\n    /**\n     * Returns the last N elements of the array.\n     * @param {number} n - The number of elements to return.\n     * @returns {Array_ideal} A new array containing the last N elements.\n     */\n    lastN(n) {\n        if (n === 0 || this.length === 0) {\n            return [];\n        }\n\n        if (this.length < n) {\n            return this.slice();\n        }\n\n        return this.slice(-n);\n    }\n\n    /**\n     * Returns the second to last element of the array.\n     * @returns {*} The second to last element of the array.\n     */\n    secondToLast() {\n        return this.at(this.length - 2);\n    }\n\n    /**\n     * Checks if the array contains the specified element.\n     * @param {*} element - The element to check for.\n     * @returns {boolean} True if the element is found, false otherwise.\n     */\n    contains(element) {\n        return this.includes(element);\n    }\n\n    /**\n     * Checks if the array contains any of the elements in the provided array.\n     * @param {Array} anArray - The array of elements to check for.\n     * @returns {boolean} True if any of the elements are found, false otherwise.\n     */\n    containsAny(anArray) {\n        return anArray.canDetect(item => this.contains(item));\n    }\n\n    /**\n     * Removes duplicate elements from the array.\n     * @returns {Array_ideal} The current array after removing duplicates.\n     */\n    removeDuplicates() {\n        const u = this.unique();\n        if (this.length !== u.length) {\n            this.copyFrom(u);\n        }\n        return this;\n    }\n\n    /**\n     * Checks if the array has duplicate elements.\n     * @returns {boolean} True if duplicates are found, false otherwise.\n     */\n    hasDuplicates() {\n        if (this.length > 100) {\n            return this.hasDuplicates_setImplementation();\n        } else {\n            return this.hasDuplicates_indexOfImplementation();\n        }\n    }\n\n    /**\n     * Checks if the array has duplicate elements using a Set implementation.\n     * @returns {boolean} True if duplicates are found, false otherwise.\n     */\n    hasDuplicates_setImplementation() {\n        const set = new Set();\n        for (let i = 0; i < this.length - 1; i++) {\n            const v = this[i];\n            if (set.has(v)) {\n                console.warn(\"found duplicate of \", v);\n                return true;\n            } else {\n                set.add(v);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the array has duplicate elements using indexOf implementation.\n     * @returns {boolean} True if duplicates are found, false otherwise.\n     */\n    hasDuplicates_indexOfImplementation() {\n        for (let i = 0; i < this.length - 1; i++) {\n            const v = this[i];\n            if (this.indexOf(v, i + 1) !== -1) {\n                console.warn(\"found duplicate of \", v);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Checks if the array has the specified prefix.\n     * @param {Array} otherArray - The array to check for as a prefix.\n     * @returns {boolean} True if the array has the specified prefix, false otherwise.\n     */\n    hasPrefix(otherArray) {\n        if (this.length < otherArray.length) {\n            return false;\n        }\n\n        for (let i = 0; i < this.length; i++) {\n            if (this.at(i) !== otherArray.at(i)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the element after the specified element in the array.\n     * @param {*} v - The element to find the next element after.\n     * @returns {*} The element after the specified element, or null if not found.\n     */\n    itemAfter(v) {\n        let i = this.indexOf(v);\n\n        if (i === -1) {\n            return null;\n        }\n\n        i = i + 1;\n\n        if (i > this.length - 1) {\n            return null;\n        }\n\n        if (this.at(i) !== undefined) {\n            return this.at(i);\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the element before the specified element in the array.\n     * @param {*} v - The element to find the previous element before.\n     * @returns {*} The element before the specified element, or null if not found.\n     */\n    itemBefore(v) {\n        let i = this.indexOf(v);\n\n        if (i === -1) {\n            return null;\n        }\n\n        i = i - 1;\n\n        if (i < 0) {\n            return null;\n        }\n\n        if (this.at(i)) {\n            return this.at(i);\n        }\n\n        return null;\n    }\n\n    /**\n     * Creates a deep copy of the array, calling the copy method on each element if it exists.\n     * @param {Object} copyDict - An optional dictionary to pass to the copy method.\n     * @returns {Array_ideal} A deep copy of the array.\n     */\n    copy(copyDict) {\n        return this.slice().map((v) => {\n            if (v.copy) {\n                return v.copy(copyDict);\n            } else {\n                return v;\n            }\n        });\n    }\n\n    /**\n     * Splits the array into multiple sub-arrays.\n     * @param {number} subArrayCount - The number of sub-arrays to create.\n     * @returns {Array<Array_ideal>} An array of sub-arrays.\n     */\n    split(subArrayCount) {\n        const subArrays = [];\n        const subArraySize = Math.ceil(this.length / subArrayCount);\n\n        for (let i = 0; i < this.length; i += subArraySize) {\n            let subArray = this.slice(i, i + subArraySize);\n            if (subArray.length < subArraySize) {\n                let lastSubArray = subArrays.pop();\n                if (lastSubArray) {\n                    subArray = lastSubArray.concat(subArray);\n                }\n            }\n            subArrays.push(subArray);\n        }\n\n        return subArrays;\n    }\n\n    /**\n     * Inserts an element at the specified index.\n     * @param {number} i - The index to insert the element at.\n     * @param {*} e - The element to insert.\n     * @returns {Array_ideal} The current array after inserting the element.\n     */\n    atInsert(i, e) {\n        this.splice(i, 0, e);\n        return this;\n    }\n\n    /**\n     * Inserts multiple elements at the specified index.\n     * @param {number} i - The index to insert the elements at.\n     * @param {Array} items - The elements to insert.\n     * @returns {Array_ideal} The current array after inserting the elements.\n     */\n    atInsertItems(i, items) {\n        let n = i;\n        items.forEach(item => {\n            this.atInsert(n, item);\n            n++;\n        });\n        return this;\n    }\n\n    /**\n     * Appends one or more elements to the end of the array.\n     * @param {...*} elements - The elements to append.\n     * @returns {Array_ideal} The current array after appending the elements.\n     */\n    append() {\n        this.appendItems.call(this, arguments);\n        return this;\n    }\n\n    /**\n     * Appends multiple elements to the end of the array.\n     * @param {Array} elements - The elements to append.\n     * @returns {Array_ideal} The current array after appending the elements.\n     */\n    appendItems(elements) {\n        this.push.apply(this, elements);\n        return this;\n    }\n\n    /**\n     * Appends multiple elements to the end of the array if they are not already present.\n     * @param {Array} elements - The elements to append.\n     * @returns {Array_ideal} The current array after appending the elements.\n     */\n    appendItemsIfAbsent(elements) {\n        this.appendIfAbsent.apply(this, elements);\n        return this;\n    }\n\n    /**\n     * Moves multiple items to a specified index in the array.\n     * @param {Array} movedItems - The items to move.\n     * @param {number} anIndex - The index to move the items to.\n     * @returns {Array_ideal} The current array after moving the items.\n     */\n    moveItemsToIndex(movedItems, anIndex) {\n        const newArray = this.shallowCopy();\n        let insertIndex = anIndex;\n\n        movedItems.forEach(item => assert(this.contains(item)));\n\n        movedItems.forEach(item => {\n            const i = this.indexOf(item);\n            if (i == -1) {\n                throw new Error(\"this isn't handled yet\");\n            }\n\n            if (i < insertIndex) {\n                insertIndex--;\n            }\n            newArray.remove(item);\n        });\n\n        movedItems.reversed().forEach(item => {\n            newArray.atInsert(insertIndex, item);\n        });\n\n        this.copyFrom(newArray);\n        return this;\n    }\n\n    /**\n     * Prepends an element to the beginning of the array.\n     * @param {*} e - The element to prepend.\n     * @returns {Array_ideal} The current array after prepending the element.\n     */\n    prepend(e) {\n        this.unshift(e);\n        return this;\n    }\n\n    /**\n     * Appends one or more elements to the end of the array if they are not already present.\n     * @param {...*} elements - The elements to append.\n     * @returns {boolean} True if any elements were appended, false otherwise.\n     */\n    appendIfAbsent() {\n        const elements = Array.from(arguments);\n        let appended = false;\n\n        elements.forEach((value) => {\n            if (!this.contains(value)) {\n                this.push(value);\n                appended = true;\n            }\n        });\n\n        return appended;\n    }\n\n    /**\n     * Removes all elements from the array.\n     * @returns {Array_ideal} The current array after removing all elements.\n     */\n    removeAll() {\n        while (this.length) {\n            this.pop();\n        }\n        return this;\n    }\n\n    /**\n     * Removes the element at the specified index.\n     * @param {number} i - The index of the element to remove.\n     * @returns {Array_ideal} The current array after removing the element.\n     */\n    removeAt(i) {\n        this.willMutate(\"removeAt\");\n        this.splice(i, 1);\n        this.didMutate(\"removeAt\");\n        return this;\n    }\n\n    /**\n     * Removes the specified element from the array.\n     * @param {*} e - The element to remove.\n     * @returns {Array_ideal} The current array after removing the element.\n     */\n    remove(e) {\n        const i = this.indexOf(e);\n        if (i !== -1) {\n            this.removeAt(i);\n        }\n        return this;\n    }\n\n    /**\n     * Returns a new array with all empty values removed.\n     * @returns {Array_ideal} A new array with all empty values removed.\n     */\n    emptiesRemoved() {\n        return this.filter(v => !Type.isNullOrUndefined(v));\n    }\n\n    /**\n     * Removes and returns the first element of the array.\n     * @returns {*} The first element of the array.\n     */\n    removeFirst() {\n        return this.shift();\n    }\n\n    /**\n     * Removes and returns the last element of the array.\n     * @returns {*} The last element of the array.\n     */\n    removeLast() {\n        return this.pop();\n    }\n\n    /**\n     * Removes multiple elements from the array.\n     * @param {Array} elements - The elements to remove.\n     * @returns {Array_ideal} The current array after removing the elements.\n     */\n    removeItems(elements) {\n        elements.forEach(e => this.remove(e));\n        return this;\n    }\n\n    /**\n     * Removes all elements from the array.\n     * @returns {Array_ideal} The current array after removing all elements.\n     */\n    empty() {\n        this.splice(0, this.length);\n        return this;\n    }\n\n    /**\n     * Shuffles the elements of the array in-place.\n     * @returns {Array_ideal} The shuffled array.\n     */\n    shuffle() {\n        let i = this.length;\n\n        if (i === 0) {\n            return false;\n        }\n\n        while (--i) {\n            const j = Math.floor(Math.random() * (i + 1));\n            const tempi = this.at(i);\n            const tempj = this.at(j);\n            this.atPut(i, tempj);\n            this.atPut(j, tempi);\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns a random element from the array.\n     * @returns {*} A random element from the array.\n     */\n    atRandom() {\n        const i = Math.floor(Math.random() * this.length);\n        return this.at(i);\n    }\n\n    /**\n     * Returns a random element from the array using a cryptographically secure random number generator.\n     * @returns {*} A random element from the array.\n     */\n    pickOneAtRandom() {\n        if (this.length === 0) {\n            return undefined;\n        }\n\n        const randomBuffer = new Uint32Array(2);\n        crypto.getRandomValues(randomBuffer);\n\n        const SHIFT_AMOUNT = 21;\n        const MAX_SAFE_VALUE = 9007199254740991;\n\n        const randomValue = (randomBuffer[0] * (1 << SHIFT_AMOUNT)) + (randomBuffer[1] >>> (32 - SHIFT_AMOUNT));\n        const randomIndex = Math.floor((randomValue / MAX_SAFE_VALUE) * this.length);\n\n        return this[randomIndex];\n    }\n\n    /**\n     * Removes and returns a random element from the array.\n     * @returns {*} The removed random element.\n     */\n    removeOneAtRandom() {\n        const pick = this.pickOneAtRandom();\n        this.remove(pick);\n        return pick;\n    }\n\n    /**\n     * Iterates over the elements of the array and calls the specified method on each element if it exists.\n     * @param {string} methodName - The name of the method to call.\n     * @param {*} arg1 - The first argument to pass to the method.\n     * @param {*} arg2 - The second argument to pass to the method.\n     * @param {*} arg3 - The third argument to pass to the method.\n     * @returns {Array_ideal} The current array.\n     */\n    forEachPerformIfResponds(methodName, arg1, arg2, arg3) {\n        this.forEach((item) => {\n            if (item) {\n                const f = item[methodName];\n                if (f) {\n                    f.call(item, arg1, arg2, arg3);\n                }\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Iterates over the elements of the array and calls the specified method on each element.\n     * @param {string} methodName - The name of the method to call.\n     * @param {*} arg1 - The first argument to pass to the method.\n     * @param {*} arg2 - The second argument to pass to the method.\n     * @param {*} arg3 - The third argument to pass to the method.\n     * @returns {Array_ideal} The current array.\n     */\n    forEachPerform(methodName, arg1, arg2, arg3) {\n        this.forEach((item) => {\n            if (item) {\n                const f = item[methodName];\n                if (f) {\n                    f.call(item, arg1, arg2, arg3);\n                } else {\n                    throw new Error(Type.typeName(item) + \" does not respond to '\" + methodName + \"'\");\n                }\n            }\n        });\n        return this;\n    }\n\n    /**\n     * Sorts the elements of the array in-place based on the specified method.\n     * @param {string} functionName - The name of the method to call on each element.\n     * @returns {Array_ideal} The sorted array.\n     */\n    sortPerform(functionName) {\n        const args = this.slice.call(arguments).slice(1);\n        return this.sort(function (x, y) {\n            const xRes = x[functionName].apply(x, args);\n            const yRes = y[functionName].apply(y, args);\n            if (xRes < yRes) {\n                return -1;\n            } else if (yRes < xRes) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n\n    /**\n     * Returns a new array containing the values of the specified property for each element.\n     * @param {string} propertyName - The name of the property to map.\n     * @returns {Array} A new array containing the mapped values.\n     */\n    mapProperty(propertyName) {\n        return this.map(e => e[propertyName]);\n    }\n\n    /**\n     * Creates a Map where the keys are unique values of the specified property and the values are the corresponding elements.\n     * @param {string} propertyName - The name of the property to use as keys.\n     * @param {boolean} [ignoreCollisions=false] - Whether to ignore collisions (duplicate keys) or throw an error.\n     * @returns {Map} A Map containing the unique index.\n     */\n    uniqueIndexMapForProperty(propertyName, ignoreCollisions = false) {\n        const m = new Map();\n        this.forEach(entry => {\n            const k = entry[propertyName];\n            if (!m.has(k)) {\n                m.set(k, entry);\n            } else {\n                if (!ignoreCollisions) {\n                    const msg = \"Array found two of the same value ('\" + k + \"') while building a uniqueIndexMap for property '\" + propertyName + \"'\";\n                    console.warn(msg);\n                    throw new Error(msg);\n                }\n            }\n        });\n        return m;\n    }\n\n    /**\n     * Creates a Map where the keys are values of the specified property and the values are arrays of corresponding elements.\n     * @param {string} propertyName - The name of the property to use as keys.\n     * @returns {Map} A Map containing the index.\n     */\n    indexMapForProperty(propertyName) {\n        const m = new Map();\n        this.forEach(entry => {\n            const k = entry[propertyName];\n            if (m.has(k)) {\n                const array = m.get(k);\n                array.push(entry);\n            } else {\n                m.set(k, [entry]);\n            }\n        });\n        return m;\n    }\n\n    /**\n     * Creates a Map where the keys are the results of calling the specified method on each element and the values are arrays of corresponding elements.\n     * @param {string} methodName - The name of the method to call on each element.\n     * @returns {Map} A Map containing the index.\n     */\n    indexMapForMethodName(methodName) {\n        const m = new Map();\n        this.forEach(entry => {\n            const k = entry[methodName].apply(entry);\n            if (m.has(k)) {\n                const array = m.get(k);\n                array.push(entry);\n            } else {\n                m.set(k, [entry]);\n            }\n        });\n        return m;\n    }\n\n    /**\n     * Checks if the array contains an element that satisfies the specified condition.\n     * @param {Function} func - The condition function to check for.\n     * @returns {boolean} True if an element satisfies the condition, false otherwise.\n     */\n    canDetect(func) {\n        const result = this.detect(func);\n        return result !== undefined && result !== null;\n    }\n\n    /**\n     * Returns the first element that satisfies the specified condition.\n     * @param {Function} func - The condition function to check for.\n     * @returns {*} The first element that satisfies the condition, or null if not found.\n     */\n    detect(func) {\n        for (let i = 0; i < this.length; i++) {\n            const v = this.at(i);\n            if (func(v, i)) {\n                return v;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the first element that satisfies the specified condition, starting from the end of the array.\n     * @param {Function} func - The condition function to check for.\n     * @returns {*} The first element that satisfies the condition, or null if not found.\n     */\n    reverseDetect(func) {\n        for (let i = this.length - 1; i > -1; i--) {\n            const v = this.at(i);\n            if (func(v, i)) {\n                return v;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the first non-false return value of the specified function.\n     * @param {Function} func - The function to call for each element.\n     * @returns {*} The first non-false return value, or null if not found.\n     */\n    detectAndReturnValue(func) {\n        for (let i = 0; i < this.length; i++) {\n            const v = this.at(i);\n            const result = func(v, i);\n            if (result) {\n                return result;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the first element that satisfies the specified method call.\n     * @param {string} functionName - The name of the method to call.\n     * @param {...*} args - The arguments to pass to the method.\n     * @returns {*} The first element that satisfies the method call, or null if not found.\n     */\n    detectPerform(functionName) {\n        const args = this.slice.call(arguments).slice(1);\n        return this.detect((value, index) => {\n            return value[functionName].apply(value, args);\n        });\n    }\n\n    /**\n     * Returns the first element that has the specified property value.\n     * @param {string} slotName - The name of the property to check.\n     * @param {*} slotValue - The value of the property to check for.\n     * @returns {*} The first element that has the specified property value, or null if not found.\n     */\n    detectProperty(slotName, slotValue) {\n        for (let i = 0; i < this.length; i++) {\n            const v = this.at(i);\n            if (v[slotName] === slotValue) {\n                return v;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the index of the first element that satisfies the specified condition.\n     * @param {Function} func - The condition function to check for.\n     * @returns {number} The index of the first element that satisfies the condition, or null if not found.\n     */\n    detectIndex(func) {\n        for (let i = 0; i < this.length; i++) {\n            if (func(this.at(i), i)) {\n                return i;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a new array with all null values removed.\n     * @returns {Array_ideal} A new array with all null values removed.\n     */\n    nullsRemoved() {\n        return this.filter(v => !Type.isNull(v));\n    }\n\n    /**\n     * Returns a new array containing only the elements that do not satisfy the specified condition.\n     * @param {Function} func - The condition function to check for.\n     * @returns {Array_ideal} A new array containing only the elements that do not satisfy the condition.\n     */\n    reject(func) {\n        return this.filter(v => !func(v));\n    }\n\n    /**\n     * Returns an array containing the index and value of the maximum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @returns {Array} An array containing the index and value of the maximum element.\n     */\n    maxEntry(optionalFunc) {\n        const length = this.length;\n        const mEntry = [undefined, undefined];\n\n        for (let i = 0; i < length; i++) {\n            let v = this.at(i);\n            if (optionalFunc) {\n                v = optionalFunc(v);\n            }\n\n            if (mEntry[1] === undefined || v > mEntry[1]) {\n                mEntry[0] = i;\n                mEntry[1] = v;\n            }\n        }\n\n        return mEntry;\n    }\n\n    /**\n     * Returns the index of the maximum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @returns {number} The index of the maximum element.\n     */\n    maxIndex(optionalFunc) {\n        return this.maxEntry(optionalFunc)[0];\n    }\n\n    /**\n     * Returns the value of the maximum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @param {*} [theDefault] - An optional default value to return if the array is empty.\n     * @returns {*} The value of the maximum element.\n     */\n    maxValue(optionalFunc, theDefault) {\n        return this.maxEntry(optionalFunc)[1];\n    }\n\n    /**\n     * Returns the maximum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @returns {*} The maximum element.\n     */\n    maxItem(optionalFunc) {\n        return this.at(this.maxIndex(optionalFunc));\n    }\n\n    /**\n     * Returns an array containing the index and value of the minimum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @returns {Array} An array containing the index and value of the minimum element.\n     */\n    minEntry(optionalFunc) {\n        const length = this.length;\n        const mEntry = [undefined, undefined];\n\n        for (let i = 0; i < length; i++) {\n            let v = this[i];\n            if (optionalFunc) {\n                v = optionalFunc(v);\n            }\n\n            if (mEntry[1] === undefined || v < mEntry[1]) {\n                mEntry[0] = i;\n                mEntry[1] = v;\n            }\n        }\n\n        return mEntry;\n    }\n\n    /**\n     * Returns the index of the minimum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @returns {number} The index of the minimum element.\n     */\n    minIndex(optionalFunc) {\n        return this.maxEntry(optionalFunc)[0];\n    }\n\n    /**\n     * Returns the value of the minimum element in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before comparing.\n     * @returns {*} The value of the minimum element.\n     */\n    minValue(optionalFunc) {\n        return this.minEntry(optionalFunc)[1];\n    }\n\n    /**\n     * Returns the sum of all elements in the array.\n     * @param {Function} [optionalFunc] - An optional function to apply to each element before summing.\n     * @returns {number} The sum of all elements.\n     */\n    sum(optionalFunc) {\n        let sum = 0;\n        const length = this.length;\n\n        for (let i = 0; i < length; i++) {\n            let v = this.at(i);\n            if (optionalFunc) {\n                v = optionalFunc(v);\n            }\n\n            sum = sum + v;\n        }\n\n        return sum;\n    }\n\n    /**\n     * Returns the average of all elements in the array.\n     * @returns {number} The average of all elements.\n     */\n    average() {\n        if (this.length === 0) {\n            return 0;\n        }\n        return this.sum() / this.length;\n    }\n\n    /**\n     * Returns a new array with duplicate elements removed.\n     * @returns {Array_ideal} A new array containing only unique elements.\n     */\n    unique () {\n        return Array.from(new Set(this));\n    }\n\n    /**\n     * Converts the array to a Set object.\n     * @returns {Set} A new Set containing the array's elements.\n     */\n    asSet () {\n        return new Set(this)\n    }\n\n    /**\n     * Returns a new array with the elements in reverse order.\n     * @returns {Array_ideal} A new array with the elements reversed.\n     */\n    reversed () {\n        return this.shallowCopy().reverse();\n    }\n\n    /**\n     * Converts the array to a path string.\n     * @returns {string} A string representation of the array as a path.\n     */\n    asPath () {\n        if (this.length === 1 && this.first() === \"\") {\n            return \"/\";\n        }\n        else {\n            return this.join(\"/\");\n        }\n    }\n\n    /**\n     * Checks if the array represents an absolute path.\n     * @returns {boolean} True if the array represents an absolute path, false otherwise.\n     */\n    isAbsolutePath () {\n        return this.first() === \"\";\n    }\n\n    /**\n     * Checks if the array represents a relative path.\n     * @returns {boolean} True if the array represents a relative path, false otherwise.\n     */\n    isRelativePath () {\n        return this.first() !== \"\";\n    }\n\n    /**\n     * Filters the array in-place, removing elements that do not satisfy the specified condition.\n     * @param {Function} func - The condition function to check for.\n     * @returns {Array_ideal} The filtered array.\n     */\n    filterInPlace (func) {\n        for (let i = this.length - 1; i >= 0; i--) {\n            const v = this.at(i);\n            if (!func(v)) {\n                this.removeAt(i)\n            }\n        }\n        return this\n    }\n\n    /**\n     * Returns a new array containing only the elements that satisfy the specified condition.\n     * @param {Function} func - The condition function to check for.\n     * @returns {Array_ideal} A new array containing only the elements that satisfy the condition.\n     */\n    select (func) {\n        return this.filter(func)\n    }\n\n    /**\n     * Returns a new array containing all elements after the specified element.\n     * @param {*} v - The element to search for.\n     * @returns {Array_ideal} A new array containing all elements after the specified element.\n     */\n    after (v) {\n        const index = this.indexOf(v);\n\n        if (index === -1) {\n            return [];\n        }\n\n        return this.slice(index + 1);\n    }\n\n    /**\n     * Returns a new array containing all elements before the specified element.\n     * @param {*} v - The element to search for.\n     * @returns {Array_ideal} A new array containing all elements before the specified element.\n     */\n    before (v) {\n        const index = this.indexOf(v);\n\n        if (index === -1) {\n            return this.slice();\n        }\n\n        return this.slice(0, index);\n    }\n\n    /**\n     * Replaces all occurrences of a specified value with a new value in the array.\n     * @param {*} oldValue - The value to replace.\n     * @param {*} newValue - The new value to replace with.\n     * @returns {Array_ideal} The modified array.\n     */\n    replaceOccurancesOfWith (oldValue, newValue) {\n        // isMutator\n        for (let i = 0; i < this.length; i++) {\n            if (this.at(i) === oldValue) {\n                this.atPut(i, newValue);\n            }\n        }\n        return this\n    }\n\n    /**\n     * Removes all occurrences of a specified value from the array.\n     * @param {*} e - The value to remove.\n     * @returns {Array_ideal} The modified array.\n     */\n    removeOccurancesOf (e) {\n        // isMutator\n        for (let i = this.length - 1; i >= 0; i--) {\n            const v = this.at(i);\n            if (v === e) {\n                this.removeAt(i)\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Joins the elements of the array into a new array, inserting a separator between each element.\n     * @param {Function} aFunc - The function to call for each element to get the separator.\n     * @returns {Array} A new array containing the joined elements.\n     */\n    joinWithFunc (aFunc) {\n        // not a mutator\n        // like join, but calls aFunc with the array and index as arguments\n        // to get each new item to insert between array items\n        const joined = []\n        for (let i = 0; i < this.length; i++) {\n            const v = this[i]\n            joined.push(v)\n            if (i < this.length - 1) {\n                const separator = aFunc(this, i)\n                joined.push(separator)\n            }\n        }\n        return joined\n    }\n\n    /**\n     * Returns a new array containing all elements before the specified element.\n     * @param {*} item - The element to search for.\n     * @returns {Array_ideal} A new array containing all elements before the specified element.\n     */\n    itemsBefore (item) {\n        const index = this.indexOf(item);\n        if (index !== -1) {\n            return this.slice(0, index);\n        }\n        return this\n    }\n\n    /**\n     * Returns a new array containing the union of the elements in this array and another array.\n     * @param {Array_ideal} other - The other array.\n     * @returns {Array_ideal} A new array containing the union of the elements.\n     */\n    union (other) {\n        let r = this.concat(other).unique()\n        return r;\n    }\n\n    /**\n     * Returns a new array containing the intersection of the elements in this array and another array.\n     * @param {Array_ideal} other - The other array.\n     * @returns {Array_ideal} A new array containing the intersection of the elements.\n     */\n    intersection (other) { // returns all items that are present in both\n        const thisSet = new Set(this)\n        return other.filter((v) => {\n            return thisSet.has(v);\n        });\n    }\n\n    /**\n     * Returns a new array containing the elements in another array that are not present in this array.\n     * @param {Array_ideal} other - The other array.\n     * @returns {Array_ideal} A new array containing the difference of the elements.\n     */\n    difference (other) { // returns items in other that are not in self\n        const thisSet = new Set(this)\n        return other.filter(v => !thisSet.has(v));\n    }\n\n    /**\n     * Returns a new array containing the elements that are present in either this array or another array, but not in both.\n     * @param {Array_ideal} other - The other array.\n     * @returns {Array_ideal} A new array containing the symmetric difference of the elements.\n     */\n    symmetricDifference (other) { // returns items in either not present in the other\n        let all = this.concat(other)\n        const thisSet = new Set(this)\n        const otherSet = new Set(other)\n        return all.filter(v => !thisSet.has(v) || !otherSet.has(v));\n    }\n\n    /**\n     * Checks if this array is equal to another array.\n     * @param {Array_ideal} array - The other array.\n     * @returns {boolean} True if the arrays are equal, false otherwise.\n     */\n    equals (array /*, visited = new Set()*/) {\n        // we want this to work on any object that confroms to the array protocol, \n        // not just objects of the same JS type\n        // but how do we test for the [] accessor?\n        // also, how do we deal with circular structures?\n\n        /*\n        if (visited.has(this)) {\n            return true // ?\n        }\n        visited.add(this)\n        */\n\n        if (array.length === undefined) {\n            return false;\n        }\n\n        // compare lengths - can save a lot of time \n        if (this.length !== array.length) {\n            return false;\n        }\n\n        for (let i = 0, l = this.length; i < l; i++) {\n            const a = this.at(i)\n            const b = array.at(i)\n\n            // Check if we have nested arrays\n            /*\n                if (this.at(i) instanceof Array && array[i] instanceof Array) {\n                    // recurse into the nested arrays\n                    if (!this.at(i).equals(array[i]))\n                        return false;       \n                }     \n            */\n\n            if (a.equals && !a.equals(b, visited)) {\n                return false;\n            } else if (a !== b) {\n                // Warning - two different object instances will never be equal: {x:20} !== {x:20}\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n    /**\n     * Checks if this array contains an element that is equal to a given element.\n     * @param {*} b - The element to check for.\n     * @returns {boolean} True if the array contains an equal element, false otherwise.\n     */\n    containsEquals (b) {\n        for (let i = 0, l = this.length; i < l; i++) {\n            let a = this.at(i)\n\n            if (a.equals) {\n                if (!a.equals(b)) {\n                    return false;\n                }\n            } else if (a !== b) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n}).initThisCategory();\n\n",
  "jO8vvO0H6a4eiar8wwrVFFEUV4ZUTauePk4DMBVwZAE=": "\"use strict\";\n\n/**\n * @module ideal\n * @class Date_ideal\n * @extends Date\n * @description Extended Date class with additional utility methods.\n */\n(class Date_ideal extends Date {\n\n    /**\n     * @returns {Date} A shallow copy of the current Date object.\n     */\n    copy () {\n        return this.shallowCopy()\n    }\n\n    /**\n     * @returns {Date} A new Date object with the same time as the current one.\n     */\n    shallowCopy () {\n        return new Date(this.getTime())\n    }\n\n    // ---\n   \n    /**\n     * @returns {string[]} An array of month names.\n     */\n    monthNames () {\n        return [ \n            \"January\", \"February\", \"March\", \n            \"April\", \"May\", \"June\", \n            \"July\", \"August\", \"September\", \n            \"October\", \"November\", \"December\" \n        ];\n    }\n\n    /**\n     * @returns {string} The name of the current month.\n     */\n    monthName () {\n        const monthNumber = this.getMonth() - 1\n        return this.monthNames()[monthNumber];\n    }\n\n    /**\n     * @returns {string} The date number with its ordinal suffix (e.g., \"1st\", \"2nd\", \"3rd\", \"4th\").\n     */\n    dateNumberName () {\n        const dayNumber = this.getDate()\n        return dayNumber + dayNumber.ordinalSuffix()\n    }\n\n    /**\n     * Pads a number with a leading zero if it's a single digit.\n     * @param {number} n - The number to pad.\n     * @returns {string} The padded number as a string.\n     */\n    paddedNumber (n) {\n        const s = \"\" + n\n        if (s.length === 1) { \n            return \"0\" + s\n        }\n        return s\n    }\n\n    /**\n     * @returns {string} The hours padded with a leading zero if necessary.\n     */\n    zeroPaddedHours () {\n        return this.paddedNumber(this.getHours())\n    }\n\n    /**\n     * @returns {string} The minutes padded with a leading zero if necessary.\n     */\n    zeroPaddedMinutes () {\n        return this.paddedNumber(this.getMinutes())\n    }\n\n    /**\n     * @returns {string} The seconds padded with a leading zero if necessary.\n     */\n    zeroPaddedSeconds () {\n        return this.paddedNumber(this.getSeconds())\n    }\n\n    /**\n     * @returns {number} The hours in 12-hour format (1-12).\n     */\n    getTwelveHours () {\n        let h = this.getHours()\n        if (h > 12) { h -= 12 }\n        if (h === 0) { h = 12 }\n        return h\n    }\n\n    /**\n     * @returns {string} The time in US format (HH:MM) with zero-padded hours and minutes.\n     */\n    zeroPaddedUSDate () {\n        return this.paddedNumber(this.getTwelveHours()) + \":\" + this.paddedNumber(this.getMinutes())\n    }\n\n}).initThisCategory();\n\n\n\n\n\n\n",
  "8Ti4b6QyBhtJVQQIfpZw5IkR1t1XKYIGfB+lYw8cInA=": "\"use strict\";\n\n/**\n * @module ideal\n * @class String_ideal\n * @extends String\n * @description Extended String class with additional utility methods.\n */\n\n(class String_ideal extends String {\n\n    /**\n     * Returns the string itself\n     * @returns {string} The string\n     */\n    asString () {\n        return this;\n    }\n    \n    /**\n     * Counts the occurrences of a substring in the string\n     * @param {string} substring - The substring to count\n     * @returns {number} The number of occurrences\n     */\n    countOccurances (substring) {\n        return this.split(substring).length - 1;\n    }\n\n    /**\n     * Creates a shallow copy of the string (which is the string itself for primitives)\n     * @returns {string} The string\n     */\n    shallowCopy () {\n        return this\n    }\n\n    /**\n     * Returns a duplicate of the string (which is the string itself for primitives)\n     * @returns {string} The string\n     */\n    duplicate () {\n        return this\n    }\n    \n    /**\n     * Checks if the string is empty\n     * @returns {boolean} True if the string is empty, false otherwise\n     */\n    isEmpty () {\n        return this.length === 0;\n    }\n\n    /**\n     * Returns the length of the string\n     * @returns {number} The length of the string\n     */\n    size () {\n        return this.length;\n    }\n    \n    /**\n     * Checks if the string begins with the given prefix\n     * @param {string} prefix - The prefix to check\n     * @returns {boolean} True if the string begins with the prefix, false otherwise\n     */\n    beginsWith (prefix) {\n        if (!prefix || this.length < prefix.length) {\n            return false;\n        }\n        for (let i = 0; i < prefix.length; i ++) {\n            if (this.charAt(i) !== prefix.charAt(i)) {\n                return false\n            }\n        } \n        return true\n    }\n\n    /**\n     * Checks if the string contains the given substring\n     * @param {string} aString - The substring to search for\n     * @returns {boolean} True if the string contains the substring, false otherwise\n     */\n    contains (aString) {\n        return this.indexOf(aString) !== -1;\n    }\n\n    /**\n     * Returns the substring before the first occurrence of the given string\n     * @param {string} aString - The string to search for\n     * @returns {string} The substring before aString, or the entire string if aString is not found\n     */\n    before (aString) {\n        const index = this.indexOf(aString);\n        \n        if (index === -1) {\n            return this;\n        }\n\n        return this.slice(0, index);\n    }\n\n    /**\n     * Returns the substring after the first occurrence of the given string\n     * @param {string} aString - The string to search for\n     * @returns {string} The substring after aString, or an empty string if aString is not found\n     */\n    after (aString) {\n        const index = this.indexOf(aString);\n\n        if (index === -1) {\n            return \"\";\n        }\n        \n        return this.slice(index + aString.length);\n    }\n\n    /**\n     * Returns the substring between two given strings\n     * @param {string} prefix - The starting string\n     * @param {string} suffix - The ending string\n     * @returns {string|null} The substring between prefix and suffix, or null if either is not found\n     */\n    between (prefix, suffix) {\n        const after = this.after(prefix);\n        if (after != null) {\n            const before = after.before(suffix);\n            if (before != null) {\n                return before;\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Returns the first character of the string\n     * @returns {string} The first character\n     */\n    first () {\n        return this.slice(0, 1);\n    }\n\n    /**\n     * Returns the string without its first character\n     * @returns {string} The string without its first character\n     */\n    rest () {\n        return this.slice(1);\n    }\n\n    /**\n     * Repeats the string a specified number of times\n     * @param {number} times - The number of times to repeat the string\n     * @returns {string} The repeated string\n     */\n    repeated (times) {\n        let result = \"\";\n        const aString = this;\n        times.repeat(function () { result += aString });\n        return result\n    }\n\n    /**\n     * Removes specified prefixes from the string\n     * @param {string[]} aStringList - An array of prefixes to remove\n     * @returns {string} The string with the prefixes removed\n     */\n    sansPrefixes (aStringList) {\n        let result = this\n        aStringList.forEach((s) => { result = result.sansPrefix(s) })\n        return result\n    }\n\n    /**\n     * Removes a specified prefix from the string\n     * @param {string} prefix - The prefix to remove\n     * @returns {string} The string with the prefix removed\n     */\n    sansPrefix (prefix) {\n        return this.substring(this.startsWith(prefix) ? prefix.length : 0);\n    }\n\n    /**\n     * Removes specified suffixes from the string\n     * @param {string[]} aStringList - An array of suffixes to remove\n     * @returns {string} The string with the suffixes removed\n     */\n    sansSuffixes (aStringList) {\n        let result = this\n        aStringList.forEach((s) => { result = result.sansSuffix(s) })\n        return result\n    }\n\n    /**\n     * Removes a specified suffix from the string\n     * @param {string} suffix - The suffix to remove\n     * @returns {string} The string with the suffix removed\n     */\n    sansSuffix (suffix) {\n        if (this.endsWith(suffix)) {\n            return this.substr(0, this.length - suffix.length);\n        }\n        else {\n            return this;\n        }\n    }\n\n    /**\n     * Removes leading and trailing whitespace from the string\n     * @returns {string} The trimmed string\n     */\n    stripped () {\n        return this.replace(/^\\s\\s*/, \"\").replace(/\\s\\s*$/, \"\");\n    }\n\n    /**\n     * Converts the first character of each word to lowercase\n     * @returns {string} The string with uncapitalized words\n     */\n    uncapitalized () {\n        return this.replace(/\\b[A-Z]/g, function (match) {\n            return match.toLowerCase();\n        });\n    }\n\n    /**\n     * Converts the string to a number\n     * @returns {number} The numeric value of the string, or NaN if conversion is not possible\n     */\n    asNumber () {\n        if (this === \"\" || this === null || this === undefined) {\n            return NaN;\n        }\n        \n        const number = Number(this);\n        return isNaN(number) ? NaN : number;\n    }\n\n    /**\n     * Converts camelCase to a human-readable string\n     * @returns {string} The humanized string\n     */\n    humanized () {\n        const words = [];\n        let start = -1;\n        const capitalized = this.capitalized();\n        let i;\n        for (i = 0; i < capitalized.length; i++) {\n            if (capitalized.slice(i, i + 1).match(/[A-Z]/)) {\n                let word = capitalized.slice(start, i);\n                if (word) {\n                    words.append(word);\n                }\n                start = i;\n            }\n        }\n        words.append(capitalized.slice(start, i));\n        return words.join(\" \");\n    }\n\n    /**\n     * Capitalizes the first letter of each word in the string\n     * @returns {string} The titleized string\n     */\n    titleized () {\n        return this.split(/\\s+/).map(function (s) { return s.capitalized() }).join(\" \");\n    }\n\n    /**\n     * Encodes the string to base64\n     * @returns {string} The base64 encoded string\n     */\n    base64Encoded () {\n        return window.btoa(this);\n    }\n\n    /**\n     * Encodes the string to URL-safe base64\n     * @returns {string} The URL-safe base64 encoded string\n     */\n    base64UrlEncoded () {\n        return this.base64Encoded().replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \",\");\n    }\n\n    /**\n     * Decodes a base64 encoded string\n     * @returns {string} The decoded string\n     */\n    base64Decoded () {\n        return window.atob(this);\n    }\n\n    /**\n     * Decodes a URL-safe base64 encoded string\n     * @returns {string} The decoded string\n     */\n    base64UrlDecoded () {\n        return this.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/,/g, \"=\").base64Decoded();\n    }\n\n    /**\n     * Counts the occurrences of a substring in the string\n     * @param {string} str - The substring to count\n     * @returns {number} The number of occurrences\n     */\n    stringCount (str) {\n        return this.split(str).length - 1;\n    }\n\n    /**\n     * Counts the number of lines in the string\n     * @returns {number} The number of lines\n     */\n    lineCount () {\n        let count = 0\n        for (let i = 0; i < this.length; i++) {\n            const c = this.charAt(i)\n            if (c === \"\\n\") {\n                count ++\n            }\n        }\n        return count\n    }\n\n    /**\n     * Returns an array of single character strings\n     * @returns {string[]} An array of characters\n     */\n    characters () {\n        return Array.from(this);\n    }\n\n    /**\n     * Returns an array of character codes\n     * @returns {number[]} An array of character codes\n     */\n    characterCodes () {\n        return Array.from(this, char => char.charCodeAt(0));\n    }\n\n    /**\n     * Iterates over each character in the string\n     * @param {function(string): void} fn - Function to call for each character\n     */\n    forEachCharacter (fn) {\n        for (let i = 0; i < this.length; i++) {\n            const c = this.charAt(i)\n            fn(c)\n        }\n    }\n\n    /**\n     * Iterates over each character in the string with its index\n     * @param {function(number, string): void} fn - Function to call for each character and its index\n     */\n    forEachKV (fn) {\n        for (let i = 0; i < this.length; i++) {\n            const c = this.charAt(i)\n            fn(i, c)\n        }\n    }\n\n    /**\n     * Splits the string by multiple delimiters\n     * @param {string[]} splitters - Array of delimiter strings\n     * @returns {(string|null)[]} Array of split substrings or null if a splitter wasn't found\n     */\n    splitArray (splitters) {\n        let s = this\n        const results = []\n        splitters.forEach( (splitter) => {\n            if (s.contains(splitter)) {\n                const before = s.before(splitter)\n                s = s.after(splitter)\n                results.push(before)\n            } else {\n                results.push(null)\n            }\n        })\n        return results\n    }\n\n    /**\n     * Replaces substrings in the string based on a map\n     * @param {Map<string, string>} map - Map of substrings to replace and their replacements\n     * @returns {string} The string with replacements applied\n     */\n    replaceMap (map) {\n        let s = this;\n        map.forEach((value, key) => {\n            s = s.replaceAll(key, value);\n        });\n        return s;\n    }\n\n    /**\n     * Splits the string into path components\n     * @returns {string[]} Array of path components\n     */\n    pathComponents () {\n        if (this === \"/\") {\n            return [\"\"];\n        }\n        else if (this === \"\") {\n            return [];\n        }\n        else {\n            return this.split(\"/\");\n        }\n    }\n\n    /**\n     * Returns the string without its last path component\n     * @returns {string} The string without the last path component\n     */\n    sansLastPathComponent () {\n        const c = this.pathComponents()\n        c.removeLast();\n        return c.join(\"/\");\n    }\n\n    /**\n     * Returns the last path component of the string\n     * @returns {string} The last path component\n     */\n    lastPathComponent () {\n        const components = this.pathComponents()\n        if (components.length) {\n            return this.pathComponents().last();\n        }\n        return \"\"\n    }\n\n    /**\n     * Returns the filename part of the path (last component without extension)\n     * @returns {string} The filename\n     */\n    fileName () {\n        return this.lastPathComponent().sansExtension()\n    }\n\n    /**\n     * Returns the string without its file extension\n     * @returns {string} The string without the file extension\n     */\n    sansExtension () {\n        const parts = this.split(\".\")\n        if (parts.length > 1) {\n            parts.pop()\n        }\n        return parts.join(\".\")\n    }\n\n    /**\n     * Returns the file extension of the path\n     * @returns {string} The file extension\n     */\n    pathExtension () {\n        const extension = this.split(\".\").last();\n        return extension;\n    }\n\n    /**\n     * Indents each line of the string\n     * @param {number} n - Number of indentation units\n     * @param {string} [spacer=\" \"] - The indentation character\n     * @returns {string} The indented string\n     */\n    indent (n, spacer = \" \") {\n        const indentation = spacer.repeat(n);\n        return this.split('\\n').map(line => indentation + line).join('\\n');\n    }\n\n    /**\n     * Pads the string on the left to a specified length\n     * @param {number} length - The desired length\n     * @param {string} padding - The padding character\n     * @returns {string} The padded string\n     */\n    padLeft (length, padding) {\n        let str = this;\n        while (str.length < length) {\n            str = padding + str;\n        }\n\n        return str.substring(0, length);\n    }\n\n    /**\n     * Pads the string on the right to a specified length\n     * @param {number} length - The desired length\n     * @param {string} padding - The padding character\n     * @returns {string} The padded string\n     */\n    padRight (length, padding) {\n        let str = this;\n        while (str.length < length) {\n            str = str + padding;\n        }\n\n        return str.substring(0, length);\n    }\n\n    /**\n     * Removes leading and trailing whitespace from the string\n     * @returns {string} The trimmed string\n     */\n    strip () {\n        return String(this).replace(/^\\s+|\\s+$/g, \"\");\n    }\n\n    /**\n     * Parses the string as JSON and returns the resulting object\n     * @returns {Object} The parsed JSON object\n     */\n    asObject () {\n        return JSON.parse(this);\n    }\n\n    /**\n     * Returns the setter method name for this property name\n     * @returns {string} The setter method name\n     */\n    asSetter () {\n        const cache = this.thisPrototype()._setterCacheMap \n        let result = cache[this]\n        if (!result) {\n             result = \"set\" + this.capitalized()\n             cache.set(this, result)\n             // test for highwater mark\n             if (cache.size > 50000) {\n                console.warn(\"setter cache is getting big! clearing...\")\n                cache.clear()\n             }\n        }\n        return result\n    }\n\n    /**\n     * Returns the first character of the string\n     * @returns {string} The first character\n     */\n    firstCharacter () {\n        return this.slice(0);\n    }\n\n    /**\n     * Returns the last character of the string\n     * @returns {string} The last character\n     */\n    lastCharacter () {\n        return this.slice(-1);\n    }\n\n    /**\n     * Capitalizes the first letter of each word in the string\n     * @returns {string} The string with capitalized words\n     */\n    capitalizeWords () {\n        return this.replace(/(?:^|\\s)\\S/g, function (a) {\n            return a.toUpperCase();\n        });\n    }\n\n    /**\n     * Clips the string to a specified length and adds an ellipsis if necessary\n     * @param {number} length - The maximum length\n     * @returns {string} The clipped string\n     */\n    clipWithEllipsis (length) {\n        if (this.length <= length) {\n            return this.toString();\n        }\n        return this.substring(0, length) + '...';\n    }\n\n    /**\n     * Generates Lorem Ipsum text\n     * @param {number} [minWordCount=10] - Minimum number of words\n     * @param {number} [maxWordCount=40] - Maximum number of words\n     * @returns {string} Generated Lorem Ipsum text\n     */\n    loremIpsum (minWordCount, maxWordCount) {\n        // ... (implementation)\n    }\n\n    /**\n     * Escapes HTML special characters in the string\n     * @returns {string} The HTML-escaped string\n     */\n    escapeHtml () {\n        return this.replace(/[&<>\"'\\/]/g, function (s) {\n            const entityMap = {\n                \"&\": \"&amp;\",\n                \"<\": \"&lt;\",\n                \">\": \"&gt;\",\n                \"\\\"\": \"&quot;\",\n                \"'\": \"&#39;\",\n                \"/\": \"&#x2F;\"\n            };\n            return entityMap[s];\n        });\n    }\n\n    /**\n     * Checks if the string contains HTML tags\n     * @returns {boolean} True if the string contains HTML tags, false otherwise\n     */\n    containsHtml () {\n        return /<(\\w+)[^>]*>/.test(this);\n    }\n\n    /**\n     * Generates a GUID (Globally Unique Identifier)\n     * @returns {string} A GUID\n     */\n    GUID () {\n        function s4() {\n            return Math.floor((1 + Math.random()) * 0x10000)\n                .toString(16)\n                .substring(1);\n        }\n        return s4() + s4() + \"-\" + s4() + \"-\" + s4() + \"-\" +\n            s4() + \"-\" + s4() + s4() + s4();\n    }\n\n    /**\n     * Calculates the byte length of the UTF-8 encoded string\n     * @returns {number} The byte length\n     */\n    byteLength () {\n        let s = this.length;\n        for (let i = this.length - 1; i >= 0; i--) {\n            const code = this.charCodeAt(i);\n            if (code > 0x7f && code <= 0x7ff) {\n                s ++;\n            } else if (code > 0x7ff && code <= 0xffff) { \n                s += 2;\n            }\n            if (code >= 0xDC00 && code <= 0xDFFF) {\n                i--; //trail surrogate\n            }\n        }\n        return s;\n    }\n\n    /**\n     * Returns a human-readable description of the string's byte size\n     * @returns {string} A formatted string describing the byte size\n     */\n    byteSizeDescription () {\n        return this.byteLength().byteSizeDescription()\n    }\n\n    /**\n     * Computes a hash code for the string\n     * @returns {number} The hash code\n     */\n    hashCode () {\n        return this.hashCode64();\n    }\n\n    /**\n     * Computes a 32-bit hash code for the string\n     * @returns {number} The 32-bit hash code\n     */\n    hashCode32() {\n        let hash = 0;\n        for (let i = 0; i < this.length; i++) {\n        const chr = this.charCodeAt(i);\n        hash = ((hash << 5) - hash) + chr;\n        hash |= 0; // Convert to 32bit integer\n        }\n        return hash;\n    }\n    \n    /**\n     * Computes a 64-bit hash code for the string\n     * @returns {number} The 64-bit hash code\n     */\n    hashCode64 () {\n        let h1 = 0xdeadbeef ^ 0, h2 = 0x41c6ce57 ^ 0;\n        for (let i = 0; i < this.length; i++) {\n        const chr = this.charCodeAt(i);\n        h1 = Math.imul(h1 ^ chr, 2654435761);\n        h2 = Math.imul(h2 ^ chr, 1597334677);\n        }\n        h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);\n        h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);\n        return 4294967296 * (2097151 & h2) + (h1 >>> 0);\n    }\n\n    /**\n     * Computes the SHA-256 digest of the string\n     * @returns {Promise<ArrayBuffer>} A promise that resolves to the SHA-256 digest\n     */\n    promiseSha256Digest () {\n        const uint8Array = new TextEncoder(\"utf-8\").encode(this);    \n        return crypto.subtle.digest(\"SHA-256\", uint8Array.buffer)\n    }\n\n    /**\n     * Strips HTML tags from the string\n     * @returns {string} The string with HTML tags removed\n     */\n    stripHTML () {\n        const doc = new DOMParser().parseFromString(this, 'text/html');\n        return doc.body.textContent || \"\";\n    }\n\n    /**\n     * Removes HTML elements with specified tag names\n     * @param {string[]} tagNames - Array of tag names to remove\n     * @returns {string} The HTML string with specified elements removed\n     */\n    stripHtmlElementsWithTagNames (tagNames) {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(this, 'text/html');\n    \n        tagNames.forEach(tagName => {\n            doc.querySelectorAll(tagName).forEach(el => el.remove());\n        });\n    \n        return doc.body.innerHTML;\n    }\n\n    /**\n     * Replaces the content of specified HTML tags\n     * @param {Map<string, string>} tagNameToContentMap - Map of tag names to new content\n     * @returns {string} The HTML string with replaced content\n     */\n    replaceContentOfHtmlTagMap (tagNameToContentMap) {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(this, 'text/html');\n    \n        tagNameToContentMap.forEach((newContent, tagName) => {\n            doc.querySelectorAll(tagName).forEach(el => {\n                el.innerHTML = newContent;\n            });\n        });\n    \n        return doc.body.innerHTML;\n    }\n\n    /**\n     * Computes the difference between this string and another string\n     * @param {string} otherString - The string to compare with\n     * @returns {Object[]} An array of difference objects\n     */\n    diff (otherString) {\n        // ... (implementation)\n    }\n\n    /**\n     * Returns a normalized version of the HTML string\n     * @returns {string} The normalized HTML string\n     */\n    asNormalizedHtml () {\n        const element = document.createElement(\"div\");        \n        element.innerHTML = this;        \n        return element.innerHTML;\n    }\n\n    /**\n     * Extracts the content of elements with a specific tag\n     * @param {string} tagName - The tag name to search for\n     * @returns {string[]} An array of content strings from matching elements\n     */\n    contentOfElementsOfTag (tagName) {\n        function Element_hasParentWithTag (element, tagName) {\n          tagName = tagName.toLowerCase();\n          \n          while (element) {\n            if (element.tagName && element.tagName.toLowerCase() === tagName.toLowerCase()) {\n              return true;\n            }\n            element = element.parentNode;\n          }\n          \n          return false;\n        }\n    \n        const el = document.createElement(\"div\");\n        el.innerHTML = this;\n        let matches = el.elementsOfTag(tagName);    \n        const results = [];\n        matches.forEach((e) => results.push(e.innerHTML));\n        return results;\n    }\n\n}).initThisCategory();\n\nString.prototype._setterCacheMap = new Map();\n\nString.prototype._setterCacheMap = new Map();\n\n\n\n\n",
  "jtgIiRM/Fke0pNrFF5jBf/vzKhXjBYX7+hbsVxeyOLg=": "\"use strict\";\n\n/**\n * @module ideal\n */\n\n/**\n * @namespace Base64\n * @description Utility for converting between integers and base64 strings\n * @private\n */\nconst Base64 = (function () {\n    const digitsStr = \n    //   0       8       16      24      32      40      48      56     63\n    //   v       v       v       v       v       v       v       v      v\n        \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-\";\n    let digits = digitsStr.split(\"\");\n    let digitsMap = {};\n    for (let i = 0; i < digits.length; i++) {\n        digitsMap[digits[i]] = i;\n    }\n    return {\n        fromInt (int32) {\n            let result = \"\";\n            while (true) {\n                result = digits[int32 & 0x3f] + result;\n                int32 >>>= 6;\n                if (int32 === 0) {\n                    break;\n                }\n            }\n            return result;\n        },\n        toInt (digitsStr) {\n            let result = 0;\n            const digits = digitsStr.split(\"\");\n            for (let i = 0; i < digits.length; i++) {\n                result = (result << 6) + digitsMap[digits[i]];\n            }\n            return result;\n        }\n    };\n})();\n\n/**\n * @class Number_ideal\n * @extends Number\n * @description Extended Number class with additional utility methods.\n */\n(class Number_ideal extends Number {\n\n    /**\n     * Returns a duplicate of the number (which is the number itself for primitives)\n     * @returns {number} The number\n     */\n    duplicate () {\n        return this;\n    }\n    \n    /**\n     * Returns a copy of the number (which is the number itself for primitives)\n     * @returns {number} The number\n     */\n    copy () {\n        return this;\n    }\n\n    /**\n     * Returns a shallow copy of the number (which is the number itself for primitives)\n     * @returns {number} The number\n     */\n    shallowCopy () {\n        return this;\n    }\n\n    /**\n     * Repeats a function the number of times specified by this number\n     * @param {function(number): (boolean|void)} func - The function to repeat\n     * @returns {Number_ideal} This number instance\n     */\n    repeat (func) {\n        for (let i = 0; i < this; i++) {\n            if (func(i) === false) {\n                return this;\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Iterates from 0 to this number (exclusive), calling the provided function for each number\n     * @param {function(number): void} func - The function to call for each number\n     */\n    forEach (func) {\n        assert(Number.isInteger(this))\n        for (let i = 0; i < this; i++) {\n            func(i);\n        }\n    }\n\n    /**\n     * Iterates from this number - 1 to 0, calling the provided function for each number\n     * @param {function(number): void} func - The function to call for each number\n     */\n    reverseForEach (func) {\n        assert(Number.isInteger(this))\n        for (let i = this - 1; i >= 0; i--) {\n            func(i);\n        }\n    }\n\n    /**\n     * Throws an error if called (placeholder for potential future implementation)\n     * @throws {Error} Always throws an error\n     */\n    map () {\n        throw new Error(\"Number map is actually used?\");\n    }\n\n    /**\n     * Checks if the number is even\n     * @returns {boolean} True if the number is even, false otherwise\n     */\n    isEven () {\n        return this % 2 === 0;\n    }\n\n    /**\n     * Checks if the number is odd\n     * @returns {boolean} True if the number is odd, false otherwise\n     */\n    isOdd () {\n        return this % 2 !== 0;\n    }\n\n    /**\n     * Returns the ordinal suffix for the number\n     * @returns {string} The ordinal suffix ('st', 'nd', 'rd', or 'th')\n     */\n    ordinalSuffix () {\n        const i = this;\n        let j = i % 10;\n        let k = i % 100;\n        \n        if (j === 1 && k !== 11) {\n            return \"st\";\n        }\n        if (j === 2 && k !== 12) {\n            return \"nd\";\n        }\n        if (j === 3 && k !== 13) {\n            return \"rd\";\n        }\n        return \"th\";\n    }\n\n    /**\n     * Converts the number to a base64 string\n     * @returns {string} The base64 representation of the number\n     */\n    toBase64 () {\n        return Base64.fromInt(this);\n    }\n\n    /**\n     * Converts a base64 string to a number\n     * @param {string} base64String - The base64 string to convert\n     * @returns {number} The number represented by the base64 string\n     */\n    fromBase64 (base64String) {\n        // need to call like: \n        // Number.prototype.fromBase64(\"...\")\n        return Base64.toInt(base64String);\n    }\n\n    /**\n     * Returns a human-readable string describing the byte size\n     * @returns {string} A formatted string representing the byte size\n     */\n    byteSizeDescription () {\n        return ByteFormatter.clone().setValue(this).formattedValue();\n    }\n\n    /**\n     * Returns the number with its ordinal indicator\n     * @returns {string} The number followed by its ordinal indicator\n     */\n    withOrdinalIndicator () {\n        return this + \"\" + this.ordinalIndicator()\n    }\n\n    /**\n     * Returns the ordinal indicator for the number\n     * @returns {string} The ordinal indicator ('st', 'nd', 'rd', or 'th')\n     */\n    ordinalIndicator () {\n        const num = this;\n\n        if (typeof num !== 'number' || isNaN(num) || !Number.isInteger(num)) {\n            return '';\n        }\n    \n        const lastDigit = num % 10;\n        const lastTwoDigits = num % 100;\n    \n        if (lastTwoDigits >= 11 && lastTwoDigits <= 13) {\n            return 'th';\n        }\n    \n        switch (lastDigit) {\n            case 1:\n                return 'st';\n            case 2:\n                return 'nd';\n            case 3:\n                return 'rd';\n            default:\n                return 'th';\n        }\n    }\n\n    /**\n     * Returns a string representation of the number as a count for a given label\n     * @param {string} label - The label to use for the count\n     * @returns {string} A formatted string representing the count\n     */\n    asCountForLabel (label) {\n        const count = this;\n        if (count === 0) {\n            return \"no \" + label + \"s\";\n        } else if (count === 1) {\n            return count + \" \" + label;\n        } \n        return count + \" \" + label + \"s\";\n    }\n\n    /**\n     * Returns a random number between this number and another number\n     * @param {number} other - The other number to use as a range boundary\n     * @returns {number} A random number between this number and the other number\n     */\n    randomBetween (other) {\n        const min = Math.min(this, other);\n        const max = Math.max(this, other);\n        const randomValue = Math.random() * (max - min) + min;\n        return randomValue;\n    }\n    \n}).initThisCategory();\n",
  "M80591IHc5IMuVz0zOEWT2OKEUS2M0jzLC7Vv8Hoj3w=": "\"use strict\";\n\n/**\n * @module ideal\n * @class Boolean_ideal\n * @extends Boolean\n * @description Extended Boolean class with additional utility methods.\n */\n(class Boolean_ideal extends Boolean {\n\n    /**\n     * @returns {boolean} Returns the boolean value itself.\n     */\n    duplicate () {\n        return this\n    }\n \n    // logic\n\n    /**\n     * @returns {boolean} Returns the negation of the boolean value.\n     */\n    negate () {\n        return !this\n    }\n\n    /**\n     * Performs a logical AND operation with another boolean value.\n     * @param {boolean} v - The boolean value to AND with.\n     * @returns {boolean} The result of the AND operation.\n     */\n    and (v) {\n        return this && v\n    }\n\n    /**\n     * Performs a logical OR operation with another boolean value.\n     * @param {boolean} v - The boolean value to OR with.\n     * @returns {boolean} The result of the OR operation.\n     */\n    or (v) {\n        return this || v\n    }\n\n    /**\n     * Performs a logical XOR operation with another boolean value.\n     * @param {boolean} v - The boolean value to XOR with.\n     * @returns {boolean} The result of the XOR operation.\n     */\n    xor (v) {\n        return ( this && !v ) || ( !this && v )\n    }\n\n    // control flow\n\n    /**\n     * Executes the provided closure if the boolean value is true.\n     * @param {Function} aClosure - The function to execute if the boolean is true.\n     * @returns {*} The result of the closure if executed, otherwise undefined.\n     */\n    ifTrue (aClosure) { // just a test\n        if (this) {\n            return aClosure()\n        }\n        return undefined\n    }\n\n}).initThisCategory();\n",
  "Y5iK9iyeD4+j8g7uviDBGcW2Op2utoYMy+Ssblv4LaY=": "\"use strict\";\n\n/**\n * @module ideal\n * @class Set_ideal\n * @extends Set\n * @description Extended Set class with additional utility methods.\n */\n(class Set_ideal extends Set {\n\n    /**\n     * Creates a new Set from an iterator\n     * @param {Iterator} iterator - The iterator to create the Set from\n     * @returns {Set_ideal} A new Set containing the iterator's values\n     */\n    static fromIterator (iterator) {\n        const results = new this()\n        let entry = iterator.next()\n        while (!entry.done) {\n            const v = entry.value\n            results.add(v)\n            entry = iterator.next()\n        }\n        return results\n    }\n\n    /**\n     * Checks if this set is equal to another set\n     * @param {Set} aSet - The set to compare with\n     * @returns {boolean} True if the sets are equal, false otherwise\n     */\n    equals (aSet) {\n        return this.size === aSet.size && [...this].every(v => aSet.has(v));\n    }\n\n    /**\n     * Returns the number of elements in the set\n     * @returns {number} The number of elements\n     */\n    count () {\n        return this.size\n    }\n\n    /**\n     * Creates a shallow copy of the set\n     * @returns {Set} A new Set with the same elements\n     */\n    shallowCopy () {\n        return new Set(this);\n    }\n\n    /**\n     * Creates a deep copy of the set\n     * @param {Map} [refMap=new Map()] - A map to handle circular references\n     * @returns {Set_ideal} A new Set with deeply copied elements\n     */\n    deepCopy (refMap = new Map()) {\n        const newSet = new this.constructor();\n\n        this.forEachV((v) => {\n            newSet.add(Type.deepCopyForValue(v, refMap));\n        });\n\n        return newSet;\n    }\n\n    /**\n     * Returns an array of all elements in the set\n     * @returns {Array} An array containing all elements\n     */\n    keysArray () {\n        return Array.fromIterator(this.values())\n    }\n\n    /**\n     * Returns an array of all elements in the set\n     * @returns {Array} An array containing all elements\n     */\n    valuesArray () {\n        return this.keysArray()\n    }\n\n    /**\n     * Returns an array of all elements in the set\n     * @returns {Array} An array containing all elements\n     */\n    asArray () {\n        return this.keysArray()\n    }\n    \n    /**\n     * Iterates over the set, calling a function for each key-value pair\n     * @param {function(*, *, Set_ideal): void} fn - The function to call for each entry\n     */\n    forEachKV (fn) {\n        this.forEach((v, k, self) => fn(k, v, self))\n    }\n\n    /**\n     * Iterates over the set, calling a function for each key\n     * @param {function(*): void} fn - The function to call for each key\n     */\n    forEachK (fn) {\n        this.forEach((v, k) => fn(k))\n    }\n\n    /**\n     * Iterates over the set, calling a function for each value\n     * @param {function(*): void} fn - The function to call for each value\n     */\n    forEachV (fn) {\n        this.forEach(v => fn(v))\n    }\n\n    /**\n     * Checks if the set can detect an element that satisfies the given function\n     * @param {function(*): boolean} func - The function to test each element\n     * @returns {boolean} True if an element is detected, false otherwise\n     */\n    canDetect (func) {\n        const result = this.detect(func);\n        return result !== undefined && result !== null;\n    }\n    \n    /**\n     * Finds the first element in the set that satisfies the given function\n     * @param {function(*): boolean} fn - The function to test each element\n     * @returns {*} The first element that satisfies the function, or undefined if none found\n     */\n    detect (fn) {\n        for (let v of this) {\n            const r = fn(v)\n            if (r === true) {\n                return v;\n            }\n        }\n        return undefined\n    }\n\n    /**\n     * Alias for select method\n     * @param {function(*): boolean} fn - The function to test each element\n     * @returns {Array} An array of elements that satisfy the function\n     */\n    filter (fn) {\n        return this.select(fn)\n    }\n    \n    /**\n     * Returns an array of elements that satisfy the given function\n     * @param {function(*): boolean} fn - The function to test each element\n     * @returns {Array} An array of elements that satisfy the function\n     */\n    select (fn) {\n        return this.valuesArray().select(fn)\n    }\n\n    /**\n     * Creates a new set with the results of calling a provided function on every element\n     * @param {function(*): *} func - Function that produces an element of the new Set\n     * @returns {Set} A new Set with each element being the result of the callback function\n     */\n    map (func) {\n        const result = new Set()\n        this.forEach((v) => result.add(func(v)))\n        return result\n    }\n\n    /**\n     * Placeholder method to avoid throwing an error if the browser defines it\n     * @private\n     */\n    isSubsetOf_isOptional () {\n        // so exception isn't thrown if the browser defines it\n    }\n\n    /**\n     * Checks if this set is a subset of another set\n     * @param {Set} superSet - The set to check against\n     * @returns {boolean} True if this set is a subset of superSet, false otherwise\n     */\n    isSubsetOf (superSet) {\n        return superSet.isSupersetOf(this);\n    }\n\n    /**\n     * Placeholder method to avoid throwing an error if the browser defines it\n     * @private\n     */\n    isSupersetOf_isOptional () {\n        // so exception isn't thrown if the browser defines it\n    }\n\n    /**\n     * Checks if this set is a superset of another set\n     * @param {Set} subset - The set to check against\n     * @returns {boolean} True if this set is a superset of subset, false otherwise\n     */\n    isSupersetOf (subset) {\n        if (this.size < subset.size) {\n            return false\n        }\n\n        for (let v of subset) {\n            if (!this.has(v)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Placeholder method to avoid throwing an error if the browser defines it\n     * @private\n     */\n    union_isOptional () {\n        // so exception isn't thrown if the browser defines it\n    }\n    \n    /**\n     * Returns a new set that is the union of this set and another set\n     * @param {Set} setB - The set to union with\n     * @returns {Set} A new set containing all elements from both sets\n     */\n    union (setB) {\n        let _union = new Set(this);\n        for (let v of setB) {\n            _union.add(v);\n        }\n        return _union;\n    }\n\n    /**\n     * Placeholder method to avoid throwing an error if the browser defines it\n     * @private\n     */\n    intersection_isOptional () {\n        // so exception isn't thrown if the browser defines it\n    }\n    \n    /**\n     * Returns a new set that is the intersection of this set and another set\n     * @param {Set} setB - The set to intersect with\n     * @returns {Set} A new set containing elements common to both sets\n     */\n    intersection (setB) {\n        let _intersection = new Set();\n        for (let elem of setB) {\n            if (this.has(elem)) {\n                _intersection.add(elem);\n            }\n        }\n        return _intersection;\n    }\n\n    /**\n     * Placeholder method to avoid throwing an error if the browser defines it\n     * @private\n     */\n    symmetricDifference_isOptional () {\n        // so exception isn't thrown if the browser defines it\n    }\n\n    /**\n     * Returns a new set that is the symmetric difference of this set and another set\n     * @param {Set} setB - The set to compute the symmetric difference with\n     * @returns {Set} A new set containing elements in either set but not in both\n     */\n    symmetricDifference (setB) { \n        let _difference = new Set(this);\n        for (let v of setB) {\n            if (_difference.has(v)) {\n                _difference.delete(v);\n            } else {\n                _difference.add(v);\n            }\n        }\n        return _difference;\n    }\n\n    /**\n     * Placeholder method to avoid throwing an error if the browser defines it\n     * @private\n     */\n    difference_isOptional () {\n        // so exception isn't thrown if the browser defines it\n    }\n    \n    /**\n     * Returns a new set that is the difference of this set and another set\n     * @param {Set} setB - The set to subtract\n     * @returns {Set} A new set containing elements in this set that are not in setB\n     */\n    difference (setB) {\n        let _difference = new Set(this);\n        for (let v of setB) {\n            _difference.delete(v);\n        }\n        return _difference;\n    }\n\n    /**\n     * Checks if the set is empty\n     * @returns {boolean} True if the set is empty, false otherwise\n     */\n    isEmpty () {\n        return this.size == 0        \n    }\n\n    /**\n     * Removes and returns an arbitrary element from the set\n     * @returns {*} The removed element\n     */\n    pop () {\n        const iter = this.values();\n        const value = iter.next().value;\n        return value\n    }\n    \n    /**\n     * Returns an immutable version of this set\n     * @returns {ImmutableSet} An immutable set with the same elements as this set\n     */\n    asImmutable () {\n        return new ImmutableSet(this);\n    }\n\n}).initThisCategory();\n",
  "PUUDI0c8hzBd7jOe4MWY0eETRhXJHGx87AQd2BC+dYY=": "\"use strict\";\n\n/**\n * @module ideal\n * @class Range_ideal\n * @extends Range\n * @description Extended Range class with additional utility methods.\n */\n(class Range_ideal extends Range {\n\n   /**\n    * Checks if this range is equal to another range.\n    * @param {Range} otherRange - The range to compare with\n    * @returns {boolean} True if the ranges are equal, false otherwise\n    */\n   isEqual (otherRange) {\n    if (this === otherRange) {\n      return true;\n    }\n  \n    if (\n      this.startContainer !== otherRange.startContainer ||\n      this.startOffset !== otherRange.startOffset ||\n      this.endContainer !== otherRange.endContainer ||\n      this.endOffset !== otherRange.endOffset\n    ) {\n      return false;\n    }\n  \n    return true;\n  };\n\n}).initThisCategory();\n\n    ",
  "6KBcNcTD5uR3wcjp68I5JQQhe/KcudBIZr3GoHarOoU=": "\"use strict\";\n\n/**\n * @module ideal\n * @class Map_ideal\n * @extends Map\n * @description Extended Map class with additional utility methods.\n */\n(class Map_ideal extends Map {\n\n    /**\n     * Creates a deep copy of the map\n     * @param {Map} [refMap=new Map()] - A map to handle circular references\n     * @returns {Map_ideal} A new Map_ideal instance with deeply copied entries\n     */\n    deepCopy (refMap = new Map()) {\n        const m = new this.constructor();\n\n        this.forEachKV((k, v) => {\n            m.set(k, Type.deepCopyForValue(v, refMap));\n        });\n\n        return m;\n    }\n\n    /**\n     * Creates a shallow copy of the map\n     * @returns {Map_ideal} A new Map_ideal instance with the same entries\n     */\n    shallowCopy () {\n        return new Map(this)\n    }\n\n    /**\n     * Returns the number of entries in the map\n     * @returns {number} The number of entries\n     */\n    count () {\n        return this.size\n    }\n\n    /**\n     * Gets the value associated with the specified key\n     * @param {*} k - The key to look up\n     * @returns {*} The value associated with the key, or undefined if the key doesn't exist\n     */\n    at (k) {\n        return this.get(k)\n    }\n\n    /**\n     * Sets a value for a key if it doesn't already exist\n     * @param {*} k - The key to set\n     * @param {*} v - The value to set\n     * @returns {Map_ideal} This map instance\n     */\n    atIfAbsentPut (k, v) {\n        if (!this.has(k)) {\n            this.set(k, v)\n        }\n        return this\n    }\n\n    /**\n     * Checks if the map has a specific key\n     * @param {*} k - The key to check\n     * @returns {boolean} True if the key exists, false otherwise\n     */\n    hasKey (k) {\n        return this.has(k)\n    }\n\n    /**\n     * Sets a value for a key\n     * @param {*} k - The key to set\n     * @param {*} v - The value to set\n     * @returns {Map_ideal} This map instance\n     */\n    atPut (k, v) {\n        this.set(k, v)\n        return this\n    }\n\n    /**\n     * Removes a key-value pair from the map\n     * @param {*} k - The key to remove\n     * @returns {Map_ideal} This map instance\n     */\n    removeKey (k) {\n        this.delete(k)\n        return this\n    }\n\n    /**\n     * Iterates over the map, calling a function for each key-value pair\n     * @param {function(*, *, Map_ideal): void} fn - The function to call for each entry\n     */\n    forEachKV (fn) {\n        this.forEach((v, k, self) => fn(k, v, self));\n    }\n\n    /**\n     * Iterates over the map, calling a function for each key\n     * @param {function(*): void} fn - The function to call for each key\n     */\n    forEachK (fn) {\n        this.forEach((v, k) => fn(k));\n    }\n\n    /**\n     * Iterates over the map, calling a function for each value\n     * @param {function(*): void} fn - The function to call for each value\n     */\n    forEachV (fn) {\n        this.forEach((v, k) => fn(v));\n    }\n\n    /**\n     * Returns an array of all keys in the map\n     * @returns {Array} An array containing all keys\n     */\n    keysArray () {\n        return Array.fromIterator(this.keys());\n    }\n\n    /**\n     * Returns a set of all keys in the map\n     * @returns {Set} A set containing all keys\n     */\n    keysSet () {\n        return Set.fromIterator(this.keys());\n    }\n\n    /**\n     * Returns an array of all values in the map\n     * @returns {Array} An array containing all values\n     */\n    valuesArray () {\n        return Array.fromIterator(this.values());\n    }\n\n    /**\n     * Returns a set of all values in the map\n     * @returns {Set} A set containing all values\n     */\n    valuesSet () {\n        return Set.fromIterator(this.values());\n    }\n\n    /**\n     * Merges this map's entries into another map\n     * @param {Map} aMap - The map to merge into\n     */\n    mergeInto (aMap) {\n        this.forEachKV((k, v) => aMap.set(k, v));\n    }\n\n    /**\n     * Merges another map's entries into this map\n     * @param {Map} aMap - The map to merge from\n     */\n    merge (aMap) {\n        aMap.forEachKV((k, v) => this.set(k, v));\n    }\n\n    /**\n     * Filters the map in-place, keeping only entries that satisfy the given predicate\n     * @param {function(*, *): boolean} fn - The predicate function\n     * @returns {Map_ideal} This map instance\n     */\n    selectInPlaceKV (fn) {\n        const keys = this.keysArray();\n        keys.forEach(k => {\n            const v = this.get(k);\n            if (!fn(k, v)) {\n                this.delete(k);\n            }\n        })\n        return this;\n    }\n\n    /**\n     * Creates a new map with entries that satisfy the given predicate\n     * @param {function(*, *): boolean} fn - The predicate function\n     * @returns {Map_ideal} A new filtered map\n     */\n    select (fn) {\n        const m = new this.constructor()\n        this.forEach((v, k) => {\n            if (fn(k, v)) {\n                m.set(k, v)\n            }\n        })\n        return m\n    }\n\n    /**\n     * Checks if this map is equal to another map\n     * @param {Map} aMap - The map to compare with\n     * @returns {boolean} True if the maps are equal, false otherwise\n     */\n    isEqual (aMap) {\n        if (this.count() !== aMap.count()) {\n            return false\n        }\n\n        for (let k of this.keys()) {\n            const v1 = this.get(k)\n            const v2 = aMap.get(k)\n            if (v1 !== v2) {\n                return false\n            }\n        }\n        \n        return true\n    }\n\n    /**\n     * Checks if the map is empty\n     * @returns {boolean} True if the map is empty, false otherwise\n     */\n    isEmpty () {\n        return this.size === 0        \n    }\n\n    /**\n     * Converts the map to a plain object\n     * @returns {Object} A plain object representation of the map\n     */\n    asDict () {\n        const dict = {}\n        this.forEachKV((k, v) => dict[k] = v)\n        return dict\n    }\n    \n    /**\n     * Populates the map from a plain object\n     * @param {Object} aDict - The object to populate from\n     * @returns {Map_ideal} This map instance\n     */\n    fromDict (aDict) {\n        this.clear()\n        Object.entries(aDict).forEach(([k, v]) => this.set(k, v))\n        return this\n    }\n\n    /**\n     * Returns a string description of the map\n     * @returns {string} A JSON string representation of the map\n     */\n    description () {\n        return JSON.stableStringify(this.asDict(), null, 2) // may throw error if values aren't json compatible\n    }\n\n    /**\n     * Reorders a key to be before another key\n     * @param {*} keyToMove - The key to move\n     * @param {*} beforeKey - The key to move before\n     * @returns {Map_ideal} This map instance\n     */\n    reorderKeyToBeBefore (keyToMove, beforeKey) {\n        if (!this.has(keyToMove) || !this.has(beforeKey)) {\n          return this;\n        }\n      \n        const value = this.get(keyToMove);\n        this.delete(keyToMove);\n      \n        const entries = Array.from(this.entries());\n        this.clear();\n      \n        let keyInserted = false;\n        for (const [key, val] of entries) {\n          if (key === beforeKey && !keyInserted) {\n            this.set(keyToMove, value);\n            keyInserted = true;\n          }\n          if (key !== keyToMove) {\n            this.set(key, val);\n          }\n        }\n      \n        return this;\n    };\n    \n    /**\n     * Reorders a key to be after another key\n     * @param {*} keyToMove - The key to move\n     * @param {*} afterKey - The key to move after\n     * @returns {Map_ideal} This map instance\n     */\n    reorderKeyToBeAfter (keyToMove, afterKey) {\n        if (!this.has(keyToMove) || !this.has(afterKey)) {\n          return this;\n        }\n      \n        const value = this.get(keyToMove);\n        this.delete(keyToMove);\n      \n        const entries = Array.from(this.entries());\n        this.clear();\n      \n        for (const [key, val] of entries) {\n          this.set(key, val);\n          if (key === afterKey) {\n            this.set(keyToMove, value);\n          }\n        }\n      \n        return this;\n    }\n\n    /**\n     * Creates an index of the map's values based on a method call\n     * @param {string} methodName - The name of the method to call on each value\n     * @returns {Map} A new map where keys are method results and values are sets of matching entries\n     */\n    indexedByMethod (methodName) {\n        const index = new Map();\n        this.valuesArray().forEach(v => {\n            const methodResult = v[methodName]();\n            let matchSet = index.get(methodResult);\n            if (!matchSet) {\n                matchSet = new Set();\n                index.set(methodResult, matchSet);\n            }\n            matchSet.add(v);\n        });\n        return index;\n    }\n\n    /**\n     * Creates a new map with keys and values swapped\n     * @returns {Map_ideal} A new map with inverted key-value pairs\n     */\n    inverted () {\n        const invertedMap = new this.constructor();\n        this.forEachKV((k, v) => {\n            invertedMap.set(v, k);\n        });\n        return invertedMap;\n    }\n\n}).initThisCategory();\n\n    ",
  "9jPogkKurnFuretNBq9+dCb9ekla56mA1dMxrkxA5zA=": "\"use strict\";\n\n/**\n * @module ideal\n * @class Error_ideal\n * @extends Error\n * @description Extended Error class with additional utility methods.\n */\n(class Error_ideal extends Error {\n\n    /**\n     * Rethrows the error, setting the cause if it's undefined.\n     * @throws {Error} This error\n     */\n    rethrow () {\n        if (this.cause === undefined && typeof(Error.cause) === 'function') {\n            this.cause = this;\n        }\n        throw this;\n    }\n\n    /**\n     * Asserts that a value is truthy, throwing an error if it's not.\n     * @param {*} v - The value to assert\n     * @param {string|function} [errorMessage] - The error message or a function that returns it\n     * @param {string} [errorName] - The name of the error\n     * @returns {*} The asserted value\n     * @throws {Error} If the assertion fails\n     */\n    static assert (v, errorMessage, errorName) {\n        if (!Boolean(v)) {\n            if (typeof(errorMessage) === \"function\") {\n                errorMessage = errorMessage();\n            }\n            const m = errorMessage ? errorMessage : \"assert failed - false value\";\n            //debugger;\n            const e = new Error(m);\n            if (errorName) {\n                e.name = errorName;\n            }\n            if (errorMessage) {\n                console.warn(\"assert failed: \" + errorMessage);\n            }\n            throw e;\n        }\n        return v;\n    }\n\n    /**\n     * Asserts that a value is not undefined.\n     * @param {*} v - The value to check\n     * @returns {*} The asserted value\n     * @throws {Error} If the value is undefined\n     */\n    static assertDefined (v) {\n        if (v === undefined) {\n            throw new Error(\"assert failed - undefined value\");\n        }\n        return v;\n    }\n\n    /**\n     * Logs the current stack trace to the console.\n     */\n    static showCurrentStack () {\n        const e = new Error();\n        e.name = \"STACK TRACE\";\n        e.message = \"\";\n        console.log( e.stack );\n    }\n\n    /**\n     * Asserts that a function throws an error when called.\n     * @param {Function} func - The function to test\n     * @throws {Error} If the function doesn't throw\n     */\n    static assertThrows (func) {\n        assert(Type.isFunction(func));\n\n        let didThrow = false;\n        try {\n            func();\n        } catch(e) {\n            didThrow = true;\n        }\n\n        if (!didThrow) {\n            console.log(\"assertThrows(\" + func.toString() + \") failed\");\n        } else {\n            //console.log(\"assertThrows(\" + func.toString() + \") passed\");\n        }\n\n        assert(didThrow);\n    }\n\n    /**\n     * Executes a function and shows any error that occurs.\n     * @param {Function} func - The function to execute\n     */\n    static try (func) {\n        try {\n            func();\n        } catch (error) {\n            this.showError(error);\n        }\n    }\n\n    /**\n     * Gets the URL of the calling script.\n     * @returns {string} The URL of the calling script\n     */\n    static callingScriptURL () {\n        const urls = new Error().stackURLs();\n        return urls[1];\n    }\n\n    \n    stackURLs () {\n        let urls = this.stack.split(\"at\");\n        urls.removeFirst();\n        urls = urls.map(url => {\n            \n            if (url.contains(\"(\")) {\n                url = url.after(\"(\");\n            }\n    \n            url = url.strip();\n    \n            const parts = url.split(\":\");\n            parts.removeLast();\n            parts.removeLast();\n            return parts.join(\":\");\n        })\n        return urls;\n    }\n\n    /**\n     * Generates a formatted description of the error.\n     * @returns {string} A formatted description of the error\n     */\n    description () {\n        const error = this;\n        const lines = error.stack.split(\"\\n\");\n        const firstLine = lines.removeFirst();\n        const out = [];\n        const indent = \"    \";\n\t\t\n        lines.forEach(function (line) {\n            if (line.contains(\"at file\")) {\n                out.push([\"....\", line.after(\"at \").split(\"/\").pop()]);\n            } else {\n                line = line.after(\"at \");\n                if (line === \"\") {\n                    return;\n                }\n                const obj = line.before(\".\");\n                const method = line.after(\".\").before(\" (\");\n                const path = line.after(\"(\").before(\")\");\n                const filePart = path.split(\"/\").pop();\n                let file = filePart.before(\":\");\n                if (file === \"\") { \n                    file = \"???.js:??:?\";\n                }\n                const className = file.before(\".js\");\n                const location = filePart.after(\":\");\n                out.push([className + \" \" + method + \"()      \", file + \":\" + location]);\n            }\n        })\n\t\t\n        let s = firstLine + \"\\n\";\n        const m = out.maxValue(function (entry) { return entry[0].length });\n        out.forEach(function (entry) {\n            s += indent + entry[0] + \" \".repeat(m + 1 - entry[0].length) + entry[1] + \"\\n\";\n        })\n\t\t\n        //s = error.message + \"\\n\" + s;\n        s = s.replaceAll(\"<br>\", \"\\n\");\n        return s;\n    }\n\t\n    /**\n     * Logs the error description to the console.\n     */\n    show () {\n        console.warn(this.description());\n    }\n\n}).initThisCategory();\n\n// --- helper functions ---\n\n/**\n * Global assert function.\n * @param {*} v - The value to assert\n * @param {string|function} [errorMessage] - The error message or a function that returns it\n * @returns {*} The asserted value\n * @throws {Error} If the assertion fails\n */\ngetGlobalThis().assert = function assert(v, errorMessage) {\n    return Error.assert(v, errorMessage);\n}\n\n/**\n * Global assertDefined function.\n * @param {*} v - The value to check\n * @param {string|function} [errorMessage] - The error message or a function that returns it\n * @returns {*} The asserted value\n * @throws {Error} If the value is undefined\n */\ngetGlobalThis().assertDefined = function assertDefined(v, errorMessage) {\n    return Error.assertDefined(v, errorMessage);\n}\n\n/**\n * Global assertThrows function.\n * @param {Function} func - The function to test\n * @throws {Error} If the function doesn't throw\n */\ngetGlobalThis().assertThrows = function assertThrows(func) {\n    Error.assertThrows(func);\n}\n",
  "9PFy00BoIvgftlz3H7yGD1cIwlycPa00c3nxwiEDC4g=": "\"use strict\";\n\n/** \n * @module ideal\n * @class Function_ideal\n * @extends Function\n * @description Some extra methods for the Javascript Function primitive\n*/\n\n",
  "x7VG1YKgnIp5PDne/rAW912lccoYDda7lTyvG66mIng=": "\"use strict\";\n\n\n\nif (!getGlobalThis().Image) {\n    console.log(\"WARNING: no Image object found - maybe we are not in browser?\")\n} else {\n\n    /**\n     * @module ideal\n     * @class Image_ideal\n     * @extends Image\n     * @description Some extra methods for the Javascript Image primitive\n     */\n    (class Image_ideal extends Image {\n\n        /**\n         * Sets the delegate object for this image.\n         * @param {Object} anObject - The delegate object\n         * @returns {Image_ideal} This image instance\n         */\n        setDelegate (anObject) {\n            Object.defineSlot(this, \"_delegate\", anObject)\n            return this\n        }\n\n        /**\n         * Gets the delegate object for this image.\n         * @returns {Object|undefined} The delegate object\n         */\n        delegate () {\n            return this._delegate\n        }\n\n        /**\n         * Loads an image from a given URL.\n         * @param {string} url - The URL of the image to load\n         * @returns {Image_ideal} This image instance\n         */\n        loadUrl (url) {\n            this.crossOrigin = \"Anonymous\";\n            this.onload = () => { \n                this.onDidLoad() \n            }\n            this.onerror = () => { \n                console.warn(\"error loading image \" + url)\n            }\n\n            this.src = url;\n            return this\n        }\n\n        /**\n         * Handles the image load event.\n         * Converts the loaded image to a data URL and notifies the delegate.\n         * @returns {Image_ideal} This image instance\n         */\n        onDidLoad () {\n            // create a canvas the size of the image\n            const canvas = document.createElement(\"CANVAS\");\n            canvas.height = this.height;\n            canvas.width = this.width;\n\n            // draw image to the canvas\n            const ctx = canvas.getContext(\"2d\");\n            ctx.drawImage(this, 0, 0);\n\n            // get the image data from the canvas\n            const data = canvas.toDataURL(\"image/jpeg\");\n\n            // tell the delegate about the loaded data\n            if (this._delegate) {\n                /**\n                 * Callback function for the delegate when the image data URL is fetched.\n                 * @callback didFetchDataUrl\n                 * @param {string} data - The image data URL\n                 */\n                this._delegate.didFetchDataUrl(data)\n            }\n\n            return this\n        }\n\n    }).initThisCategory();\n\n}\n",
  "lbaNB8419hFX4MznW7AokgsB4X90DgwCzHZq1KS9Ne8=": "\"use strict\";\n\n/** \n * @module ideal\n    Some code for adding categories to all the typed array types. \n\n*/\n\nType.typedArrayTypeNames().forEach((name) => {\n    const aClass = getGlobalThis()[name]\n\n    if (Type.isUndefined(aClass)) {\n        console.warn(\"TypeArray-store error: missing type \" + name);\n        return;\n    }\n\n    /*\n    Object.defineSlots(aClass, { // class methods\n    })\n    */\n\n    Object.defineSlots(aClass.prototype, { // instance methods\n        base64Encoded: function(aRecord, aStore) {\n            return btoa(String.fromCharCode.apply(null, new Uint8Array(this)));\n        },\n    })\n\n});\n\nObject.defineSlots(ArrayBuffer.prototype, { // TODO: move to ArrayBuffer_ideal\n    base64Encoded: function (aRecord, aStore) {\n        return btoa(String.fromCharCode.apply(null, new Uint8Array(this)));\n    },\n\n    promiseSha256Digest: function () {\n        return crypto.subtle.digest(\"SHA-256\", this);\n     }\n});\n\n//console.log(\"base64Encoded test:\", new Uint32Array([1, 2, 3]).base64Encoded())",
  "l4TgB/NaLRTo36tsAGe47ccJcAOtj0TtLm8ex7w/3Aw=": "\"use strict\";\n\n/**\n * @module ideal\n * @class ImmutableSet\n * @extends Set\n * @description An immutable version of the JavaScript Set primitive with additional methods\n */\n\n(class ImmutableSet extends Set {\n\n    /**\n     * Returns an empty ImmutableSet instance\n     * @returns {ImmutableSet} An empty ImmutableSet\n     */\n    static emptySet () {\n        if (this._emptySet === undefined) {\n            this._emptySet = new this();\n        }\n        return this._emptySet;\n    }\n\n    /**\n     * Creates a new ImmutableSet\n     * @param {Iterable} [values] - The initial values for the set\n     */\n    constructor (values) {\n        const self = super(values);\n        self._isImmutable = true;\n    }\n\n    /**\n     * Attempts to add a value to the set (throws an error if immutable)\n     * @param {*} v - The value to add\n     * @throws {Error} If the set is immutable\n     */\n    add (v) {\n        if (this._isImmutable) {\n            this.onMutationError(\"add\");\n        } else {\n            return super.add(v);\n        }\n    }\n\n    /**\n     * Attempts to clear the set (throws an error if immutable)\n     * @throws {Error} If the set is immutable\n     */\n    clear () {\n        if (this._isImmutable) {\n            this.onMutationError(\"clear\");\n        } else {\n            return super.clear();\n        }\n    }\n\n    /**\n     * Attempts to delete a value from the set (throws an error if immutable)\n     * @param {*} v - The value to delete\n     * @throws {Error} If the set is immutable\n     */\n    delete (v) {\n        if (this._isImmutable) {\n            this.onMutationError(\"delete\");\n        } else {\n            return super.add(v);\n        }\n    }\n\n    /**\n     * Throws an error when a mutation method is called on an immutable set\n     * @param {string} methodName - The name of the method that was called\n     * @throws {Error} Always throws an error\n     * @private\n     */\n    onMutationError (methodName) {\n        throw new Error(\"attempt to call mutation method '\" + methodName + \"' on ImmutableSet\");\n    }\n\n    /**\n     * Runs a self-test to ensure the immutability of the set\n     * @throws {Error} If the self-test fails\n     */\n    static selfTest () {\n        let didThrow = false;\n        try {\n            const set = new ImmutableSet(new Set([1, 2, 3]));\n            set.clear(); // should throw Error: attempt to call mutation method 'clear' on ImmutableSet\n        } catch (e) {\n            didThrow = true;\n        }\n        assert(didThrow);\n    }\n\n}).initThisClass();\n\n//ImmutableSet.selfTest();",
  "hfeoiJtNOnsDqACK3paH/hA07JT/Y1dKubTBVjz/F+8=": "\"use strict\";\n\n/*\n\n    JSON_ideal\n\n    Some extra methods for JSON.\n\n*/\n\n//(class JSON_ideal extends JSON {\n    \nJSON.nodeCount = function (json) {\n    let count = 1; // Start with 1 to count the current node\n    \n    if (Array.isArray(json)) {\n        // If it's an array, recursively count nodes for each element\n        json.forEach(item => {\n        count += countJsonNodes(item);\n        });\n    } else if (typeof json === 'object' && json !== null) {\n        // If it's an object, recursively count nodes for each property\n        Object.values(json).forEach(value => {\n        count += countJsonNodes(value);\n        });\n    }\n    \n    return count;\n}\n    \n//}).initThisCategory();\n\n\n\n",
  "O169p9hHrFc8pVCThKk3W8tJVyU/ufxM9zS91Xhi6hw=": "\"use strict\";\n\n/*\n\n    Slot\n\n    Abstraction for a slot on a prototype. \n    An array of these are stored in each prototype.\n    \n    - stores slot related data, such as:\n        - default value\n        - cloning policy \n        - persistent policy\n        - comment\n        - whether slot can be:\n            - edited\n            - inspected\n        - isPrivate\n        - slotType\n    - handles auto generating getter/setter\n\n    NOTE:\n\n        TODO: hooks code is a mess, need to cleanup and modularize\n*/\n\nif (!getGlobalThis().ideal) {\n    getGlobalThis().ideal = {} \n}\n\ngetGlobalThis().ideal.Slot = (class Slot extends Object { \n\n    setShouldStore (aBool) {\n        throw new Error(\"Slot.setShouldStore should not be called on Slot\");\n    }\n\n    shouldStore () {\n        throw new Error(\"Slot.shouldStore should not be called on Slot\");\n    }\n\n    simpleNewSlot (slotName, initialValue) {  \n        // TODO: unify with Object.newSlot by separating out bit that creates a Slot instance\n        const privateName = \"_\" + slotName;\n        Object.defineSlot(this, privateName, initialValue);\n\n        if (!this[slotName]) {\n            const simpleGetter = function () {\n                return this[privateName];\n            }\n\n            Object.defineSlot(this, slotName, simpleGetter);\n        }\n\n        const setterName = \"set\" + slotName.capitalized();\n\n        if (!this[setterName]) {\n            const simpleSetter = function (newValue) {\n                this[privateName] = newValue;\n                return this;\n            }\n\n            Object.defineSlot(this, setterName, simpleSetter);\n        }\n\n        this._slotNames.add(slotName);\n        \n        return this;\n    }\n\n    initPrototypeSlots () {\n        Object.defineSlot(this, \"_slotNames\", new Set());\n        \n        this.simpleNewSlot(\"owner\", null); // typically a reference to a .prototype\n        this.simpleNewSlot(\"name\", false);\n        this.simpleNewSlot(\"privateName\", null);\n        this.simpleNewSlot(\"setterName\", null);\n        this.simpleNewSlot(\"directSetterName\", null);\n        this.simpleNewSlot(\"initValue\", null); // needed?\n\n        // slot hook names\n        this.simpleNewSlot(\"methodForWillGet\", null);\n        this.simpleNewSlot(\"methodForWillUpdate\", null);\n        this.simpleNewSlot(\"methodForDidUpdate\", null);\n        this.simpleNewSlot(\"methodForUndefinedGet\", null);\n        this.simpleNewSlot(\"methodForOnFinalized\", null);\n        this.simpleNewSlot(\"methodForShouldStoreSlot\", null);\n        //this.simpleNewSlot(\"methodNameCache\", null)\n\n        // getter\n        this.simpleNewSlot(\"ownsGetter\", true);\n        this.simpleNewSlot(\"doesHookGetter\", false);\n        //this.simpleNewSlot(\"hookedGetterIsOneShot\", false) \n        //this.simpleNewSlot(\"isInGetterHook\", false)\n\n        // setter\n        this.simpleNewSlot(\"ownsSetter\", true); // if true, we'll create the setter\n        this.simpleNewSlot(\"doesHookSetter\", false); // if shouldStore, then auto post isDirty?\n        this.simpleNewSlot(\"ownsValue\", false); // if true, and the owner instance gets (for example) a shutdown method, it propogates to the slot value\n        //this.simpleNewSlot(\"doesPostSetter\", false); // posts a didUpdateSlot<SlotName> notification\n\n        // storage related\n        this.simpleNewSlot(\"shouldStoreSlot\", false); // should hook setter\n        this.simpleNewSlot(\"initProto\", null); // clone this proto in init\n        this.simpleNewSlot(\"finalInitProto\", null); // if not set (e.g. by deserialization), clone this proto in finalInit\n        //this.simpleNewSlot(\"shouldFinalInitAsSubnode\", false); // if final init is used, it will add the init instance as a subnode use \"isSubnode\" instead\n        this.simpleNewSlot(\"isSubnode\", null); // in finalInit, add value as subnode if not already present\n        this.simpleNewSlot(\"isSubnodeField\", null); // in finalInit, create a field for the slot and add as subnode\n        this.simpleNewSlot(\"isSubnodeFieldVisible\", true); // sets isVisible on Field when created\n\n        this.simpleNewSlot(\"valueClass\", null); // declare the value should be a kind of valueClass\n        //this.simpleNewSlot(\"field\", null);\n        //this.simpleNewSlot(\"isLazy\", false); // should hook getter\n        this.simpleNewSlot(\"isWeak\", false); // should hook getter\n\n        // debugging \n        //this.simpleNewSlot(\"doesBreakInGetter\", false) // uses \"debugger;\"\n        //this.simpleNewSlot(\"doesBreakInSetter\", false) // uses \"debugger;\"\n\n        // copying behavior\n        //this.simpleNewSlot(\"initOp\", \"copyValue\")\n        //this.simpleNewSlot(\"validInitOps\", new Set([\"null\", \"lazy\", \"proto\", \"nop\", \"copyValue\", \"duplicate\"])) \n        this.simpleNewSlot(\"duplicateOp\", \"nop\");\n        this.simpleNewSlot(\"validDuplicateOps\", new Set([\"nop\", \"copyValue\", \"duplicate\"]));\n        this.simpleNewSlot(\"comment\", null);\n        this.simpleNewSlot(\"isPrivate\", false);\n\n        // inspector related\n        // slotType is a string value, eg: \"Boolean\", \"String\", \"Number\", \"Action\" - can be used to find a class \n        // to create an inspector node for the slotValue\n        this.simpleNewSlot(\"slotType\", null);\n        this.simpleNewSlot(\"canInspect\", false);\n        this.simpleNewSlot(\"canEditInspection\", true);\n        this.simpleNewSlot(\"label\", null); // visible label on inspector\n        this.simpleNewSlot(\"allowsNullValue\", false); // used for validation\n        this.simpleNewSlot(\"validValues\", null); // used for options field and validation\n        this.simpleNewSlot(\"validValuesClosure\", null);\n        this.simpleNewSlot(\"validatesOnSet\", true);\n        this.simpleNewSlot(\"allowsMultiplePicks\", false);\n        this.simpleNewSlot(\"inspectorPath\", null); // if non-null, uses to create a path for the slot inspector\n        this.simpleNewSlot(\"summaryFormat\", \"none\"); // passed into slot inspector node\n\n        this.simpleNewSlot(\"syncsToView\", false); // if true, will hook slot setter to call this.scheduleSyncToView() on slotValue change (implemented by ViewableNode)\n        this.simpleNewSlot(\"syncsToNode\", false); // if true, will hook slot setter to call this.scheduleSyncToNode() on slotValue change (implemented by NodeView)\n\n        this.simpleNewSlot(\"actionMethodName\", null); // used by slots that will be represented by ActionFields to store the methodName\n        this.simpleNewSlot(\"annotations\", null);\n        this.simpleNewSlot(\"fieldInspectorClassName\", null);\n    }\n\n    setFinalInitProto (aProto) {\n        this._finalInitProto = aProto;\n        if (aProto && this.slotType() === null) {\n            this.setSlotType(aProto.type()); // hack\n        }\n        return this;\n    }\n    // --- label ---\n\n    setLabelToCapitalizedSlotName () {\n        let s = this.name().capitalized();\n        // If the name was camel case, we want to split it into words.\n        s = s.replace(/([A-Z])/g, ' $1').trim();\n        this.setLabel(s);\n        return this;\n    }\n\n    // --- annotations ---\n\n    setValidValues (v) {\n        this._validValues = v;\n\n        // sanity check\n        if (v) {\n            const isValid = this._validValues.includes(this.initValue());\n            if (!isValid) {\n                const isOptionsDict = Type.isArray(v) && v.length && v.first().label;\n                if (!isOptionsDict) {\n                    console.log(\"ERROR Slot.setValidValues:\")\n                    const s = \"this._validValues: \" + JSON.stableStringify(this._validValues) + \" doesn't contain '\" + this.initValue() + \"'\";\n                    console.log(s)\n                    debugger;\n                    //throw new Error(\"valid values constraint not met: \" + s)\n                }\n            }\n        }\n        return this\n    }\n\n    // --- annotations ---\n\n    annotations () {\n        if (!this._annotations) {\n            this._annotations = new Map();\n        }\n        return this._annotations;\n    }\n\n    setAnnotation (key, value) {\n        this.annotations().set(key, value);\n        return this;\n    }\n\n    hasAnnotation (key) {\n        return this.annotations().has(key);\n    }\n\n    getAnnotation (key) {\n        return this.annotations().get(key);\n    }\n\n    removeAnnotation () {\n        this.annotations().delete(key);\n        return this\n    }\n\n    // --- value placeholder ---\n\n    setValuePlaceholder (s) {\n        this.setAnnotation(\"valuePlaceholder\", s);\n        return this;\n    }\n\n    valuePlaceholder () {\n        return this.getAnnotation(\"valuePlaceholder\");\n    }\n\n    // --- subnode field helpers ---\n\n    setNodeFillsRemainingWidth (aBool) {\n        this.setAnnotation(\"nodeFillsRemainingWidth\", aBool);\n        return this;\n    }\n\n    nodeFillsRemainingWidth () {\n        return this.getAnnotation(\"nodeFillsRemainingWidth\") === true;\n    }\n\n    setKeyIsVisible (aBool) {\n        this.setAnnotation(\"keyIsVisible\", aBool);\n        return this\n    }\n\n    keyIsVisible () {\n        return this.getAnnotation(\"keyIsVisible\") !== false;\n    }\n\n    // --- standard annotations ---\n\n    setShouldJsonArchive (aBool) {\n        this.setAnnotation(\"shouldJsonArchive\", aBool);\n        return this\n    }\n\n    shouldJsonArchive () {\n        return this.getAnnotation(\"shouldJsonArchive\");\n    }\n\n    // --- description ---\n\n    setDescription (s) {\n        this.setAnnotation(\"description\", s);\n        return this;\n    }\n\n    description () {\n        return this.getAnnotation(\"description\");\n    }\n\n    setDescriptionAndPlaceholder (s) {\n        this.setDescription(s);\n        this.setValuePlaceholder(s);\n        return this;\n    }\n\n    // --- examples ---\n\n    setExamples (anArray) {\n        this.setAnnotation(\"examples\", anArray);\n        return this;\n    }\n\n    examples () {\n        return this.getAnnotation(\"examples\");\n    }\n\n    // --- read only ---\n\n    setIsReadOnly (aBool) {\n        this.setAnnotation(\"readOnly\", aBool);\n        return this;\n    }\n\n    isReadOnly () {\n        return this.getAnnotation(\"readOnly\");\n    }\n    \n    // --- required ---\n\n    setIsRequired (b) {\n        this.setAnnotation(\"isRequired\", b);\n        return this;\n    }\n\n    isRequired () {\n        const b = this.getAnnotation(\"isRequired\");\n        if (b === undefined) {\n            return true; //  default to true\n        }\n        return b;\n    }\n\n    // --- json schema (to set directly) if value is raw json ---\n\n    setJsonSchema (schema) {\n        this.setAnnotation(\"jsonSchema\", schema);\n        return this;\n    }\n\n    jsonSchema () {\n        return this.getAnnotation(\"jsonSchema\");\n    }\n\n    // --- items type ---\n\n    validJsonSchemaItemsTypes () {\n        const validItemsTypes = [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\", \"integer\"];\n        return validItemsTypes;\n    }\n\n    setJsonSchemaItemsType (s) {\n        assert(Type.isString(\"string\"));\n        //assert(this.validJsonSchemaItemsTypes().contains(s));\n        this.setAnnotation(\"jsonSchemaItemsType\", s);\n        return this;\n    }\n\n    jsonSchemaItemsType () {\n        return this.getAnnotation(\"jsonSchemaItemsType\");\n    }\n\n    // --- items description ---\n\n    setJsonSchemaItemsDescription (s) {\n        this.setAnnotation(\"jsonSchemaItemsDescription\", s);\n        return this;\n    }\n\n    jsonSchemaItemsDescription () {\n        return this.getAnnotation(\"jsonSchemaItemsDescription\");\n    }\n\n    // --- items ref ---\n\n    setJsonSchemaItemsRef (s) {\n        this.setAnnotation(\"jsonSchemaItemsRef\", s);\n        return this;\n    }\n\n    jsonSchemaItemsRef () {\n        return this.getAnnotation(\"jsonSchemaItemsRef\");\n    }\n\n    // --- items is unique ---\n\n    setJsonSchemaItemsIsUnique (b) {\n        this.setAnnotation(\"jsonSchemaItemsIsUnique\", b);\n        return this;\n    }\n\n    jsonSchemaItemsIsUnique () {\n        return this.getAnnotation(\"jsonSchemaItemsIsUnique\");\n    }\n\n    // --- is in json schema ---\n\n    setIsInJsonSchema (b) {\n        this.setAnnotation(\"isInJsonSchema\", b);\n        return this;\n    }\n\n    isInJsonSchema () {\n        return this.getAnnotation(\"isInJsonSchema\");\n    }\n\n    // --- inspector ---\n\n    fieldInspectorClassName () {\n        if (Type.isString(this._fieldInspectorClassName)) {\n            return this._fieldInspectorClassName;\n        }\n        return this.defaultFieldInspectorClassName();\n    }\n\n    defaultFieldInspectorClassName () {\n        const slotType = this.slotType();\n        assert(!Type.isNull(slotType), \"slotType is null for slot: \" + this.name());\n        let fieldName = \"BM\" + slotType + \"Field\";\n\n        if (this.validValues() || this.validValuesClosure()) {\n            fieldName = \"BMOptionsNode\";\n        }\n        \n        return fieldName;\n    }\n\n    newInspectorField () {\n        const slotType = this.slotType();\n        if (slotType /*&& this.canInspect()*/) {\n            const fieldName = this.fieldInspectorClassName();\n            let proto = getGlobalThis()[fieldName];\n\n            if (!proto) {\n                //let nodeName = \"BM\" + slotType + \"Node\";\n                const nodeName = \"BMPointerField\";\n                proto = getGlobalThis()[nodeName];\n            }\n\n            if (proto) {\n                const field = proto.clone();\n\n                field.setKey(this.name());\n                field.setKeyIsEditable(false);\n                field.setValueMethod(this.name());\n                field.setValueIsEditable(this.canEditInspection());\n                field.setCanDelete(false);\n\n                if (field.setValuePlaceholderText) {\n                    const p = this.valuePlaceholder();\n                    if (p) {\n                        field.setValuePlaceholderText(this.valuePlaceholder());\n                    }\n                }\n                //assert(!field.nodeCanAddSubnode());\n\n                if (this.label()) {\n                    if (slotType === \"Action\") { // TODO: hack - find a uniform way to handle this\n                        field.setTitle(this.label());\n                        field.setMethodName(this.actionMethodName());\n                    } else {\n                        field.setKey(this.label());\n                    }\n                }\n\n                if (this.validValues()) {\n                    field.setValidValues(this.validValues());\n                    field.setAllowsMultiplePicks(this.allowsMultiplePicks());\n                    field.setNodeSubtitleIsChildrenSummary(true);\n                } else if (this.validValuesClosure()) {\n                    field.setValidValuesClosure(this.validValuesClosure());\n                    field.setAllowsMultiplePicks(this.allowsMultiplePicks());\n                    field.setNodeSubtitleIsChildrenSummary(true);\n                }\n                return field;\n            }\n        }\n        return null;\n    }\n\n    computedValidValues () {\n        if (this.validValues()) {\n            return this.validValues();\n        } else if (this.validValuesClosure()) {\n            return this.validValuesClosure()();\n        }\n        return null;\n    }\n\n    validDuplicateOps () {\n        return new Set([\"nop\", \"copyValue\", \"duplicate\"]);\n    }\n    \n    setDuplicateOp (aString) {\n        assert(this.validDuplicateOps().has(aString));\n        this._duplicateOp = aString;\n        return this;\n    }\n\n    /*\n    onInstanceGetDuplicateValue (anInstance) {\n        const v = this.onInstanceGetValue(anInstance)\n        const dop = this.duplicateOp()\n\n        if (v === null) {\n            return null\n        } else if (dop === \"nop\") {\n            return v\n        } else if (dop === \"copyValue\") {\n            return v\n        } else if (dop === \"duplicate\" && v && v.duplicate) {\n            return v.duplicate()\n        }\n\n        throw new Error(\"unable to duplicate\")\n    }\n    */\n\n    setName (aName) {\n        assert(Type.isString(aName) && aName.trim().length > 0);\n        this._name = aName;\n        const n = this.name().capitalized();\n        this.setPrivateName(\"_\" + aName);\n        this.setSetterName(\"set\" + n);\n\n        //this.updateCachedMethodNames();\n\n        this.setDirectSetterName(\"directSet\" + n); // -> getCachedMethodNameFor(\"directSet\")\n        this.setMethodForWillGet(\"willGetSlot\" + n);\n        this.setMethodForDidUpdate(\"didUpdateSlot\" + n);\n        this.setMethodForWillUpdate(\"willUpdateSlot\" + n);\n        this.setMethodForUndefinedGet(\"onUndefinedGet\" + n); // for lazy slots\n        this.setMethodForOnFinalized(\"onFinalizedSlot\" + n); // for weak slots\n        this.setMethodForShouldStoreSlot(\"shouldStoreSlot\" + n); // for weak slots\n        return this;\n    }\n\n    // --- method name cache ---\n\n    /*\n    addCachedMethodName (k) {\n        this.methodNameCache().set(k, k + this.name().capitalized());\n        return this\n    }\n\n    updateCachedMethodNames () {\n        this.addCachedMethodName(\"directSet\" );\n        this.addCachedMethodName(\"willGetSlot\");\n        this.addCachedMethodName(\"didUpdateSlot\");\n        this.addCachedMethodName(\"willUpdateSlot\");\n        this.addCachedMethodName(\"onUndefinedGet\") ;// for lazy slots\n        this.addCachedMethodName(\"onFinalizedSlot\"); // for weak slots\n        this.addCachedMethodName(\"shouldStoreSlot\") ;// for weak slots\n    }\n\n    getCachedMethodNameFor (k) {\n        const result = this.methodNameCache().set(k, v);\n        if(typeof(result) === \"string\") {\n            throw new Error(\"missing method name cache for '\" + k + \"'\");\n        }\n        return result;\n    }\n    */\n\n    // ---\n\n    copyFrom (aSlot) {\n        // This is used by overrideSlot().\n        // Need to be careful about non json slot values.\n\n        this._slotNames.forEach(slotName => {\n            const privateName = \"_\" + slotName;\n            let value = aSlot[privateName];\n\n            if (slotName === \"owner\") {\n                if (value.isPrototype()) {\n                    // assume this gets set after the copy if needed\n                }\n            } else if (slotName === \"initProto\") {\n                // ok to copy this\n            //} else if (!Type.isDeepJsonType(value)) {\n            } else {\n                value = Type.deepCopyForValue(value);\n            }\n            \n            this[privateName] = value;\n            /*\n            const setterName = \"set\" + slotName.capitalized()\n            const v = aSlot[slotName].apply(aSlot)\n            this[setterName].call(this, v)\n            */\n        });\n        return this;\n    }\n\n    autoSetGetterSetterOwnership () {\n        this.setOwnsGetter(!this.alreadyHasGetter());\n        this.setOwnsSetter(!this.alreadyHasSetter());\n        return this;\n    }\n\n    hookNames () {\n        const hookMethodNames = this._slotNames.filter(n => n.beginsWith(\"methodFor\"));\n        const hookNames = hookMethodNames.map(n => this[n].apply(this));\n        return hookNames;\n    }\n\n    ownerImplemnentsdHooks () {\n        return true\n        /*\n        const slotsMap = this.owner().slotsMap() // TODO: this is slow\n        return this.hookNames().canDetect(hookName => slotsMap.has(hookName)) \n        */\n    }\n\n    setDoesHookSetter (aBool) {\n        if (this._doesHookSetter !== aBool) {\n            this._doesHookSetter = aBool;\n            if (aBool) {\n                if (this.alreadyHasSetter() && !this.ownsSetter()) {\n                    const msg = this.owner().type() + \".\" + this.setterName() + \"() exists, so we can't hook it - fix by calling slot.setOwnsSetter(true)\";\n                    console.log(msg);\n                    throw new Error(msg);\n                } \n                // this.setOwnsSetter(true);\n            }\n            //this.setupSetter();\n        }\n        return this;\n    }\n\n    // setup\n\n    setupInOwner () {\n        this.autoSetGetterSetterOwnership();\n        this.setupValue();\n        this.setupGetter();\n        this.setupSetter();\n        return this;\n    }\n\n    setupValue () {\n        Object.defineSlot(this.owner(), this.privateName(), this.initValue());\n        return this;\n    }\n\n    // getter\n\n    alreadyHasGetter () {\n        return this.owner().hasOwnProperty(this.getterName()); // TODO: hasOwnProperty? \n    }\n\n    setupGetter () {\n        if (this.ownsGetter()) {\n            if (this.ownerImplemnentsdHooks()) {\n                Object.defineSlot(this.owner(), this.getterName(), this.autoGetter());\n            } else {\n                this.makeDirectGetter();\n            }\n        }\n        return this;\n    }\n\n    alreadyHasSetter () {\n        return this.owner().hasOwnProperty(this.setterName());  // TODO: hasOwnProperty? \n    }\n\n    setupSetter () {\n        if (this.ownsSetter()) {\n            if (this.ownerImplemnentsdHooks()) {\n                Object.defineSlot(this.owner(), this.setterName(), this.autoSetter());\n            } else {\n                this.makeDirectSetter();\n            }\n            //Object.defineSlot(this.owner(), this.directSetterName(), this.directSetter());\n        }\n    }\n\n    // --- getter ---\n\n    getterName () {\n        return this.name();\n    }\n\n    // direct getter\n\n    makeDirectGetter () {\n        Object.defineSlot(this.owner(), this.getterName(), this.directGetter());\n        return this;\n    }\n\n    directGetter () {\n        assert(arguments.length === 0);\n        const privateName = this.privateName();\n        const func = function () {\n            return this[privateName];\n        }\n        return func;\n    }\n\n    // hooked getter\n\n    makeDirectGetterOnInstance (anInstance) {\n        Object.defineSlot(anInstance, this.getterName(), this.directGetter());\n        return this;\n    }\n\n    // ----------------------------------------\n\n    autoGetter () {\n        const slot = this;\n        return function (arg) { \n           // assert(Type.isUndefined(arg)); // TODO: remove this\n            return this.getSlotValue(slot);\n        }\n    }\n\n    validateValue (v) {\n        if (v === null && this.allowsNullValue() === true) {\n            return true;\n        }\n\n        //const validValues = this.computedValidValues(); // closure may reference unloaded classes...\n        const validValues = this.validValues();\n        \n        if (validValues === null) {\n            return true;\n        }\n        \n        if (validValues.includes(v)) {\n            return true;\n        }\n\n        function ValidValue_hasLabel (self, label) {\n            if (self.label === label) {\n                return true;\n            }\n            if (self.options) {\n                return ValidValues_haveLabel(self.options, label);\n            }\n            return false;\n        }\n\n        function ValidValues_haveLabel (validValues, label) {\n            return validValues.detect(vv => ValidValue_hasLabel(vv, v));\n        }\n\n        if (ValidValues_haveLabel(validValues, v)) {\n            return true;\n        }\n\n        return false;\n    }\n\n    autoSetter () {\n        const slot = this;\n        return function (newValue) {\n            if (slot.validatesOnSet()) {\n                const isValid = slot.validateValue(newValue);\n                if (!isValid) {\n                    const validValues = slot.validValues();\n                    const errorMsg = \"WARNING: \" + this.type() + \".\" + slot.setterName() +  \"() called with invalid argument value (\" + Type.typeName(newValue) + \") '\" + newValue + \"' not in valid values: \" + validValues;\n                    console.log(errorMsg);\n                    let initValue = slot.initValue();\n                    //assert(initValue);\n                    console.log(\"RESOLUTION: setting value to initValue: \", initValue);\n                    //debugger;\n                    newValue = initValue; //validValues.first(); // not safe\n                    //throw new Error(errorMsg);\n                }\n            }\n\n            return this.setSlotValue(slot, newValue);\n        };\n    }\n\n    // --- setter ---\n\n    makeDirectSetter () {\n        Object.defineSlot(this.owner(), this.setterName(), this.directSetter());\n        return this;\n    }\n\n    directSetter () {\n        const privateName = this.privateName();\n        const func = function (newValue) {\n            this[privateName] = newValue;\n            return this;\n        }\n        return func;\n    }\n\n    // call helpers\n\n    onInstanceRawGetValue (anInstance) {\n        return anInstance[this.privateName()];\n    }\n\n    onInstanceGetValue (anInstance) {\n        return anInstance[this.getterName()].apply(anInstance);\n    }\n\n    onInstanceSetValue (anInstance, aValue) {\n        const m = anInstance[this._setterName];\n        if (Type.isUndefined(m)) {\n            throw new Error(anInstance.type() + \" is missing setter '\" + this._setterName + \"'\");\n        }\n        return m.call(anInstance, aValue); // not consistent with rawset to return this...\n    }\n\n    onInstanceRawSetValue (anInstance, aValue) {\n        anInstance[this._privateName] = aValue;\n        return this;\n    }\n\n    // --- StoreRefs for lazy slots ---\n\n    onInstanceSetValueRef (anInstance, aRef) {\n        anInstance.lazyRefsMap().set(this.name(), aRef);\n        return this;\n    }\n\n    onInstanceGetValueRef (anInstance, aRef) {\n        return anInstance.lazyRefsMap().get(this.name());\n    }\n\n    copyValueFromInstanceTo (anInstance, otherInstance) {\n        /*\n        if (this.isLazy()) {\n            const valueRef = this.onInstanceGetValueRef(anInstance);\n            if (valueRef) {\n                this.onInstanceSetValueRef(otherInstance, valueRef);\n                return this;\n            }\n        }\n        */\n\n        const v = this.onInstanceGetValue(anInstance);\n        this.onInstanceSetValue(otherInstance, v);\n        return this;\n    }\n\n    // -----------------------------------------------------\n\n    finalInitProtoClass () {\n        let finalInitProto = this._finalInitProto;\n        if (typeof(finalInitProto) === \"string\") {\n            const finalInitClass = getGlobalThis()[finalInitProto];\n            assert(finalInitClass, \"missing finalInitProto class '\" + finalInitProto + \"'\");\n            finalInitProto = finalInitClass;\n        }\n        return finalInitProto;\n    }\n\n    onInstanceFinalInitSlot (anInstance) {\n        assert(this.slotType() !== null, \" slotType is null for \" + anInstance.type() + \".\" + this.name());\n\n        const finalInitProto = this.finalInitProtoClass(); //this._finalInitProto;\n        if (finalInitProto) {\n            let oldValue = this.onInstanceGetValue(anInstance);\n\n            if (oldValue && oldValue.type() !== finalInitProto.type()) {\n                const warning = \"slot '\" + this.name() + \"' finalInitProto type (\" + finalInitProto.type() + \") does not match existing value (\" + oldValue.type() + \") from Store\";\n                console.warn(warning);\n                debugger;\n                //throw new Error(warning);\n                oldValue = null; // let the code below override it\n            }\n\n            if (Type.isNullOrUndefined(oldValue)) {\n            //if (oldValue === null) {\n\n                /*\n                let newValue;\n                if (this.isSubnode()) { // see if it's already a subnode\n                    const oldSubnode = anInstance.firstSubnodeOfType(finalInitProto);\n                    if (oldSubnode) {\n                        newValue = oldSubnode;\n                    } else {\n                        const newSubnode = finalInitProto.clone();\n                        this.addSubnode(newSubnode);\n                        newValue = newSubnode;\n                    }\n                } else {\n                    newValue = finalInitProto.clone();\n                }\n                */\n\n                /*\n                if (typeof(finalInitProto) === \"string\") {\n                    const finalInitClass = getGlobalThis()[finalInitProto];\n                    assert(finalInitClass, \"missing finalInitProto class '\" + finalInitProto + \"'\");\n                    finalInitProto = finalInitClass;\n                }\n                    */\n\n                const newValue = finalInitProto.clone();\n                this.onInstanceSetValue(anInstance, newValue);\n\n                /*\n                if (this.shouldFinalInitAsSubnode()) {\n                    anInstance.addSubnode(newValue);\n                    \n                    const title = this.finalInitTitle();\n                    if (title) {\n                        newValue.setTitle(title);\n                        anInstance.subnodeWithTitleIfAbsentInsertProto(title, finalInitProto);\n                    } else {\n                        anInstance.addSubnode(newValue);\n                    }\n                }\n                */\n            } \n        }\n\n        if (this.isSubnode()) { \n            // sanity check - we don't typically want to add it automatically if subnodes are stored\n            assert(anInstance.shouldStoreSubnodes() === false);\n            const value = this.onInstanceGetValue(anInstance);\n            assert(value);\n            anInstance.assertValidSubnodeType(value); // tmp - this is also done in addSubnode\n            anInstance.addSubnode(value);\n        }\n\n        if (this.isSubnodeField()) {\n            assert(anInstance.shouldStoreSubnodes() === false, \"error on slot definition '\" + this.name() + \"' subnode fields are not supported with shouldStoreSubnodes\");\n            anInstance.addSubnodeFieldForSlot(this);\n        }\n    }\n\n    onInstanceInitSlot (anInstance) {\n        //assert(Reflect.has(anInstance, this.privateName())) // make sure slot is defined - this is true even if it's value is undefined\n        let defaultValue = anInstance[this._privateName];\n\n        /*\n        const op = this.initOp();\n        assert(this.validInitOps().contains(op)); // TODO: put on setter instead\n\n        const opMethods = {\n            \"null\" : () => { \n                this.onInstanceSetValue(anInstance, null);\n            },\n\n            \"lazy\" : () => { \n                const obj = this.initProto().clone();\n                anInstance[this.privateName()] = obj;\n            },\n\n            \"proto\" : () => { \n                const obj = this.initProto().clone();\n                this.onInstanceSetValue(anInstance, obj);\n            },\n\n            \"nop\" : () => { \n            },\n\n            \"copyValue\" : () => { \n                this.onInstanceSetValue(anInstance, defaultValue);\n            },\n    \n            \"duplicate\" : () => { \n                if (defaultValue) {\n                    const obj = defaultValue.duplicate();\n                    this.onInstanceSetValue(anInstance, obj);\n                }\n            },\n        }\n\n        opMethods[op].apply(this);\n        */\n\n        const initProto = this._initProto;\n        /*\n        if (this.isLazy()) {\n            const obj = initProto.clone();\n            anInstance[this._privateName] = obj;\n        } else */ \n        if (initProto) {\n            const obj = initProto.clone();\n            this.onInstanceSetValue(anInstance, obj);\n        } /*\n        else if (this._initValue) {\n            this.onInstanceSetValue(anInstance, this._initValue);\n        }\n        */\n\n        /*\n        if (this.field()) {\n            // duplicate the field instance owned by the slot,\n            // add it as a subnode to the instance,\n            // and sync it to the instance's slot value\n            const newField = this.field().duplicate();\n            anInstance.addSubnode(newField);\n            newField.getValueFromTarget();\n        }\n        */\n    }\n\n    onInstanceLoadRef (anInstance) {\n        const storeRef = this.onInstanceGetValueRef(anInstance);\n        if (storeRef) {\n            \n            //console.warn(anInstance.typeId() + \".\" + this.name() + \" [\" + anInstance.title() + \"] - loading storeRef\");\n            //console.warn(anInstance.title() + \" loading storeRef for \" + this.name());\n            const obj = storeRef.unref();\n            /*\n            //console.warn(\"   loaded: \" + obj.type());\n            anInstance[this.privateName()] = obj; // is this safe? what about initialization?\n            //this.onInstanceSetValue(anInstance, obj);\n            this.onInstanceSetValueRef(anInstance, null);\n            */\n\n            const setter = anInstance[this.setterName()];\n            setter.apply(anInstance, [obj]); // WARNING: this may mark objects as dirty\n\n        } else {\n            //console.warn(anInstance.typeId() + \" unable to load storeRef - not found\");\n            //console.warn(anInstance.typeId() + \".shouldStoreSubnodes() = \" + anInstance.shouldStoreSubnodes());\n            //throw new Error(\"\");\n        }\n    }\n\n    hasSetterOnInstance (anInstance) {\n        return Type.isFunction(anInstance[this.setterName()]);\n    }\n\n    // --- should store on instance ---\n\n    shouldStoreSlotOnInstance (anInstance) {\n        const methodName = this.methodForShouldStoreSlot();\n        const method = anInstance[methodName];\n        if (method) {\n            const v = method.apply(anInstance);\n            if (Type.isBoolean(v)) { // allows instance to result null to use slot's own value\n                return v;\n            }\n        }\n        return this.shouldStoreSlot();\n    }\n\n    /*\n    setShouldStoreSlotOnInstance (anInstance, aBool) {\n        const k = this.shouldStoreSlotOnInstancePrivateName();\n        Object.defineSlot(anInstance, k, aBool);\n        return aBool;\n    }\n    */\n\n    // --- JSON schema ---\n\n    /*\n        Valid JSON schema properties:\n\n        [\n        \"$id\",\n        \"$schema\",\n        \"$ref\",\n        \"$comment\",\n        \"title\",\n        \"description\",\n        \"type\",\n        \"properties\",\n        \"items\",\n        \"required\",\n        \"additionalProperties\",\n        \"definitions\",\n        \"pattern\",\n        \"minLength\",\n        \"maxLength\",\n        \"minimum\",\n        \"maximum\",\n        \"enum\",\n        \"format\",\n        \"default\",\n        \"examples\",\n        \"dependencies\",\n        \"patternProperties\",\n        \"minItems\",\n        \"maxItems\",\n        \"uniqueItems\",\n        \"multipleOf\"\n    ];\n    */\n\n    jsonSchemaType () {\n        //const validJsonTypeValues = [\"null\", \"boolean\", \"object\", \"array\", \"number\", \"string\", \"integer\"];\n\n        let type = this.slotType();\n\n        // what about integer?\n\n        const passThroughTypes = new Set([\"String\", \"Number\", \"Boolean\", \"Array\"])\n\n        if (passThroughTypes.has(type)) {\n            return type.toLowerCase();\n        }\n\n        if (type === \"Action\") {\n            return null;\n        }\n\n        return \"object\";\n    }\n\n    jsonSchemaTitle () {\n        return this.name(); // slot name\n    }\n\n    jsonSchemaDescription () {\n        return this.description();\n    }\n\n    jsonSchemaExamples () {\n        return this.examples();\n    }\n\n    jsonSchemeAddRanges (schema) {\n        const a = this.jsonSchemaEnum();\n        if (a) {\n            const enumArray = a.shallowCopy();\n\n            if (schema.type === \"number\") {\n                enumArray.sort((a, b) => a - b)\n\n                const hasANonInteger = enumArray.filter(v => { return !Type.isInteger(v); }).length > 0;\n                if (!hasANonInteger) {\n                    schema.type = \"integer\";\n                }\n\n                const isContiguous = enumArray.length > 1 && enumArray.every((v, i, a) => { return i === 0 || v === a[i - 1] + 1; });\n                if (isContiguous) {\n                    // items were sorted, so we can just grab the first and last\n                    const min = enumArray.first();\n                    const max = enumArray.last();\n                    schema.minimum = min;\n                    schema.maximum = max;\n                } else {\n                    schema.enum = enumArray;\n                }\n            } else {\n                schema.enum = enumArray;\n            }\n        }\n    }\n\n    jsonSchemaEnum () {\n        const enumArray = [];\n\n        const validValues = this.computedValidValues();\n        if (validValues) {\n            validValues.forEach(v => {\n                assert(Type.isDeepJsonType(v));\n                if (!Type.isNull(v) && v.label) {\n                    enumArray.push(v.label);\n                } else {\n                    enumArray.push(v);\n                }\n            });\n\n            if (this.allowsNullValue() && !validValues.includes(null)) {\n                enumArray.push(null);\n            }\n        }\n\n        return enumArray.length ? enumArray : undefined;\n    }\n\n    jsonSchemaProperties (refSet) {\n        assert(refSet);\n        const proto = this.finalInitProtoClass();\n        if (proto) {\n            if (Type.isString(proto)) {\n                return {\n                    \"$ref\": BMNode.jsonSchemaRefForTypeName(proto, refSet)\n                };\n            } else {\n                return {\n                    \"$ref\": proto.jsonSchemaRef(refSet)\n                };\n            }\n            //return proto.jsonSchemaProperties(refSet);\n        }\n        return undefined;\n    }\n\n    jsonSchemaRequired () {\n        const proto = this.finalInitProto();\n        if (proto) {\n            return proto.jsonSchemaRequired();\n        }\n        return undefined;\n    }\n\n    /*\n    setJsonSchemaTitle (title) {\n        debugger;\n        this.setName(title); // can't do this after initPrototype\n        return this;\n    }\n\n    setJsonSchema (schema) {\n        this.setJsonSchemaTitle(schema.description);\n        this.setJsonSchemaDescription(schema.description);\n        this.setJsonSchemaExamples(schema.examples);\n        this.setJsonSchemaEnum(schema.enum);\n        assert(!schema.properties); // only definitions schemas should have properties\n\n        //this.setSlotType(schema.type);\n        return this;\n    }\n    */\n\n\n    asJsonSchema (refSet) {\n        assert(refSet);\n        if (this.jsonSchema()) {\n            // has a direct json schema\n            const schema = this.jsonSchema();\n            // need to recursively decend into the schema to find refs\n            // and add them to the refSet\n            \n            return schema;\n        }\n\n        //otherwise, compose one from the slot meta info\n\n        assert(refSet);\n\n        const properties = this.jsonSchemaProperties(refSet);\n\n        if (properties !== undefined && properties[\"$ref\"] !== undefined) {\n            // it's a reference, so just return the properties\n            return properties;\n        }\n\n        const type = this.jsonSchemaType();\n\n        // it's probably a base type\n        const schema = {\n            type: this.jsonSchemaType(),\n            description: this.jsonSchemaDescription(),\n            //enum: this.jsonSchemaEnum(), // use jsonSchemeAddRanges instead\n            properties: this.jsonSchemaProperties(refSet),\n            readOnly: this.isReadOnly()\n        };\n\n        if (this.initValue() !== undefined) {\n            schema.default = this.initValue();\n        }\n\n        const title = this.jsonSchemaTitle();\n\n        if (this.name() !== title) {\n            schema.title = title;\n        }\n\n        if (this.jsonSchemaExamples()) {\n            schema.examples = this.jsonSchemaExamples();\n        }\n\n        this.jsonSchemeAddRanges(schema);\n\n        // handle array type\n        const itemsType = this.jsonSchemaItemsType();\n\n        if (itemsType) {\n            schema.items = {\n                \"description\": this.jsonSchemaItemsDescription(),\n                \"uniqueItems\": this.jsonSchemaItemsIsUnique()\n            }\n\n           if (this.validJsonSchemaItemsTypes().contains(itemsType)) {\n                schema.items.type = itemsType; // it's a json type\n           } else {\n                // it's a class \n                const aClass = getGlobalThis()[itemsType];\n                assert(aClass && aClass.isClass());\n                schema.items[\"$ref\"] = aClass.jsonSchemaRef(refSet);\n            }\n        \n        }\n\n        if (this.allowsMultiplePicks()) {\n            assert(schema.type === \"array\"); // sanity check\n            assert(schema.properties === undefined); // sanity check\n        }\n\n        return schema;\n    }\n\n    // ----------------------------------------------------------\n\n    acceptsValue (v) {\n        //const typeNames = Type.typeNamesForValue(value);\n        const valueType = Type.typeName(v);\n        const slotType = this.slotType();\n\n        if (slotType === valueType) {\n            return true;\n        }\n\n        if (Type.isNull(v)) {\n            if (slot.allowsNullValue()) {\n                return true;\n            }\n        }\n\n        if (slotType === \"JSON Object\") {\n            debugger;\n        }\n\n\n        if (slotType.hasSuffix(\" Class\")) {\n            debugger;\n        }\n\n        if (slotType === \"Action\") {\n            return true;\n        }\n\n        const slotTypeClass = getGlobalThis()[slotType];\n\n        /*\n        if (v.thisClass().classNameSet().has(slotType)) {\n            return true;\n        }\n        */\n\n        if (v.thisClass().isKindOf(slotTypeClass)) {\n            return true;\n        }\n\n        /*\n\n        if (this.slotType() === \"String\") {\n            if (Type.isString(v)) {\n                return true;\n            }\n        }\n\n        if (this.slotType() === \"Number\") {\n            if (Type.isNumber(v)) {\n                return true;\n            }\n        }\n\n        if (this.slotType() === \"Boolean\") {\n            if (Type.isBoolean(v)) {\n                return true;\n            }\n        }\n\n\n        if (this.slotType() === \"Array\") {\n            if (Type.isArray(v)) {\n                return true;\n            }\n        }\n        */\n \n        return false;\n    }\n\n    onInstanceSetValueWithJsonSchemaTypeCheck (anInstance, v) {\n        const slot = this;\n        const value = slot.valueFromJson(jsonValue);\n\n        if (slot.finalInitProto()) {\n            const obj = slot.onInstanceGetValue(anInstance)\n            obj.fromJsonSchema(v); // this will do a type check?\n            return this;\n        }\n\n        if (slot.acceptsValue(value)) {\n            slot.onInstanceSetValue(anInstance, value);\n        } else {\n            throw new Error(\"fromJsonSchema type mismatch for key '\" + this.name() + \"'\");\n        }\n\n        return this;\n    }\n\n    assertValidValueOnInstance (anInstance) {\n        assert(this.slotType() !== null, \"slotType is null for slot: \" + this.name());\n        const v = this.onInstanceGetValue(anInstance);\n        if (v !== null) {\n            assert(this.acceptsValue(v), \"slot value type mismatch for key '\" + this.name() + \"'\");\n        }\n        return this;\n    }\n    \n}.initThisClass());\n\n\n// --- slot methods on Function -------------------------------------------------\n\n/*\nObject.defineSlots(Function.prototype, {\n    slot: function () {\n        return this._slot\n    },\n\n    setSlot: function (aSlot) {\n        this._slot = aSlot\n        return this\n    },\n\n})\n*/",
  "QBQX9qyZEjwRSAwtAKRiazEB9oysu8gOArvxSVHYMks=": "\"use strict\";\n\n/*\n\n    ProtoClass\n    \n    A place for adding Smalltalk like features to the base object\n    that we don't want to add to all Object (and Object decendants) yet,\n    as I'm not sure how they might effect the rest of the system.\n\n*/\n\n(class ProtoClass extends Object {\n\n    static newSubclassWithName (newClassName) {\n        const newClass = class extends this {\n          static name = newClassName;\n          \n          constructor(...args) {\n            super(...args);\n          }\n        };\n        //getGlobalThis()[newClassName] = newClass; // initThisClass() will do this, don't do it here so it doesn't throw an error\n\n        // NOTE: the caller will need to add any slots (or add an initPrototype method) and then call initThisClass() on the new class\n        return newClass;\n      }\n\n   // --- clone ---\n\n   static preClone () {\n        if (this.isSingleton() && this.hasShared()) {\n            // kinda weird dealing with shared in clone like this\n            // do we do this to deal with deserialization of singletons?\n            return this.shared();\n        }\n\n        const obj = new this();\n        if (this.isSingleton()) {\n            this.setShared(obj);\n        }\n\n        return obj;\n    }\n    \n    static clone () {\n        const obj = this.preClone();\n        obj.init();\n        obj.finalInit();\n        obj.afterInit();\n        //this.allInstancesWeakSet().add(obj)\n        return obj;\n    }\n\n    // --- shared ---\n\n    static sharedContext () {\n        return this\n    }\n\n    static hasShared () {\n        return Object.hasOwn(this.sharedContext(), \"_shared\")\n        //return !Type.isNullOrUndefined(this.sharedContext()._shared)\n    }\n    \n    static shared () {\n        if (!this.isSingleton()) {\n            console.warn(\"WARNING: called \" + this.type() + \".shared() but class not declared a singleton!\");\n            /*\n                // to properly declare a singleton, add this to the class declaration (must be a subclass of ProtoClass):\n                \n                static initClass () {\n                    this.setIsSingleton(true)\n                    return this\n                }\n            */\n            debugger;\n        }\n\n        if (!this.hasShared()) {\n            this.setShared(this.clone())\n        }\n        //assert(this.isKindOf(this._shared.thisClass()), this.type() + \".shared() not a kind of existing shared instance class \" + this._shared.thisClass().type());\n        return this._shared;\n    }\n\n    static setShared (v) {\n        this.sharedContext()._shared = v;\n        return this;\n    }\n\n    // --- init ---\n\n    static initClass () { // called only once when class is created\n\n        //console.log(this.type() + \" initThisClass\");\n        Object.defineSlot(this, \"_shared\", undefined);\n        //this.newClassSlot(\"shared\", undefined);\n        this.newClassSlot(\"isSingleton\", false);\n        this.newClassSlot(\"setterNameMap\", new Map()); // TODO: share this between all classes\n        this.newClassSlot(\"allProtoSlotsMap\", new Map());\n        this.newClassSlot(\"jsonSchemaDescription\", null);\n\n        //this.newClassSlot(\"allInstancesWeakSet\", new EnumerableWeakSet());\n    }\n\n    // --- class slots and variables ---\n\n\n    static ancestorClassesTypesIncludingSelf () {\n        return this.ancestorClassesIncludingSelf().map(c => c.type());\n    }\n\n    static ancestorClassesTypes () {\n        return this.ancestorClasses().map(c => c.type());\n    }\n\n    /*\n    static ancestorClassesIncludingSelf (results = []) {\n        results.push(this)\n\n        const parent = this.parentClass()\n        if (parent && parent.ancestorClasses) {\n            //assert(!results.contains(parent))\n            parent.ancestorClassesIncludingSelf(results)\n        }\n        return results\n    }\n    */\n\n    static isSubclassOf (aClass) {\n        //assert(aClass.isClass())\n        return this.ancestorClassesIncludingSelf().contains(aClass);\n    }\n\n    static ancestorClassesIncludingSelf () {\n        const results = this.ancestorClasses().shallowCopy();\n        results.atInsert(0, this);\n        return results;\n    }\n\n    static descendantClasses (results = []) {\n        const children = this.childClasses();\n        children.forEach(child => {\n            results.push(child);\n            child.descendantClasses(results);\n        })\n        return results;\n    }\n\n    static superClass () {\n        return Object.getPrototypeOf(this);\n    }\n\n    static subclassesDescription (level, traversed) {\n\n        if (Type.isUndefined(level)) {\n            level = 0;\n        }\n\n        if (Type.isUndefined(traversed)) {\n            traversed = new Set();\n        }\n\n        /*\n        if (traversed.has(this)) {\n            throw new Error(\"already traversed \", this.type())\n        } else {\n            console.log(\"newly traversing \", this.type())\n        }\n        traversed.add(this)\n        */\n        //const prefix = \"<div class=level\" + level + \">\"\n        //const postfix = \"</div>\"\n\n        const prefix = \"\";\n        const postfix = \"\";\n\n        const spacer = \"  \".repeat(level);\n        const lines = [];\n        if (level === 1) {\n            //lines.append(\"----\")\n        }\n        const path = \"\";\n        lines.append(prefix + spacer + this.type() + \" \" + path + postfix);\n        /*\n        if (this.parentClass()) { // for UML diagram\n            lines.append(\"[\" + this.type() + \"] -> [\" + this.parentClass().type() + \"]\")\n        }\n        */\n        const sortedSubclasses = this.subclasses().sort((a, b) => a.type().localeCompare(b.type()));\n        const subclassLines = sortedSubclasses.map((subclass) => {\n            return subclass.subclassesDescription(level + 1, traversed);\n        })\n        lines.appendItems(subclassLines);\n        return lines.join(\"\\n\");\n    }\n\n    // --- instance ---\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isDebugging\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"lazyRefsMap\", null);\n            slot.setSlotType(\"Map\");\n        }\n        Object.defineSlot(this, \"_timeoutNameToIdMap\", null);\n    }\n\n    lazyRefsMap () {\n        if (!this._lazyRefsMap) {\n            this._lazyRefsMap = new Map();\n        }\n        return this._lazyRefsMap;\n    }\n\n    setType (aString) {\n        this.constructor.name = aString;\n        return this;\n    }\n\n    // --- slots ---\n\n    slotsWithAnnotation (key, value) {\n        assert(this.isPrototype());\n        return this.allSlotsMap().valuesArray().select(slot => slot.getAnnotation(key) === value);\n    }\n\n    slotNamed (slotName) {\n        assert(this.isPrototype())\n\n        const slot = this.ownSlotNamed(slotName)\n        \n        if (slot) {\n            return slot\n        }\n\n        // look in parent\n        const p = this.__proto__ \n        if (p && p.ownSlotNamed) {\n            return p.slotNamed(slotName)\n        }\n\n        return null\n    }\n\n    ownSlotNamed (slotName) {\n        assert(this.isPrototype())\n\n        const slot = this.slotsMap().at(slotName)\n        if (slot) {\n            return slot\n        }\n        \n        return null\n    }\n\n    // slot objects\n\n    getSlot (slotName) {\n        return this.allSlotsMap().get(slotName)\n    }\n\n    hasSlot (slotName) {\n        //return this.hasOwnProperty(slotName);\n        return this.getSlot(slotName) !== undefined;\n    }\n\n    detectSlot (fn) { // returns undefined if no match\n        // TODO: Optimize - this should stop search on match\n        let matchingSlot = undefined\n        this.forEachSlot(slot =>  {\n            if (matchingSlot === undefined && fn(slot)) {\n                matchingSlot = slot \n            }\n        })\n        return matchingSlot\n    }\n\n    /*\n    allSlotsRawValueMap () { // what about action slots?\n        const map = new Map()\n        this.forEachSlotKV((slotName, slot) => map.set(slot.name(), slot.onInstanceRawGetValue(this)))\n        return map\n    }\n\n    isEqual (anObject) {\n        // Should this test Type equality?\n        if (this.type() !== obj2.type()) {\n            return false\n        }\n        const sm1 = this.allSlotsRawValueMap()\n        const sm2 = anObject.allSlotsRawValueMap()\n        return sm1.isEqual(sm2)\n    }\n    */\n\n    // -------------------------------------\n\n    newSlotIfAbsent (slotName, initialValue) {\n        const slot = this.getSlot(slotName);\n        if (slot) {\n            return slot;\n        }\n        return this.justNewSlot(slotName, initialValue);\n    }\n\n    newSlot (slotName, initialValue, allowOnInstance=false) {\n        /*\n        if (Reflect.ownKeys(this).contains(slotName)) {\n            const msg = \"WARNING: \" + this.type() + \".\" + slotName + \" slot already exists\"\n            throw new Error(msg)\n        }\n        */\n\n        if (this.hasSlot(slotName)) {\n            // hack to avoid error for methods like Set isSubsetOf, which exist on only on some browsers\n            // so we define ourselves.\n            if(typeof(initialValue) === \"function\" && this[slotName + \"_isOptional\"] !== undefined) {\n                return null;\n            }\n            const msg = this.type() + \" newSlot('\" + slotName + \"') - slot already exists\";\n            console.log(msg);\n            debugger;\n            throw new Error(msg);\n        }\n        return this.justNewSlot(slotName, initialValue, allowOnInstance);\n    }\n\n\n    overrideSlot (slotName, initialValue, allowOnInstance=false) {\n        const oldSlot = this.getSlot(slotName);\n        if (Type.isUndefined(oldSlot)) {\n            const msg = this.type() + \" newSlot('\" + slotName + \"') - no existing slot to override\";\n            console.log(msg);\n            throw new Error(msg);\n        }\n        const slot = this.justNewSlot(slotName, initialValue, allowOnInstance);\n        slot.copyFrom(oldSlot);\n        slot.setInitValue(initialValue);\n        slot.setOwner(this);\n        return slot;\n    }\n\n    justNewSlot (slotName, initialValue, allowOnInstance=false) { // private\n        if (!allowOnInstance) {\n            assert(this.isPrototype());\n        }\n        assert(Type.isString(slotName));\n\n        /*\n        // TODO: we want to create the private slots and initial value on instances\n        // but ONLY create method slots on classes, not instances...\n        const privateName = \"_\" + slotName;\n        this[privateName] = initialValue;\n        */\n\n        const slot = ideal.Slot.clone().setName(slotName).setInitValue(initialValue);\n        slot.setOwner(this);\n        this.slotsMap().set(slotName, slot);\n        this.allSlotsMap().set(slotName, slot);\n        return slot;\n    }\n\n    assertProtoSlotsHaveType () {\n        this.slotsMap().forEachKV((slotName, slot) => {\n            assert(Type.isString(slot.slotType()), () => { return this.type() + \" slot \" + slotName + \" has no type\" });\n        });\n    }\n\n    newWeakSlot (slotName, initialValue) {\n        const slot = this.newSlot(slotName, initialValue);\n        slot.setIsWeak(true);\n        return slot;\n    }\n\n    // --- weak slot ---\n\n    onFinalizedSlot (aSlot) {\n        this[aSlot.privateName()] = undefined; // replace the weak ref with undefined\n\n        // only called on weak slot\n        const k = aSlot.methodForOnFinalized();\n        const m = this[k];\n        if (m) {\n            m.apply(this);\n        }\n    }\n\n    getWeakSlotValue (aSlot) {\n        const privateName = aSlot.privateName(); // fix this value\n        const weakRef = this[privateName];\n\n        if (weakRef === null) {\n            return null;\n        }\n\n        if (weakRef === undefined) {\n            return undefined;\n        }\n\n        // if we got here, it's a weakref\n        const v = weakRef.deref();\n        if (v === undefined) {\n            // it must have been collected\n            this.onFinalizedSlot(aSlot);\n        }\n        return v;\n    }\n\n    setWeakSlotValue (aSlot, newValue) {\n        const privateName = aSlot.privateName()  // fix this value\n        const oldValue = this.getWeakSlotValue(aSlot) // doesn't trigger willGetSlot() but may call onFinalizedSlot()\n\n        if (newValue !== oldValue) {\n            if (newValue === null) {\n                this[privateName] = null\n            } else {\n                this[privateName] = new WeakRef(newValue)\n            }\n        }\n        return this\n    }\n\n    // --- base getter setter ---\n\n    baseGetSlotValue (aSlot) {\n        if (aSlot.isWeak()) {\n            return this.getWeakSlotValue(aSlot);\n        } else {\n            //const privateName = aSlot.privateName();\n            //return this[privateName];\n            return this[aSlot._privateName];\n        }\n    }\n\n    baseSetSlotValue (aSlot, newValue) {\n        const privateName = aSlot.privateName();\n        if (aSlot.isWeak()) {\n            this.setWeakSlotValue(aSlot, newValue);\n        } else {\n            this[privateName] = newValue;\n        }\n        //this[privateName];\n        return this;\n    }\n\n    // --- auto getter setter ---\n\n    getSlotValue (aSlot) { //testing this\n        const v = this.baseGetSlotValue(aSlot);\n\n        /*\n        if (v === undefined) {\n            this.onUndefinedGetSlot(aSlot);\n        }\n        */\n\n        this.willGetSlot(aSlot);\n        return this.baseGetSlotValue(aSlot);\n    }\n\n    /*\n    onUndefinedGetSlot (aSlot) {\n        // get undefined hook\n        // e.g.: slot \"subnodes\" -> onUndefinedGetSubnodes()\n\n        if (aSlot.isLazy()) {\n            aSlot.onInstanceLoadRef(this)\n        }\n\n        const undefHook = aSlot.methodForUndefinedGet()\n        const m = this[undefHook]\n        if (m) {\n            m.apply(this)\n        }\n    }\n    */\n   \n    willGetSlot (aSlot) {\n        // e.g.: slot \"subnodes\" -> willGetSlotSubnodes()\n        const s = aSlot.methodForWillGet();\n        const f = this[s];\n        if (f) {\n            f.apply(this);\n        }\n    }\n\n    // --- setter ---\n\n    setSlotValue (aSlot, newValue) {\n        const oldValue = this.baseGetSlotValue(aSlot)\n        if (oldValue !== newValue) {\n            this.baseSetSlotValue(aSlot, newValue)\n            this.didUpdateSlot(aSlot, oldValue, newValue)\n        }\n        return this\n    }\n\n    // ----\n\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        const methodName = aSlot.methodForDidUpdate();\n        const method = this[methodName];\n\n        if (method) {\n            method.call(this, oldValue, newValue);\n        }\n        /*\n        if (aSlot.shouldStoreSlot()) {\n            this.didMutate(aSlot.name())\n        }\n        */\n    }\n\n    init () { \n        super.init();\n        // subclasses should override to do initialization\n        //assert(this.isInstance());\n        this.initializeSlots();\n    }\n\n    initializeSlots () {\n        this.thisPrototype().allSlotsMap().forEach(slot => slot.onInstanceInitSlot(this));\n    }\n\n    finalInit () {\n        super.finalInit();\n        this.finalInitSlots();\n    }\n\n    finalInitSlots () {\n        this.thisPrototype().allSlotsMap().forEach(slot => slot.onInstanceFinalInitSlot(this));\n    }\n\n    toString () {\n        return this.type();\n    }\n\n    ownsSlot (name) {\n        return this.hasOwnProperty(name);\n    }\n\n    argsAsArray (args) {\n        return Array.prototype.slice.call(args);\n    }\n\n    respondsTo (methodName) {\n        const f = this[methodName] \n        return typeof(f) === \"function\";\n    }\n\n    performWithArgList (message, argList) {\n        return this[message].apply(this, argList);\n    }\n\n    perform (message) { // will apply any extra arguments to call\n        if (this[message] && this[message].apply) {\n            return this[message].apply(this, this.argsAsArray(arguments).slice(1));\n        }\n\n        throw new Error(this, \".perform(\" + message + \") missing method\")\n        return this;\n    }\n\n    setterNameForSlot (name) {\n        return \"set\" + name.capitalized()\n        /*\n        // cache these as there aren't too many and it will avoid extra string operations\n        if (!m.has(name)) {\n            m.set(name, \"set\" + name.capitalized())\n        }\n        return m.get(name)\n        */\n    }\n\n    toString () {\n        return this.typeId();\n    }\n\n    // --- ancestors ---\n\n    firstAncestorClassWithPostfix (aPostfix) {\n        // not a great name but this walks back the ancestors (including self) and tries to find an\n        // existing class with the same name as the ancestor + the given postfix\n        // useful for things like type + \"View\" or type + \"Tile\", etc\n        //this.debugLog(\" firstAncestorClassWithPostfix(\" + aPostfix + \")\")\n        const classes = this.thisClass().ancestorClassesIncludingSelf()\n        for (let i = 0; i < classes.length; i++) {\n            const aClass = classes[i]\n\n            const name = aClass.type() + aPostfix\n            const proto = Object.getClassNamed(name)\n            if (proto) {\n                return proto\n            }\n            const sansName = name.sansPrefix(\"BM\") // TODO: remove this hack\n            //console.log(\"sansName:\", sansName)\n            const sansProto = Object.getClassNamed(sansName) // hack to deal with nodeViewClass issues\n            if (sansProto) {\n              //  debugger;\n                return sansProto\n            }\n        }\n        return null\n    }\n\n    // debugging\n\n    debugLog (s) {\n        if (this.isDebugging()) {\n            if (Type.isFunction(s)) {\n                s = s()\n            }\n\n            //const tid = this.thisClass().hasShared() ? this.type() + \"(shared)\" : this.debugTypeId();\n            const tid = this.thisClass().hasShared() ? this.debugTypeId() + \"(shared)\" : this.debugTypeId();\n\n            if (arguments.length == 1) {\n                console.log(tid + \" \" + s)\n            } else {\n                console.log(tid + \" \", arguments[0], arguments[1])\n            }\n        }\n        return this\n    }\n\n    // --- other ---\n\n    freeze () {\n        Object.freeze(this)\n        return this\n    }\n\n}.initThisClass());\n\n\n\n",
  "5g/n0cOdc6Bbbbe1ND0ugKXXoMeomyANaaCT+n2h86U=": "\"use strict\";\n\n/*\n\n    ObservableProxy\n\n    A class for wrapping a reference in a proxy which can\n    send proxy trap notifications to observers.\n\n    WARNING:\n\n    Proxies are ~10x slower that direct getter/setters or wrappers around them,\n    so they may not be appropraite for high frequency use objects.\n\n    MOTIVATION:\n\n    The motivation for this class was originally as an access tripwire \n    for lazy loading of persistent objects.\n\n    POTENITAIL USES:\n\n    https://exploringjs.com/es6/ch_proxies.html\n\n    Example:\n\n        const myObject = [\"a\", \"b\", \"c\"]\n        const proxyRef = ObservableProxy.newProxyFor(myObject)\n        proxyRef.observable().addObserver(myObserver)\n\n        now if we call:\n\n            proxyRef.length\n\n        it will trigger the \"get\" trap and send an \"onGetObserved\" message to myObserver.\n        \n*/\n\n\n(class ObservableProxy extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"observers\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"target\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"revocable\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"trapNames\", [\n                \"apply\",\n                \"construct\",\n                \"defineProperty\", // Object.defineProperty\n                \"deleteProperty\", // Object.deleteProperty\n                \"get\", // obj.x or obj[x]\n                \"getOwnPropertyDescriptor\", // Object.getOwnPropertyDescriptor\n                \"getPrototypeOf\", // Object.getPrototypeOf\n                \"has\", // x in obj\n                \"isExtensible\", // Reflect.isExtensible(target)\n                \"ownKeys\", // Reflect.ownKeys(target)\n                \"preventExtensions\", //  Reflect.preventExtensions(target);\n                \"set\", // obj.x = y or obj[x] = y\n                \"setPrototypeOf\", // Reflect.setPrototypeOf()\n            ]);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"noteNamesDict\", null);\n            slot.setSlotType(\"Object\"); // JSON Object\n        }\n    }\n  \n    initPrototype () {\n        this.setIsDebugging(false);\n    }\n\n    init () {\n        super.init();\n        this.setObservers([]);\n        this.setupNoteNames();\n        return this;\n    }\n\n    newProxyFor (aTarget) {\n        const handler = this.thisClass().clone();\n        handler.setTarget(aTarget);\n        //const proxy = new Proxy(aTarget, handler)\n        this.setRevocable(Proxy.revocable(aTarget, handler));\n        return this.proxy();\n    }\n\n    proxy () {\n        return this.revocable().proxy;\n    }\n\n    revoke () {\n        this.postForTrap(\"revoke\", null);\n        this._revocable.revoke();\n        return this;\n    }\n\n    setupNoteNames () {\n        this._noteNamesDict = {};\n        this.trapNames().map((name) => {\n            // examples: \"onObservedGet\", \"onObservedSet\"\n            const noteName = \"onObserved\" + name.capitalized();\n            this._noteNamesDict[name] = noteName;\n        })\n        return this;\n    }\n\n    addObserver (obs) {\n        this.observers().appendIfAbsent(obs);\n        return obs\n    }\n\n    removeObserver (obs) {\n        this.observers().remove(obs);\n        return obs;\n    }\n\n    postForTrap (trapName, propertyName) {\n        const noteName = this.noteNamesDict()[trapName];\n\n        this._observers.forEach((obs) => {\n            if (obs[noteName]) {\n                if (this.isDebugging()) {\n                    this.debugLog(\" posting \" + noteName);\n                }\n                obs[noteName].call(obs, this.target(), propertyName);\n            }\n        })\n        return true;\n    }\n\n    // --- proxy trap methods ---\n    \n    /*\n\n    apply (target, thisArg, argumentsList) {\n        this.postForTrap(\"apply\", propertyName);\n        return target[propertyName].apply(target, argumentsList);\n    }\n\n    construct (target) {\n\n    }\n\n    */\n\n    defineProperty (target, propertyName, descriptor) {\n        this.postForTrap(\"defineProperty\", propertyName);\n        return Object.defineProperty(target, propertyName, descriptor);\n    }\n\n    deleteProperty (target, propertyName) {\n        this.postForTrap(\"deleteProperty\", propertyName);\n        return delete target[propertyName];\n    }\n\n    get (target, propertyName) {\n        if (propertyName === \"observable\") {\n            const self = this;\n            return () => { return self; }\n        }\n\n        /*\n        const proxyMethods = { \"methodName\": true }\n        if (proxyMethods.hasOwnProperty(propertyName)) {\n            let self = this\n            return () => {\n                return self[propertyName].apply(self, arguments)\n            }\n        }\n        */\n\n        this.postForTrap(\"get\", propertyName);\n        return Reflect.get(target, propertyName, target);\n    }\n\n    getOwnPropertyDescriptor (target, propertyName) {\n        this.postForTrap(\"getOwnPropertyDescriptor\", propertyName);\n        return Object.getOwnPropertyDescriptor(target, propertyName);\n    }\n\n    getPrototypeOf (target) {\n        this.postForTrap(\"getPrototypeOf\", null);\n        return Object.getPrototypeOf(target);\n    }\n\n    isExtensible (target, propertyName) {\n        this.postForTrap(\"isExtensible\", propertyName);\n        return Reflect.isExtensible(target);\n    }\n\n    has (target, propertyName) {\n        this.postForTrap(\"has\", propertyName);\n        return Reflect.has( target, propertyName );\n    }\n\n    ownKeys (target, propertyName) {\n        this.postForTrap(\"ownKeys\", propertyName);\n        return Reflect.ownKeys(target);\n    }\n\n    preventExtensions (target, propertyName) {\n        this.postForTrap(\"preventExtensions\", propertyName);\n        return Reflect.preventExtensions(target);\n    }\n\n    set (target, propertyName, newValue) {\n        this.postForTrap(\"set\", propertyName);\n        return Reflect.set(target, propertyName, newValue);\n    }\n\n    setPrototypeOf (target, prototype) {\n        this.postForTrap(\"setPrototypeOf\", null);\n        return Object.setPrototypeOf(target, prototype); \n    }\n\n    // ---------------\n\n    static selfTest () {\n        const resultsDict = {};\n\n        const noteNamesDict = ObservableProxy.clone().noteNamesDict();\n        \n        assert(\"need to fix this to assign to method name\");\n        const eventMethod = (target, propertyName) => { \n            resultsDict[propertyName] = true;\n            console.log(\"got note \" + propertyName);\n        }\n\n        const testObserver = {};\n\n        Object.values(noteNamesDict).forEach((name) => { \n            testObserver[name] = eventMethod;\n        })\n\n    \n        const testArray = [\"a\", \"b\", \"c\"];\n        const arrayProxy = ObservableProxy.newProxyFor(testArray);\n        arrayProxy.observable().addObserver(testObserver);\n    \n        const length = arrayProxy.length; // get\n        arrayProxy[0] = 1 ;// set\n        const v = arrayProxy[0]; // get\n        1 in arrayProxy; // has\n    \n        Reflect.ownKeys(arrayProxy);\n        Object.getOwnPropertyDescriptor(arrayProxy, \"clone\");\n        delete arrayProxy[0];\n        //new arrayProxy\n        arrayProxy.observable().revoke();\n\n        try {\n            arrayProxy.length;\n        } catch(e) {\n            console.log(\"proxy properly revoked\");\n        }\n\n        return true;\n    }\n\n}.initThisClass());\n\n//ObservableProxy.selfTest()",
  "7lTkv5V+zTPOxTmZVtvySzorVNaokFeuDjiU5Wm2KsQ=": "\"use strict\";\n\n/*\n\n    FirewallProxy\n\n    Usefull for passing references to objects but limiting\n    how it can be accessed e.g. which methods can be called on it.\n\n    An example use case would be an immutable proxy for an array.\n    So an object that owns the array can share an immutable proxy for it\n    that doesn't allow other's to mutate it.\n        \n    Example:\n\n        const array = [\"a\", \"b\", \"c\"]\n        const proxyRef = FirewallProxy.newProxyFor(array)\n        proxyRef.observable().setProtectedMethodNames(new Set([...]))\n        proxyRef.observable().setProtectedTrapNames(new Set([...]))\n    \n*/\n\n(class FirewallProxy extends ObservableProxy {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"protectedTraps\", null);\n            slot.setSlotType(\"Set\");\n        }\n        {\n            const slot = this.newSlot(\"protectedMethods\", null);\n            slot.setSlotType(\"Set\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        this.setProtectedTraps(this.defaultProtectedTraps().shallowCopy())\n        this.setProtectedMethods(this.defaultProtectedMethods().shallowCopy())\n        this.setIsDebugging(false)\n        return this\n    }\n\n    defaultProtectedTraps () {\n        return new Set([\n            \"defineProperty\", // Object.defineProperty\n            \"deleteProperty\", // Object.deleteProperty\n            \"preventExtensions\", //  Reflect.preventExtensions(target);\n            \"set\", // obj.x = y or obj[x] = y\n            \"setPrototypeOf\", // Reflect.setPrototypeOf()\n        ])\n    }\n\n    defaultProtectedMethods () {\n        return new Set([\n        ])\n    }\n\n    // need to hook GET so we return special functions to hook protected method calls\n\n    postForTrap (trapName, propertyName) {\n        // instead of posting to observers, \n        // just check if it's a protected trap and, if so, raise an exception\n        // TODO: abstract non posting behavior from ObservableProxy and \n        // use as parent class of both ObservableProxy and Firewall\n        if (this.protectedTraps().has(trapName)) {\n            const msg = \" blocked proxy trap '\" + trapName + \"' on property '\" + propertyName + \"'\"\n            this.debugLog(msg)\n            throw new Error(this.typeId() + msg)\n            return false\n        }\n\n        return true\n    }\n\n    onProtectedMethodCall (propertyName, argsList) {\n        const msg = \" blocked method call '\" + propertyName + \"' \"\n        this.debugLog(msg)\n        throw new Error(this.typeId() + msg)\n    }\n\n    get (target, propertyName) {\n        if (propertyName === \"observable\") {\n            const self = this\n            return () => { return self }\n        }\n\n        this.postForTrap(\"get\", propertyName)\n\n        // if it's a protected method, we'll return a special function\n        // that calls onProtectedMethodCall to raise an exception\n        const isProtected = this.protectedMethods().has(propertyName)\n        if (isProtected) {\n            const isFunction = Type.isFunction(target[propertyName])\n            if (isFunction) {\n                const self = this\n                return () => {\n                    return self.onProtectedMethodCall(propertyName, arguments)\n                }\n            }\n        }\n\n        return Reflect.get(target, propertyName, target);\n    }\n\n    static selfTest () {\n        // test array\n        const array = [\"a\", \"b\", \"c\"]\n        const ap = array.asReadOnly()\n        assertThrows(() => ap.atPut(0, \"foo\"))\n        assertThrows(() => ap[0] = \"bar\")\n        assertThrows(() => ap.pop())\n        assertThrows(() => ap.reverse())\n        assertThrows(() => ap.shift())\n        assertThrows(() => ap.sort())\n\n        // test set\n        const set = new Set([\"foo\", \"bar\"])\n        const sp = set.asReadOnly()\n        assertThrows(() => sp.add(1))\n        assertThrows(() => sp.clear())\n        assertThrows(() => sp.delete(\"foo\"))\n\n        // test map\n        const map = new Map([ [\"foo\", 1], [\"bar\", 2] ])\n        const mp = set.asReadOnly()\n        assertThrows(() => mp.clear())\n        assertThrows(() => mp.delete(\"foo\"))\n        assertThrows(() => mp.set(\"foo\", 2))\n\n        // test date\n        const date = new Date()\n        const dp = date.asReadOnly()\n        assertThrows(() => dp.setYear(1999))\n\n        console.log(this.type() + \" - self test passed\")\n    }\n}.initThisClass());\n\n\n// ------------------------------------------------------------------\n// Use FirewallProxy to implement asReadOnly methods on basic types\n// ------------------------------------------------------------------\n\nObject.defineSlots(Object.prototype, {\n    \n    mutatorMethodNamesSet () {\n        return new Set([\n            \"__defineGetter__\",  \n            \"__defineSetter__\",\n        ])\n    }\n\n})\n\nObject.defineSlots(Set.prototype, {\n    \n    mutatorMethodNamesSet () {\n        return new Set([\n            \"add\",\n            \"clear\",\n            \"delete\"\n        ])\n    }\n\n})\n\nObject.defineSlots(Map.prototype, {\n\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"clear\",\n            \"delete\",\n            \"set\",\n        ])\n    }\n\n})\n\nObject.defineSlots(Array.prototype, {\n\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"copyWithin\",\n            \"pop\",\n            \"push\",\n            \"reverse\",\n            \"shift\",\n            \"sort\",\n            \"splice\",\n            \"unshift\"\n        ])\n    }\n\n})\n\nObject.defineSlots(Date.prototype, {\n    \n    mutatorMethodNamesSet () {\n        return new Set([\n            \"setDate\",\n            \"setFullYear\",\n            \"setHours\",\n            \"setMilliseconds\",\n            \"setMinutes\",\n            \"setMonth\",\n            \"setSeconds\",\n            \"setTime\",\n            \"setUTCDate\",\n            \"setUTCFullYear\",\n            \"setUTCHours\",\n            \"setUTCMilliseconds\",\n            \"setUTCMinutes\",\n            \"setUTCMonth\",\n            \"setUTCSeconds\",\n            \"setYear\",\n        ])\n    }\n\n})\n\nObject.defineSlots(Object.prototype, {\n\n    asReadOnly () {\n        const obj = FirewallProxy.newProxyFor(this)\n        obj.observable().setProtectedMethods(this.mutatorMethodNamesSet())\n        return obj\n    }\n\n})\n\n\n//FirewallProxy.selfTest()\n",
  "XQEQaCkNpW+HPqtVzFbd68fuTv5BCiaqZUWjIMSQl7A=": "\"use strict\";\n\n/**\n * A subclass of Array that hooks the base mutation methods so we can\n * track mutations to the array and call willMutate and didMutate hooks.\n * \n * For this to work, you need to use method alternatives to the non-method\n * array operations:\n * \n *   - a[i] -> instead use a.at(i) \n *   - a[i] = b -> instead use a.atPut(i, b)\n *   - delete a[i] -> instead use a.removeAt(i)\n * \n * To do this without using method alternatives, we would need to use\n * a Proxy to intercept the array operations, which would be safer, \n * but also slower and more memory intensive.\n * \n * @module ideal.collections\n * @class HookedArray\n * @extends Array\n */\n\n(class HookedArray extends Array {\n\n    /**\n     * Initializes prototype slots and sets up mutator hooks.\n     */\n    initPrototypeSlots () {\n        //Object.defineSlot(this, \"_allowsNulls\", false)\n\n        this.setupMutatorHooks()\n        //Array.prototype.setupMutatorHooks()\n    }\n\n    // ------------------------------\n\n    /**\n     * @returns {Set<string>} A set of method names that mutate the array\n     */\n    mutatorMethodNamesSet () {\n        // we can't hook []= or delete[] but we can hook these\n        // and use hooked methods instead of operators for those\n        return new Set([\n            \"copyWithin\",\n            \"pop\",\n            \"push\",\n            \"reverse\",\n            \"shift\",\n            \"sort\",\n            \"splice\",\n            \"unshift\"\n        ])\n    }\n\n    /**\n     * @returns {HookedArray} A read-only shallow copy of the array\n     */\n    asReadOnlyShalowCopy () {\n        const obj = this.thisClass().withArray(this)\n        obj.willMutate = () => {\n            throw new Error(\"attempt to mutate a read only array\")\n        }\n        return obj\n    }\n\n    /**\n     * Performs a self-test of the HookedArray class\n     * @returns {typeof HookedArray} The HookedArray class\n     */\n    static selfTest () {\n        const a = this.clone()\n\n        let gotWillMutate = false\n        let gotDidMutate = false\n\n        a.willMutate = () => {\n            gotWillMutate = true\n        }\n        a.didMutate = () => {\n            gotDidMutate = true\n        }\n        a.push(\"b\")\n        assert(gotWillMutate)\n        assert(gotDidMutate)\n\n        const b = a.asReadOnlyShalowCopy()\n\n        let caughtReadOnlyMutate = false\n        try {\n            b.pop()\n        } catch (e) {\n            caughtReadOnlyMutate = true\n        }\n        assert(caughtReadOnlyMutate)\n\n        console.log(this.type() + \" - passed self test\")\n        return this\n    }\n\n}.initThisClass()); //.selfTest()\n\n/*\n(class Array_mutator extends Array {\n    mutatorMethodNamesSet () {\n        // we can't hook []= or delete[] but we can hook these\n        // and use hooked methods instead of operators for those\n        return new Set([\n            \"pop\",\n            \"push\",\n            \"reverse\",\n            \"shift\",\n            \"sort\",\n            \"splice\",\n            \"unshift\"\n        ])\n    }\n}).initThisCategory();\n\nArray.prototype.setupMutatorHooks();\n*/\n",
  "Ts+v/txSxsyt4/a5NojUETUk5CDV2rXJIfkTx4nClxY=": "\"use strict\";\n\n/**\n * A subclass of Set that hooks the base mutation methods.\n * \n * For this to work, you need to use method alternatives to the non-method\n * (operator) operations.\n * @module ideal.collections\n * @class HookedSet\n * @extends Set\n */\n\n(class HookedSet extends Set {\n\n    /**\n     * Sets up mutator hooks.\n     */\n    initPrototypeSlots () {\n        this.setupMutatorHooks()\n    }\n\n    // ------------------------------\n\n    /**\n     * Returns a Set of mutator method names that should be hooked.\n     * These include add, clear, and delete.\n     * @returns {Set<string>} A Set containing the names of mutator methods.\n     */\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"add\",\n            \"clear\",\n            \"delete\"\n        ])\n    }\n\n    /**\n     * Performs a self-test of the HookedSet class.\n     * @returns {boolean} True if the self-test passes, false otherwise.\n     */\n    static selfTest () {\n        const a = this.clone()\n        \n        let gotWillMutate = false\n        let gotDidMutate = false\n\n        a.willMutate = () => {\n            gotWillMutate = true\n        }\n        \n        a.didMutate = () => {\n            assert(gotWillMutate)\n            gotDidMutate = true\n        }\n\n        a.add(\"b\")\n        assert(gotWillMutate)\n        assert(gotDidMutate)\n\n        console.log(this.type() + \" - passed self test\")\n        return true\n    }\n\n}.initThisClass()); \n\n//HookedSet.selfTest()\n\n",
  "q/nIDAsNOJSubuJIrnllQVvgAZ9R6G/X9kOjzaQ4s08=": "\"use strict\";\n\n/**\n * HookedMap is a subclass of Map that hooks the base mutation methods.\n * \n * The JS Map object holds key-value pairs and remembers the original insertion order of the keys.\n * For this to work, you need to use method alternatives to the non-method (operator) operations.\n *\n * @module ideal.collections\n * @class HookedMap\n * @extends Map\n */\n\n(class HookedMap extends Map {\n\n    /**\n     * Initializes the prototype slots and sets up mutator hooks.\n     */\n    initPrototypeSlots () {\n        this.setupMutatorHooks()\n    }\n\n    /**\n     * Returns a Set of mutator method names that should be hooked.\n     * @returns {Set<string>} A Set containing the names of mutator methods.\n     */\n    mutatorMethodNamesSet () {\n        return new Set([\n            \"clear\",\n            \"delete\",\n            \"set\",\n        ])\n    }\n\n    /**\n     * Performs a self-test of the HookedMap class.\n     * @returns {HookedMap} Returns the class itself after the test.\n     */\n    static selfTest () {\n        const a = this.clone()\n        \n        let gotWillMutate = false\n        let gotDidMutate = false\n\n        /**\n         * Hook called before a mutation occurs.\n         * @method willMutate\n         */\n        a.willMutate = () => {\n            gotWillMutate = true\n        }\n\n        /**\n         * Hook called after a mutation occurs.\n         * @method didMutate\n         */\n        a.didMutate = () => {\n            gotDidMutate = true\n        }\n\n        a.clear()\n        assert(gotWillMutate)\n        assert(gotDidMutate)\n\n        console.log(this.type() + \" - passed self test\")\n        return this\n    }\n\n}.initThisClass()); //.selfTest()\n\n",
  "vYMSmrUQheUJI5xk1li9lwbYkxAP6FXtJLXeIpAHqe0=": "\"use strict\";\n\n/**\n * @module ideal.collections\n * @class IndexedArray\n * @extends HookedArray\n * @description A subclass of Array that maintains a dictionary index of the \n * elements of the list via an index closure. The index closure should return \n * a string. For this to work, you need to avoid using the Array \n * operations which can't be overridden:\n * \n *     a[i] -> instead use a.at(i) \n *     a[i] = b -> instead use a.atPut(i, b)\n *     delete a[i] -> instead use a.removeAt(i)\n * \n */\n(class IndexedArray extends HookedArray {\n\n    /**\n     * Initialize prototype slots\n     * @private\n     */\n    initPrototypeSlots () {\n        Object.defineSlot(this, \"_index\", null);\n        Object.defineSlot(this, \"_indexClosure\", null);\n        Object.defineSlot(this, \"_needsReindex\", false);\n    }\n\n    /**\n     * Initialize the IndexedArray\n     */\n    init () {\n        super.init();\n        this.setIndex(new Map());\n    }\n\n    /**\n     * Set the index Map\n     * @param {Map} aMap - The Map to use as the index\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    setIndex (aMap) {\n        this._index = aMap;\n        return this;\n    }\n\n    /**\n     * Get the current index, reindexing if necessary\n     * @returns {Map} - The current index\n     */\n    index () {\n        if (this._needsReindex) {\n            this.reindex();\n        }\n        return this._index;\n    }\n\n    /**\n     * Set the index closure function\n     * @param {Function} aFunction - The function to use for indexing\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    setIndexClosure (aFunction) {\n        if (aFunction !== this._indexClosure) {\n            this._indexClosure = aFunction;\n            this.setNeedsReindex(true);\n        }\n        return this;\n    }\n\n    /**\n     * Get the current index closure function\n     * @returns {Function|null} - The current index closure function\n     */\n    indexClosure () {\n        return this._indexClosure;\n    }\n\n    /**\n     * Check if the array is indexed\n     * @returns {boolean} - True if the array has an index closure function\n     */\n    isIndexed () {\n        return Type.isFunction(this._indexClosure);\n    }\n\n    /**\n     * Set whether the array needs reindexing\n     * @param {boolean} aBool - Whether reindexing is needed\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    setNeedsReindex (aBool) {\n        this._needsReindex = aBool;\n        return this;\n    }\n\n    /**\n     * Check if the array needs reindexing\n     * @returns {boolean} - True if reindexing is needed\n     */\n    needsReindex () {\n        return this._needsReindex;\n    }\n\n    /**\n     * Reindex the array\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    reindex () {\n        this.setNeedsReindex(false); // do this first to avoid infinite loop\n        this._index.clear();\n        this.forEach( v => this.addItemToIndex(v) );\n        return this;\n    }\n\n    /**\n     * Check if an item is in the index\n     * @param {*} anObject - The item to check\n     * @returns {boolean} - True if the item is in the index\n     */\n    hasIndexedItem (anObject) {\n        const key = this.indexKeyForItem(anObject);\n        return !Type.isUndefined(this.itemForIndexKey(key));\n    }\n\n    /**\n     * Handle mutations to the array\n     * @param {string} slotName - The name of the slot that was mutated\n     * @param {*} optionalValue - The value involved in the mutation\n     */\n    didMutate (slotName, optionalValue) {\n        super.didMutate(slotName, optionalValue);\n\n        if (this._indexClosure && !this._needsReindex && optionalValue) {\n            // If we don't already need to reindex, \n            // check if we can avoid it.\n            // These cover the common use cases.\n\n            /*\n            if (slotName === \"push\") {\n                // need to add a way to handle multiple arguments first\n                optionalArguments.forEach(v => this.addItemToIndex(v));\n                return;\n            }\n            */\n\n            if (slotName === \"atPut\") {\n                // We can just add it, instead of doing a fill reindex.\n                this.addItemToIndex(optionalValue);\n                return;\n            }\n\n            if (slotName === \"removeAt\") {\n                if (!this.contains(optionalValue)) {\n                    // No copies of this value in the array, \n                    // so we can just remove it from the index.\n                    this.removeItemFromIndex(optionalValue);\n                    return;\n                }\n            }\n        }\n\n        this.setNeedsReindex(true);\n    }\n\n    /**\n     * Get an item from the index by its key\n     * @param {string} key - The index key\n     * @returns {*} - The item corresponding to the key\n     */\n    itemForIndexKey (key) {\n        return this.index().get(key);\n    }\n\n    /**\n     * Check if an item is in the index\n     * @param {*} v - The item to check\n     * @returns {boolean} - True if the item is in the index\n     */\n    indexHasItem (v) {\n        assert(this.isIndexed());\n        const key = this.indexClosure()(v);\n        return this.hasIndexKey(key);\n    }\n\n    /**\n     * Check if a key exists in the index\n     * @private\n     * @param {string} key - The key to check\n     * @returns {boolean} - True if the key exists in the index\n     */\n    hasIndexKey (key) {\n        return this._index.has(key);\n    }\n\n    /**\n     * Get the index key for an item\n     * @private\n     * @param {*} v - The item to get the key for\n     * @returns {string} - The index key for the item\n     */\n    indexKeyForItem (v) {\n        const key = this.indexClosure()(v);\n        return key;\n    }\n\n    /**\n     * Add an item to the index\n     * @private\n     * @param {*} v - The item to add\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    addItemToIndex (v) {\n        const key = this.indexKeyForItem(v);\n        assert(Type.isString(key));\n        this._index.set(key, v);\n        return this;\n    }\n\n    /**\n     * Remove an item from the index\n     * @private\n     * @param {*} v - The item to remove\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    removeItemFromIndex (v) {\n        const key = this.indexKeyForItem(v);\n        this._index.delete(key);\n        return this;\n    }\n\n    /**\n     * Run self-test for IndexedArray\n     * @returns {IndexedArray} - Returns this for chaining\n     */\n    static selfTest () {\n        let ia = IndexedArray.clone();\n        ia.setIndexClosure(v => v.toString());\n        ia.push(123);\n        let result = ia.itemForIndexKey(\"123\");\n        assert(result === 123);\n        return this;\n    }\n\n}.initThisClass());\n\n//IndexedArray.selfTest()\n",
  "uuhWoZjPINdrLKiLevpGYgvNh/0taO7X4+OijLtFiio=": "\"use strict\";\n\n/**\n * @module ideal.collections\n * @class SortedArray\n * @extends IndexedArray\n * @description A subclass of IndexedArray that maintains its subnodes in sorted order.\n * It does this by calling resort() on the array when a mutation occurs on the subnode items or the sort function changes.\n * The sort closure should return a comparison result.\n */\n\n(class SortedArray extends IndexedArray {\n\n\n    /**\n     * Initializes the SortedArray instance.\n     */\n    init () {\n        super.init()\n        Object.defineSlot(this, \"_isSorting\", false)\n        Object.defineSlot(this, \"_sortFunc\", null)\n    }\n\n    /**\n     * Checks if the array has a sort function defined.\n     * @returns {boolean} True if a sort function is defined, false otherwise.\n     */\n    doesSort () {\n        return !Type.isNull(this._sortFunc)\n    }\n\n    /**\n     * Sets the sort function for the array.\n     * The sort function should take two arguments of type BMNode and \n     * return a negative value if the first argument is less than the second,\n     * Changing the sort function will cause the array to be resorted.\n     * To disable sorting, pass null as the sort function.\n     * @param {Function} aFunc - The sorting function to use.\n     * @returns {SortedArray} The SortedArray instance.\n     */\n    setSortFunc (aFunc) {\n        if (this._sortFunc !== aFunc) {\n            this._sortFunc = aFunc;\n            if (aFunc) {\n                this.resort();\n            }\n        }\n        return this\n    }\n\n    /**\n     * Gets the current sort function.\n     * @returns {Function|null} The current sort function or null if not set.\n     */\n    sortFunc () {\n        return this._sortFunc\n    }\n\n    /**\n     * Calls resort method when the sort function changes.\n     * @param {Function|null} oldValue - The previous sort function.\n     * @param {Function|null} newValue - The new sort function.\n     */\n    didChangeSlotSortFunc (oldValue, newValue) {\n        this.resort()\n    }\n\n    /**\n     * Resorts the array using the current sort function.\n     * @returns {SortedArray} The SortedArray instance.\n     */\n    resort () {\n        if (this._sortFunc && this.length && !this._isSorting) {\n            this._isSorting = true;\n            this.sort(this._sortFunc);\n            this._isSorting = false;\n        }\n        return this;\n    }\n\n    /**\n     * Determines if a resort is needed based on mutation method called. \n     * These mutation methods do not require a resort: pop, shift, sort, removeAt, remove, removeAll.\n     * @param {string} slotName - The name of the modified slot.\n     * @returns {boolean} True if a resort is needed, false otherwise.\n     */\n    needsResortOnForSlot (slotName) {\n        const nonOrderChangingSlots = [\n            \"pop\", \n            \"shift\", \n            \"sort\", \n            \"removeAt\", \n            \"remove\", \n            \"removeAll\"\n        ];\n        return !nonOrderChangingSlots.contains(slotName);\n    }\n\n    /**\n     * Calls resort if there is a sort function and the slot name is in the list of slots that require a resort.\n     * @param {string} methodNameThatCausedMutation - The name of the method that caused the mutation.\n     * @param {*} [optionalValue] - The optional value associated with the mutation.\n     */\n    didMutate (methodNameThatCausedMutation, optionalValue) {\n        if (this._isSorting) {\n            return;\n        }\n\n        super.didMutate(methodNameThatCausedMutation, optionalValue);\n\n        if (this._sortFunc && this.needsResortOnForSlot(methodNameThatCausedMutation)) {\n            this.resort();\n        }\n    }\n    \n    /**\n     * Runs a self-test on the SortedArray class.\n     * @returns {typeof SortedArray} The SortedArray class.\n     */\n    static selfTest () {\n        let sa = this.clone();\n        sa.setSortFunc((a, b) => { return a - b });\n        sa.push(3, 1, 2);\n        assert(sa.isEqual([1, 2, 3]));\n        return this;\n    }\n\n}.initThisClass()); //.selfTest()\n",
  "k+gHDb5fgwS32bbdrwXv1vYfmXajkO7Rl1ig7MCyBz0=": "\"use strict\";\n\n/*\n\n    AtomicMap\n \n*/\n\ngetGlobalThis().ideal.AtomicMap = class AtomicMap extends ProtoClass {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isInTx\", false); \n            slot.setDescription(\"Public read, private write. Boolean, true during a tx.\");\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"map\", null); // public read, private write - Map, contains current state of map\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"snapshot\", null); // private - Map, contains shallow copy of map before tx which we can revert to if tx is cancelled\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"isOpen\", true); // public read, private write\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"changedKeySet\", null); // private method\n            slot.setSlotType(\"Set\");\n        }\n        {\n            const slot = this.newSlot(\"keysAndValuesAreStrings\", true); // private method - Bool, if true, runs assertString on all input keys and values\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"totalBytesCache\", null); // private\n            slot.setSlotType(\"Number\");\n            slot.setAllowsNullValue(true);\n        }\n        /*\n        {\n            const slot = this.newSlot(\"currentTxPromise\", null); // private\n        }\n        {\n            const slot = this.newSlot(\"queuedSets\", null);\n        }\n        */\n        {\n            const slot = this.newSlot(\"beginPromiseFifoQueue\", null); // first-in-first-out queue of promises, last in queue is was the earliest promise added\n            slot.setSlotType(\"Array\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    init () {\n        super.init();\n        this.setMap(new Map());\n        this.setSnapshot(null);\n        this.setChangedKeySet(new Set());\n        //this.setSnapshot(new Map());\n        //this.setQueuedSets([]);\n        this.setBeginPromiseFifoQueue([]);\n        this.setIsDebugging(false);\n    }\n\n    open () {\n        this.setIsOpen(true);\n        return this;\n    }\n\n    assertAccessible () {\n        this.assertOpen();\n    }\n\n    assertOpen () {\n        assert(this.isOpen());\n    }\n\n    async promiseOpen () {\n        this.open();\n    }\n\n    close () {\n        this.setIsOpen(false);\n        return this;\n    }\n\n    begin () {\n        throw new Error(\"deprecated - use promiseBegin\");\n    }\n    \n    async promiseBegin () {\n        const lastPromise = this.beginPromiseFifoQueue().last();\n\n        this.beginPromiseFifoQueue().push(Promise.clone()); // do this first so next caller will see we were here first\n\n        if (lastPromise) {\n            await lastPromise; // now we can await for the previous one, if there is one\n        }\n\n        this.debugLog(() => \" begin --- (queue size is \" + this.beginPromiseFifoQueue().length + \")\");\n        this.assertAccessible();\n        this.assertNotInTx(); // if in TX then this has been used improperly as it should only be called once per event loop?\n        this.setSnapshot(this.map().shallowCopy());\n        this.changedKeySet().clear();\n        this.setIsInTx(true);\n    }\n\n    revert () {\n        this.debugLog(() => \" revert ---\");\n        this.assertInTx();\n        this.setMap(this.snapshot());\n        this.setSnapshot(null);\n        this.changedKeySet().clear();\n        this.setIsInTx(false);\n        this.onCompleteTx();\n        return this\n    }\n\n    async promiseApplyChanges () {\n        // for subclasses to implement\n        await this.applyChanges();\n    }\n\n    async promiseCommit () {\n        this.debugLog(() => \" prepare commit ---\");\n        this.assertInTx();\n        if (this.hasChanges()) {\n            //await this.asyncProcessSetPromiseQueue()\n            await this.promiseApplyChanges();\n            this.changedKeySet().clear();\n            this.clearTotalBytesCache();\n        }\n        this.onCompleteTx();\n    }\n\n    onCompleteTx () {\n        this.setIsInTx(false);\n        const currentPromise = this.beginPromiseFifoQueue().shift();\n        currentPromise.callResolveFunc();\n    }\n\n    // --- changes ---\n\n    hasChanges () {\n        return this.changedKeySet().size > 0;\n        //return this.changedKeySet().size > 0 || this.queuedSets().length > 0\n    }\n\n    applyChanges () { // private - apply changes to snapshot\n        this.setSnapshot(null);\n        return this;\n    }\n\n    // need to make sure writes happen within a transaction\n\n    assertInTx () { // private\n\t    assert(this.isInTx());\n    }\n\n    assertNotInTx () { // private\n\t    assert(!this.isInTx());\n    }\n\n    // reads\n \n    // --- keys ---\n\n    keysArray () {\n        return this.map().keysArray();\n    }\n\n    keysSet () {\n        return this.map().keysSet();\n    }\n\n    // --- values ---\n\n    valuesArray () {\n        return this.map().valuesArray();\n    }\n\n    valuesSet () {\n        return this.map().valuesSet();\n    }\n\n    // ---\n\n    has (k) {\n        return this.map().has(k);\n    }\n\n    hasKey (k) {\n        return this.map().hasKey(k);\n    }\n\n    at (k) {\n        return this.map().at(k);\n    }\n\n    // writes\n\n    clear () {\n        this.keysArray().forEach(k => this.removeKey(k));\n        return this;\n    }\n\n    // --- async set ---\n\n    /*\n    async asyncQueueSetKvPromise (kvPromise) {\n        const promise = Promise.clone();\n        const kvTuple = await kvPromise\n\n        assert(Type.isArray(kvTuple) && kvTuple.length == 2);\n        const k = kvTuple[0];\n        const v = kvTuple[1];\n        this.set(k, v);\n        promise.callResolveFunc();\n\n        this.queuedSets().push(setPromise);\n        return promise;\n    }\n\n    async asyncProcessSetPromiseQueue () {\n        await Promise.all(this.queuedSets());\n        this.setQueuedSets([]);\n    }\n    */\n\n    // ---------------\n\n    set (k, v) {\n        return this.atPut(k, v);\n    }\n\n    atPut (k, v) {\n        this.assertInTx();\n        if (this.keysAndValuesAreStrings()) {\n            assert(Type.isString(k));\n            assert(Type.isString(v));\n        }\n\n        //console.log(this.debugTypeId() + \" atPut('\" + k + \"', <\" + typeof(v) + \"> '\" + v + \"')\")\n        this.assertAccessible();\n        this.assertInTx();\n        this.changedKeySet().add(k);\n        this.map().set(k, v);\n        return this;\n    }\n\n    removeKey (k) {\n        this.assertInTx();\n        this.changedKeySet().add(k);\n        if (this.keysAndValuesAreStrings()) {\n            assert(Type.isString(k));\n        }\n\n        this.assertAccessible();\n        this.assertInTx();\n        this.map().delete(k);\n        return this;\n    }\n\n    // --- enumeration ---\n\n    forEachKV (fn) {\n        this.assertNotInTx() ;\n        this.assertAccessible();\n        this.map().forEach((v, k, self) => fn(k, v, self));\n    }\n\n    forEachK (fn) {\n        //this.assertNotInTx()  // why is this needed?\n        this.assertAccessible();\n        this.map().forEach((v, k) => fn(k));\n    }\n\n    forEachV (fn) {\n        this.assertNotInTx();\n        this.assertAccessible();\n        this.map().forEach(v => fn(v));\n    }\n\n    // read extras \n\n    keysArray () {\n        return this.map().keysArray();\n    }\n\t\n    valuesArray () {\n        return this.map().valuesArray();\n    }\n\n    count () { \n        return this.map().size;\n    }\t\n\n    clearTotalBytesCache () {\n        this.setTotalBytesCache(null);\n        return this;\n    }\n\n    /*\n    String.prototype.lengthInBytes = function () {\n        return (new TextEncoder().encode(this)).length\n    }\n    */\n\n    totalBytes () {\n        const cachedResult = this.totalBytesCache();\n        if (!Type.isNull(cachedResult)) {\n            return cachedResult;\n        }\n\n        this.assertNotInTx();\n        this.assertAccessible();\n        assert(this.keysAndValuesAreStrings());\n        let byteCount = 0;\n        this.map().forEachKV((k, v) => {\n            byteCount += k.length + v.length // not correct for unicode, but fast and good enough for now\n            //byteCount += k.byteLength() + v.byteLength() // correct, but slow\n        })\n        this.setTotalBytesCache(byteCount);\n        return byteCount;\n    }\n\n    asJson () {\n        return this.map().asDict();\n    }\n\n    fromJson (json) {\n        this.map().clear();\n        this.map().fromDict(json);\n        return this\n    }\n\n    // test\n\n    static async selfTest () {\n        const m = this.clone()\n\n        // atPut test\n        await m.promiseBegin();\n        m.atPut(\"foo\", \"bar\");\n        await m.promiseCommit(); \n        assert(m.count() === 1)\n        assert(m.Array()[0] === \"foo\")\n\n        // removeAt test\n        await m.promiseBegin();\n        m.removeAt(\"foo\");\n        await m.promiseCommit();\n        assert(m.count() === 0);\n\n        return true;\n    }\n\n}.initThisClass(); //.selfTest()\n\n",
  "FQtrncoBnMVh73ygsp6tIUqGnOTymZeHG4FH6XEblkg=": "\"use strict\";\n\n/**\n * Takes a number and returns a string with a more human readable format.\n *\n * @example\n * const stringVersion = NumberFormatter.clone().setValue(1234).setSignificantDigits(2).formattedValue();\n * // stringVersion will be \"1.2K\"\n *\n * @module ideal.formatters\n * @class NumberFormatter\n * @extends ProtoClass\n */\n(class NumberFormatter extends ProtoClass {\n    initPrototypeSlots () {\n\n        /**\n         * The number to be formatted.\n         * @type {number}\n         * @default 0\n         */\n        {\n            const slot = this.newSlot(\"value\", 0);\n            slot.setShouldStoreSlot(false);\n            slot.setSlotType(\"Number\");\n            slot.setCanInspect(false);\n        }\n\n        /**\n         * The number of significant digits to use in the formatted output.\n         * @type {number}\n         * @default 2\n         */\n        {\n            const slot = this.newSlot(\"significantDigits\", 2);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Number\");\n            slot.setCanInspect(true);\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    /**\n     * Formats the number value into a human-readable string.\n     * @returns {string} The formatted number value.\n     */\n    formattedValue () {\n        const number = this.value();\n        const significantDigits = this.significantDigits();\n\n        const suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n        const magnitude = Math.floor(Math.log10(Math.abs(number)) / 3);\n        const scaled = number / Math.pow(10, magnitude * 3);\n      \n        if (magnitude === 0) {\n          return number.toString();\n        } else {\n          const roundedScaled = Number(scaled.toPrecision(significantDigits));\n          return roundedScaled + suffixes[magnitude];\n        }\n    }\n\n}.initThisClass());\n",
  "DOZFEfxSc5ny1nmzfwvx0XIjbBpbvI8qpxNZtZTIe3w=": "\"use strict\";\n\n/**\n * ByteFormatter takes a number of bytes and returns a string with the order of magnitude in \n * standard SI decimal digital information format.\n *\n * @example\n * const stringVersion = ByteFormatter.clone().setValue(aNumberOfBytes).formattedValue()\n *\n * @example\n * // Output examples:\n * // if aNumberOfBytes was 300, stringVersion would be 300 bytes.\n * // if aNumberOfBytes was 3,000, stringVersion would be 3 kB.\n * // if aNumberOfBytes was 30,000, stringVersion would be 30 kB.\n * // if aNumberOfBytes was 300,000, stringVersion would be 300 kB.\n * // if aNumberOfBytes was 3,000,000, stringVersion would be 3 MB.\n *\n * @todo Move to power notation after max order name exceeded\n * @module ideal.formatters\n * @class ByteFormatter\n * @extends ProtoClass\n */\n\n(class ByteFormatter extends ProtoClass {\n    initPrototypeSlots () {\n\n        /**\n         * The number of bytes to format.\n         * @type {number}\n         * @default 0\n         */\n        {\n            const slot = this.newSlot(\"value\", 0);\n            slot.setShouldStoreSlot(false);\n            slot.setSlotType(\"Number\");\n            slot.setCanInspect(false);\n        }\n\n        /**\n         * Whether to use a postfix in the formatted output.\n         * @type {boolean}\n         * @default true\n         */\n        {\n            const slot = this.newSlot(\"usePostfix\", true);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setCanInspect(true);\n        }\n\n        /**\n         * Whether to use a space between the number and the unit in the formatted output.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"useSpace\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setCanInspect(true);\n        }\n\n        /**\n         * Whether to use long names for units in the formatted output.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"useLongNames\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setCanInspect(true);\n        }\n\n        /**\n         * Array of short unit names.\n         * @type {string[]}\n         */\n        {\n            const slot = this.newSlot(\"orderNamesShort\", [\n                \"bytes\", \n                \"k\", \n                \"M\", \n                \"G\", \n                \"T\", \n                \"P\", \n                \"E\", \n                \"Z\", \n                \"Y\"\n            ]);\n            slot.setSlotType(\"Array\");\n        }\n        \n        /**\n         * Array of long unit names.\n         * @type {string[]}\n         */\n        {\n            const slot = this.newSlot(\"orderNamesLong\", [\n                \"bytes\", \n                \"kilobytes\", \n                \"megabytes\", \n                \"gigabytes\", \n                \"terabytes\", \n                \"petabytes\", \n                \"exabytes\", \n                \"zettabytes\", \n                \"yottabytes\"\n            ]);\n            slot.setSlotType(\"Array\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    /**\n     * Formats the byte value into a human-readable string.\n     * @returns {string} The formatted byte value.\n     */\n    formattedValue () {\n        const b = Math.floor(this.value());\n        let postfix = this.usePostfix() ? \"B\" : \"\";\n        let space = this.useSpace() ? \" \" : \"\";\n\t\t\n        const orderNames = this.useLongNames() ? this.orderNamesLong() : this.orderNamesShort();\n        let order = b === 0 ? 0 : Math.floor(Math.log10(b)/3)\n        order = Math.min(order, orderNames.length - 1)\n        let orderName = orderNames[order]\n\n        if (order === 0 || this.useLongNames()) {\n            space = \" \"\n            postfix = \"\"\n        }\n\n        const v = Math.floor(b / Math.pow(10, order*3))\n\t\t\n        // remove plural if v === 1\n        if (orderName[orderName.length-1] === \"s\" && v === 1) {\n            orderName = orderName.substring(0, orderName.length - 1)\n        }\n\t\t\n        return v + space + orderName + postfix\n    }\n}.initThisClass());\n",
  "6ZtsGhtFcGhSgrHi2RzukxmrcZP57vzOVkAeGO6ruCI=": "\"use strict\";\n\n/**\n * TimePeriodFormatter takes a number of seconds and formats it in a compact format.\n *\n * @example\n * const stringVersion = TimePeriodFormatter.clone().setValueInSeconds(seconds).formattedValue()\n *\n * @example\n * // Output examples:\n * // if seconds was 10, stringVersion would be 10s.\n * // if seconds was 60, stringVersion would be 1m.\n * // if seconds was 3600, stringVersion would be 1h.\n * // if seconds was 172800, stringVersion would be 2d.\n *\n * @module ideal.formatters\n * @class TimePeriodFormatter\n * @extends ProtoClass\n */\n(class TimePeriodFormatter extends ProtoClass {\n    initPrototypeSlots () {\n        /**\n         * The number of seconds to format.\n         * @type {number}\n         * @default 0\n         */\n        {\n            const slot = this.newSlot(\"valueInSeconds\", 0);\n            slot.setSlotType(\"Number\");\n        }\n\n        /**\n         * A map of time periods to their abbreviated forms.\n         * @type {Map<string, string>}\n         */\n        {\n            const slot = this.newSlot(\"periodsMap\", new Map(Object.entries({ \n                seconds: \"s\", \n                minutes: \"m\", \n                hours: \"h\", \n                days: \"d\", \n                months: \"months\", \n                years: \"years\"\n            })));\n            slot.setSlotType(\"Object\"); \n        }\n    }\n\n    /**\n     * Formats the time period into a compact string representation.\n     * @returns {string} The formatted time period string.\n     */\n    formattedValue () {\n        const periods = this.periodsMap();\n\n        const seconds = this.valueInSeconds();\n        if (seconds === null) {\n            return \"?\";\n        }\n\n        if (seconds < 60) {\n            return Math.floor(seconds) + periods.get(\"seconds\");\n        }\n        \n        const minutes = Math.floor(seconds/60);\n        if (minutes < 60) {\n            return minutes + periods.get(\"minutes\");\n        }\n\n        const hours = Math.floor(minutes/60);\n        if (hours < 24) {\n            return hours + periods.get(\"hours\");\n        }\n        \n        const days = Math.floor(hours/24);\n        return days + periods.get(\"days\");\n    }\n    \n}.initThisClass());\n",
  "wDYJbQIzRZplsS34TRVsrnLRKjSFQSV6su4vh7kzBBk=": "\"use strict\";\n\n/**\n * TimeFormatter takes a JavaScript Date and produces a formatted string description\n * following the object's format option properties.\n *\n * @example\n * const formatter = TimeFormatter.clone()\n * formatter.setIs24Hour(false)          // this is the default\n * formatter.setShowsMeridiem(true)      // this is the default\n * formatter.setUppercaseMeridiem(false) // this is the default\n * formatter.setAmString(\"am\")           // this is the default\n * formatter.setPmString(\"pm\")           // this is the default\n * formatter.setShowsSeconds(false)      // this is the default\n * formatter.setShowsMilliseconds(false) // this is the default\n * formatter.setHourMinuteSpacer(\":\")    // this is the default\n * formatter.setDate(new Date())\n * const aDateString = formatter.formattedValue()\n *\n * // example output: \"10:11am\"\n *\n * @module ideal.formatters\n * @class TimeFormatter\n * @extends ProtoClass\n */\n(class TimeFormatter extends ProtoClass {\n    initPrototypeSlots () {\n        /**\n         * The date to be formatted.\n         * @type {Date}\n         * @default null\n         */\n        {\n            const slot = this.newSlot(\"date\", null) // temp value which will be formatted\n            slot.setShouldStoreSlot(false)\n            slot.setSlotType(\"Date\") // a javascript Date object\n            slot.setCanInspect(true)\n        }\n\n        /**\n         * Whether to use 24-hour format.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"is24Hour\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        /**\n         * Whether to show meridiem (AM/PM).\n         * @type {boolean}\n         * @default true\n         */\n        {\n            const slot = this.newSlot(\"showsMeridiem\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n        /**\n         * Whether to uppercase the meridiem.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"uppercaseMeridem\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n            \n        /**\n         * The string to use for AM.\n         * @type {string}\n         * @default \"am\"\n         */\n        {\n            const slot = this.newSlot(\"amString\", \"am\")\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"String\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * The string to use for PM.\n         * @type {string}\n         * @default \"pm\"\n         */\n        {\n            const slot = this.newSlot(\"pmString\", \"pm\")\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"String\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * Whether to pad hours with zeros.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"doesPadHours\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * Whether to show hours.\n         * @type {boolean}\n         * @default true\n         */\n        {\n            const slot = this.newSlot(\"showsHours\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * The spacer between hours and minutes.\n         * @type {string}\n         * @default \":\"\n         */\n        {\n            const slot = this.newSlot(\"hourMinuteSpacer\", \":\")\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"String\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * Whether to show minutes.\n         * @type {boolean}\n         * @default true\n         */\n        {\n            const slot = this.newSlot(\"showsMinutes\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * Whether to show seconds.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"showsSeconds\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n                \n        /**\n         * Whether to show milliseconds.\n         * @type {boolean}\n         * @default false\n         */\n        {\n            const slot = this.newSlot(\"showsMilliseconds\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n    }\n  \n    initPrototype () {      \n    }\n\n    /**\n     * Pads a number with leading zeros to a specified length.\n     * @param {number} n - The number to pad.\n     * @param {number} [padLength=2] - The desired length of the padded number.\n     * @returns {string} The padded number as a string.\n     */\n    paddedNumber (n, padLength) {\n        if (!padLength) {\n            padLength = 2\n        }\n        const s = \"\" + n\n        if (s.length < padLength) { \n            return \"0\".repeat(padLength - s.length) + s\n        }\n        return s\n    }\n\n    /**\n     * Gets the hours in 12-hour format.\n     * @returns {number} The hours in 12-hour format.\n     */\n    getTwelveHours () {\n        let h = this.date().getHours()\n        if (h > 12) { h -= 12 }\n        if (h === 0) { h = 12 }\n        return h\n    }\n\n    /**\n     * Gets the date in zero-padded US format (HH:MM).\n     * @returns {string} The date in zero-padded US format.\n     */\n    zeroPaddedUSDate () {\n        return this.paddedNumber(this.getTwelveHours()) + \":\" + this.paddedNumber(this.getMinutes())\n    }\n\n    /**\n     * Gets the hours string based on the formatter's settings.\n     * @returns {string} The hours string.\n     */\n    hoursString () {\n        let h = this.date().getHours()\n\n        if (!this.is24Hour()) {\n            h = this.getTwelveHours()\n        }\n        \n        if (this.doesPadHours()) {\n            this.paddedNumber(h)\n        }\n\n        return \"\" + h\n    }\n\n    /**\n     * Gets the minutes string.\n     * @returns {string} The minutes string.\n     */\n    minutesString () {\n        return this.paddedNumber(this.date().getMinutes())\n    }\n\n    /**\n     * Gets the seconds string.\n     * @returns {string} The seconds string.\n     */\n    secondsString () {\n        return this.paddedNumber(this.date().getSeconds())\n    }\n\n    /**\n     * Gets the milliseconds string.\n     * @returns {string} The milliseconds string.\n     */\n    millisecondsString () {\n        return this.paddedNumber(this.date().getMilliseconds() % 1000)\n    }\n\n    /**\n     * Gets the meridiem string (AM/PM) based on the formatter's settings.\n     * @returns {string} The meridiem string.\n     */\n    meridiemString () {\n        let s = \"\"\n        \n        if (this.date().getHours() < 12) {\n            s = this.amString()\n        } else {\n            s = this.pmString()\n        }\n        \n        if (this.uppercaseMeridem()) {\n            s = s.toUpperCase()\n        }\n\n        return s\n    }\n\n    /**\n     * Formats the date value into a string based on the formatter's settings.\n     * @returns {string} The formatted date string.\n     */\n    formattedValue () {\n        assert(this.date())\n        let s = \"\"\n\n        if (this.showsHours()) {\n            s += this.hoursString()\n        }\n\n        if (this.showsMinutes()) {\n            if (s.length) {\n                s += this.hourMinuteSpacer()\n            }\n            s += this.minutesString()\n        } \n\n        if (this.showsMeridiem()) { // correct location wrt seconds?\n            s += this.meridiemString()\n        } \n\n        if (this.showsSeconds()) {\n            if (s.length) {\n                s += this.hourMinuteSpacer()\n            }\n            s += this.secondsString()\n        } \n\n        if (this.showsMilliseconds()) {\n            if (s.length) {\n                s += this.hourMinuteSpacer()\n            }\n            s += this.millisecondsString() \n        } \n\n        if (true) {\n            const h = this.date().getHours()\n            const m = this.date().getMinutes()\n            if (h === 0 && m === 0) { \n                s = \"midnight\"\n            }\n\n            if (h === 12 && m === 0) { \n                s = \"noon\"\n            }\n        }\n\n        return s\n    }\n}.initThisClass());\n\n\n\n\n",
  "dqEZRpxZXbdUAwA++434sdwuahLDIo/6/4ldoEA/888=": "\"use strict\";\n\n/*\n\n    Documentation\n\n    An simple in-memory documentation system.\n    \n    TODO: Rename to something more unique.\n\n*/\n\n(class Documentation extends ProtoClass {\n    initPrototypeSlots () {\n    }\n  \n    initPrototype () {\n    }\n\n    classes () {\n        return ProtoClass.allClassesSet().asArray()\n    }\n\n    methodsDocsForClass (aClass) {\n        const methods = []\n        Object.getOwnPropertyNames(aClass).forEach((methodName) => {\n            const v = aClass[methodName]\n            //const docs = v._docs\n            if (Type.isFunction(v) && methodName !== \"constructor\") {\n                const source = v.toString()\n                let argNames = source.after(\"(\").before(\")\").split(\",\").map(s => s.trim())\n                if (argNames[0] === \"\") { \n                    argNames = [] \n                }\n                methods.push({ name: methodName, argNames: argNames, comments: v.extractComments() })\n            }\n        })\n        return methods\n    }\n\n    asJson () {\n        const classes = []\n        this.classes().forEach((aClass) => {\n            const classDict = {}\n            classDict.name = aClass.type()\n            const superclass = aClass.superClass()\n            if (superclass.type) {\n                classDict.superClass = superclass.type()\n            }\n            classes.push(classDict)\n            classDict.methods = this.methodsDocsForClass(aClass)\n            //classDict.comments = aClass.comments()\n        })\n        return classes\n    }\n\n    show () {\n        const classes = this.asJson()\n        const lines = []\n        classes.forEach((aClass) => {\n            lines.push(aClass.name + \" : \" + aClass.superClass)\n            /*\n            aClass.methods.forEach((aMethod) => {\n                let argsString = \"\"\n                if (aMethod.argNames.length > 0) {\n                    argsString = \"(\" + aMethod.argNames.join(\",\") + \")\"\n                }\n                lines.push(\"  - \" + aMethod.name + argsString + \" \" + aMethod.comments)\n            })\n            */\n        })\n        /*\n        const s = JSON.stableStringify(this.asJson(), 2, 2)\n        */\n        console.log(\"DOCUMENTATION:\\n\\n\", lines.join(\"\\n\"))\n    }\n}.initThisClass());\n\n\n/*\n// --- Object category -------------------------------------\n\nObject.defineSlots(Object.prototype, {\n\n    docs: function () {\n        if (!this._docs) {\n            this._docs = {}\n        }\n        return this._docs\n    },\n\n    setDocs: function (name, description) {\n        const docs = this.docs()\n        docs._name = methodName\n        docs._description = description\n        return this\n    },\n    \n})\n\n// --- Function category -------------------------------------\n\nObject.defineSlots(Function.prototype, {\n\n    docs: function () {\n        if (!this._docs) {\n            this._docs = {}\n        }\n        return this._docs\n    },\n\n    setDocs: function (name, description, returns) {\n        const docs = this.docs()\n        docs._name = name\n        docs._description = description\n        docs._returns = returns \n        return this\n    },\n\n    extractComments: function () {\n        const commentPattern = new RegExp(\"(\\\\/\\\\*([^*]|[\\\\r\\\\n]|(\\\\*+([^*\\/]|[\\\\r\\\\n])))*\\\\*+\\/)|(\\/\\/.*)\", \"g\");\n        return this.toString().match(commentPattern)\n    },\n})\n\n*/",
  "ditg62SGBq6hVtgECUmup1Tu9qtc5BQvoLNhe+PMluo=": "\"use strict\";\n\n/*\n    \n    StackTrace\n    \n    Class that can parse a JS stack trace, into StackFrame objects.\n\n\n*/\n\n(class StackFrame extends ProtoClass {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"functionName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"url\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"lineNumber\", null);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"characterNumber\", null);\n            slot.setSlotType(\"Number\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    fromLine (line) {\n        line = line.after(\"at \")\n\n        if (line.contains(\"(\")) {\n            const functionName = line.before(\"(\").strip()\n            this.setFunctionName(functionName)\n            line = line.between(\"(\", \")\").strip()\n        }\n        \n        const parts = line.split(\":\")\n        if (parts.length !== 4) {\n            console.log(\"unexpected stacktrace line format: '\" + line + \"'\")\n            return this\n        }\n        const lineNumber = parts.removeLast()\n        this.setLineNumber(Number(lineNumber))\n\n        const characterNumber = parts.removeLast()\n        this.setCharacterNumber(Number(characterNumber))\n\n        const url = parts.join(\":\")\n        this.setUrl(url)\n\n        return this\n    }\n\n    description () {\n        return \"  \" + this.functionName() + \"() line \" + this.lineNumber()\n    }\n\n    show () {\n        console.log(this.description())\n    }\n}.initThisClass());;\n\n\n// -----------------------------------------------------------------\n\n(class StackTrace extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"error\", null);\n            slot.setSlotType(\"Error\");\n        }\n        {\n            const slot = this.newSlot(\"stackFrames\", []);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    init () {\n        super.init()\n    }\n\t\n    setError (error) {\n        this._error = error\n\n        const lines = error.stack.split(\"\\n\")\n        const firstLine = lines.removeFirst()\n\t\t\n        const frames = lines.map((line) => {\n            return StackFrame.clone().fromLine(line)\n        })\n        this.setStackFrames(frames)\n\n        return this\n    }\n\n    show () {\n        console.log(this.type() + \": '\" + this.error().message + \"'\")\n        this.stackFrames().forEach(frame => frame.show())\n    }\n\n    test () {\n        const f1 = function () {\n            try {\n                throw(new Error(\"test error\"))\n            } catch (e) {\n                StackTrace.clone().setError(e).show()\n            }\n        }\n        \n        const f2 = function () { f1() }\n        const f3 = function () { f2() }\n        f3()        \n    }\n\n}.initThisClass());\n\n//StackTrace.clone().test()\n//console.log(\"Currently running script:\", Error.callingScriptURL())\n",
  "QrrsNUVd5AmfwV9cB1Xaz2p/QT+f7/HQR63owTzyQCw=": "\"use strict\";\n\n/*\n\n    NamespaceSearch\n \n    A way to search the Javascript namespace.\n    All slots are enumerated and passed through a user defined closure to find matches.\n\n    Example use:\n\n        const search = new NamespaceSearch()\n        search.setSlotMatchClosure(function (slotOwner, slotName, slotValue, slotPath) {\n            return slotName === \"String\"\n        })\n        search.find()\n        assert(search.matchingPaths()[0] === \"globalThis/String\")\n\n*/\n\n(class NamespaceSearch extends ProtoClass {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"visited\", null);\n            slot.setSlotType(\"Set\");\n        }\n        {\n            const slot = this.newSlot(\"matchingPaths\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"slotMatchClosure\", null);\n            slot.setSlotType(\"Function\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    init () {\n        super.init();\n        this.clear();\n    }\n\n    clear () {\n        this.setVisited(new Set([this])) // to avoid searching this object\n        this.setMatchingPaths([])\n    }\n\n    find (searchString) {\n        this.clear()\n\n        if (searchString) {\n            this.setSlotMatchClosure((slotOwner, slotName, slotValue, slotPath) => {\n                return slotName === s\n            })\n        }\n\n        //this.findOnObject(globalThis, [\"globalThis\"])\n        this.findOnObject(getGlobalThis(), [\"globalThis\"])\n        return this\n    }\n\n    findOnObject (v, path = []) {\n        if (Type.isNullOrUndefined(v)) {\n            return false\n        }\n\n        if (this.visited().has(v)) {\n            return false\n        } else {\n            this.visited().add(v)\n        }\n\n        //const joinedPath = path.join(\"/\")\n\n        Object.getOwnPropertyNames(v).forEach((k) => {\n            if (this.canAccessSlot(v, k)) {\n                this.findOnSlot(v, k, path)\n            }\n        })\n    }\n\n    canAccessSlot (v, k) {\n        // to avoid illegal operation errors\n        const descriptor = Object.getOwnPropertyDescriptor(v, k)\n        const hasCustomGetter = Type.isUndefined(descriptor.get)\n        return !hasCustomGetter\n    }\n\n    findOnSlot (slotOwner, slotName, path = []) {\n        const localPath = path.shallowCopy()\n        localPath.push(slotName)\n        \n        const slotValue = slotOwner[slotName]\n\n        if (this.doesMatchOnSlot(slotOwner, slotName, slotValue, localPath)) {\n            this.addMatchingPath(localPath)\n        }\n\n        this.findOnObject(slotValue, localPath)\n    }\n\n    doesMatchOnSlot (slotOwner, slotName, slotValue, slotPath) {\n        return this.slotMatchClosure()(slotOwner, slotName, slotValue, slotPath)\n    }\n\n    addMatchingPath (aPath) {\n        const stringPath = aPath.join(\"/\")\n        if (!this.matchingPaths().contains(stringPath)) {\n            this.matchingPaths().push(stringPath)\n        }\n        return this\n    }\n\n    showMatches () {\n        console.log(\"matchingPaths:\")\n        this.matchingPaths().forEach(p => console.log(\"  \" + p))\n    }\n\n    static selfTest () {\n        const ns = NamespaceSearch.clone()\n        ns.setSlotMatchClosure(function (slotOwner, slotName, slotValue, slotPath) {\n            return slotName === \"String\"\n        })\n        ns.find()\n        assert(ns.matchingPaths()[0] === \"globalThis/String\")\n    }\n\n}.initThisClass());\n\n//NamespaceSearch.selfTest()\n",
  "kBZ1L07ZjTN+HDno7i4T8QJIYV+MfPY4tAZZLD6krSY=": "\"use strict\";\n\n/* \n    HttpResponseCodes\n\n    Example use:\n\n    const info = HttpResponseCodes.shared().infoForCode(426)\n\n    // info contains: { \"type\": \"Client Error\", \"description\": \"Upgrade Required\" }\n\n*/\n\n(class HttpResponseCodes extends ProtoClass {\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"codesMap\", null);\n      slot.setSlotType(\"Map\");\n    }\n  }\n\n  initPrototype () {\n    this.setCodesMap(this.codesAsMap());\n  }\n\n  init () {\n    super.init();\n  }\n\n  codesAsMap () {\n    const m = new Map();\n    const json = this.jsonCodes();\n    Object.keys(json).forEach(code => {\n      const value = json[code];\n      m.set(code, value);\n    });\n    return m;\n  }\n\n  infoForCode (code) {\n    const info = this.codesMap().get(\"\" + code);\n    return info;\n  }\n\n  stringForCode (code) {\n    const info = this.infoForCode(code);\n    if (info) {\n      return \"HTTP Response Code '\" + code + \"': \" + info.type + \": \" + info.description;\n    }\n    return \"Unknown HTTP Response code: '\" + code + \"'\";\n  }\n\n\n  shortStringForCode (code) {\n    const info = this.infoForCode(code);\n    if (info) {\n      return info.type + \": \" + info.description;\n    }\n    return \"Unknown HTTP Response code: '\" + code + \"'\";\n  }\n\n  jsonCodes () {\n    return {\n      \"100\": {\"type\": \"Informational\", \"description\": \"Continue\"},\n      \"101\": {\"type\": \"Informational\", \"description\": \"Switching Protocols\"},\n      \"102\": {\"type\": \"Informational\", \"description\": \"Processing\"},\n      \"200\": {\"type\": \"Success\", \"description\": \"OK\"},\n      \"201\": {\"type\": \"Success\", \"description\": \"Created\"},\n      \"202\": {\"type\": \"Success\", \"description\": \"Accepted\"},\n      \"203\": {\"type\": \"Success\", \"description\": \"Non-Authoritative Information\"},\n      \"204\": {\"type\": \"Success\", \"description\": \"No Content\"},\n      \"205\": {\"type\": \"Success\", \"description\": \"Reset Content\"},\n      \"206\": {\"type\": \"Success\", \"description\": \"Partial Content\"},\n      \"207\": {\"type\": \"Success\", \"description\": \"Multi-Status\"},\n      \"208\": {\"type\": \"Success\", \"description\": \"Already Reported\"},\n      \"226\": {\"type\": \"Success\", \"description\": \"IM Used\"},\n      \"300\": {\"type\": \"Redirection\", \"description\": \"Multiple Choices\"},\n      \"301\": {\"type\": \"Redirection\", \"description\": \"Moved Permanently\"},\n      \"302\": {\"type\": \"Redirection\", \"description\": \"Found\"},\n      \"303\": {\"type\": \"Redirection\", \"description\": \"See Other\"},\n      \"304\": {\"type\": \"Redirection\", \"description\": \"Not Modified\"},\n      \"305\": {\"type\": \"Redirection\", \"description\": \"Use Proxy\"},\n      \"307\": {\"type\": \"Redirection\", \"description\": \"Temporary Redirect\"},\n      \"308\": {\"type\": \"Redirection\", \"description\": \"Permanent Redirect\"},\n      \"400\": {\"type\": \"Client Error\", \"description\": \"Bad Request\"},\n      \"401\": {\"type\": \"Client Error\", \"description\": \"Unauthorized\"},\n      \"402\": {\"type\": \"Client Error\", \"description\": \"Payment Required\"},\n      \"403\": {\"type\": \"Client Error\", \"description\": \"Forbidden\"},\n      \"404\": {\"type\": \"Client Error\", \"description\": \"Not Found\"},\n      \"405\": {\"type\": \"Client Error\", \"description\": \"Method Not Allowed\"},\n      \"406\": {\"type\": \"Client Error\", \"description\": \"Not Acceptable\"},\n      \"407\": {\"type\": \"Client Error\", \"description\": \"Proxy Authentication Required\"},\n      \"408\": {\"type\": \"Client Error\", \"description\": \"Request Timeout\"},\n      \"409\": {\"type\": \"Client Error\", \"description\": \"Conflict\"},\n      \"410\": {\"type\": \"Client Error\", \"description\": \"Gone\"},\n      \"411\": {\"type\": \"Client Error\", \"description\": \"Length Required\"},\n      \"412\": {\"type\": \"Client Error\", \"description\": \"Precondition Failed\"},\n      \"413\": {\"type\": \"Client Error\", \"description\": \"Payload Too Large\"},\n      \"414\": {\"type\": \"Client Error\", \"description\": \"URI Too Long\"},\n      \"415\": {\"type\": \"Client Error\", \"description\": \"Unsupported Media Type\"},\n      \"416\": {\"type\": \"Client Error\", \"description\": \"Range Not Satisfiable\"},\n      \"417\": {\"type\": \"Client Error\", \"description\": \"Expectation Failed\"},\n      \"418\": {\"type\": \"Client Error\", \"description\": \"I'm a teapot\"},\n      \"421\": {\"type\": \"Client Error\", \"description\": \"Misdirected Request\"},\n      \"422\": {\"type\": \"Client Error\", \"description\": \"Unprocessable Entity\"},\n      \"423\": {\"type\": \"Client Error\", \"description\": \"Locked\"},\n      \"424\": {\"type\": \"Client Error\", \"description\": \"Failed Dependency\"},\n      \"425\": {\"type\": \"Client Error\", \"description\": \"Too Early\"},\n      \"426\": {\"type\": \"Client Error\", \"description\": \"Upgrade Required\"},\n      \"428\": {\"type\": \"Client Error\", \"description\": \"Precondition Required\"},\n      \"429\": {\"type\": \"Client Error\", \"description\": \"Too Many Requests\"},\n      \"431\": {\"type\": \"Client Error\", \"description\": \"Request Header Fields Too Large\"},\n      \"451\": {\"type\": \"Client Error\", \"description\": \"Unavailable For Legal Reasons\"},\n      \"500\": {\"type\": \"Server Error\", \"description\": \"Internal Server Error\"},\n      \"501\": {\"type\": \"Server Error\", \"description\": \"Not Implemented\"},\n      \"502\": {\"type\": \"Server Error\", \"description\": \"Bad Gateway\"},\n      \"503\": {\"type\": \"Server Error\", \"description\": \"Service Unavailable\"},\n      \"504\": {\"type\": \"Server Error\", \"description\": \"Gateway Timeout\"},\n      \"505\": {\"type\": \"Server Error\", \"description\": \"HTTP Version Not Supported\"},\n      \"506\": {\"type\": \"Server Error\", \"description\": \"Variant Also Negotiates\"},\n      \"507\": {\"type\": \"Server Error\", \"description\": \"Insufficient Storage\"},\n      \"508\": {\"type\": \"Server Error\", \"description\": \"Loop Detected\"},\n      \"510\": {\"type\": \"Server Error\", \"description\": \"Not Extended\"},\n      \"511\": {\"type\": \"Server Error\", \"description\": \"Network Authentication Required\"}\n    };\n  }\n\n}.initThisClass());\n\n",
  "ehWxcsSrKLcgE6JzkVJbPkJUI71220BauWZFKlfkvSo=": "\n\n\"use strict\";\n\n/*\n\n    StreamNode\n\n    Base class for StreamTextNode and StreamElementNode\n\n*/\n\n(class StreamNode extends ProtoClass {\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"parent\", null); // parent tag\n            slot.setSlotType(\"StreamNode\");\n            slot.setAllowsNullValue(true);\n        }\n\n        {\n            const slot = this.newSlot(\"domNode\", null); // HTMLElement or TextNode\n            slot.setSlotType(\"HTMLElement\");\n        }\n\n        {\n            const slot = this.newSlot(\"isClosed\", false); // true if the stream has read the closing of the node\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    detectAncestor (func) {\n        if (func(this)) {\n            return this;\n        }\n        if (this.parent()) {\n            return this.parent().detectAncestor(func);\n        }\n        return null;\n    }\n\n    onOpen () {\n        const domNode = this.asDomNode();\n        /*\n        // parent responsible for calling appendChild\n        if (this.parent()) {\n            domNode.setParent(this.parent().domNode())\n        }\n        */\n        this.setDomNode(domNode);\n        return this;\n    }\n\n    onClose () {\n        // called by HtmlStreamReader\n        this.setIsClosed(true);\n        return this;\n    }\n\n    rootNode () {\n        if (this.parent()) {\n            return this.parent().rootNode();\n        }\n        return this;\n    }\n\n    tagPath () {\n        const path = this.parent() ? this.parent().tagPath() : [];\n        path.push(this);\n        return path;\n    }\n\n    numberPath () {\n        return this.tagPath().map(tag => tag.childIndex());\n    }\n\n    depth () {\n        return this.tagPath().length;\n    }\n\n    depthSpacer () {\n        return \"  \".repeat(this.depth());\n    }\n\n}.initThisClass());\n",
  "vCtw4lefvlwS/Z0OYsyUUOy9JdS5oA6HUFr2dx8uDys=": "\n\n\"use strict\";\n\n/*\n\n    StreamTextNode\n\n\n*/\n\n(class StreamTextNode extends StreamNode {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"text\", \"\"); // string\n            slot.setSlotType(\"String\");\n        }\n    }\n  \n    initPrototype () {\n    }\n\n    appendText (s) {\n        assert(Type.isString(s));\n        this.setText(this.text() + s);\n        this.domNode().textContent = this.text();\n        return this;\n    }\n\n    /*\n    onClose () {\n        super.onClose();\n        return this;\n    }\n    */\n\n    isTextNode () {\n        return true;\n    }\n\n    asHtml () {\n        return this.text();\n    }\n\n    textContent () {\n        return this.text();\n    }\n\n    description () {\n        return this.text().clipWithEllipsis(15);\n    }\n\n    show () {\n        console.log(this.depthSpacer() + this.text());\n    }\n\n    asDomNode () {\n        const domNode = document.createTextNode(this.textContent());\n        return domNode;\n    }\n    \n}.initThisClass());\n",
  "3oaZ6iWqwRFCRhh1+ZtSByCRh+/n4vluQIzueTcSpVY=": "\n\"use strict\";\n\n/*\n\n  StreamElementNode\n\n*/\n\n(class StreamElementNode extends StreamNode {\n\n    initPrototypeSlots () {\n      {\n          const slot = this.newSlot(\"name\", \"\"); // string\n          slot.setSlotType(\"String\");\n      }\n  \n      {\n          const slot = this.newSlot(\"attributes\", null); // dictionary TODO: make this a Map\n          slot.setSlotType(\"Object\");\n      }\n  \n      {\n          const slot = this.newSlot(\"text\", \"\"); // string\n          slot.setSlotType(\"String\");\n      }\n\n      {\n        const slot = this.newSlot(\"children\", null); // array of child tags and strings\n        slot.setSlotType(\"Array\");\n      }\n    }\n  \n    initPrototype () {\n    }\n  \n    init () {\n      super.init();\n      this.setAttributes({});\n      this.setChildren([]);\n    }\n\n    isTextNode () {\n      return false;\n    }\n\n    lastTextNode () {\n      const last = this.children().last();\n      if (last && last.isTextNode()) {\n        return last;\n      }\n      return null;\n    }\n  \n    addChild (aNode) { // node is String or SentenceTag\n      aNode.setParent(this);\n      this.children().push(aNode);\n      this.domNode().appendChild(aNode.domNode());\n      return this;\n    }\n  \n    attributesString () {\n      const parts = [];\n      for (const [key, value] of Object.entries(this.attributes())) {\n        parts.push(key + '=\"' + value + '\"');\n      }\n      return parts.join(\" \")\n    }\n  \n    openTagString () {\n      const as = this.attributesString();\n      return \"<\" + this.name() + (as ? \" \" + as : \"\") + \">\";\n    }\n\n    closeTagString () {\n      if (this.isClosed()) {\n        return \"</\" + this.name() + \">\";\n      } \n      return \"\";\n    }\n\n    description () {\n      return this.openTagString() + this.innerHtml().clipWithEllipsis(15) + this.closeTagString();\n    }\n\n    asHtml () {\n      // NOTE: this is not normalized HTML, use asHtmlNormalized() on the returned value before comparing\n      return this.openTagString() + this.innerHtml() + this.closeTagString();\n    }\n  \n    innerHtml () {\n    // NOTE: this is not normalized HTML, use asHtmlNormalized() on the returned value before comparing\n      const strings = this.children().map(child => child.asHtml());\n      return strings.join(\"\");\n    }\n\n    textContent () {\n      return this.children().map(c => c.textContent()).join(\"\");\n    }\n\n    show () {\n      console.log(this.depthSpacer() + this.openTagString());\n      this.children().forEach(child => child.show());\n      console.log(this.depthSpacer() + this.closeTagString());\n      return this;\n    }\n\n    asDomNode() {\n      const newNode = document.createElement(this.name());\n      const attributes = this.attributes();\n\n      if (attributes) {\n        for (const [key, value] of Object.entries(attributes)) {\n          newNode.setAttribute(key, value);\n        }\n      }\n      return newNode;\n    }\n\n    // --- helpers ---\n\n    dataNote () {\n      return this.attributes()[\"data-note\"];\n    }\n  \n  }.initThisClass());\n  ",
  "efFNSw7SunQxSugFqMC9KoR6ob70eY5K42sLxUVItMM=": "\"use strict\";\n\n/*\n\n    HtmlStreamReader\n\n    Wrapper over htmlparser2 library which:\n    - deals with TextNodes (instead of just elements)\n    - constructs virtual DOM during streaming\n    - virtual DOM also manages a real DOM\n\n    IMPORTANT:\n\n    Unlike the real DOM, when the virtual DOM node is asked for it's HTML (via asHtml() or innerHtml()), it:\n    - does not close any (as yet) unclosed elements or text\n    This ensures that each call to, say:\n\n     reader.rootNode().innerHtml()\n\n    Will being with the exact value of the last call to it. \n    This is helpful for doing proper incremental merging.\n\n\n    Example use:\n\n    const reader = HtmlStreamReader.clone();\n    reader.setDelegate(this);\n    reader.beginHtmlStream();\n    reader.onStreamHtml(chunk1);\n    reader.onStreamHtml(chunk2);\n    ...\n    reader.onStreamHtml(lastChunk);\n    reader.endHtmlStream();\n\n    // delegate protocol\n\n      onHtmlStreamReaderStart (reader)\n      onHtmlStreamReaderPushNode (reader, streamNode)\n      onHtmlStreamReaderPopNode (reader, streamNode) \n      onHtmlStreamReaderEnd (reader)\n\n*/\n\n(class HtmlStreamReader extends ProtoClass { \n\n  initPrototypeSlots () {\n    {\n        const slot = this.newSlot(\"parser\", null);\n        slot.setSlotType(\"htmlparser2.Parser\");\n    }\n\n    {\n        const slot = this.newSlot(\"currentNode\", null);\n        slot.setSlotType(\"StreamElementNode\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setSlotType(\"Error\");\n    }\n  }\n  \n  initPrototype () {\n  }\n\n  init () {\n    super.init();\n    this.setParser(this.newParser());\n    //this.setIsDebugging(true);\n  }\n\n  newParser () {\n      const self = this;\n      const parser = new htmlparser2.Parser(\n      {\n        onopentag (tagName, attributes) {\n          self.onOpenElement(tagName, attributes)\n        },\n\n        ontext (text) {\n          self.onText(text)\n        },\n\n        onclosetag (tagname) {\n          self.onCloseElement(tagname)\n        },\n\n        onend () {\n          self.onEnd()\n        }\n      }, \n      { \n          decodeEntities: true \n      }\n      );\n      \n      parser._target = this;\n\n      return parser;\n  }\n\n  shutdown () {\n    this.setParser(null);\n    return this;\n  }\n\n  newElement () {\n    return StreamElementNode.clone();\n  }\n\n  pushTopNode () {\n    const topNode = this.newElement().setName(\"top\").onOpen();\n    this.setCurrentNode(topNode); \n  }\n\n  rootElement () {\n    return this.rootNode().domNode();\n  }\n\n  // --- called by owner to input html stream ---\n\n  beginHtmlStream () {\n    this.pushTopNode();\n    this.sendDelegate(\"onHtmlStreamReaderStart\", [this]);\n  }\n\n  onStreamHtml (chunk) {\n    this.parser().write(chunk);\n  }\n\n  isValidEnd () {\n    let endNode = this.currentNode();\n    if (endNode.thisClass().isKindOf(StreamTextNode)) {\n      endNode = endNode.parent();\n    }\n    return endNode === this.rootNode();\n  }\n\n  endHtmlStream () {\n    /*\n    if (!this.isValidEnd()) {\n      // need to pop if its a StreamTextNode\n      this.setError(new Error(\"HtmlStreamReader.endHtmlStream() ended with unclosed elements\"));\n      console.warn(this.error().message);\n      debugger;\n    }\n    */\n    this.parser().end();\n    this.sendDelegate(\"onHtmlStreamReaderEnd\", [this]);\n  }\n\n  // --- tags ---\n\n  pushNode (newNode) {\n    const currentNode = this.currentNode();\n    //console.log(\"PUSH \" + newNode.asHtml());\n    assert(!currentNode.isTextNode());\n    currentNode.addChild(newNode);\n    this.setCurrentNode(newNode);\n    this.sendDelegate(\"onHtmlStreamReaderPushNode\", [this, newNode]);\n    return newNode;\n  }\n\n  popNode () {\n    const n = this.currentNode();\n    //console.log(\"POP \" + n.asHtml());\n    assert(n);\n    n.onClose();\n    const p = n.parent();\n    assert(p); // this can happen on an incomplete tag e.g. [<div class=\"']\n    this.setCurrentNode(p);\n\n    this.sendDelegate(\"onHtmlStreamReaderPopNode\", [this, n]);\n    //this.show();\n    return n;\n  }\n\n  rootNode () {\n    return this.currentNode().rootNode();\n  }\n\n  show () {\n    const line = \"-\".repeat(20);\n    console.log(line + \" \" + this.type() + \" \" + line);\n    this.rootNode().show();\n    console.log(line + line);\n    //debugger;\n  }\n\n  previousTag () {\n    return this.currentNode().parent();\n  }\n\n  // --- htmlparser2 events ---\n\n  popIfCurrentNodeIsText () {\n    const n = this.currentNode();\n    if (n.isTextNode()) {\n      this.onCloseText(); // will do pop\n    }\n  }\n\n  // --- open and close element ---\n\n  onOpenElement (tagName, attributes) {\n    //console.log(\"onOpenElement(\" + tagName + \", \" + JSON.stringify(attributes) + \")\");\n\n    this.popIfCurrentNodeIsText();\n\n    const e = this.newElement();\n    e.setParent(this.currentNode());\n    e.setName(tagName);\n    e.setAttributes(attributes);\n    e.onOpen();\n    //console.log(\"onOpenElement \" + e.openTagString());\n    this.pushNode(e);\n  }\n\n  onCloseElement (tagName) {\n    //console.log(\"onCloseElement(\" + tagName + \")\");\n\n    this.popIfCurrentNodeIsText();\n    \n    const currentNode = this.currentNode();\n    if (currentNode && currentNode.name() === tagName) {\n      const e = this.popNode();\n      assert(e.name() === tagName);\n      //console.log(\"onCloseElement \" + e.asHtml());\n    } else {\n      console.warn(\"WARNING:  \" + this.type() + \".onCloseElement(\" + tagName + \") doesn't match current node \" + currentNode.name() + \" so we will ignore it and won't send a callback\");\n    }\n  }\n\n  // ---------------------------------\n\n  onText (text) {\n    //console.log(\"onText '\" + text + \"'\");\n    const n = this.currentNode();\n    //debugger;\n    \n    if (n.isTextNode()) {\n      n.appendText(text);\n    } else {\n      this.onOpenText(text);\n    }\n  }\n\n  onOpenText (text) {\n    //console.log(\"onOpenText '\" + text + \"'\");\n    const newNode = StreamTextNode.clone().setText(text).onOpen();\n    this.pushNode(newNode);\n  }\n\n  onCloseText () {\n    const n = this.currentNode();\n    //console.log(\"onCloseText '\" + n.text() + \"'\");\n    assert(n.isTextNode());\n    this.popNode();\n  }\n\n  // --------------------------------\n\n  onEnd () {\n    this.popIfCurrentNodeIsText();\n  }\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate();\n\n    /*\n    if (this.isDebugging()) {\n      console.log(this.type() + \" --------------- calling delegate \" + methodName + \"(\" + args.join(\",\") + \")\");\n    }\n    */\n\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        f.apply(d, args)\n        return true\n      }\n    } else {\n      /*\n      const error = this.type() + \" delegate missing method '\" + methodName + \"'\";\n      console.log(error);\n      debugger;\n      throw new Error(error);\n      */\n    }\n    return false\n  }\n\n}.initThisClass());\n\n\nconst testSentenceReader = function () {\n\n  console.log(\n    \"=========================================================================\"\n  );\n\n  \n  const results = [];\n  const others = [];\n  const htmlResults = [];\n\n  const reader = HtmlStreamReader.clone();\n  reader.setDelegate({\n    onSpokenSentence: (text, html) => {\n      results.push(text);\n      htmlResults.push(html);\n    }\n  })\n\n  // Simulate random breaks in the HTML content\n  reader.beginHtmlStream();\n  reader.onStreamHtml('<div class=\"session-name\">The Lost City\\'s Hidden Secrets</div>\\n\\n<span');\n  reader.onStreamHtml('>Welcome, brave souls, to the edge of the <div class=\\\"location-name\\\">Sighing Desert</div>.</span>');\n  reader.onStreamHtml('<span data-note=\"speak\">Here, amid the dunes that stretch like slumbering golden serpents beneath the relentless sun, lies the enigma of a vanished civilization.</span>\\n\\n');\n  reader.endHtmlStream();\n\n  const expectedSentences = [\n    \"The Lost City's Hidden Secrets\",\n    //\"\\n\\n\",\n    \"Welcome, brave souls, to the edge of the Sighing Desert.\",\n    \"Here, amid the dunes that stretch like slumbering golden serpents beneath the relentless sun, lies the enigma of a vanished civilization.\"\n    //\"\\n\\n\"\n  ];\n\n  const passed = JSON.stringify(results) === JSON.stringify(expectedSentences);\n\n  if (passed) {\n    console.log(`Test Passed - Output:` + JSON.stringify(results, 2, 2));\n  } else {\n    console.warn(`Test Failed:`);\n    console.warn(`Input: '<div class=\"session-name\">The Lost City's Hidden Secrets</div><span data-note=\"speak\">Welcome, brave souls, to the edge of the <div class=location-name>Sighing Desert</div>.</span><span data-note=\"speak\">Here, amid the dunes that stretch like slumbering golden serpents beneath the relentless sun, lies the enigma of a vanished civilization.</span>'`);\n    console.warn(\"Expected Output: \", JSON.stringify(expectedSentences, 2, 2));\n    console.warn(\"  Actual Output: \", JSON.stringify(results, 2, 2));\n    debugger;\n  }\n\n  console.log(\n    \"=========================================================================\"\n  );\n  \n}\n\n//testSentenceReader();",
  "6ucBwQQq8sjpJfSqILKXmWKKkB+eJZOs7KLoOkJ12Pc=": "\"use strict\";\n\n/*\n\n    JsonStreamReader\n\n    Wrapper over clarinet library which:\n    - constructs JSON while reading stream\n\n\n    Example use:\n\n      const reader = JsonStreamReader.clone();\n      reader.setDelegate(this);\n      reader.beginJsonStream();\n      reader.onStreamJson(firstChunk);\n      ...\n      reader.onStreamJson(lastChunk);\n      reader.endJsonStream();\n\n    // delegate protocol\n\n      //onJsonStreamReaderStart (reader)\n      onJsonStreamReaderPushContainer (reader, json)\n      onJsonStreamReaderPopBaseContainer (reader, json) \n      //onJsonStreamReaderEnd (reader)\n\n*/\n\n(class JsonStreamReader extends ProtoClass { \n\n  initPrototypeSlots () {\n    {\n        const slot = this.newSlot(\"parser\", null);\n        slot.setSlotType(\"clarinet.parser\");\n    }\n\n    // NOTE: a \"container\" is a node that can have children (such as Object or Array)\n\n    {\n      const slot = this.newSlot(\"containerStack\", null);\n      slot.setSlotType(\"Array\");\n    }\n\n    {\n      const slot = this.newSlot(\"currentContainer\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    // stack of keys for objects\n\n    {\n      const slot = this.newSlot(\"keyStack\", null);\n      slot.setSlotType(\"Array\");\n    }\n\n    {\n      const slot = this.newSlot(\"currentKey\", null);\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null);      \n      slot.setSlotType(\"Object\");\n    }\n  }\n\n  newParser () {\n      const parser = clarinet.parser();\n\n      parser.onerror = (e) => {\n        // an error happened. e is the error.\n        this.onError(e);\n      };\n\n      parser.onvalue = (v) => {\n        // got some value.  v is the value. can be string, double, bool, or null.\n        this.onValue(v);\n      };\n\n      parser.onopenobject = (key) => {\n        // opened an object. key is the first key.\n        this.onOpenObject(key);\n      };\n\n      parser.onkey = (key) => {\n        // got a subsequent key in an object.\n        this.onKey(key);\n      };\n\n      parser.oncloseobject = () => {\n        this.onCloseObject();\n      };\n\n      parser.onopenarray = () => {\n        this.onOpenArray();\n      };\n\n      parser.onclosearray = () => {\n        this.onCloseArray();\n      };\n\n      parser.onend = () => {\n        // parser stream is done, and ready to have more stuff written to it.\n        this.onEnd();\n      };\n\n      //parser.write('{\"foo\": \"bar\"}').close();\n      \n      return parser;\n  }\n\n  beginJsonStream () {\n    this.setParser(this.newParser());\n    this.setContainerStack([]);\n    this.setKeyStack([]);\n    this.pushContainer([]); // root container\n  }\n\n  endJsonStream () {\n    // check stack is empty?\n    //this.popContainer();\n    //this.rootContainer(); // should be an array of all the json objects we've read\n  }\n\n  onStreamJson (data) {\n    assert(Type.isString(data), \"data must be a string\");\n    console.log(\"onStreamJson('\" + data + \"')\");\n    this.parser().write(data);\n    return this;\n  }\n\n  shutdown () {\n    this.setParser(null);\n    return this;\n  }\n\n  rootContainer () {\n    return this.containerStack().first();\n  }\n\n  show () {\n    const s = JSON.stableStringify(this.rootContainer());\n    console.log(\"root: \", s);\n  }\n    \n  // --- conatiner stack ---\n    \n  currentContainer () {\n    return this.containerStack().last();\n  }\n\n  pushContainer (container) {\n    assert(container, \"container is null\");\n    this.containerStack().push(container);\n    this.sendDelegate(\"onJsonStreamReaderPushContainer\", [this, container]);\n\n    //this.debugLog(\"push \", JSON.stableStringify(container));\n    //this.show();\n    return this;\n  }\n\n  popContainer () {\n    assert(this.containerStack().length > 1, \"can't close root array\");\n    const item = this.containerStack().pop();\n    this.sendDelegate(\"onJsonStreamReaderPopContainer\", [this, item]);\n    return item;\n  }\n\n  // --- key stack ---\n\n  currentKey () {\n    return this.keyStack().last();\n  }\n\n  pushKey (key) {\n    assert(Type.isString(key), \"key must be a string\");\n    this.keyStack().push(key);\n    return this;\n  }\n\n  popKey () {  \n    assert(this.keyStack().length > 0, \"can't pop empty key stack\");\n    this.keyStack().pop();\n    return this;\n  }\n\n  // --- parser events ---\n\n  onError(e) {\n    console.log(this.type() + \" error: \" + e);\n    debugger;\n    this.sendDelegate(\"onJsonStreamReaderError\", [this, e]);\n  }\n  \n  onKey (key) {\n    this.pushKey(key);\n    //this.debugLog(\"k '\" + key + \"'\");\n  }\n\n  onValue (v) {\n    const container = this.currentContainer();\n    assert(container, \"no current container\");\n    if (Type.isArray(container)) {\n      container.push(v);\n    } else {\n      assert(this.currentKey(), \"no current key\");\n      container[this.currentKey()] = v;\n      this.popKey();\n    }\n    //this.debugLog(\"v \" + JSON.stableStringify(v));\n  }\n\n  onOpenObject (key) {    \n    const item = {};\n    this.onValue(item);\n    this.pushContainer(item);\n    //this.debugLog(\"onOpenObject \");\n    this.onKey(key);\n  }\n\n  onCloseObject () {\n    assert(this.containerStack().length > 1, \"can't close root object\");\n    const item = this.popContainer();\n    //this.debugLog(\"onCloseObject \", JSON.stableStringify(item));\n  }\n\n  onOpenArray () {\n    const item = [];\n    this.onValue(item);\n    this.pushContainer(item);\n    //this.debugLog(\"onOpenArray \");\n  }\n\n  onCloseArray () {\n    assert(this.containerStack().length > 1, \"can't close root array\");\n    const item = this.popContainer();\n    //this.debugLog(\"onCloseArray \", JSON.stableStringify(item));\n  }\n\n  onEnd () {\n    this.popIfCurrentNodeIsText();\n  }\n\n  // --------------------------------\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate();\n\n    /*\n    if (this.isDebugging()) {\n      console.log(this.type() + \" --------------- calling delegate \" + methodName + \"(\" + args.join(\",\") + \")\");\n    }\n    */\n\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        f.apply(d, args)\n        return true\n      }\n    } else {\n      /*\n      const error = this.type() + \" delegate missing method '\" + methodName + \"'\";\n      console.log(error);\n      debugger;\n      throw new Error(error);\n      */\n    }\n    return false\n  }\n\n}.initThisClass());\n\n/*\nconst testJsonReader = function () {\n\n  console.log(\n    \"=========================================================================\"\n  );\n  \n  const jsonInput = [{ \"a\": 1 }, [1, 2, 3], { \"b\": 2 }];\n\n  const reader = JsonStreamReader.clone();\n\n  // Simulate random breaks in the HTML content\n  reader.beginJsonStream();\n  const s = JSON.stableStringify(jsonInput);\n  reader.onStreamJson(s);\n  reader.endJsonStream();\n  //reader.show();\n\n  console.log(\"input: \", JSON.stableStringify(jsonInput));\n  console.log(\"output: \", JSON.stableStringify(reader.rootContainer()));\n  debugger;\n\n  console.log(\n    \"=========================================================================\"\n  );\n  \n}\n\ntestJsonReader();\n*/",
  "FC40xzlmmWQDHqOd4v64Nmm5rLi6bQ7ddZ5ke93lVGg=": "\"use strict\";\n\n\n/*\n\n    SyncAction\n\n    An action managed by the SyncScheduler.\n\n*/\n\n(class SyncAction extends ProtoClass {\n\n    static ActionKeyForTargetAndMethod (target, method) {\n        return target.typeId() + \".\" + method;\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"target\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"method\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"order\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"args\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"isUnscheduled\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"error\", null);\n            slot.setSlotType(\"Error\");\n        }\n    }\n\n    initPrototype () {\n    }\n\t\n    tryToSend () {\n        try {\n            this.send();\n        } catch(error) {\n            console.warn(this.typeId() + \".tryToSend(\" + this.description() + \") caught exception: \");\n            error.show();\n            this.setError(error);\n            return error;\n        }\n        return null;\n    }\n\t\n    send () {\n        //this.debugLog(() => \"   <- sending \" + this.description())\n        const t = this.target();\n        const m = this.method();\n        const a = this.args();\n        t[m].apply(t, a ? a : []);\n        return null\n    }\n\t\n    actionsKey () {\n        return SyncAction.ActionKeyForTargetAndMethod(this.target(), this.method())\n    }\n\t\n    equals (anAction) {\n        return anAction !== null && \n               (this.target() === anAction.target()) && \n               (this.method() === anAction.method())\n    }\n\t\n    description () {\n        const t = this.target() ? this.target().debugTypeId() : \"null\"\n        const o = this.order() === 0 ? \"\" : \" order:\" + this.order()\n        return this.typeId() + \" \" + t + \" \" + this.method() + \"\" + o\n    }\n\n}.initThisClass());\n\n",
  "QEY2QcmlTseaF/663lNPEt5eM7D4VE4FaJa6dHN1EUo=": "\"use strict\";\n\n/*\n\n    SyncScheduler\n\n    SyncScheduler is sort of a lower level NotificationCenter.\n    \n    SyncScheduler essientially:\n        - receives requests of the form \"send targetA messageB\" (Note: often, the sender is also the target)\n        - and at the end of the event loop (via a timeout):\n        -- coaleses them (so the same message isn't sent twice to the same target)\n        -- sends them\n\n    The NotificationCenter could be used to do this, but it would be heavier:\n     - overhead of every receiver registering observations\n     - overhead of matching observations with posts\n     - potential garbage collection issues (may already be solved with weak references now)\n\n    Motivation:\n\n    Many state changes can cause the need to synchronize a given object \n    with others within a given event loop, but we only want synchronization to \n    happen at the end of an event loop, so a shared SyncScheduler instance is used to\n    track which sync actions should be sent at the end of the event loop and only sends each one once.\n\n    SyncScheduler should be used to replace most cases where this.addTimeout() would otherwise be used.\n\n       example use:\n    \n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToNode\");\n\n    Automatic sync loop detection\n\n    It will throw an error if a sync action is scheduled while another is being performed,\n    which ensures sync loops are avoided.\n\n    Ordering\n\n    Scheduled actions can also be given a priority via an optional 3rd argument:\n\n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToNode\", 1);\n\n    Higher priorities will be performed *later* than lower ones. \n\n    Some typical sync methods:\n\n        // view\n    \tsyncToNode\t\n        syncFromNode\n        \n    When to run\n\n        When a UI event is handled, SyncSchedule.fullSyncNow should be called just before\n        control is returned to the browser to ensure that another UI event won't occur\n        before syncing as that could leave the node and view out of sync.\n            For example:\n                - edit view #1\n                - sync to node\n                - node posts didUpdateNode\n                - edit view #2\n                - view gets didUpdateNode and does syncFromNode which overwrites view state #2 causing an error!\n            But the above would have been ok if the didUpdateNode was posted once at the end of the event loop.\n\n    Pause and Resume\n\n        SyncScheduler can be paused and resumed to prevent syncing from happening.\n        An example of when this is useful is when initializing the application (e.g. appDidInit) \n        and you don't want any syncing to happen until the app is fully initialized.\n        Example use:\n\n            SyncScheduler.shared().pause()\n            SyncScheduler.shared().resume()\n\n*/\n\n(class SyncScheduler extends ProtoClass {\n\n    static initClass () {\n        this.setIsSingleton(true);\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"actions\", new Map());\n            slot.setSlotType(\"Map\");\n        }\n\n        {\n            const slot = this.newSlot(\"hasTimeout\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"isProcessing\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"currentAction\", null);\n            slot.setSlotType(\"SyncAction\");\n        }\n\n        {\n            const slot = this.newSlot(\"isPaused\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    // --- pause/resume ---\n\n    pause () {\n        this.setIsPaused(true);\n        return this;\n    }\n\n    resume () {\n        this.setIsPaused(false);\n        this.setTimeoutIfNeeded();\n        return this;\n    }\n\n    // --- actions ---\n\n    newActionForTargetAndMethod (target, syncMethod, order) {\n        return SyncAction.clone().setTarget(target).setMethod(syncMethod).setOrder(order ? order : 0)\n    }\n\t\n    scheduleTargetAndMethod (target, syncMethod, optionalOrder) { // higher order performed last\n        if (!this.hasScheduledTargetAndMethod(target, syncMethod)) {\n            const newAction = this.newActionForTargetAndMethod(target, syncMethod, optionalOrder)\n\n            this.debugLog(() => \"    -> scheduling \" + newAction.description())\n\n            /*\n            if (this.isProcessing() && this.currentAction().method() !== \"processPostQueue\") {\n                this.debugLog(() => \"    - isProcessing \" + this.currentAction().description() +  \" while scheduling \" + newAction.description())\n            }\n            */\n            \n            if (syncMethod !== \"processPostQueue\") {\n                if (this.currentAction() && this.currentAction().equals(newAction)) {\n                    const error = [\n                        this.type() + \" LOOP DETECTED: \",\n                        \"  scheduleTargetAndMethod: (\" + newAction.description() + \")\",\n                        \"  while processing: (\" + this.currentAction().description() + \")\"\n                    ].join(\"\\n\")\n                    console.log(error)\n                    debugger\n                    throw new Error(error)\n                }\n            }\n\n            this.actions().atIfAbsentPut(newAction.actionsKey(), newAction)\n\t    \tthis.setTimeoutIfNeeded()\n            return true\n        }\n\t\t\n        return false\n    }\n\n    isSyncingOrScheduledTargetAndMethod(target, syncMethod) {\n        const sc = this.hasScheduledTargetAndMethod(target, syncMethod) \n        const sy = this.isSyncingTargetAndMethod(target, syncMethod) \n        return sc || sy;\n    }\n\n    hasScheduledTargetAndMethod (target, syncMethod) {\n        const actionKey = SyncAction.ActionKeyForTargetAndMethod(target, syncMethod)\n    \treturn this.actions().hasKey(actionKey)\n    }\n\n    isSyncingTargetAndMethod (target, syncMethod) {\n        const ca = this.currentAction()\n        if (ca) {\n            const action = this.newActionForTargetAndMethod(target, syncMethod)\n    \t\treturn ca.equals(action)\n        }\n        return false\n    }\n    \n    actionsForTarget (target) {\n        return this.actions().valuesArray().select(action => action.target() === target)\n    }\n\n    hasActionsForTarget (target) {\n        return this.actions().valuesArray().canDetect(action => action.target() === target)\n    }\n\n    unscheduleTarget (target) {\n        if (this.hasActionsForTarget(target)) {\n            console.log(\"unscheduling target \" + target.debugTypeId())\n\n            if (this.isProcessing()) {\n                console.warn(\"WARNING: SynScheduler unscheduleTarget while processing actions set - will unschedule action\")\n                //debugger;\n                //return this\n            }\n\n            this.actionsForTarget(target).forEach(action => {\n                this.removeActionKey(action.actionsKey())\n            })\n        }\n\n        assert(!this.hasActionsForTarget()) // todo: remove this sanity check\n        return this\n    }\n\n    // return SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, \"syncFromNode\")\n\n\n    unscheduleTargetAndMethod (target, syncMethod) {\n        const k = this.newActionForTargetAndMethod(target, syncMethod).actionsKey()\n        this.removeActionKey(k)\n        return this\n    }\n\n    removeActionKey (k) {\n        const action = this.actions().at(k)\n        if (action) {\n            action.setIsUnscheduled(true)\n            this.actions().removeKey(k)\n        }\n        return this\n    }\n\t\n    setTimeoutIfNeeded () {\n\t    if (!this.hasTimeout() && !this.isPaused() && this.actions().size > 0) {\n            this.setHasTimeout(true);\n\t        this.addTimeout(() => { \n\t            this.setHasTimeout(false);\n\t            this.processSets();\n\t        }, 1);\n\t    }\n\t    return this;\n    }\n\t\n    orderedActions () {\n        const sorter = function (a1, a2) { return a1.order() - a2.order() }\n        return this.actions().valuesArray().sort(sorter)\n    }\n\t\n    processSets () {\n        if (this.isPaused()) {\n            return this;\n        }\n\n        if (this.isProcessing()) {\n            console.warn(\"WARNING: SynScheduler attempt to processSets before last set is completed\")\n            return this\n        }\n        assert(!this.isProcessing())\n\n        //console.log(\" --- SyncScheduler BEGIN ---\")\n        //this.show()\n\n        this.setIsProcessing(true)\n        let error = null\n\n        //this.debugLog(this.description())\n        this.debugLog(\"Sync\")\n        \n        const actions = this.orderedActions()\n        this.actions().clear()\n \n        actions.forEach((action) => {\n            if (action.isUnscheduled()) {\n               debugger;\n            } else {\n                this.setCurrentAction(action)\n                const actionError = action.tryToSend()\n                //const actionError = action.send()\n                if (actionError) {\n                    error = actionError\n                }\n                this.setCurrentAction(null)\n            }\n        })\n        \n        this.setCurrentAction(null)\n        this.setIsProcessing(false)\n        \n        if (error) {\n            error.rethrow();\n        }\n\n        //console.log(\" --- SyncScheduler END --- (END OF EVENT LOOP!)\")\n\n        return this\n    }\n\n    actionCount () {\n        return this.actions().size\n    }\n\n    fullSyncNow () {\n        if (this.isPaused()) {\n            //console.log(\"SyncScheduler.fullSyncNow called while isPaused so SKIPPING\")\n            return this\n            \n        }\n        if (this.isProcessing()) {\n            this.debugLog(() => \"fullSyncNow called while isProcessing so SKIPPING\")\n            return this\n        }\n\n        if (this.actionCount()) {\n            this.debugLog(\" --- fullSyncNow start --- \")\n            let count = 0\n            const maxCount = 10\n\n            while (this.actionCount()) {\n                /*\n                if (count > -1) {\n                    console.log(\"\\nSyncScheduler looped \" + count + \" times, queue size is: \" + this.actionCount() + \"\\n\")\n                }\n                */\n\n                this.processSets()\n                count ++\n\n    \n\n                if (count > 6) {\n                    this.setIsDebugging(true)\n                    console.log(\"\\n\\nSyncScheduler looped \" + count + \" times without resolving. Are we in a sync loop?\")\n                    console.log(\" --- processSets # \" + count + \" --- \")\n                    console.log(\"\\nSyncActions (\" + this.actionCount() + \") :\\n\" + this.actionsDescription())\n                    console.log(\"\\n\" + BMNotificationCenter.shared().shortDescription() + \":\\n\" + BMNotificationCenter.shared().notesDescription())\n                    console.log(\" --- \")\n                    debugger\n                }\n                assert (count < maxCount)\n            }\n\n            this.debugLog(\" --- fullSyncNow end --- \")\n        }\n\n        return this\n    }\n\n    actionsDescription () {\n        if (this.orderedActions().length === 0) {\n            return \"none\";\n        }\n        return this.orderedActions().map(action => \"    \" + action.description() ).join(\"\\n\")\n    }\n\n    show () {\n        console.log(this.type() + \":\")\n        console.log(this.actionsDescription())\n    }\n\n}.initThisClass());\n\n",
  "rTwhzEKTqSZteOqJ11Mn1C8WyMwC+Xz2VmF5LqLOFso=": "\"use strict\";\n\n/*\n\n    BMNotification\n\n*/\n\n(class BMNotification extends ProtoClass {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"name\", null);\n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"sender\", null);\n            slot.setSlotType(\"Object\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"info\", null);\n            slot.setSlotType(\"Object\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"center\", null); // NotificationCenter that owns this\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"BMNotificationCenter\");\n        }\n        {\n            const slot = this.newSlot(\"senderStack\", null);\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"noteHash\", null);\n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n    }\n\n    initPrototype () {\n    }\n\n    senderId () {\n        return this.sender().debugTypeId()\n    }\n\n    setSender (obj) {\n        assert(Type.isObject(obj))\n        this._sender = obj\n        //this._senderId = obj.typeId())\n        this.clearNoteHash()\n        return this\n    }\n\n    setName (aName) {\n        this._name = aName;\n        this.clearNoteHash()\n        return this\n    }\n    \n    isEqual (obs) {\n        if (this === obs) { \n            return true \n        }\n\n        //return (this.name() === obs.name()) && (this.sender() === obs.sender())\n\n        return this.noteHash() === obs.noteHash()\n    }\n\n    // --- note hash ---\n\n    clearNoteHash () {\n        this._noteHash = null;\n        return this\n    }\n\n    noteHash () {\n        if (!this._noteHash) {\n            const id = Type.typeUniqueId(this.name()) + \" \" + Type.typeUniqueId(this.sender()); // must be implemented the same by BMObservation\n            this._noteHash = id.hashCode64();\n        }\n        return this._noteHash\n    }\n\n    // --- ---\n\n    isPosted () {\n        return this.center().hasNotification(this)\n    }\n    \n    post () {\n        if (this.center().isDebugging()) {\n            //console.log(typeof(this.senderId()) + \".\" + this.senderId() + \" posting note \" + this.name() + \" and recording stack for debug\")\n            const e = new Error()\n            e.name = \"\" //\"Notification Post Stack\"\n            e.message = this.senderId() + \" posting note '\" + this.name() + \"'\" \n            this.setSenderStack(e.stack);\n        }\n\n        //console.log(\"   queuing post \" + this.senderId() + \" '\" + this.name() + \"'\" )\n       \n        this.center().addNotification(this)\n        return this\n    }\n    \n    /*\n    schedulePost () {\n\t     SyncScheduler.shared().scheduleTargetAndMethod(this, \"post\")\n    }\n    */\n\n    description () {\n        const s = this.senderId() ? this.senderId() : \"null\"\n        const n = this.name() ? this.name() : \"null\"\n        return s + \" \" + n\n    }\n\n    newObservation () {\n        /*\n            this avoids note name typos and helps runtime check/debug note name changes as note name isn't hardcoded as string in multiple places\n            example use:\n\n                aFileLoader.doneNote().newObservation().setObserver(this).setIsOneShot(true).startWatching()\n\n                how about:\n\n                (in Node)\n\n                this.observeNote(aFileLoader.doneNote())\n                this.observeNoteOnce(aFileLoader.doneNote())\n        */\n        return BMNotificationCenter.shared().newObservation().setName(this.name()).setSender(this.sender())\n    }\n\n}.initThisClass());\n\n",
  "1LXWJut8sL+MHMhxKWi3dyBAupZqV9XUxwT5+z+z8O8=": "\"use strict\";\n\n/* \n\n    BMNotificationCenter\n    \n    A notification system that queues notifications and waits for the \n    app to return to the event loop (using a timeout) to post them. \n    It filters out duplicate notifications (posted on the same event loop) \n    and duplicate observations (same object registering the same observation again).\n        \n    WeakRefs: \n\n        The Observation class holds sender and observer references as weakrefs,\n        and when either is collected, it will automatically call Observation.stopWatching()\n        and remove itself from the NotificationCenter.\n\n        It's still good policy from an observer to explicilty call stopWatching as\n        soon as it no longer needs to observe, unless it wants to observer for it's entire\n        lifetime.\n\n    Example use:\n \n    Observing notifications:\n\n        // start watching for \"changed\" message from sender object\n        this._obs = BMNotificationCenter.shared().newObservation().setName(\"changed\").setObserver(this).setSender(sender).startWatching()\n    \n        // start watching for \"changedStoredSlot\" message from any sender object\n        this._obs = BMNotificationCenter.shared().newObservation().setName(\"changedStoredSlot\").setObserver(this).startWatching()\n\n        // stop watching this observation\n        this._obs.stopWatching()\n        \n        // stop watching all\n        BMNotificationCenter.shared().removeObserver(this)\n\n        // watch only for first note named \"appDidInit\"\n        this.watchOnceForNote(\"appDidInit\")\n        // WARNING: in this case, if app has already done init, this will never be called!\n\n    If the source object has an accessor for a notification it uses, we can do:\n\n        sourceObject.didLoadNote().newObservation().setObserver(this).startWatching()\n        \n    Posting notifications:\n\n        // post a notification\n        const note = this.newNoteNamed(\"hello\").post()\n\n        // repost same notification\n        note.post()\n\n    Broadcasting notifications:\n\n        For use cases where the overhead of creating post objects would be costly, \n        it's possible to send a direct message to all name listeners without waiting\n        until the event loop to end. These will pass the sender itself instead of a Notification object.\n\n        See Broadcaster class.\n\n    Helper methods available to subclasses of BMNode:\n\n        this.postNoteNamed(\"hello\")\n        this.watchOnceForNote(\"hello\")\n        this.watchOnceForNoteFrom(\"hello\", sourceObject)\n\n        this.observeNote(aFileLoader.doneNote()) // still need to handle observation removal\n        this.observeNoteOnce(aFileLoader.doneNote()) \n\n        note: I think nodes try remove their observations when removed?\n\n    Pause and resume:\n\n        The NotificationCenter can be paused and resumed. When paused, it will not process any notifications.\n        This can be useful when you want to prevent notifications from being processed while doing things like\n        app initialization.\n\n        Example use:\n\n        BMNotificationCenter.shared().pause();\n        BMNotificationCenter.shared().resume();\n*/\n\n(class BMNotificationCenter extends ProtoClass {\n\n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"observations\", null); // array \n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"observationsMap\", null); // map of obsHash to observation \n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"notifications\", null); // array \n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"debugNoteName\", \"appDidInit\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"currentNote\", null);\n            slot.setSlotType(\"BMNotification\");\n        }\n        {\n            const slot = this.newSlot(\"isProcessing\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"obsHighwaterCount\", 100); // used\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"noteSet\", null); // Set used for fast lookup for matching note\n            slot.setSlotType(\"Set\");\n        }\n        {\n            const slot = this.newSlot(\"isPaused\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"senderIndex\", null);\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"nameIndex\", null);\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"nullSenderMatchSet\", null);\n            slot.setSlotType(\"Set\");\n        }\n        {\n            const slot = this.newSlot(\"nullNameMatchSet\", null);\n            slot.setSlotType(\"Set\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        this.setObservations([]);\n        this.setObservationsMap(new Map());\n        this.setNotifications([]);\n        this.setNoteSet(new Set());\n    }\n\n    observations () {\n       // debugger;\n        return this.observationsMap().valuesArray();\n    }\n\n    pause () {\n        this.setIsPaused(true);\n        return this;\n    }\n\n    resume () {\n        this.setIsPaused(false);\n        return this;\n    }\n\n    shortDescription () {\n        return \"NotificationCenter \" + this.notifications().length + \" notes, \" + this.observations().length + \" obs\";\n    }\n\n    // --- observations ----\n\n    /*\n    cleanIfNeeded () {\n        if (this.observations().count() < this.obsHighwaterCount()) {\n            this.cleanObservations()\n            this.setObsHighwaterCount(this.observations().count() * 2)\n        }\n    }\n\n    cleanObservations () {\n        // remove observations whose senders or observers have been collected\n        this.observations().shallowCopy().forEach(obs => {\n            obs.clean()\n        })\n    }\n    */\n    \n    hasObservation (obs) {\n        return this.observationsMap().has(obs.obsHash());\n        //return this.observations().canDetect(ob => ob.isEqual(obs));\n    }\n    \n    addObservation (obs) {\n        if (!this.hasObservation(obs)) {\n            this.observationsMap().set(obs.obsHash(), obs);\n            //this.observations().push(obs);\n        }\n        return this;\n    }\n\n    newObservation () {\n        return BMObservation.clone().setCenter(this);\n    }\n\n    observersOfSender (sender) {\n        return this.observationsWithSender(sender).map(obs => obs.observer());\n    }\n\n    observationsWithSender (sender) {\n        return this.observations().filter(obs => obs.sender() === sender);\n    }\n\n    hasObservationsForSender (sender) {\n        return this.observationsWithSender(sender).length > 0;\n    }\n\n    observationsWithObserver (observer) {\n        return this.observations().filter(obs => obs.observer() === observer);\n    }\n\n    /*\n    observationsForSender (sender) {\n        const matches = this.observations().filter(obs => obs.sender() === sender)\n        return matches\n    }\n    */\n    \n    removeObservation (anObservation) {\n        this.observationsMap().delete(anObservation.obsHash());\n        /*\n        const filtered = this.observations().filter(obs => !obs.isEqual(anObservation))\n        this.setObservations(filtered)\n        */\n        return this\n    }\n    \n    removeObserver (anObserver) {        \n        this.observationsMap().selectInPlaceKV((key, obs) => obs.observer() !== anObserver);\n        return this;\n    }\n\n    // --- notifying ----\n    \n    hasNotification (note) {\n        if (this.noteSet().has(note)) {\n            // quick check to see if we have an exact match\n            // reusing notes can help make these lookups more efficient\n            return true\n        }\n        return this.notifications().canDetect(n => n.isEqual(note))\n    }\n    \n    addNotification (note) {\n        if (!this.hasNotification(note)) {\n            /*\n            if (note.sender().title && note.sender().title === \"STRVCTapp\") {\n                console.log(\"NotificationCenter '\" + note.sender().title() + \"' \" + note.name())\n            }\n            */\n            this.noteSet().add(note);\n            this.notifications().push(note);\n\t\t    SyncScheduler.shared().scheduleTargetAndMethod(this, \"processPostQueue\", -1);\n        }\n        return this;\n    }\n\n    newNote () {\n        return BMNotification.clone().setCenter(this);\n    }\n    \n    // --- timeout & posting ---\n    \n    processPostQueue () {\n        if (this.isPaused()) {\n            console.log(\"WARNING: BMNotificationCenter.processPostQueue() called while paused - SKIPPING\");\n            return this;\n        }\n\n        // TODO: for performance, we could make an observationName->observations dictionary\n        // but only worthwhile if observation list is sufficiently large\n\n        // keep local ref of notifications and set \n        // notifications to empty array in case any are\n        // added while we process them\n\n        /*\n        console.log(\" --- \" + this.type() + \" processPostQueue BEGIN ---\")\n        this.show()\n        console.log(\" \")\n        */\n        this.setCurrentNote(null);\n\n        if (!this.isProcessing()) {\n            this.setIsProcessing(true);\n            this.calcIndexes();\n            //console.log(\"processPostQueue \" + this.notifications().length);\n            const notes = this.notifications();\n            this.setNotifications([]);\n            notes.forEach(note => {\n                this.noteSet().delete(note);\n                this.postNotificationNow(note);\n            })\n            //notes.forEach(note => this.tryToPostNotificationNow(note));\n            this.setIsProcessing(false);\n        } else {\n            Error.showCurrentStack();\n            console.warn(\"WARNING: attempt to call processPostQueue recursively while on note: \", this._currentNote);\n        }\n\n        //console.log(\" --- \" + this.type() + \" processPostQueue END ---\");\n\n        return this;\n    }\n\n    tryToPostNotificationNow (note) {\n        try { \n            this.postNotificationNow(note);\n            //this.debugLog(\"   <- posting \" + note.description() )\n        } catch (error) {\n            console.log(this.type() + \" caught exception while posting: \" + note.description());\n            return error;\n        }\n        return null;\n    }\n\n    shouldDebugNote (note) {\n        return note.isDebugging() || (this.isDebugging() === true && (this.debugNoteName() === null || this.debugNoteName() === note.name()));\n    }\n\n    calcIndexes () {\n        const senderIndex = this.observationsMap().indexedByMethod(\"sender\");\n        this.setSenderIndex(senderIndex);\n\n        const nameIndex = this.observationsMap().indexedByMethod(\"name\");\n        this.setNameIndex(nameIndex);\n\n        const emptySet = ImmutableSet.emptySet();\n\n        const nullSenderMatchSet = this.senderIndex().get(null) || emptySet;\n        this.setNullSenderMatchSet(nullSenderMatchSet);\n\n        const nullNameMatchSet = this.nameIndex().get(null) || emptySet;\n        this.setNullNameMatchSet(nullNameMatchSet);\n    }\n    \n    postNotificationNow (note) {\n        // use a copy of the observations list in \n        // case any are added while we are posting \n        //\n        // TODO: add an dictionary index for efficiency\n\n        this.setCurrentNote(note);\n        \n        /*\n        const showDebug = this.shouldDebugNote(note);\n\n        if (showDebug) {\n            console.log(\" >>> \" + this.type() + \" senderId \" + note.senderId() + \" posting \" + note.name());\n            //this.showObservers()\n        }\n        */\n\n        const matching = this.observationsMatchingNotification(note);\n\n        matching.forEach(obs => {\n            /*\n            if (showDebug) {\n                //console.log(\" >>> \" + this.type() + \" \" + note.name() + \" matches obs: \" + obs.description());\n                if (obs.observer.type() === \"HwChatInputTile\") {\n                    console.log(\" >>> \" +this.type() + \" sending \", note.name() + \" to observer \" + obs.observer().typeId());\n                }\n            }\n            */\n        \n            obs.sendNotification(note);\n            //obs.tryToSendNotification(note);  \n        });       \n        \n        this.setCurrentNote(null);\n    }\n\n    observationsMatchingNotification (note) {\n        // use our observation indexes for fast matching with the notification\n        // IMPORTANT: assumes calcIndexes() has been called before modifying observations\n\n        const emptySet = ImmutableSet.emptySet();\n\n        const senderMatchSet = this.senderIndex().get(note.sender()) || emptySet;\n        const nameMatchSet = this.nameIndex().get(note.name()) || emptySet;\n\n        const fullSenderMatchSet = this.nullSenderMatchSet().union(senderMatchSet);\n        const fullNameMatchSet = this.nullNameMatchSet().union(nameMatchSet);\n\n        const matching = fullSenderMatchSet.intersection(fullNameMatchSet);\n        return matching;\n    }\n\n    /*\n    observationsMatchingNotification (note) {\n        return this.observations().filter(obs => obs.matchesNotification(note));\n    }\n    */\n\n    show () {\n        console.log(this.type() + \":\");\n        console.log(\"  posting notes:\");\n        console.log(this.notesDescription());\n        console.log(\"  observations:\");\n        console.log(this.observersDescription());\n    }\n\n    notesDescription () {\n        return this.notifications().map(note => \"    \" + note.description()).join(\"\\n\");\n    }\n\n    observersDescription () {\n        return this.observations() .map(obs => \"    \" + obs.description()).join(\"\\n\");\n    }\n    \n    showCurrentNoteStack () {\n        if (this.currentNote() === null) {\n            //console.log(\"BMNotificationCenter.showCurrentNoteStack() warning - no current post\")\n        } else {\n            console.log(\"current post sender stack: \", this.currentNote().senderStack());\n        }\n    }\n\n}.initThisClass());\n",
  "p0YkBbHTT0DiCbdZUP2SHWlDJOghIR/8juVF0YeGNhM=": "\"use strict\";\n\n/*\n\n    BMObservation\n\n    An abstraction for a NotificationCenter observation. \n    Holds references to which notification message a given observer is wants\n    notifications for. \n\n*/\n\n(class BMObservation extends ProtoClass {\n\n    initPrototypeSlots () {\n    \n        {\n            const slot = this.newSlot(\"center\", null); // NotificationCenter that owns this\n            slot.setSlotType(\"BMNotificationCenter\");\n        }\n        {\n            const slot = this.newSlot(\"name\", null);\n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"sendName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"isOneShot\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"didFinalizeStop\", false); \n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newWeakSlot(\"observer\", null); // WeakRef slot to observer\n            slot.setSlotType(\"Object\"); // TODO: add observer protocol\n        }\n        {\n            const slot = this.newWeakSlot(\"sender\", null); // WeakRef to sender\n            slot.setSlotType(\"Object\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"obsHash\", null); \n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"noteHash\", null); \n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n    }\n\n\n    init () {\n        super.init()\n        this.setSender(null)\n        this.setObserver(null)\n        this.setIsDebugging(false)\n    }\n\n    onFinalizedSlotObserver () {\n        this.stopFromCollectedRef()\n    }\n\n    onFinalizedSlotSender () {\n        this.stopFromCollectedRef()\n    }\n\n    stopFromCollectedRef () {\n        if (!this.didFinalizeStop()) {\n            // need this check because if observer and sender finalizations occur in the same event loop\n            // both with try to schedule stopWatching, and the SyncScheduler will (mistakenly?) detect this is a loop\n            this.setDidFinalizeStop(true)\n            this.scheduleMethod(\"stopWatching\")\n        }\n        return this\n    }\n\n    // --- clearing hashes ---\n\n    didUpdateSlotSender () {\n        this.clearHashes();\n    }\n\n    didUpdateSlotObserver () {\n        this.clearHashes();\n    }\n\n    didUpdateSlotName () {\n        this.clearHashes();\n    }\n\n    clearHashes () {\n        this.clearNoteHash();\n        this.clearObsHash();\n        return this;\n    }\n\n    // --- observation hash ---\n\n    clearObsHash () {\n        this._obsHash = null;\n        return this\n    }\n\n    obsHash () {\n        if (!this._noteHash) {\n            const id = Type.typeUniqueId(this.name()) + Type.typeUniqueId(this.observer()) + Type.typeUniqueId(this.sender()); // needs to be unique for each observation\n            this._obsHash = id.hashCode64();\n        }\n        return this._obsHash\n    }\n\n    // --- notification hash ---\n\n    clearNoteHash () {\n        this._noteHash = null;\n        return this\n    }\n\n    noteHash () {\n        if (!this._noteHash) {\n            const id = Type.typeUniqueId(this.name()) + \" \" + Type.typeUniqueId(this.sender()); // must be implemented the same by BMNotification\n            this._noteHash = id.hashCode64();\n        }\n        return this._noteHash\n    }\n\n    // --- equality ---\n\n    isEqual (obs) {\n        return this.obsHash() === obs.obsHash();\n\n        /*\n        const sameName = this.name() === obs.name();\n        const sameObserver = this.observer() === obs.observer();\n        const sameSender = this.sender() === obs.sender();\n        return sameName && sameObserver && sameSender;\n        */\n    }\n\n    // --- private helpers ---\n\n    valueId (v) { // private\n        return v ? v.typeId() : \"undefined\"\n    }\n\n    // --- sender ---\n\n    senderId () { \n        return this.valueId(this.sender())\n    }\n\n    /*\n    senderOrObserverWasCollected () {\n        return this.observer() === undefined || this.sender() === undefined\n    }\n\n    clean () {\n        if (this.senderOrObserverWasCollected()) {\n            debugger\n            this.stopWatching()\n        }\n    }\n    */\n\n    // --- observer --- \n\n    observerId () { \n        return this.valueId(this.observer())\n    }\n\n    // ---\n\n    /*\n    matchesNotification (note) {\n        // this is used so much, it might be worth direct accessors...\n        const sender = this._sender\n        const matchesSender = (sender === null) || (sender === note._sender) \n        if (matchesSender) {\n            const name = this._name\n            const matchesName = (name === null) || (note._name === name) \n            return matchesName\n        }\n        return false\n    }\n    */\n\n    getMatchMethod () {\n        const sender = this.sender();\n        const name = this.name();\n        const senderNull = Type.isNull(sender);\n        const nameNull = Type.isNull(name);\n\n        if (senderNull) {\n            if (nameNull) {\n                return (note) => { return true; }\n            }\n            return (note) => { return note.name() === name; }\n        }\n        if (nameNull) {\n            return (note) => { return note.sender() === sender; }\n        }\n        return (note) => { return note.noteHash() === this.noteHash(); }\n    }\n\n    matchesNotification (note) {\n        if (!this._matchMethod) {\n            this._matchMethod = this.getMatchMethod();\n        }\n\n        return this._matchMethod.call(this, note);\n    }\n\n    /*\n    matchesNotification (note) {\n        const sender = this.sender();\n        const matchesSender = (sender === null) || (sender === note.sender());\n        if (matchesSender) {\n            const name = this.name();\n            const matchesName = (name === null) || (note.name() === name);\n            return matchesName;\n        }\n        return false;\n    }\n    */\n\n    tryToSendNotification (note) {\n        try {\n            this.sendNotification(note)       \n        } catch(error) {\n            console.log(\"NOTIFICATION EXCEPTION: '\" + error.message + \"'\");\n            console.log(\"  OBSERVER (\" + this.observer() + \") STACK: \", error.stack)\n            if (note.senderStack()) {\n                console.log(\"  SENDER (\" + note.senderId() + \") STACK: \", note.senderStack())\n            }\n\n            // how to we propogate the exception so we can inspect it in the debugger\n            // without causing an inconsistent state by not completing the other notifications?\n            throw error\n        }\n        return null\n    }\n\n    sendNotification (note) {\n        const obs = this.observer()\n        if (obs === undefined) { // observer may have been collected\n            console.log(\"OBSERVER COLLECTED ON: \" + this.description())\n            this.stopWatching()\n            return\n        }\n\n        if (this.center().isDebugging() || this.isDebugging()) {\n        //if (note.name() === \"onUpdatedNode\") {\n            //console.log(this._observer + \" receiving note \" + note.name() + \" from \" + note.sender() )\n            console.log(note.sender().debugTypeId() + \" sending note \" + note.name() + \" to \" + this.observer().debugTypeId());\n        }\n\n        const method = this.sendName() ? obs[this.sendName()] : obs[note.name()];\n        //const method = obs[note.name()];\n\n        if (method) {\n            method.call(obs, note)\n        } else {\n            if (this.isDebugging()) {\n                this.debugLog(\" no method found for note name \" + note.name())\n            }\n        }\n\n        if (this.isOneShot()) {\n            this.stopWatching()\n        }\n    }\n\n    startWatching () {\n        this.center().addObservation(this)\n        //this.sender().onStartObserving()\n        return this\n    }\n\n    isWatching () {\n        return this.center().hasObservation(this)\n    }\n\n    stopWatching () {\n        this.center().removeObservation(this)\n        //this.sender().onStopObserving()\n        return this\n    }\n\n    /*\n    stopWatchingIfSenderOrObserverCollected () {\n        if (this.sender() === undefined || this.observer() === undefined) {\n            this.stopWatching()\n        }\n    }\n    */\n\n    description () {\n        return this.observerId() + \" listening to \" + this.senderId() + \" \" + this.name()\n    }\n\n    static testWeakRefs () {\n        const observer = new Object()\n        const sender = new Object()\n        const observation = BMNotificationCenter.shared().newObservation().setName(\"weakRefTest\").setObserver(observer).setSender(sender).startWatching()\n        // let's see if this onFinalizedSlotObserver or onFinalizedSlotSender get called and it auto stops watching \n    }\n\n}.initThisClass());\n\n//BMObservation.testWeakRefs()\n",
  "yKoSvLxqpK2LlFsohxQrgemR1tTaSNYDcZOPu57+kes=": "\"use strict\";\n\n/*\n\n    Broadcaster\n\n    Fast notifications that immediately message listeners \n    instead of using Observer and Notification objects.\n    As multiple notifications of the same name are not merged\n    within the same event loop, it's up to listeners to implement handlers efficiently.\n\n    Example use:\n\n        // inside a storable node\n        init () {\n            ...\n            Broadcaster.shared().addListenerForName(this, \"didChangeStoredSlot\")\n            ...\n        }\n\n        // inside a StoreableNode, on slot change\n        onSlotChange (...) {\n            ...\n            Broadcaster.shared().broadcastNameAndArgument(\"didChangeStoredSlot\", this)\n            ...\n        }\n\n        // inside a persistent store\n        didChangeStoredSlot (aSender) {\n            ... tell store to persist it ...\n        }\n\n    Example use:\n*/\n\n(class Broadcaster extends ProtoClass {\n\n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"nameToListenersMap\", null);  // Map to set\n            slot.setSlotType(\"Map\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        this.setNameToListenersMap(new Map())\n    }\n\n    listenerSetForName (name) {\n        assert(!Type.isNullOrUndefined(name))\n\n        // probably not inneficient since \n        // 1. we don't remove listeners often\n        // 2. we don't have many names\n        const n2l = this.nameToListenersMap()\n\n        if (!n2l.has(name)) {\n            n2l.set(name, new Set())\n        }\n        return n2l.get(name)\n    }\n\t\n    addListenerForName (aListener, name) {\n        this.listenerSetForName(name).add(aListener)\n        return this\n    }\n    \n    removeListenerForName (aListener, name) {\n        this.listenerSetForName(name).delete(aListener)\n        return this\n    }\n\n    broadcastNameAndArgument (methodName, anArgument) {\n        this.listenerSetForName(methodName).forEach(v => {\n            v[methodName].call(v, anArgument)\n        })\n        return this\n    }\n\n    removeListenersForName (name) {\n        this.nameToListenersMap().delete(name)\n        return this\n    }\n\n    clean () {\n        const n2l = this.nameToListenersMap()\n        n2l.shallowCopy().forEachKV((name, listenerSet) => {\n            if (listenerSet.size === 0) {\n                n2l.delete(name)\n            }\n        })\n    }\n\n}.initThisClass());\n\nObject.defineSlots(ProtoClass.prototype, {\n\n    broadcastMessage: function(methodName) {\n        Broadcaster.shared().broadcastNameAndArgument(methodName, this)\n        return this\n    }\n    \n})\n",
  "sLEX1iUMRo5RqUbElDIUl+yWyVKqnv95GuStM3Dsieg=": "\"use strict\";\n\n/*\n\n    PersistentAtomicMap\n\n    An persistent atomic Map implemented as \n    a read & write cache on top of IndexedDB.\n    \n    On open, it reads the entire db into a dictionary\n    so we can do synchronous reads and writes (avoiding IndexedDB's async API),\n    and then call the async commit at the end of the event loop.\n\n    Notes:\n\n    - keys and values are assumed to be strings\n\t- any exception between begin and commit should halt the app and require a restart to ensure consistency\n\n    API:\n\n    - at(key) returns a value from the internal dict\n    - begin() shallow copies the current internal dict\n    - atPut(key, value) & removeAt(key)\n        applies normal op and adds key to changedKeySet\n    - revert() reverts changes since begin\n    - commit() constructs a transaction using changedKeySet \n\t- at(key) first checks the writeCache beforing checking the readCache\n\t\t\n    TODO: \n    \n    - auto sweep after a write if getting full? \n        \n*/\n\n(class PersistentAtomicMap extends ideal.AtomicMap {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"name\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"idb\", null);\n            slot.setSlotType(\"IndexedDBFolder\");\n        }\n        {\n            const slot = this.newSlot(\"txCount\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"isApplying\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setIsOpen(false)\n        this.setIdb(IndexedDBFolder.clone())\n        this.setIsDebugging(false)\n        this.setName(\"PersistentAtomicMap\")\n    }\n\n    setName (aString) {\n        this._name = aString\n        this.idb().setPath(this.name())\n        return this\n    }\n\n    // open\n\n    isOpen () {\n        return this.idb().isOpen()\n    }\n\n    open () {\n        throw new Error(this.type() + \" synchronous open not supported\")\n        return this\n    }\n\n    setName (aString) {\n        this._name = aString\n        this.idb().setPath(this.name())\n        return this\n    }\n\n    async promiseOpen () {\n        this.debugLog(() => \"promiseOnOpen() '\" + this.name() + \"'\");\n        await this.idb().promiseOpen();\n        return this.promiseOnOpen(); // it can deal with multiple calls while it's opening\n    }\n\t\n    async promiseOnOpen () {\n        if (false) {\n            debugger;\n            this.debugLog(\"onOpen() - CLEARING BEFORE OPEN\");\n             await this.promiseClear();\n        } \n\n        this.debugLog(\"onOpen() - loading cache\");\n        await this.promiseLoadMap();\n    }\n\n    async promiseLoadMap () {\n        const map = await this.idb().promiseAsMap();\n        assert(!Type.isNull(map));\n        //console.log(this.debugTypeId() + \" onOpen() --- loaded cache with \" + this.recordsMap().count() + \" keys\")\n        this.setMap(map);\n        //console.log(\"map keys:\", map.keysArray())\n        this.setIsOpen(true);\n        //this.verifySync(callback, errorCallback)\n    }\n\n    // --- close ---\n\n    close () {\n        if (this.isOpen()) {\n            this.idb().close()\n        }\n        super.close()\n        return this\n    }\n\t\n    // ---- clear --- \n\t\t\n    async promiseClear () {\n        await this.idb().promiseClear();\n        this.map().clear();\n    }\n\t\t\n    // --- transactions ---\n\n    newTxId () {\n        const count = this.txCount()\n        //const s = this.typeId() + \"_TX_\" + count\n        const s = \"TX_\" + count\n        this.setTxCount(count + 1)\n        return s\n    }\n\n    async promiseApplyChanges () {\n        //console.log(this.name() + \" --- promiseApplyChanges ---\")\n        //debugger\n        const count = this.changedKeySet().size\n        const tx = this.idb().privateNewTx();\n        //const tx = await this.idb().promiseNewTx();\n        await this.applyChangesToTx(tx);\n        //return tx.promiseCommit();\n    }\n\n    async applyChangesToTx (tx) {\n        //debugger\n        assert(!this.isApplying())\n        this.setIsApplying(true)\n\n        tx.setTxId(this.newTxId())\n        tx.setIsDebugging(this.isDebugging())\n        tx.begin()\n        this.changedKeySet().forEachK((k) => {\n            const v = this.at(k)\n            if (!this.has(k)) {\n                tx.removeAt(k)\n            } else {\n                const isUpdate = this.snapshot().has(k)\n                if (isUpdate) {\n                    tx.atUpdate(k, v)\n                } else {\n                    tx.atAdd(k, v)\n                }                \n            }\n        })\n        \n        super.applyChanges() // do this last as it will clear the snapshot\n        \n        this.debugLog(() => \"---- \" + this.type() + \" committed tx with \" + count + \" writes ----\");\n\n        // indexeddb commits on next event loop automatically\n        // tx is marked as committed and will throw exception on further writes\n\n        await tx.promiseCommit();\n        this.setIsApplying(false);\n        //await this.promiseVerifySync();\n    }\n\t\n    // --- helpers ---\n\n    async promiseVerifySync () {\n        const currentMap = this.map().shallowCopy();\n        const map = await this.idb().promiseAsMap();\n\n        const isSynced = map.isEqual(currentMap); // works if keys and values are strings\n        if (isSynced) {\n            this.debugLog(\".verifySync() SUCCEEDED\");\n        } else {\n            //this.idb().show()\n            //console.log(\"syncdb idb json: \", JSON.stringify(map.asDict(), null, 2))\n            throw new Error(his.debugTypeId() + \".verifySync() FAILED\");\n            debugger;\n        }\n    }\n    \n}.initThisClass());\n\n",
  "s7KYZeL/GTumcEgghlH+R2E4soBIZvQdaR+H9yhdjlc=": "\"use strict\";\n\n/**\n * \n * An async Map wrapper for IndexedDB.\n * \n * @class PersistentAsyncMap\n * @extends ProtoClass\n */\n(class PersistentAsyncMap extends ProtoClass {\n\n    /**\n     * Initialize prototype slots for the PersistentAsyncMap.\n     * @returns {undefined}\n     */\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"name\", \"PersistentAsyncDictionary\");\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"idb\", null);\n            slot.setSlotType(\"IndexedDBFolder\");\n        }\n    }\n\n    /**\n     * Initialize the PersistentAsyncMap instance.\n     * @returns {undefined}\n     */\n    init () {\n        super.init()\n        this.setIdb(IndexedDBFolder.clone())\n        this.setIsDebugging(false)\n    }\n    \n    /**\n     * Assert that the map is accessible and open.\n     * @throws {Error} If the map is not open.\n     * @returns {undefined}\n     */\n    assertAccessible () {\n        super.assertAccessible()\n        this.assertOpen()\n    }\n\n    /**\n     * Check if the map is open.\n     * @returns {boolean} True if the map is open, false otherwise.\n     */\n    isOpen () {\n        return this.idb().isOpen()\n    }\n\n    /**\n     * Synchronous open method (not supported).\n     * @throws {Error} Always throws an error as synchronous open is not supported.\n     */\n    open () {\n        throw new Error(this.type() + \" synchronous open not supported\")\n    }\n\n    /**\n     * Close the map if it's open.\n     * @returns {PersistentAsyncMap} The instance for method chaining.\n     */\n    close () {\n        if (this.isOpen()) {\n            this.idb().close()\n            this.setIsOpen(false)\n        }\n        return this\n    }\n\n    /**\n     * Asynchronously open the map.\n     * @returns {Promise<void>}\n     */\n    async promiseOpen () {\n        if (!this.isOpen()) {\n            this.idb().setPath(this.name());\n        }\n        await this.idb().promiseOpen();\n        await this.promiseOnOpen() ;\n    }\n\t\n    /**\n     * Perform actions after opening the map (can be overridden).\n     * @returns {Promise<void>}\n     */\n    promiseOnOpen () {\n        //return this.promiseClear()\n    }\n\t\n    /**\n     * Assert that the map is open.\n     * @throws {Error} If the map is not open.\n     * @returns {PersistentAsyncMap} The instance for method chaining.\n     */\n    assertOpen () {\n        assert(this.isOpen())\n        return this\n    }\n\t\n    /**\n     * Clear all data in the map.\n     * @returns {Promise<void>}\n     */\n    async promiseClear () {\n        await this.promiseOpen();\n        await this.idb().promiseClear();\n    }\n\n    /**\n     * Get all keys in the map.\n     * @returns {Promise<Array>} A promise that resolves with an array of all keys.\n     */\n    async promiseAllKeys () {\n        await this.promiseOpen();\n        return this.idb().promiseAllKeys();\n    }\n\n    /**\n     * Check if a key exists in the map.\n     * @param {*} key - The key to check.\n     * @returns {Promise<boolean>} A promise that resolves with true if the key exists, false otherwise.\n     */\n    async promiseHasKey (key) {\n        await this.promiseOpen();\n        return this.idb().promiseHasKey(key);\n    }\n\n    /**\n     * Get the value associated with a key.\n     * @param {*} key - The key to retrieve the value for.\n     * @returns {Promise<*>} A promise that resolves with the value, or undefined if the key doesn't exist.\n     */\n    async promiseAt (key) {\n        await this.promiseOpen();\n        return this.idb().promiseAt(key);\n    }\n\n    /**\n     * Set a value for a key in the map.\n     * @param {*} key - The key to set.\n     * @param {*} value - The value to set. If undefined, the key will be deleted.\n     * @returns {Promise<void>}\n     */\n    async promiseAtPut (key, value) {\n        await this.promiseOpen();\n        return this.idb().promiseAtPut(key, value);\n    }\n\n    /**\n     * Remove a key from the map.\n     * @param {*} key - The key to remove.\n     * @returns {Promise<void>}\n     */\n    async promiseRemoveAt (key) {\n        await this.promiseOpen();\n        return this.idb().promiseRemoveAt(key);\n    }\n\n}.initThisClass());\n",
  "nHwVyfdQZcqAAyHxPFm3PSzp26Mihu1/wBjhZmsUgKY=": "\"use strict\";\n\n/* \n    SimpleSynth\n\n    Example usess:\n\n    SimpleSynth.clone().playSendBeep()\n    SimpleSynth.clone().playReceiveBeep()\n\n    SimpleSynth.clone().playButtonTap()\n\n    SimpleSynth.clone().playButtonDown()\n    SimpleSynth.clone().playButtonUp()\n    SimpleSynth.clone().playButtonCancelled()\n\n*/\n\n(class SimpleSynth extends ProtoClass {\n\n  static initClass () {\n    this.setIsSingleton(true);\n  }\n\n  initPrototypeSlots () {\n    //this.newSlot(\"idb\", null);\n  }\n  \n  initPrototype () {\n  }\n\n  audioContext () {\n    const context = new (window.AudioContext || window.webkitAudioContext)();\n    return context;\n  }\n\n  playOminousSound () {\n    const audioContext = this.audioContext();\n\n    const notes = [110, 123.47, 130.81, 146.83]; // Frequencies for notes A2, B2, C3, and D3\n\n    notes.forEach((note, index) => {\n      const startTime = audioContext.currentTime + index * 0.5;\n      const oscillator = audioContext.createOscillator();\n      const gainNode = audioContext.createGain();\n\n      oscillator.frequency.value = note;\n      oscillator.type = index % 2 === 0 ? \"sine\" : \"triangle\";\n      gainNode.gain.setValueAtTime(0.2, startTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);\n\n      oscillator.connect(gainNode);\n      gainNode.connect(audioContext.destination);\n\n      oscillator.start(startTime);\n      oscillator.stop(startTime + 0.5);\n    });\n  }\n\n  playNotes (notes) {\n    /*\n    The given function playNotes plays an array of notes using the Web Audio API. \n    Each note in the array is played for a duration of 0.1 seconds (100 milliseconds) with a delay of 0.1 seconds between each note. \n    The gain or volume of the notes is set to a low value of 0.02 to ensure that the notes are not too loud.\n    */\n    const context = this.audioContext();\n    const gainNode = context.createGain();\n    const volume = 0.1; //0.02;\n\n    gainNode.gain.setValueAtTime(volume, context.currentTime);\n    gainNode.connect(context.destination);\n\n    notes.forEach((note, index) => {\n      const oscillator = context.createOscillator();\n      oscillator.type = \"sine\";\n      oscillator.frequency.setValueAtTime(\n        note,\n        context.currentTime + index * 0.1\n      );\n\n      oscillator.connect(gainNode);\n      oscillator.start(context.currentTime + index * 0.1);\n      oscillator.stop(context.currentTime + index * 0.1 + 0.1);\n    });\n  }\n\n  playSendBeep () {\n    this.playNotes([330, 290]);\n  }\n\n  playReceiveBeep () {\n    this.playNotes([290, 330]);\n  }\n\n  playButtonTap () {\n    //this.playNotes([440]);\n    this.playTrackNamed(\"buttonPress\");\n  }\n\n  playButtonDown () {\n    //this.playNotes([400]);\n    this.playTrackNamed(\"buttonPress\");\n  }\n\n  playButtonUp () {\n    this.playNotes([480]);\n  }\n\n  playButtonCancelled () {\n    this.playNotes([440, 330]);\n  }\n\n  playNetworkConnected () {\n    this.playNotes([300, 400, 500]);\n  }\n\n  playNetworkDisconnected () {\n    this.playNotes([500, 400, 300]);\n  }\n\n  playWarning () {\n    this.playNotes([420, 450]);\n  }\n\n  playAlert () {\n    playNotes([600, 660, 600]);\n  }\n\n  playTrackNamed (trackName) {\n    const notes = this.tracksJson()[trackName];\n\n    if (!notes) {\n      console.warn(\"no track with name \" + trackName + \"'\");\n      return\n    }\n\n    this.playTrackNotes(notes)\n  }\n\n  playTrackNotes (notes) {\n    const context = this.audioContext();\n    let currentTime = context.currentTime;\n\n    notes.forEach(note => {\n        const oscillator = context.createOscillator();\n        const gainNode = context.createGain();\n\n        // Set the oscillator type\n        oscillator.type = note.oscillator || \"sine\";\n\n        // Set the oscillator frequency\n        oscillator.frequency.setValueAtTime(note.pitch, currentTime);\n\n        // Set the volume\n        gainNode.gain.setValueAtTime(note.volume || 0.7, currentTime); // Default to 0.7 if volume is not provided\n\n        // Connect the oscillator to the gain node and the gain node to the destination\n        oscillator.connect(gainNode);\n        gainNode.connect(context.destination);\n\n        // Start and stop the oscillator based on the note's length\n        oscillator.start(currentTime);\n        oscillator.stop(currentTime + (note.lengthMs / 1000)); // Convert milliseconds to seconds\n\n        // Update the current time to include the note's length and delay to the next note\n        currentTime += (note.lengthMs + (note.delayMs || 100)) / 1000; // Convert the total milliseconds to seconds\n    });\n  }\n\n  tracksJson () {\n    return {\n      \"buttonPress\": [\n        { \"pitch\": 400, \"lengthMs\": 100, \"oscillator\": \"sine\", \"delayMs\": 100, \"volume\": 0.7 }\n      ],\n      \"buttonRelease\": [\n        { \"pitch\": 480, \"lengthMs\": 100, \"oscillator\": \"sine\", \"delayMs\": 100, \"volume\": 0.7 }\n      ],\n      \"buttonCancel\": [\n        { \"pitch\": 440, \"lengthMs\": 50, \"oscillator\": \"sine\", \"delayMs\": 50, \"volume\": 0.6 },\n        { \"pitch\": 330, \"lengthMs\": 50, \"oscillator\": \"sine\", \"delayMs\": 50, \"volume\": 0.6 }\n      ],\n      \"connectionEstablished\": [\n        { \"pitch\": 300, \"lengthMs\": 100, \"oscillator\": \"sine\", \"delayMs\": 100, \"volume\": 0.7 },\n        { \"pitch\": 400, \"lengthMs\": 100, \"oscillator\": \"sine\", \"delayMs\": 100, \"volume\": 0.7 },\n        { \"pitch\": 500, \"lengthMs\": 100, \"oscillator\": \"sine\", \"delayMs\": 100, \"volume\": 0.7 }\n      ],\n      \"connectionDisconnected\": [\n        { \"pitch\": 500, \"lengthMs\": 50, \"oscillator\": \"sine\", \"delayMs\": 50, \"volume\": 0.8 },\n        { \"pitch\": 400, \"lengthMs\": 50, \"oscillator\": \"sine\", \"delayMs\": 50, \"volume\": 0.8 },\n        { \"pitch\": 300, \"lengthMs\": 50, \"oscillator\": \"sine\", \"delayMs\": 50, \"volume\": 0.8 }\n      ],\n      \"logWarning\": [\n        { \"pitch\": 420, \"lengthMs\": 75, \"oscillator\": \"sine\", \"delayMs\": 25, \"volume\": 0.6 },\n        { \"pitch\": 450, \"lengthMs\": 100, \"oscillator\": \"sine\", \"delayMs\": 100, \"volume\": 0.6 }\n      ],\n      \"alert\": [\n        { \"pitch\": 600, \"lengthMs\": 75, \"oscillator\": \"square\", \"delayMs\": 25, \"volume\": 0.9 },\n        { \"pitch\": 660, \"lengthMs\": 75, \"oscillator\": \"square\", \"delayMs\": 25, \"volume\": 0.9 },\n        { \"pitch\": 600, \"lengthMs\": 75, \"oscillator\": \"square\", \"delayMs\": 100, \"volume\": 0.9 }\n      ]\n    };\n  }\n  \n}.initThisClass());\n\n",
  "Cm6APipBR1toeSlgFr/+Prbs2aMc+rKm3f/Wk9xA2yo=": "\"use strict\";\n\n/*\n    Point\n\n    Class to represent a 2d or 3d point, optionally with a time.\n\n    TODO: \n        Move internal representation to array e.g.\n\n        const slot = this.newSlot(\"valueArray\", new Array(0, 0, 0, 0))\n\n        x () {\n            return this._valueArray[0]\n        }\n\n        isEqual (other) {\n            return this._valueArray == other.valueArray()\n        }\n\n*/\n\n\n(class Point extends ProtoClass {\n    initPrototypeSlots () {\n        const dimensionNames = [\"x\", \"y\", \"z\", \"t\"];\n        dimensionNames.forEach(slotName => {\n            const slot = this.newSlot(slotName, 0);\n            slot.setSlotType(\"Number\");\n        });\n    }\n\n    valueArray () {\n        return [this._x, this._y, this._z]\n    }\n\n    setTimeToNow () {\n        const d = new Date();\n        this._t = d.getTime();\n        return this\n    }\n\n    copyFrom (p, copyDict) {\n        this._x = p._x\n        this._y = p._y\n        this._z = p._z\n        this._t = p._t\n        return this\n    }\n\n    setXY (x, y) {\n        this._x = x;\n        this._y = y;\n        return this\n    }\n    \n    set (x, y, z, t) {\n        this._x = x;\n        this._y = y;\n        if (Type.isNumber(z)) {\n            this._z = z\n        }\n        if (Type.isNumber(t)) {\n            this._t = t\n        }\n        return this\n    }\n\n    addInPlace (p) {\n        this._x += p._x\n        this._y += p._y\n        this._z += p._z\n        this._t += p._t\n        return this\n    }\n\n    subtractInPlace (p) {\n        this._x -= p._x\n        this._y -= p._y\n        this._z -= p._z\n        this._t -= p._t\n        return this\n    }\n\n    floorInPlace () {\n        this._x = Math.floor(this._x)\n        this._y = Math.floor(this._y)\n        this._z = Math.floor(this._z)\n        return this\n    }\n\n    copy () {\n        return this.thisClass().clone().copyFrom(this)\n    }\n\n    add (p) {\n        return this.copy().addInPlace(p)\n    }\n\n    subtract (p) {\n        return this.copy().subtractInPlace(p)\n    }\n\n    asString () {\n        let s = this.type() + \"(\" + this._x + \", \" + this._y \n\n        if (this._z) { \n            s += \", \" + this._z\n        }\n\n        /*\n        if (this._t) { \n            s += \", \" + this._t + \"t\" \n        }\n        */\n\n        return s + \")\"\n    }\n\n    distanceFromOrigin () {\n        const ds = Math.pow(this.x(), 2) + Math.pow(this.y(), 2) + Math.pow(this.z(), 2)\n        return Math.sqrt(ds)\n    }\n\n    // difference with another point\n\n    dxFrom (p) {\n        return this.x() - p.x()\n    }\n\n    dyFrom (p) {\n        return this.y() - p.y()\n    }\n\n    dzFrom (p) {\n        return this.z() - p.z()\n    }\n\n    dtFrom (p) {\n        return this.t() - p.t()\n    }\n\n    distanceFrom (p) {\n        const dx = this.dxFrom(p)\n        const dy = this.dyFrom(p)\n        const dz = this.dzFrom(p)\n        return Math.sqrt(dx*dx + dy*dy + dz*dz)\n    }\n\n    // eqaulity\n\n    isEqual (p) {\n        return (this.x() === p.x()) && (this.y() === p.y()) && (this.z() === p.z()) // && (this.t() === p.t())\n    }\n\n    isEqualWithTime (p) { // not ideal\n        return (this.x() === p.x()) && (this.y() === p.y()) && (this.z() === p.z()) && (this.t() === p.t())\n    }\n\n    // comparison \n\n    isGreaterThan (p) {\n        return this.x() > p.x() && this.y() > p.y()\n    }\n\n    isLessThan (p) {\n        return this.x() < p.x() && this.y() < p.y()\n    }\n\n    isGreaterThanOrEqualTo (p) {\n        return this.x() >= p.x() && this.y() >= p.y()\n    }\n\n    isLessThanOrEqualTo (p) {\n        return this.x() <= p.x() && this.y() <= p.y()\n    }\n\n    angleInRadians () {\n        return Math.atan2(y, x);\n    }\n\n    angleInDegrees () {\n        return this.angleInRadians() * 180 / Math.PI;\n    }\n\n    angleInRadiansTo (p) {\n        return p.subtract(this).angleInRadians()\n    }\n\n    angleInDegreesTo (p) {\n        return p.subtract(this).angleInDegrees()\n    }\n\n    midpointTo (p) {\n        return this.add(p).divideByScalar(2)\n    }\n\n    multiplyByScalar (v) {\n        const p = Point.clone()\n        p.set(this.x() * v, this.y() * v, this.z() * v)\n        return p\n    }\n\n    divideByScalar (v) {\n        return this.multiplyByScalar(1/v)\n    }\n\n    negated (p) {\n        return this.multiplyByScalar(-1)\n    }\n\n    // css\n\n    asCssStringWithUnitSuffix (name, unitSuffix) {\n        if (!unitSuffix) { \n            unitSuffix = \"\"\n        }\n\n        const us = unitSuffix;\n        return name + \"(\" + this._x + us + \",\" + this._y + us + \",\" + this._z + us + \")\"\n        //const s = this.valueArray().map(v => v + unitSuffix).join(\",\")\n        //return name + \"(\" + s + \")\"\n    }\n\n    asCssTranslate3dString () {\n        return this.asCssStringWithUnitSuffix(\"translate3d\", \"px\")\n    }\n\n    asCssRotate3dDegreesString () {\n        return this.asCssStringWithUnitSuffix(\"rotate3d\", \"deg\")\n    }\n\n    asCssScale3dString () {\n        return this.asCssStringWithUnitSuffix(\"scale3d\", \"\")\n    }\n\n    // size - TODO: move to Size type?\n\n    width () {\n        return this.x()\n    }\n\n    height () {\n        return this.y()\n    }\n    \n}.initThisClass());\n",
  "J7BjwaRlTkomVJXuFRrBvlA2784sNGgnE4pOKJFixP8=": "\"use strict\";\n\n/*\n    Rectangle\n\n    Class to represent a rectangle.\n\n    NOTES\n\n    For top & bottom, we assume we are using screen coordinates so:\n\n        top = x\n    \n    and:\n\n        bottom = x + height\n\n*/\n\n(class Rectangle extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"origin\", null);\n            slot.setSlotType(\"Point\");\n        }\n        {\n            const slot = this.newSlot(\"size\", null);\n            slot.setSlotType(\"Point\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setOrigin(Point.clone())\n        this.setSize(Point.clone())\n        return this\n    }\n\n    duplicate () {\n        return this.thisClass().clone().copyFrom(this)\n    }\n\n    copyFrom (aRect) {\n        this.origin().copyFrom(aRect.origin())\n        this.size().copyFrom(aRect.size())\n        return this\n    }\n    \n    containsPoint (p) {\n        const a = p.isGreaterThanOrEqualTo(this.origin()) \n        const b = p.isLessThanOrEqualTo(this.maxPoint())\n        return a && b\n    }\n\n    containsRectangle (r) {\n        return r.origin().isGreaterThanOrEqualTo(this.origin()) && r.maxPoint().isLessThanOrEqualTo(this.maxPoint())\n    }\n\n    unionWith (r) {\n        const u = Rectangle.clone()\n        const o1 = this.origin()\n        const o2 = r.origin()\n        const m1 = this.maxPoint()\n        const m2 = r.maxPoint()\n        const minX = Math.min(o1.x(), o2.x())\n        const minY = Math.min(o1.y(), o2.y())\n        u.origin().setX(minX)\n        u.origin().setY(minY)\n        const maxX = Math.max(m1.x(), m2.x())\n        const maxY = Math.max(m1.y(), m2.y())\n        u.setWidth(maxX - minX)\n        u.setHeight(maxY - minY)\n        return u\n    }\n\n    maxPoint () {\n        return this.origin().add(this.size())\n    }\n\n    asString () {\n        return this.type() + \"(\" + this.origin().asString() + \", \" + this.size().asString() + \")\"\n    }\n\n    // x, y\n\n    x () {\n        return this.origin().x();\n    }\n\n    y () {\n        return this.origin().y();\n    }\n\n    minX () {\n        return this.x()\n    }\n\n    minY () {\n        return this.y()\n    }\n\n    maxX () {\n        return this.x() + this.width()\n    }\n\n    maxY () {\n        return this.y() + this.height()\n    }\n    \n    setMaxX (mx) {\n        const w = mx - this.x()\n        this.setWidth(w)\n        return this\n    }\n\n    setMaxY (my) {\n        const h = my - this.y()\n        this.setHeight(h)\n        return this\n    }\n\n    // width \n\n    setWidth (w) {\n        assert(w >= 0)\n        this.size().setX(w)\n        return this\n    }\n\n    width () {\n        return this.size().x();\n    }\n\n    // height\n\n    setHeight (h) {\n        assert(h >= 0)\n        this.size().setY(h)\n        return this\n    }\n\n    height () {\n        return this.size().y();\n    }\n\n    // top, bottom\n\n    top () {\n        return this.y() \n    }\n\n    bottom () {\n        return this.y() + this.height() \n    }\n\n    // left, right\n\n    left () {\n        return this.x() \n    }\n\n    right () {\n        return this.x() + this.width() \n    }\n\n    makeBoundsOfPoints (points) {\n        const firstPoint = points[0]\n        let minX = firstPoint.x()\n        let maxX = firstPoint.x()\n        let minY = firstPoint.y()\n        let maxY = firstPoint.y()\n        points.forEach(p => {\n            const x = p.x()\n            const y = p.y()\n\n            // faster than using Math.min/max\n            if (x < minX) {\n                minX = x\n            } else if (x > maxX) {\n                maxX = x \n            }\n\n            if (y < minY) {\n                minY = y \n            } else if (y > maxY) {\n                maxY = y\n            }\n        })\n        this.origin().setX(minX).setY(minY)\n        this.setMaxX(maxX)\n        this.setMaxY(maxY)\n        return this\n    }\n\n}.initThisClass());\n",
  "F07fTUp8+eL3Gd4iURLQWdoGmRTF6IMW/JRPvxj3UKc=": "\n\"use strict\";\n\n/*\n\n    DivTransform\n    \n*/\n\n(class Transform extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"position\", null);\n            slot.setComment(\"in px units\");\n            slot.setSlotType(\"Point\");\n        }\n        {\n            const slot = this.newSlot(\"rotation\", null);\n            slot.setComment(\"in degrees units\");\n            slot.setSlotType(\"Point\");\n        }\n        {\n            const slot = this.newSlot(\"scale\", null);\n            slot.setSlotType(\"Point\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setPosition(Point.clone());\n        this.setRotation(Point.clone());\n        this.setScale(Point.clone().setX(1).setY(1).setZ(1));\n        return this;\n    }\n\n    // css\n\n    cssString () {\n        // NOTE: multiple transform one line directives are applied from right to left\n        const s = \n          this.scale().asCssScale3dString() + \" \" \n        + this.position().asCssTranslate3dString() + \" \" \n        + this.rotation().asCssRotate3dDegreesString(); // is this the expected order?\n        return s\n    }\n\n    // operations\n\n    copy () {\n        const t = Transform.clone()\n        t.position().copy(this.position())\n        t.rotation().copy(this.rotation())\n        t.scale().copy(this.scale())\n        return t\n    }\n\n\n    addInPlace (otherTransform) {\n        this.position().addInPlace(otherTransform.position())\n        this.rotation().addInPlace(otherTransform.rotation())\n        this.scale().addInPlace(otherTransform.scale())\n        return this\n    }\n\n    /*\n    add (aTransform) {\n        const t = this.copy()\n        t.position().addInPlace(aTransform.position())\n        t.rotation().addInPlace(aTransform.rotation())\n        t.scale().addInPlace(aTransform.scale())\n        return t\n    }\n\n\n    subtract (aTransform) {\n        const t = this.copy()\n        t.position().subtractInPlace(aTransform.position())\n        t.rotation().subtractInPlace(aTransform.rotation())\n        t.scale().subtractInPlace(aTransform.scale())\n        return t\n    }\n    */\n   \n}.initThisClass());",
  "5NKy2Va2fLxTQykOLBoBmzk9JUr/A4X4WTOHdInG6JI=": "\"use strict\";\n\n/*\n    \n    Event-cachedPoints\n\n*/\n\nif (!getGlobalThis().Event) {\n    console.log(\"WARNING: no Event object found - maybe we are not in browser?\")\n} else {\n    Object.defineSlots(Event.prototype, {\n        hasCachedPoints: function () {\n            return this._cachedPoints !== undefined\n        },\n\n        setCachedPoints: function (points) {\n            this._cachedPoints = points\n        },\n\n        cachedPoints: function () {\n            return this._cachedPoints\n        },\n        \n        pushCachedPoint: function (point) {\n            assert(this._cachedPoints)\n            this._cachedPoints.push(point)\n        }\n    })\n}\n\n",
  "CUqkg9p8XvNSVPTcdV3yoPZ5iZWPSDXkgw1/qYz1Agw=": "\"use strict\";\n\n/*\n\n    EventPoint\n\n    Class to represent a 2d or 3d point, optionally with a time.\n\n    NOTES\n\n    Event's positions are set to the document (event.pageX, event.pageY) coordinates.\n    To get the viewport coordinates (event.clientX, event.clientY), \n    use the viewportPosition() method.\n\n*/\n\n(class EventPoint extends Point {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"id\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"state\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"target\", null);\n            slot.setSlotType(\"Element\");\n        }\n        {\n            const slot = this.newSlot(\"isDown\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"overView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"event\", null);\n            slot.setSlotType(\"Event\");\n        }\n    }\n   \n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    copyFrom (p, copyDict) {\n        super.copyFrom(p, copyDict)\n        this._id = p._id\n        this._state = p._state\n        this._target = p._target\n        return this\n    }\n\n    overView () {\n        if (this._overView === null) {\n            this._overView = this.findOverview()\n        }\n        return this._overView\n    }\n\n    findOverview () {\n        debugger;\n        // search up the dom elements until we find one \n        // associated with a DomView instance \n\n        let e = document.elementFromPoint(this.x(), this.y());\n\n\n        while (e) {\n            const view = e.domView()\n            if (view) {\n                return view\n            }\n            e = e.parentElement\n        }\n        return null\n    }\n\n    // viewport helpers\n\n    viewportPosition () {\n        const e = this.event()\n        const p = Point.clone().set(e.clientX, e.clientY)\n        return p\n    }\n\n    viewportHeight () {\n        return window.innerHeight\n    }\n\n    viewportWidth () {\n        return window.innerWidth\n    }\n\n    distFromTopOfViewport () {\n        return this.event().clientY\n    }\n\n    distFromBottomOfViewport () {\n        return this.viewportHeight() - this.distFromTopOfViewport()\n    }\n\n    distFromLeftOfViewport () {\n        return this.event().clientX\n    }\n\n    distFromRightOfViewport () {\n        return this.viewportWidth() - this.distFromLeftOfViewport()\n    }\n    \n}.initThisClass());\n",
  "lwOdzllL+jCVdc9pvCJ7aB/+Jp2GlD7i9CULbQPrMyU=": "\"use strict\";\n\n/*\n    Device\n\n*/\n\n(class Device extends ProtoClass {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n}.initThisClass());\n",
  "AJHHfwl0pgSf0raXquk7YJmXy932hKv9kUEMc4jBMvA=": "\"use strict\";\n\n/*\n    KeyboardKey\n\n\n*/\n\n(class KeyboardKey extends Device {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isDown\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"code\", null);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"name\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"keyboard\", null);\n            slot.setSlotType(\"BMKeyboard\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    onKeyDown (event) {\n        //this.debugLog(() => this.name() + \" onKeyDown \" + event._id)\n        let shouldPropogate = true\n        this.setIsDown(true)\n        return shouldPropogate\n    }\n\n    onKeyUp (event) {\n        //this.debugLog(() => this.name() + \" onKeyUp \" + event._id)\n        let shouldPropogate = true\n        this.setIsDown(false)\n        return shouldPropogate\n    }\n\n    isUp () {\n        return !this.isDown()\n    }\n\n    isOnlyKeyDown () {\n        return this.isDown() && this.keyboard().currentlyDownKeys().length\n    }\n\n    isAlphabetical (event) {\n        const c = this.code()\n        return c >= 65 && c <= 90\n    }\n    \n}.initThisClass());",
  "5tU8D9JZY/j9LpZBi1KkqduZVi3GpztI0ya+f9a8yks=": "\"use strict\";\n\n/*\n\n    Keyboard\n\n    Global shared instance that tracks current keyboard state.\n    Registers for capture key events on document.body.\n\n    MacOS/iOS note:\n\n        These Mac keys use different names in JS events:\n        CommandLeft -> MetaLeft\n        CommandRight -> MetaRight\n        Option/Alt -> Alternate\n        Control -> Control\n        Function -> [not seen by JS either as key event or modifier]\n\n    Browser Issues:\n\n        Key combinations intercepted by browser:\n\n            OSX:\n                meta-n (new window)\n                meta-m (minimize window)\n                meta-w (close window)\n                meta-t (new tab)\n\n                but we can intercept:\n                meta-o\n\n\n    Notes:\n\n        Newer JS browser APIs might have better ways to do \n        key code to name mappings. TODO: look into whether this is well supported across browsers. \n        \n*/\n\n\n(class BMKeyboard extends Device {\n\n    static initClass () {\n        this.setIsSingleton(true);\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"codeToKeysMap\", null); \n            slot.setComment(\"dictionary of KeyboardKey objects\");\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"keyboardListener\", null);\n            slot.setSlotType(\"KeyboardListener\");\n        }\n        {\n            const slot = this.newSlot(\"allModifierKeys\", null);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setupCodeToKeys();\n        this.startListening();\n        this.setIsDebugging(false);\n        this.setAllModifierKeys(this.allModifierNames().map(kn => this.keyForName(kn)));\n        return this;\n    }\n\n    startListening () {\n        const listener = KeyboardListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this)\n        this.setKeyboardListener(listener)\n        this.keyboardListener().setIsListening(true)\n        return this\n    }\n\n    setupCodeToKeys () {\n        const map = new Map();\n        this.keyCodesToNamesMap().forEachKV((code, name) => {\n            //const name = c2k[code];\n            const key = KeyboardKey.clone().setName(name).setCode(code).setKeyboard(this);\n            assert(Type.isNumber(code));\n            map.set(Number(code), key);\n        });\n        this.setCodeToKeysMap(map);\n        return this;\n    }\n\n    keyForCode (aCode) {\n        return this.codeToKeysMap().get(aCode);\n    }\n\n    keyForName (aName) {\n        const code = this.keyCodeForName(aName);\n        return this.keyForCode(code);\n    }\n\n    nameForKeyCode (aCode) {\n        const key = this.keyForCode(aCode);\n        if (key) {\n            return key.name();\n        }\n        return null;\n    }\n\n    k2c () {\n        if (!this._k2c) {\n            this._k2c = this.keyCodesToNamesMap().inverted();\n        }\n        return this._k2c\n    }\n\n    keyCodeForName (aName) {\n        return this.k2c().get(aName);\n    }\n    \n    eventIsJustModifierKey (event) {\n        const name = this.nameForKeyCode(event.keyCode)\n        return this.allModifierNames().contains(name)\n    }\n\n    keyCodesToNamesMap () {\n        return new Map([\n            [8, \"Backspace\"],\n            [9, \"Tab\"],\n            [13, \"Enter\"],\n            [16, \"Shift\"],\n            [17, \"Control\"],\n            [18, \"Alternate\"],\n            [19, \"PauseBreak\"],\n            [20, \"Capslock\"],\n            [27, \"Escape\"],\n            [32, \"Space\"],\n            [33, \"PageUp\"],\n            [34, \"PageDown\"],\n            [35, \"End\"],\n            [36, \"Home\"],\n            [37, \"LeftArrow\"],\n            [38, \"UpArrow\"],\n            [39, \"RightArrow\"],\n            [40, \"DownArrow\"],\n            [45, \"Insert\"],\n            [46, \"Delete\"],\n            [48, \"0\"],\n            [49, \"1\"],\n            [50, \"2\"],\n            [51, \"3\"],\n            [52, \"4\"],\n            [53, \"5\"],\n            [54, \"6\"],\n            [55, \"7\"],\n            [56, \"8\"],\n            [57, \"9\"],\n            [65, \"a\"],\n            [66, \"b\"],\n            [67, \"c\"],\n            [68, \"d\"],\n            [69, \"e\"],\n            [70, \"f\"],\n            [71, \"g\"],\n            [72, \"h\"],\n            [73, \"i\"],\n            [74, \"j\"],\n            [75, \"k\"],\n            [76, \"l\"],\n            [77, \"m\"],\n            [78, \"n\"],\n            [79, \"o\"],\n            [80, \"p\"],\n            [81, \"q\"],\n            [82, \"r\"],\n            [83, \"s\"],\n            [84, \"t\"],\n            [85, \"u\"],\n            [86, \"v\"],\n            [87, \"w\"],\n            [88, \"x\"],\n            [89, \"y\"],\n            [90, \"z\"],\n            [91, \"MetaLeft\"],\n            [92, \"RightWindow\"],\n            [93, \"MetaRight\"],\n            [96, \"NumberPad0\"],\n            [97, \"NumberPad1\"],\n            [98, \"NumberPad2\"],\n            [99, \"NumberPad3\"],\n            [100, \"NumberPad4\"],\n            [101, \"NumberPad5\"],\n            [102, \"NumberPad6\"],\n            [103, \"NumberPad7\"],\n            [104, \"NumberPad8\"],\n            [105, \"NumberPad9\"],\n            [106, \"Multiply\"],\n            [107, \"Plus\"],\n            [109, \"Minus\"],\n            [110, \"DecimalPoint\"],\n            [111, \"Divide\"],\n            [112, \"Function1\"],\n            [113, \"Function2\"],\n            [114, \"Function3\"],\n            [115, \"Function4\"],\n            [116, \"Function5\"],\n            [117, \"Function6\"],\n            [118, \"Function7\"],\n            [119, \"Function8\"],\n            [120, \"Function9\"],\n            [121, \"Function10\"],\n            [122, \"Function11\"],\n            [123, \"Function12\"],\n            [144, \"NumberLock\"],\n            [145, \"ScrollLock\"],\n            [186, \"Semicolon\"],\n            [187, \"EqualsSign\"],\n            [188, \"Comma\"],\n            [189, \"Dash\"],\n            [190, \"Period\"],\n            [191, \"ForwardSlash\"],\n            [192, \"GraveAccent\"],\n            [219, \"OpenBracket\"],\n            [220, \"Backslash\"],\n            [221, \"CloseBracket\"],\n            [222, \"SingleQuote\"]\n          ]);\n    }\n\n    /*\n    shiftChangingKeysDict () {\n        // Based on a Macbook Pro keyboard. \n        // Not sure if this is platform specific.\n\n        return {\n            \"\\`\": [\"Tilda\", \"~\"],\n            \"1\": [\"ExclaimationPoint\", \"!\"],\n            \"2\": [\"AtSymbol\", \"@\"],\n            \"3\": [\"Hash\", \"#\"],\n            \"4\": [\"DollarSign\", \"$\"],\n            \"5\": [\"Percent\", \"%\"],\n            \"6\": [\"Carot\"],\n            \"7\": [\"Ampersand\", \"&\"],\n            \"8\": [\"Asterisk\", \"*\"],\n            \"9\": [\"OpenParenthesis\", \"(\"],\n            \"0\": [\"CloseParenthesis\", \")\"],\n            \"-\": [\"Underscore\", \"_\"],\n            \"=\": [\"Plus\", \"+\"],\n            \"[\": [\"OpenCurlyBracket\", \"{\"],\n            \"]\": [\"CloseCurlyBracket\", \"}\"],\n            \"\\\\\": [\"Pipe\", \"|\"],\n            \";\": [\"Colon\", \":\"],\n            \"'\": [\"DoubleQuote\", \"\\\"\"],\n            \",\": [\"LessThan\", \"<\"],\n            \".\": [\"GreaterThan\", \">\"],\n            \"/\": [\"QuestionMark\", \"?\"],\n        }\n    }\n    */\n\n    shiftDict () {\n        // Based on a Macbook Pro keyboard. \n        // Not sure if this is platform specific.\n\n        return {\n            \"~\": \"Tilda\",\n            \"!\": \"ExclaimationPoint\",\n            \"@\": \"AtSymbol\",\n            \"#\": \"Hash\",\n            \"$\": \"DollarSign\",\n            \"%\": \"Percent\",\n            \"^\": \"Carot\",\n            \"&\": \"Ampersand\",\n            \"*\": \"Asterisk\",\n            \"(\": \"OpenParenthesis\",\n            \")\": \"CloseParenthesis\",\n            \"_\": \"Underscore\",\n            \"+\": \"Plus\",\n            \"{\": \"OpenCurlyBracket\",\n            \"}\": \"CloseCurlyBracket\",\n            \"|\": \"Pipe\",\n            \":\": \"Colon\",\n            \"\\\\\": \"DoubleQuote\",\n            \"<\": \"LessThan\",\n            \">\": \"GreaterThan\",\n            \"?\": \"QuestionMark\",\n        }\n    }\n\n    /*\n    specialKeyCodes () { \n        return {\n            8:  \"delete\", // \"delete\" on Apple keyboard\n            9:  \"tab\", \n            13: \"enter\", \n            16: \"shift\", \n            17: \"control\", \n            18: \"alt\", \n            20: \"capsLock\", \n            27: \"escape\", \n            33: \"pageUp\", \n            34: \"pageDown\", \n            37: \"leftArrow\",  \n            38: \"upArrow\",  \n            39: \"rightArrow\", \n            40: \"downArrow\",  \n            46: \"delete\", \n\n        }\n    }\n    */\n\n    // -- events ---\n\n    showCodeToKeys () {\n        const c2k = this.keyCodesToNamesMap();\n\n        //const s = JSON.stringify(c2k, null, 4);\n\n        const lines = c2k.keysArray().map((code) => {\n            return \"    \" + code + \": \\\"\" + this.codeToKeysMap().get(code).name() + \"\\\"\";\n        })\n        const s = \"{\\n\" + lines.join(\",\\n\") + \"}\\n\";\n        console.log(\"c2k:\", s);\n\n        /*\n        console.log(\"Keyboard:\")\n        this.codeToKeysMap().forEachKV((code, key) => {\n            console.log(\"  code: \", code + \" key name: \", this.keyForCode(code).name())\n        });\n        */\n        return this;\n    }\n\n    keyForEvent (event) {\n        const code = event.keyCode;\n        const key = this.keyForCode(code);\n        return key;\n    }\n\n    onKeyDownCapture (event) {\n        //console.log(\"event.metaKey = \", event.metaKey)\n        \n        const shouldPropogate = true;\n        const key = this.keyForEvent(event);\n\n        if (key) {\n            key.onKeyDown(event);\n\n            if (this.isDebugging()) {\n                this.debugLog(\" \" + this.downMethodNameForEvent(event));\n            }\n        } else {\n            console.warn(\"BMKeyboard.shared() no key found for event \", event);\n            debugger;\n            this.keyForEvent(event);\n        }\n            \n        return shouldPropogate;\n    }\n\n    onKeyUpCapture (event) {\n        const shouldPropogate = true\n        const key = this.keyForEvent(event)\n        if (!key) {\n            console.log(\"]]]]]]]]]]] WARNING: missing key for event: \", event)\n            return\n        }\n        key.onKeyUp(event)\n\n        if (this.isDebugging()) {\n            this.debugLog(\" \" + this.upMethodNameForEvent(event))\n            //this.debugLog(\".onKeyUpCapture \" + key.name() + \" -> \" + this.modsAndKeyNameForEvent(event) + \"KeyUp\")\n        }\n\n        return shouldPropogate\n    }\n    \n    // --- event handling method names ---\n\n    downMethodNameForEvent (event) {\n        return \"on\" + this.modsAndKeyNameForEvent(event) + \"KeyDown\";\n    }\n\n    upMethodNameForEvent (event) {\n        return \"on\" + this.modsAndKeyNameForEvent(event) + \"KeyUp\";\n    }\n\n    eventIsAlphabetical (event) {\n        const c = event.keyCode;\n        return c >= 65 && c <= 90;\n    }\n\n    eventIsNumeric (event) {\n        const c = event.keyCode;\n        return c >= 48 && c <= 57;\n    }\n\n    modsAndKeyNameForEvent (event) {\n        // examples: AltB AltShiftB\n        // Note that shift is explicit and the B key is always uppercase\n\n        if (Type.isUndefined(event.keyCode)) {\n            return \"\"\n        }\n        \n        const key = this.keyForCode(event.keyCode)\n        const isJustModifier = this.eventIsJustModifierKey(event)\n        const modifiers = this.modifierNamesForEvent(event)\n        const isAlpabetical = this.eventIsAlphabetical(event);\n        const isNumeric = this.eventIsNumeric(event);\n        let keyName = key ? key.name() : event.code\n\n        \n        if (isJustModifier) {\n            return keyName\n        }\n\n        if (event.shiftKey) {\n            // Note: if another modifier besides the shift key is down, \n            // the non-shift version of event.key is use e.g.\n            // shift-equals is \"Plus\"\n            // control-shift-equals is \"ControlShiftEquals\"\n            // this follows the Javascript event.key convention\n\n            const shiftName = this.shiftDict()[event.key]\n            if (shiftName) {\n                keyName = shiftName\n            }\n        }\n\n        if (isAlpabetical) {\n            if (event.shiftKey) {\n                keyName = keyName.capitalized()\n                modifiers.remove(\"Shift\")\n            }\n            keyName = \"_\" + keyName + \"_\"\n        }\n\n        if (isNumeric) {\n            keyName = \"_\" + keyName + \"_\";\n        }\n\n        return modifiers.join(\"\") + keyName\n    }\n\n    // --- special ---\n\n    // get key helpers\n\n    shiftKey () {\n        return this.keyForName(\"Shift\")\n    }\n\n    controlKey () {\n        return this.keyForName(\"Control\")\n    }\n\n    alternateKey () {\n        return this.keyForName(\"Alternate\")\n    }\n\n    leftCommandKey () {\n        return this.keyForName(\"MetaLeft\")\n    }\n\n    rightCommandKey () {\n        return this.keyForName(\"MetaRight\")\n    }\n\n    // get key state helpers\n\n    shiftIsDown () {\n        return this.shiftKey().isDown()\n    }\n\n    commandIsDown () {\n        return this.leftCommandKey().isDown() || this.rightCommandKey().isDown()\n    }\n\n\n    equalsSignKey () {\n        return this.keyForName(\"EqualsSign\")\n    }\n\n    minusKey () {\n        return this.keyForName(\"Dash\")\n    }\n\n    plusKey () {\n        return this.keyForName(\"Plus\")\n    }\n\n    plusIsDown () {\n        return this.plusKey().isDown()\n    }\n\n    currentlyDownKeys () {\n        return this.codeToKeys().valuesArray().select(key => key.isDown());\n    }\n\n    currentlyUpKeys () {\n        return this.codeToKeys().valuesArray().select(key => !key.isDown());\n    }\n\n    hasKeysDown () {\n        return this.currentlyDownKeys().length !== 0;\n    }\n\n    downKeyNames () {\n        return BMKeyboard.shared().currentlyDownKeys().map(k => k.name());\n    }\n\n    show () {\n        this.debugLog(\" downKeys: \", this.downKeyNames());\n    }\n\n    allModifierNames () {\n        return [\n            \"Alternate\", \n            \"Control\", \n            \"Meta\",\n            \"MetaLeft\", \n            \"MetaRight\", \n            \"Shift\", \n        ];\n    }\n\n    modifierNamesForEvent (event) {\n        let modifierNames = []\n\n        // event names are ordered alphabetically to avoid ambiguity\n\n        if (event.altKey) {\n            modifierNames.push(\"Alternate\")\n        } \n        \n        if (event.ctrlKey) {\n            modifierNames.push(\"Control\")\n        }\n        \n        if (event.metaKey) {\n            const n = event.location\n\n            //console.log(\"event.location = \", event.location)\n\n            if (n === 1) {\n                modifierNames.push(\"MetaLeft\")\n            } else if (n === 2) {\n                modifierNames.push(\"MetaRight\")\n            } else {\n                modifierNames.push(\"Meta\")\n            }\n        } \n        \n        if (event.shiftKey) {\n            modifierNames.push(\"Shift\")\n        }\n\n        return modifierNames\n    }\n\n    showEvent (event) {\n        const kb = BMKeyboard.shared()\n        console.log(\"---\")\n        console.log(\"BMKeyboard.showEvent():\")\n        console.log(\"  code: \", event.keyCode)\n        console.log(\"  name: \", kb.nameForKeyCode(event.keyCode))\n        console.log(\"  is modifier: \", kb.eventIsJustModifierKey(event))\n        console.log(\"  modifierNames: \", kb.modifierNamesForEvent(event))\n        console.log(\"  modsAndKeyName: \", kb.modsAndKeyNameForEvent(event))\n        console.log(\"---\")\n    }\n    \n}.initThisClass());\n",
  "/J2aKJQdikW3g2EVBto9+hY1VCs1zQeEDF8r2d6JUmM=": "\"use strict\";\n\n/*\n\n    Mouse\n\n    Global shared instance that tracks current mouse state in window coordinates.\n    Registers for capture mouse events on document.body.\n\n    NOTES\n\n    Doesn't deal with multi-button mouse input yet.\n    Not sure how multi-button mouse should be handled if we want code \n    to be Mac, touch pad, and touch screen compatible.\n\n*/\n\n(class Mouse extends Device {\n\n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isDown\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"downEvent\", null);\n            slot.setSlotType(\"MouseEvent\");\n        }\n        {\n            const slot = this.newSlot(\"currentEvent\", null);\n            slot.setSlotType(\"MouseEvent\");\n        }\n        {\n            const slot = this.newSlot(\"upEvent\", null);\n            slot.setSlotType(\"MouseEvent\");\n        }\n        {\n            const slot = this.newSlot(\"mouseListener\", null);\n            slot.setSlotType(\"MouseListener\");\n        }\n        {\n            const slot = this.newSlot(\"mouseMoveListener\", null);\n            slot.setSlotType(\"MouseMoveListener\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.startListening();\n        return this;\n    }\n\n    /*\n    setCurrentEvent (event) {\n        this._currentEvent = event\n        //Devices.shared().setCurrentEvent(event)\n        return this\n    }\n    */\n\n    startListening () {\n        this.setMouseListener(MouseListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))\n        this.mouseListener().setIsListening(true)\n\n        this.setMouseMoveListener(MouseMoveListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))\n        this.mouseMoveListener().setIsListening(true)\n        return this\n    }\n\n    // positions\n\n    downPos () {\n        return this.pointForEvent(this.downEvent())\n    }\n\n    currentPos () {\n        return this.pointForEvent(this.currentEvent())\n    }\n\n    upPos () {\n        return this.pointForEvent(this.upEvent())\n    }\n\n    // --- events --- follow down, up, and move events\n\n    onMouseDownCapture (event) {\n        this.setDownEvent(event)\n        this.setCurrentEvent(event)\n        this.setIsDown(true);\n        return true\n    }\n\n    onMouseMoveCapture (event) {\n        this.setCurrentEvent(event)\n        return true\n    }\n\n    onMouseUpCapture (event) {\n        this.setCurrentEvent(event)\n        this.setUpEvent(event)\n        this.setIsDown(false);\n        return true\n    }  \n\n    // -- helpers ---\n\n    pointForEvent (event) {\n        assert(event.__proto__.constructor === MouseEvent)\n\n        const p = EventPoint.clone()\n        p.set(event.pageX, event.pageY) // document position\n        p.setTarget(event.target)\n        p.setTimeToNow()\n        p.setId(\"mouse\")\n        p.setState(event.buttons)\n        p.setIsDown(event.buttons !== 0)\n        p.setEvent(event)\n        //p.findOverview()\n\n        return p\n    }\n\n    dragVector (event) {   \n        if (this.downPos()) {\n            return this.currentPos().subtract(this.downPos())\n        }\n        /*  \n        if (this.isDown()) {\n            return this.currentPos().subtract(this.downPos())\n        }\n        */\n        return Point.clone()\n    }\n\n    pointsForEvent (event) {\n        if (!event.hasCachedPoints()) {\n            const points = [this.pointForEvent(event)]\n            event.setCachedPoints(points)\n        }\n\n        return event.cachedPoints()\n    }\n\n    currentPoints () {\n        if (this.currentEvent()) {\n            return this.pointsForEvent(this.currentEvent())\n        }\n        return []\n    }\n\n    // full event name\n\n    downMethodNameForEvent (event) {\n        const s = BMKeyboard.shared().modsAndKeyNameForEvent(event)\n        return \"on\" + s + \"MouseDown\"\n    }\n\n    upMethodNameForEvent (event) {\n        const s = BMKeyboard.shared().modsAndKeyNameForEvent(event)\n        return \"on\" + s + \"MouseUp\"\n    }\n    \n}.initThisClass());\n",
  "iQ0Lz3pb6NSLZqSMfWHioNYboRknj8K6GwXnSQB/Jvs=": "\"use strict\";\n\n/*\n\n    TouchScreen\n\n    Global shared instance that tracks current touch state in window coordinates.\n    Registers for capture events on document.body.\n\n    Example use:\n\n        const hasTouch = TouchScreen.shared().isSupported()\n\n*/\n\n(class TouchScreen extends Device {\n\n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"currentEvent\", null);\n            slot.setSlotType(\"TouchEvent\");\n        }\n        {\n            const slot = this.newSlot(\"lastEvent\", null);\n            slot.setSlotType(\"TouchEvent\");\n        }\n        {\n            const slot = this.newSlot(\"touchListener\", null);\n            slot.setSlotType(\"TouchListener\");\n        }\n        {\n            const slot = this.newSlot(\"isSupported\", null);\n            slot.setSlotType(\"Boolean\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"isVisualDebugging\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        */\n    }\n\n    isSupported () {\n        if (this._isSupported === null) {\n            this._isSupported = this.calcIsSupported();\n        }\n        return this._isSupported;\n    }\n\n    calcIsSupported () {\n        // return WebBrowserWindow.isTouchDevice()\n        let result = false;\n        \n        if (\"ontouchstart\" in window) { \n            // works on most browsers \n            result = true; \n        }\n\n        if (navigator.maxTouchPoints) {\n            // works on IE10/11 and Surface\t\n            result = true; \n        } \n\n        return result\n    }\n\n    init () {\n        super.init()\n        this.startListening()\n        this.setIsDebugging(false)\n        if (this.isDebugging()) {\n            this.debugLog(\".init()\")\n        }\n        return this\n    }\n\n    setCurrentEvent (event) {\n        if (this._currentEvent !== event) {\n            this.setLastEvent(this._currentEvent)\n            this._currentEvent = event\n            if (this.isDebugging()) {\n                console.log(this.type() + \" touch count: \" + this.currentPoints().length)\n            }\n            //Devices.shared().setCurrentEvent(event)\n        }\n        return this\n    }\n\n    startListening () {\n        this.setTouchListener(TouchListener.clone().setUseCapture(true).setListenTarget(document.body).setDelegate(this))\n        this.touchListener().setIsListening(true)\n        return this\n    }\n\n    // events\n\n    onTouchBeginCapture (event) {\n        if (this.isDebugging()) {\n            console.log(this.type() + \".onTouchBeginCapture()\")\n        }\n        this.setCurrentEvent(event)\n        //this.handleLeave(event)\n        return true\n    }\n\n    /*\n    elementsForEvent (event) {\n        const elements = [];\n        const points = this.pointsForEvent(event)\n        points.forEach((point) => {\n            const e = document.elementFromPoint(p.x(), p.y());\n            if (e) {\n                elements.push(e)\n            }\n        })\n        return elements\n    }\n    */\n\n    lastPointForId (id) {\n        const lastPoints = this.pointsForEvent(this.lastEvent())\n        return lastPoints.detect(p => p.id() === id)\n    }\n\n    currentPointForId (id) {\n        const currentPoints = this.pointsForEvent(this.currentEvent())\n        return currentPoints.detect(p => p.id() === id)\n    }\n\n    onTouchMoveCapture (event) {\n        this.setCurrentEvent(event)\n        //this.handleLeave(event)\n        return true\n    }\n\n    onTouchEndCapture (event) {\n        this.setCurrentEvent(event)\n        //this.handleLeave(event)\n        return true\n    }\n\n    pointForTouch (touch) {\n        assert(event.__proto__.constructor === TouchEvent)\n        const p = EventPoint.clone()\n        p.setId(touch.identifier)\n        p.setTarget(touch.target)\n        p.set(touch.pageX, touch.pageY)  // document position\n        p.setTimeToNow()\n        p.setIsDown(true)\n        p.setEvent(touch)\n        //p.findOverview()\n        return p\n    }\n\n    justPointsForEvent (event) {\n        //if (this.isDebugging()) {\n        //  console.log(\"touches.length = \", event.touches.length)\n        //}\n\n        const points = []\n        // event.touches isn't a proper array, so we can't enumerate it normally\n        const touches = event.touches // all current touches\n        for (let i = 0; i < touches.length; i++) {\n            const touch = touches[i]\n            const p = this.pointForTouch(touch)\n            points.append(p)\n        }\n\n        return points\n    }\n\n\n    pointsForEvent (event) {\n        if (!event.hasCachedPoints()) {\n            event.preventDefault() // needed to prevent browser from handling touches?\n\n            const points = this.justPointsForEvent(event)\n            event.setCachedPoints(points)\n        }\n\n        return event.cachedPoints(event)\n    }\n\n    currentPoints () {\n        if (this.currentEvent()) {\n            return this.pointsForEvent(this.currentEvent())\n        }\n        return []\n    }\n\n    // There are no standard onTouchLeave & onTouchOver events,\n    // so this is an attempt to add them. Only really need them\n    // for visual gesture debugging at the moment though.\n    \n    /*\n    sendEventToView (eventName, event, aView) {\n        // send to listeners instead?\n        aView.gestureRecognizers().forEach((gr) => {\n            gr[eventName].call(gr, event)\n        })\n        return this\n    }\n\n    handleLeave (event) {\n        // an attempt to add onTouchLeave and onTouchOver events\n        const currentPoints = this.pointsForEvent(this.currentEvent())\n\n        currentPoints.forEach((cp) => {\n            const lp = this.lastPointForId(cp.id())\n            if (lp) {\n                const lastView    = lp.overview()\n                const currentView = cp.overview()\n\n                // check if overView is the same\n                if (lastView !== currentView) {\n                    this.sendEventToView(\"onTouchLeave\", event, lastView)\n                    this.sendEventToView(\"onTouchOver\", event, currentView)\n                }\n            } else {\n                // this is a new finger\n            }\n        })\n\n        return this\n    }\n    */\n   \n}.initThisClass());\n",
  "Ak4C3k+lLAPNQpdWu/90IulOvGJtEpqyqtiUVUtVTy8=": "\"use strict\";\n\n/*\n    GamePadManager\n\n    - checks if gamepad API is supported\n    - polls navigator gamepads state\n    - creates and removes GamePad instances to match current state\n    - can send notification of state changes for each GamePad\n\n    Since Chrome doesn't support gamePadListener, I'm just implementing\n    it to work without it, though this requires polling for game pad connected.\n\n    Example use:\n\n    // check for game pad support\n    const isSupported = GamePadManager.shared().isSupported()\n    \n    // start monitoring gamepads\n    GamePadManager.shared().startPolling()\n\n    // get array of connected game pads\n    const pads = GamePadManager.shared().connectedGamePads()\n\n    // each pad will have a unique id to identiy it\n    pads.forEach( (pad) => { \n        console.log(\"pad id:\", pad.id()) \n    })\n\n*/\n\n(class GamePadManager extends ProtoClass {\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"gamePadListener\", null)\n        {\n            const slot = this.newSlot(\"gamePadsMap\", null);\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"pollPeriod\", 1000);\n            slot.setComment(\"milliseconds\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setIsDebugging(false);\n        this.setGamePadsMap(new Map());\n        //this.startListening();\n        this.startPollingIfSupported(); // could delay this until connection if listen API is supported\n        return this;\n    }\n\n    connectedGamePads () {\n        return this.gamePadsMap().valuesArray();\n    }\n    \n    /*\n    canListenForConnect () {\n        return (\"ongamepadconnected\" in window); \n    }\n\n    startListening () {\n        if (this.canListenForConnect()) {\n            this.setGamePadListener(GamePadListener.clone().setUseCapture(true).setListenTarget(window).setDelegate(this))\n            this.gamePadListener().setIsListening(true)\n        }\n        return this\n    }\n    \n    // listener events\n\n    \n    onGamePadConnected (event) {\n        this.poll()\n        return true\n    }\n\n    onGamePadDisconnected (event) {\n        this.poll()\n        return true\n    }\n    */\n\n    startPollingIfSupported () {\n        if (this.isSupported()) {\n            this.startPolling();\n        }\n    }\n\n    isSupported () {\n        return this.navigatorGamepads() !== null;\n    }\n\n    navigatorGamepads () {\n        if (navigator.getGamepads) {\n            return navigator.getGamepads();\n        } \n        \n        if (navigator.webkitGetGamepads) {\n            return navigator.webkitGetGamepads;\n        }\n\n        return null\n    }\n\n    startPolling () {\n        if (!this._intervalId) {\n            console.log(this.type() + \".startPolling()\");\n            this._intervalId = setInterval(() => { \n                this.poll();\n            }, this.pollPeriod());\n        }\n    }\n\n    stopPolling () {\n        if (this.intervalId()) {\n            clearInterval(this.intervalId());\n            this.setIntervalId(null);\n        }\n    }\n\n    newGamePad (index) {\n        return GamePad.clone().setGamePadManager(this);\n    }\n\n    poll () {\n        const gamepads = this.navigatorGamepads();\n        //console.log(this.type() + \".poll() gamepads.length = \", gamepads.length);\n        const padsMap = this.gamePadsMap();\n\n        for (let i = 0; i < gamepads.length; i++) {\n            const gp = gamepads[i];\n            let gamePad = padsMap.get(i);\n\n            if (gp) {\n                if (!gamePad) {\n                    gamePad = this.newGamePad().setIndex(i).setId(gp.id);\n                    gamePad.onConnected();\n                    padsMap.set(i, gamePad);\n                }\n                gamePad.updateData(gp);\n\n                if (this.isDebugging()) {\n                    console.log(\"Gamepad index:\" + gp.index + \" id:\" + gp.id + \n                    \". buttonCount:\" + gp.buttons.length + \" axisCount:\" + gp.axes.length);\n                }\n            } else {\n                if (gamePad) {\n                    gamePad.onDisconnected();\n                    padsMap.set(i, null);\n                }\n            }\n        }\n    }\n\n}.initThisClass());",
  "DhGlQgPyjhNq6aYzddE60oQtziON+717X2ZOq8/6Fig=": "\"use strict\";\n\n/*\n    GamePad\n\n    A single GamePad with a unique id.\n\n*/\n\n(class GamePad extends Device {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"gamePadManager\", null);\n            slot.setSlotType(\"GamePadManager\");\n        }\n        {\n            const slot = this.newSlot(\"index\", null);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"id\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"timestamp\", null);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"buttons\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"axes\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"isConnected\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"shouldSendNotes\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setButtons([]);\n        this.setAxes([]);\n        this.setIsDebugging(false);\n        return this;\n    }\n\n    updateData (gp) {\n        assert(gp.id() === this.id()) // quick sanity check\n\n        if (gp.timestamp !== this.timestamp()) {\n            this.setTimestamp(gp.timestamp)\n            this.updateButtons(gp.buttons)\n            this.updateAxes(gp.axes)\n        }\n    }\n\n    // buttons\n\n    updateButtons (newButtons) {\n        // make sure number of buttons is correct\n        const currentButtons = this.buttons()\n        while (currentButtons.length < newButtons.length) {\n            currentButtons.push(0)\n        }\n\n        if (this.shouldSendNotes()) {\n            // check for differences\n            for (let i = 0; i < newButtons.length; i ++) {\n                if (currentButtons.at(i) !== newButtons.at(i)) {\n                    currentButtons.atPut(i, newButtons.at(i))\n                    this.changedButtonIndexTo(i, newButtons.at(i))\n                }\n            }\n        } else {\n            this.setButtons(newButtons.shallowCopy())\n        }\n\n        return this\n    }\n\n    changedButtonIndexTo (index, isDown) {\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadButton\" + index + (isDown ? \"Down\" : \"Up\")) // TODO: optimize\n        note.setInfo(isDown)\n        note.post()\n        return this\n    }\n\n    // axes\n\n    updateAxes (newAxes) {\n        // make sure number of buttons is correct\n        const currentAxes = this.axes()\n        while (currentAxes.length < newAxes.length) {\n            currentAxes.push(0)\n        }\n\n        if (this.shouldSendNotes()) {\n            // check for differences\n            for (let i = 0; i < newAxes.length; i ++) {\n                if (currentAxes.at(i) !== newAxes.at(i)) {\n                    currentAxes.atPut(i, newAxes.at(i))\n                    this.changedAxesIndexTo(i, newAxes[i])\n                }\n            }\n        } else {\n            this.setAxes(newAxes.copy())\n        }\n\n        return this\n    }\n\n    changedAxesIndexTo (index, value) {\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadAxis\" + index + \"Changed\") // TODO: optimize?\n        note.setInfo(value)\n        note.post()\n        return this\n    }\n\n    // connecting\n\n    onConnected () {\n        this.setIsConnected(true)\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadConnected\")\n        note.post()\n        return this\n    }\n\n    onDisconnected () {\n        this.setIsConnected(false)\n        const note = BMNotificationCenter.shared().newNote().setSender(this)\n        note.setName(\"onGamePadDisconnected\")\n        note.post()\n        return this\n    }\n\n}.initThisClass());\n",
  "LvKAVvvfDKguxC6eX4HDqZB29KqLtFsxpfyfocDfwaQ=": "\"use strict\";\n\n/*\n    Devices\n\n    Right now, this just sets up the standard devices. \n    Later, we can using it for \n        - discovering\n        - organizing\n        - inspecting\n        - managing\n        - globally intercepting & recording input for debugging or playback\n        etc.\n\n*/\n\n(class Devices extends ProtoClass {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"gamePadListener\", null);\n            slot.setSlotType(\"GamePadListener\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"keyboard\", null);\n            slot.setSlotType(\"BMKeyboard\");\n        }\n        {\n            const slot = this.newSlot(\"mouse\", null);\n            slot.setSlotType(\"Mouse\");\n        }\n        {\n            const slot = this.newSlot(\"touchScreen\", null);\n            slot.setSlotType(\"TouchScreen\");\n        }\n        {\n            const slot = this.newSlot(\"gamePadManager\", null);\n            slot.setSlotType(\"GamePadManager\");\n        }\n        {\n            const slot = this.newSlot(\"isSetup\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setupIfNeeded() \n        return this\n    }\n\n    setupIfNeeded () {\n        if (!this.isSetup()) {\n            Mouse.shared()\n            BMKeyboard.shared()\n            TouchScreen.shared()\n            //GamePadManager.shared()\n            this.setIsSetup(true)\n        }\n        return this\n    }\n\n    currentTouchOrMouseEvent () {\n        // needed?\n        const me = Mouse.shared().currentEvent()\n        const te = TouchScreen.shared().currentEvent()\n        const es = [me, te]\n        es.filter(e => !TypeError.isNullOrUndefined(e))\n        return es.min(e => e.timeStamp)\n    }\n    \n}.initThisClass());\n",
  "Lff3zdtLrLhi+5Of2sS3Fj/uUe54Vpk55rTKNxz2uLQ=": "\"use strict\";\n\n/*\n    EventManager\n\n    A singleton to manager tracking all events including:\n    \n        - user events\n        - timers\n        - other events (indexed db, etc) - eventually\n\n    We need this in other to:\n    \n        - do sync operators at the end of an event callback.\n\n        - track the first user initiated event in order to wait \n          to request things like audio input or audio output access\n\n    Example use:\n\n            EventManager.shared().safeWrapEvent(() => { ... }, event) // we pass in event so we can access it globally\n \n\n    Example of waiting on first user event:\n\n    await EventManager.shared().firstUserEventPromise();\n    \n*/\n\n(class EventManager extends ProtoClass {\n\n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"eventLevelCount\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"hasReceivedUserEvent\", false); // we only care about this for user events, but event manager handles timeouts too\n            slot.setSlotType(\"Boolean\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"beginUserEventDate\", null);\n            slot.setSlotType(\"Date\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"currentEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"firstUserEventPromise\", null);\n            slot.setSlotType(\"Promise\");\n            slot.setAllowsNullValue(true);\n        }\n    }\n\n    init () {\n        super.init();\n        this.setFirstUserEventPromise(Promise.clone());\n    }\n\n    currentEventName () {\n        const e = this.currentEvent();\n        if (e === null) {\n            return null;\n        } else if (Type.isString(e)) {\n            return e;\n        }\n        return e.constructor.name;\n    }\n\n    currentEventIsUserInput () {\n        const userEventNames = [\"KeyboardEvent\", \"MouseEvent\"];\n        return userEventNames.includes(this.currentEventName());\n    }\n\n    onReceivedUserEvent () { // sent by event listeners if event is user interaction (like click) that browser waits for to enable things like audio/video use\n        if (!this.hasReceivedUserEvent()) {\n            // In normal web use, things like WebAudio context can't be created until \n            // we get first user interaction. So we send this event to let listeners know when\n            // those APIs can be used. Would help if JS sent a special event for this.\n            this.setHasReceivedUserEvent(true)\n            Broadcaster.shared().broadcastNameAndArgument(\"firstUserEvent\", this) // need this for some JS APIs which can only be used after first input event\n            //this.postNoteNamed(\"onFirstUserEvent\") // we may only need one of these - added this to make it easier to listen for\n            this.firstUserEventPromise().callResolveFunc();\n        }\n        \n        return this\n    }\n\n    setEventLevelCount (n) {\n        assert(n > -1)\n        this._eventLevelCount = n\n        return this\n    }\n\n    incrementEventLevelCount () {\n        const count = this.eventLevelCount()\n        this.setEventLevelCount(count + 1)\n        //console.warn(\"<\".repeat(count) + \" incremented event \" + count)\n        return this\n    }\n\n    decrementEventLevelCount () {\n        const count = this.eventLevelCount()\n        //let stack = new Error().stack\n        //console.warn(\"<\".repeat(count) + \" decrementing event \" + count)\n        this.setEventLevelCount(count - 1)\n        return this\n    }\n    \n    /*\n    safeWrapEvent (callback, event) {\n        let result = undefined\n        this.incrementEventLevelCount()\n        try {\n            result = callback()\n            this.decrementEventLevelCount()\n        } catch (anError) {\n            console.error(anError.stack);\n            this.decrementEventLevelCount()\n            throw anError\n        } //finally {\n        //    this.decrementEventLevelCount()\n        //}\n        this.syncIfAppropriate() \n        return result\n    }\n    */\n\n    safeWrapEvent (callback, event) {\n        assert(event)\n        this.setCurrentEvent(event)\n        //ThrashDetector.shared().beginFrame()\n        //Perf.shared().beginFrame()\n        let result = undefined\n        let eventCountBefore = this.eventLevelCount()\n        this.incrementEventLevelCount()\n        //const t1 = Date.now()\n        result = callback()\n        /*\n        //const t2 = Date.now()\n        //const dt = (t2-t1)\n        if (dt) {\n            const m = \"\" + dt + \"ms\"\n            App.shared().mainWindow().setTitle(m)\n            console.log(m)\n        }\n        */\n\n        this.decrementEventLevelCount()\n        assert(this.eventLevelCount() === eventCountBefore)\n\n        this.syncIfAppropriate() // TODO: is this the best spot?\n        this.setCurrentEvent(null) // wait until after sync so our sync code can access the event\n        //Perf.shared().endFrame()\n        //ThrashDetector.shared().endFrame()\n        return result\n    }\n\n    syncIfAppropriate () {\n        \n        if (getGlobalThis().SyncScheduler) {\n            /*\n                run scheduled events here to ensure that a UI event won't occur\n                before sync as that could leave the node and view out of sync\n                e.g. \n                - edit view #1\n                - sync to node\n                - node posts didUpdateNode\n                - edit view #2\n                - view get didUpdateNode and does syncFromNode which overwrites view state #2\n            */\n\n            /*\n            if (SyncScheduler.shared().actionCount()) {\n                this.debugLog(\" onAfterEvent \" + methodName)\n            }\n            */\n           //assert(EventManager.shared().eventLevelCount() > 0)\n           if (EventManager.shared().eventLevelCount() === 0) { \n                // we check event level count to ensure that we only \n                // sync when the stack fully unwinds back to the event loop.\n                // This is not the case for some events like onblur which can be triggered by\n                // removing a DOM element from a parent, and start an event callback before the\n                // current event stack has unwound.\n                //console.log(\"--->>> fullSyncNow <<<---\")\n                SyncScheduler.shared().fullSyncNow()\n\n                /*\n                if (this.beginUserEventDate()) {\n                    const now = Date.now()\n                    const dt = now - this.beginUserEventDate()\n                    App.shared().mainWindow().setTitle(\"usr event dt:\" + (dt) + \"ms\")\n                }\n                this.setBeginUserEventDate(null)\n                */\n           }\n        }\n        return this\n    }\n\n}.initThisClass());\n",
  "EZW5x0bapo+qw1/HwZG57SN1AoN/uq3UeOZCof/L3O0=": "\"use strict\";\n\n/*\n    EventListener\n\n    Listener for single event. Should only be used by EventSetListener class.\n\n    For full list of events, see:\n\n    https://developer.mozilla.org/en-US/docs/Web/Events\n\n*/\n\nlet listenCount = 0;\n\n(class EventListener extends ProtoClass {\n\n    static initClass () {\n        this.newClassSlot(\"activeListeners\", new Set()) // tmp debugging\n    }\n\n    static activeListenersForOwner (owner) { // tmp debugging\n        return this.activeListeners().filter(v => v.owner() === owner)\n    }\n\n    static activeOwners () { // tmp debugging\n        const owners = new Set()\n        this.activeListeners().forEach(v => owners.add(v.owner()))\n        return owners\n    }\n\n    static showActive () { // tmp debugging\n        const owners = this.activeOwners()\n        console.log(\"--- EventListener \" + owners.size + \" active owners ---\")\n        /*\n        owners.forEach((owner) => {\n            const listeners = this.activeListenersForOwner(owner)\n\n            console.log(\"  \" + owner.typeId() + \": \" + listeners.length)\n            //this.showActiveForOwner(owner)\n        })\n        */\n        console.log(\"-------------------------------------\")\n    }\n\n    static showActiveForOwner (owner) { // tmp debugging\n        const listeners = this.activeListenersForOwner(owner)\n        listeners.forEach(listener => {\n            console.log(\"    \" + listener.delegate().typeId() + \" \" + listener.fullMethodName())\n        })\n    }\n\n    initPrototypeSlots () {\n        //this.newSlot(\"listenerSet\", null); // possible owner\n\n        {\n            const slot = this.newSlot(\"listenTarget\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"delegate\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"isListening\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"eventName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"methodName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"fullMethodName\", null); // calculated when methodName is set, and cached in ivar\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"handlerFunc\", null);\n            slot.setSlotType(\"Function\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"isUserInteraction\", null); // set to match eventName\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"useCapture\", false);\n            slot.setComment(\"whether event will be dispatched to listener before EventTarget beneath it in DOM tree\");\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"methodSuffix\", \"\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setHandlerFunc(event => this.safeHandleEvent(event))\n        //this.setHandlerFunc(event => this.handleEvent(event))\n        return this\n    }\n\n    // NOTE: atm, we leave restarting the event listeners up to the event set so we don't do extra restart\n\n    didUpdateSlotMethodName () {\n        this.clearFullMethodName()\n    }\n\n    didUpdateSlotMethodSuffix () {\n        this.clearFullMethodName()\n    }\n\n    didUpdateSlotUseCapture () {\n        this.clearFullMethodName()\n    }\n\n    setListenTarget (t) {\n        if (this.isListening()) {\n            assert(t)\n        }\n        this._listenTarget = t\n        return this\n    }\n\n    listenTargetDescription () {\n        return this.listenTarget().description()\n    }\n\n    // ---\n\n    clearFullMethodName () {\n        this.setFullMethodName(null)\n    }\n\n    calcFullMethodName () {\n        let suffix = \"\"\n\n        if (this.useCapture()) {\n            suffix = \"Capture\"\n        }\n\n        suffix += this.methodSuffix()\n        return this.methodName() + suffix\n    }\n\n    fullMethodName () {\n        if (!this._fullMethodName) {\n            this._fullMethodName = this.calcFullMethodName()\n        }\n        return this._fullMethodName\n    }\n\n    // ---------------------------------------------------------\n\n    setIsListening (aBool) {\n        if (aBool) {\n            this.start()\n        } else {\n            this.stop()\n        }\n        return this\n    }\n\n    assertHasListenTarget () {\n        assert(!Type.isNullOrUndefined(this.listenTarget()))\n    }\n\n    isValid () {\n        const hasListenTarget = !Type.isNullOrUndefined(this.listenTarget())\n        const hasEventName    = !Type.isNullOrUndefined(this.eventName())\n        const hasMethodName   = !Type.isNullOrUndefined(this.methodName())\n        return hasMethodName && hasEventName && hasListenTarget\n    }\n    \n    // listener key\n\n    listenerKey () {\n        let key = null\n        if (this.owner().node) {\n             key = this.owner().typeId() + \" \" + this.owner().node().title() + \" \" + this.delegate().typeId() + \" \" + this.fullMethodName()\n        } else {\n            key = this.owner().typeId() + \" \" + this.delegate().typeId() + \" \" + this.fullMethodName()\n        }\n        return key\n    }\n    \n    incrementListenCount () {\n        listenCount++\n        //EventListener.activeListeners().add(this)\n        //console.log(this.listenerKey() + \" START\")\n    }\n\n    decrementListenCount () {\n        listenCount--\n        //EventListener.activeListeners().delete(this)\n        //console.log(this.listenerKey() + \" STOP\")\n    }\n\n    // ---------------------------------------------------------\n\n    start () {\n        if (this.delegateCanRespond()) {\n            if (!this.isListening()) {\n                this.incrementListenCount()\n\n                this.debugLog(() => this.delegate().typeId() + \" will start listening for \" + this.eventName() + \" -> \" + this.methodName())\n                assert(this.isValid())\n                this._isListening = true; // can't use setter here as it would cause a loop\n                this.listenTarget().addEventListener(this.eventName(), this.handlerFunc(), this.useCapture());\n                /*\n                if (this.useCapture()) {\n                    debugger;\n                }\n                */\n            }\n        } else {\n            //console.log(this.delegate().debugTypeId() + \" doesn't respond to \" + this.fullMethodName() + \" so we won't listen for \" + this.eventName())\n            //debugger;\n        }\n        return this\n    }\n\n    owner () {\n        const d = this.delegate()\n        if (d.viewTarget) {\n            return d.viewTarget()\n        }\n        return d\n    }\n\n    ownerDescription () {\n        const d = this.delegate()\n        \n        if (d.viewTarget) {\n            //return d.viewTarget().debugTypeId() + \"->\" + d.type().before(\"GestureRecognizer\") \n            return d.viewTarget().typeId() + \" ->\" + d.type().before(\"GestureRecognizer\") \n        }\n\n        return d.typeId()\n    }\n\n    /*\n    descriptionForEvent (event) {\n        const e = event.currentTarget\n        let label = undefined\n        if (e.domView) {\n            label = e.domView().type()\n        } else {\n            label = e.constructor.name\n        }\n    }\n    */\n\n    safeHandleEvent (event) {\n        const result =  EventManager.shared().safeWrapEvent(() => {\n            //console.log(\"on event: \", this.listenerKey())\n\n            /*\n            //if (this.methodName() === \"onMouseDown\") {\n            if (this.fullMethodName() === \"onMouseDown\") {\n                console.log(\"on event: \", this.listenerKey())\n                //EventListener.showActive()\n                //MemoryUsage.shared().takeSnapshot()\n            }\n            */\n\n            return this.handleEvent(event)\n        }, event);\n        \n        return result\n    }\n\n    delegateCanRespond () {\n        if (Type.isNullOrUndefined(this.delegate())) {\n            return false\n        }\n        const method = this.delegate()[this.fullMethodName()]\n        const canRespond = Type.isFunction(method)\n        return canRespond\n    }\n\n    handleEvent (event) {\n        const fullMethodName = this.fullMethodName()\n\n        //event._isUserInteraction = this.isUserInteraction() // unused\n\n        const delegate = this.delegate()\n        const method = delegate[fullMethodName]\n\n\n        let result = true\n        if (method) {\n            this.onBeforeEvent(event)\n\n            result = method.call(delegate, event); \n\n            if (this.isDebugging()) {\n                console.log(\"sent: \" + delegate.type() + \".\" + fullMethodName, \"(\" + event.type + \") and returned \" + result)\n            }\n\n            if (result === false) {\n                event.stopPropagation()\n                if (event.cancelable) {\n                    event.preventDefault() // do we want this?\n                }\n            }\n\n            this.onAfterEvent(event)\n        } else {\n            if (this.isDebugging()) {\n                console.log(this.listenTargetDescription() + \" MISSING method: \" + delegate.type() + \".\" + fullMethodName, \"(\" + event.type + \")\" )\n            }\n        }\n\n        return result\n    }\n\n    onBeforeEvent (event) {\n        return this\n    }\n\n    onAfterEvent (event) {\n        if (this.isUserInteraction()) {\n            EventManager.shared().onReceivedUserEvent()\n        }\n        return this\n    }\n\n    stop () {\n        if (this.isListening()) {\n            this.assertHasListenTarget()\n\n            const t = this.listenTarget()\n\n            this.decrementListenCount()\n\n            //this.debugLog(() => this.delegate().typeId() + \" will stop listening for \" + this.methodName())\n            t.removeEventListener(this.eventName(), this.handlerFunc(), this.useCapture());\n            this._isListening = false; // can't use setter here as it would cause a loop\n        }\n\n        return this\n    }   \n\n}.initThisClass());\n\n",
  "njO3b0cIBYbMPjZZEA4wZgQ2fPakZcIkpdwQ/kVxz60=": "\"use strict\";\n\n/*\n    EventSetListener\n\n    Manages registering a DOM element for a set of events which will be sent to a delegate\n    using a (potentially different) method name. Subclasses override init to define the\n    event set by calling this.addEventNameAndMethodName(...) for each event.\n\n    Example use of:\n\n        const mouseListener = MouseListener.clone().setListenTarget(element).setDelegate(anObject)\n\n    will send onMouseDown(event), onMouseOver(event) etc to anObject when those events occur on the element.\n    \n    TODO: abstraction for eventsDict\n*/\n\n(class EventSetListener extends ProtoClass {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"listenTarget\", null) // DOM Element (EventTarget)\n            slot.setSlotType(\"Element\");\n        }\n        {\n            const slot = this.newSlot(\"delegate\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"isListening\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"useCapture\", false);\n            slot.setComment(\"whether event will be dispatched to listener before EventTarget beneath it in DOM tree\");\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"methodSuffix\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"listenersMap\", null) // Map of eventName -> EventListener entries\n            slot.setSlotType(\"Map\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setListenersMap(new Map());\n        this.setupListeners();\n        return this;\n    }\n\n    setupListeners () {\n        // subclasses override and set up event listeners by calling addEventNameAndMethodName()\n    }\n\n    /*\n    view () {\n        return this.listenTarget().domView()\n    }\n    */\n\n    allEventListeners () {\n        return this.listenersMap().valuesArray()\n    }\n\n    /* --- updates --- */\n\n    didUpdateSlotDelegate () {\n        this.resync()\n        return this\n    }\n\n    didUpdateSlotListenTarget () {\n        this.resync()\n        return this\n    }\n\n    didUpdateSlotUseCapture () {\n        this.resync()\n        return this\n    }\n\n    didUpdateSlotMethodSuffix () {\n        this.resync()\n        return this\n    }\n\n    resync () {\n        if (this.isListening()) {\n            console.warn(this.type() + \" resyncing while listening\")\n            debugger;\n            this.stop()\n            this.syncToListeners()\n            this.start()\n        } else {\n            this.syncToListeners()\n        }\n        return this\n    }\n\n    // --- listeners ---\n\n    newListener () {\n        const listener = EventListener.clone()\n        this.syncToListener(listener)\n        return listener\n    }\n\n    hasListenerForEventName (eventName) {\n        return this.listenersMap().has(eventName)\n    }\n\n    addEventNameAndMethodName (eventName, methodName, isUserInteraction) {\n        assert(!isUserInteraction)\n        assert(!this.isListening()) // TODO: handle this later\n        // TODO: make sure there's not already a listener for this eventName\n\n        assert(!this.hasListenerForEventName(eventName))\n\n        const listener = this.newListener()\n        listener.setEventName(eventName)\n        listener.setMethodName(methodName)\n        listener.setIsUserInteraction(isUserInteraction)\n        this.listenersMap().set(eventName, listener)\n        return listener\n    }\n\n    syncToListener (aListener) {\n        aListener.setListenTarget(this.listenTarget())\n        aListener.setDelegate(this.delegate())\n        aListener.setUseCapture(this.useCapture())\n        aListener.setIsDebugging(this.isDebugging())\n        return this\n    }\n\n    syncToListeners () {\n        this.forEachListener(listener => this.syncToListener(listener))\n        return this\n    }\n\n    forEachListener (fn) {\n        this.listenersMap().forEachV(listener => fn(listener))\n    }\n    // --- listening ---\n\n    setIsListening (aBool) {\n        if (aBool) {\n            this.start()\n        } else {\n            this.stop()\n        }\n        return this\n    }\n\n    start () {\n        if (!this.isListening()) {\n            this.syncToListeners()\n            this.forEachListener(listener => listener.start())\n            this._isListening = true; // can't use setter here as it would cause a loop\n        }\n        return this\n    }\n\n    stop () {\n        if (this.isListening()) {\n            this.forEachListener(listener => listener.stop())\n            this._isListening = false; // can't use setter here as it would cause a loop\n        }\n        return this\n    }   \n\n}.initThisClass());\n",
  "sC+EXCQcCQM16Lx97dQGINJSv9peIwpS5x3IKtUNU8E=": "\"use strict\";\n\n/*\n    AnimationListener\n\n    Listens to a set of animation events.\n\n    See: https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n\n    AnimationEvent contains \n    - animationName\n    - elapsedTime\n    - pseudoElement \n*/\n\n(class AnimationListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"animationend\", \"onAnimationEnd\");\n        this.addEventNameAndMethodName(\"animationiteration\", \"onAnimationIteration\");\n        this.addEventNameAndMethodName(\"animationstart\", \"onAnimationStart\");\n        this.addEventNameAndMethodName(\"animationcancel\", \"onAnimationCancel\");\n        return this\n    }\n\n}.initThisClass());\n",
  "lDxP+bQJHEtLtJ6wKa8QfmItto5tyBLnnMAQMIHjNsY=": "\"use strict\";\n\n/*\n    ClipboardListener\n\n    Listens to a set of clip board events.\n\n*/\n\n(class ClipboardListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"copy\", \"onCopy\");\n        this.addEventNameAndMethodName(\"cut\", \"onCut\");\n        this.addEventNameAndMethodName(\"paste\", \"onPaste\");\n        return this\n    }\n\n}.initThisClass());\n",
  "2pEA1RSdhyHObNd4XRRmS+X1X890u4DQZYjruvQ7BCg=": "\"use strict\";\n\n/*\n    DocumentListener\n\n    Listens to a set of document related events.\n\n*/\n\n(class DocumentListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // See: https://developer.chrome.com/blog/page-lifecycle-api/\n\n        this.addEventNameAndMethodName(\"visibilitychange\", \"onDocumentVisibilityChange\");\n\n        this.addEventNameAndMethodName(\"freeze\", \"onDocumentFreeze\"); // Document specific\n        this.addEventNameAndMethodName(\"resume\", \"onDocumentResume\"); // Document specific\n        this.addEventNameAndMethodName(\"fullscreenerror\", \"onDocumentFullScreenError\"); // Document specific\n\n        // See: DOMElement requestFullscreen method\n        //this.addEventNameAndMethodName(\"fullscreenchange\", \"onBrowserFullScreenChange\"); // Document specific\n        //this.addEventNameAndMethodName(\"fullscreenerror\", \"onBrowserFullScreenError\"); // Document specific\n\n        return this\n    }\n\n    listenTarget () {\n        return document // is this the best way to handle this?\n    }\n    \n}.initThisClass());\n",
  "+vsfS6Yx1psJvHGOngGLp3Lnt0KEJpVzYiMrvShXx7E=": "\"use strict\";\n\n/*\n    DragListener\n\n    Listens to a set of drag event on element being dragged.\n\n*/\n\n(class DragListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // fired on draggable element\n        this.addEventNameAndMethodName(\"dragstart\", \"onBrowserDragStart\");\n        this.addEventNameAndMethodName(\"drag\",      \"onBrowserDrag\");\n        this.addEventNameAndMethodName(\"dragend\",   \"onBrowserDragEnd\");\n        return this\n    }\n\n    start () {\n        super.start()\n        //this.listenTarget().ondragstart = (e) => { console.log(\"--- ondragstart ---\"); } // TODO: still needed?\n        return this\n    }\n    \n}.initThisClass());",
  "V05re0t2tOSwbq3W27Jb3GTHHs0yifX1xlgl32S40Ls=": "\"use strict\";\n\n/*\n    DropListener\n\n    Listens to a set of events on a drop target.\n\n*/\n\n(class DropListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // fired on drop target\n        this.addEventNameAndMethodName(\"dragover\",  \"onBrowserDragOver\"); // must prevent default\n        this.addEventNameAndMethodName(\"dragenter\", \"onBrowserDragEnter\"); // must prevent default\n        this.addEventNameAndMethodName(\"drop\",      \"onBrowserDrop\");\n        this.addEventNameAndMethodName(\"dragleave\", \"onBrowserDragLeave\");\n        return this\n    }\n\n    start () {\n        super.start()\n        //this.listenTarget().__isListeningForDrop___ = true\n        return this\n    }\n\n    stop () {\n        super.stop()\n        //this.listenTarget().__isListeningForDrop___ = false // breaks if multiple drop listeners on same element\n        return this\n    }\n\n    /*\n    onBeforeEvent (methodName, event) {\n        this.debugLog(() => { return \" onBeforeEvent \" + methodName })\n        return this\n    }\n    */\n    \n}.initThisClass());\n",
  "J5TSf3zQSNPJFigMlnUdvpUOmnNrPs7ncIUzypM+2Mg=": "\"use strict\";\n\n/*\n    FocusListener\n\n    Listens to a set of focus events.\n\n*/\n\n(class FocusListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"blur\", \"onBlur\");\n        this.addEventNameAndMethodName(\"focus\", \"onFocus\");\n        this.addEventNameAndMethodName(\"focusin\", \"onFocusIn\");\n        this.addEventNameAndMethodName(\"focusout\", \"onFocusOut\"); \n        return this\n    }\n\n}.initThisClass());\n",
  "j4+YwbxTshg1HO4hXNv7dYIJZEt/+cxWvrIR9w7Y514=": "\"use strict\";\n\n/*\n    KeyboardListener\n\n    Listens to a set of keyboard events.\n\n*/\n\n(class KeyboardListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"keyup\", \"onKeyUp\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"keydown\", \"onKeyDown\").setIsUserInteraction(true)\n        //this.addEventNameAndMethodName(\"keypress\", \"onKeyPress\"); // deprecated in modern browsers\n        //this.addEventNameAndMethodName(\"change\", \"onChange\");\n        this.addEventNameAndMethodName(\"input\", \"onInput\");\n        return this\n    }\n    \n}.initThisClass());\n",
  "nCiRl/WpJkhz+ezBS8JH22JmVQznzSh/lfqcSgFvtiA=": "\"use strict\";\n\n/*\n    MouseListener\n\n    Listens to a set of mouse events.\n\n*/\n\n\n(class MouseListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"mousedown\", \"onMouseDown\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"mouseup\",   \"onMouseUp\").setIsUserInteraction(true)\n\n        this.addEventNameAndMethodName(\"mouseover\",  \"onMouseOver\");  // triggered only when mouse enters element\n        this.addEventNameAndMethodName(\"mouseleave\", \"onMouseLeave\"); // triggered only when mouse exits element\n\n        //this.addEventNameAndMethodName(\"mousemove\", \"onMouseMove\");\n\n        // NOTE: don't see a good use case for these, so commenting out for now\n        //this.addEventNameAndMethodName(\"mouseout\",   \"onMouseOut\");   // triggered when mouse exits any child element        \n        //this.addEventNameAndMethodName(\"mouseenter\", \"onMouseEnter\"); // triggered when mouse enters any child element\n\n        this.addEventNameAndMethodName(\"click\",    \"onClick\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"dblclick\", \"onDoubleClick\").setIsUserInteraction(true) // is this valid?\n\n        this.addEventNameAndMethodName(\"contextmenu\", \"onContextMenu\"); // occurs on right mouse click on element\n        return this\n    }\n\n}.initThisClass());\n",
  "4oFKmNeurkdujMaid3f3wFeFrKelsyShold2eBh75Vw=": "\"use strict\";\n\n/*\n    MouseMoveListener\n\n    Listens to a set of mouse move events.\n    This is separated from MouseListener because move events happen at such a high rate,\n    that it's important for performance reasons to only listen for them when needed.\n\n*/\n\n\n(class MouseMoveListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"mousemove\", \"onMouseMove\");\n        return this\n    }\n\n}.initThisClass());\n",
  "nNasWeF78eUPOx41IdjP4mS9WILG0CESM4yu6lsFfDg=": "\"use strict\";\n\n/*\n    ScrollListener\n\n    Listens to scroll events.\n\n*/\n\n(class ScrollListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"scroll\",   \"onScroll\");\n        return this\n    }\n\n}.initThisClass());\n",
  "Rp/HZH75Svlyq8jVG/oC1o/PQtuXxbCBPKO6b1A80Fk=": "\"use strict\";\n\n/*\n    SelectListener\n\n    Listens to a set of select events on element.\n\n*/\n\n(class SelectListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init();\n        return this;\n    }\n\n    setListenTarget (anElement) {\n        // is event only works on document or window?\n        //assert(anElement === document || anElement === window)\n        super.setListenTarget(anElement);\n        return this;\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"selectstart\", \"onSelectStart\");\n        this.addEventNameAndMethodName(\"selectionchange\", \"onSelectionChange\"); // IMPORTANT: not widely supported\n        return this;\n    }\n    \n}.initThisClass());",
  "QkMl5UHtrH67ljvJNrpBO9YFKMyHK3jRBBbzid5qeBw=": "\"use strict\";\n\n/*\n    TouchListener\n\n    Listens to a set of touch events.\n\n*/\n \n(class TouchListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    } \n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"touchstart\",  \"onTouchStart\").setIsUserInteraction(true)\n        this.addEventNameAndMethodName(\"touchmove\",   \"onTouchMove\");\n        this.addEventNameAndMethodName(\"touchcancel\", \"onTouchCancel\");\n        this.addEventNameAndMethodName(\"touchend\",    \"onTouchEnd\");\n        return this\n    }\n\n}.initThisClass());\n",
  "1lacFMDblj5gYmswU8JSpama8sZ8y65faFmzn+DpNl8=": "\"use strict\";\n\n/*\n    TouchMoveListener\n\n    Listens to touch move events.\n    Seperated from TouchListeners for performance reasons.\n\n*/\n \n(class TouchMoveListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        return this\n    } \n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"touchmove\",   \"onTouchMove\");\n        return this\n    }\n\n}.initThisClass());\n",
  "tther27vU5F/ty/cnQvTnVugMAp+FBxA6ZuKm+vG6JE=": "\"use strict\";\n\n/*\n    TransitionListener\n\n    Listens to a set of animation transition events.\n\n*/\n\n(class TransitionListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"transitionrun\", \"onTransitionRun\");\n        this.addEventNameAndMethodName(\"transitionstart\", \"onTransitionStart\");\n        this.addEventNameAndMethodName(\"transitioncancel\", \"onTransitionCancel\");\n        this.addEventNameAndMethodName(\"transitionend\", \"onTransitionEnd\");\n        return this\n    }\n    \n}.initThisClass());\n",
  "8sOb0G6/ElhKNXz95Aa5NVuLg7oAwzkQBhUnQaXYL8k=": "\"use strict\";\n\n/*\n    GamePadListener\n\n    Listens to a set of mouse events.\n\n*/\n\n(class GamePadListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"gamepadconnected\",   \"onGamePadConnected\");\n        this.addEventNameAndMethodName(\"gamepaddisconnected\", \"onGamePadDisconnected\");\n        return this\n    }\n\n}.initThisClass());\n\n",
  "TP/WPmAaK7I8RgyLI0p4DwSyzHYB3ltHkoWOJmT2v6Q=": "\"use strict\";\n\n/*\n    WebSocketListener\n\n    Listens to a set of web socket events.\n\n    NOTES:\n    \n    MessageEvent contains:\n    - data\n    - origin\n    - lastEventId \n    - source \n    - ports\n*/\n\n(class WebSocketListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"open\", \"onOpen\");\n        this.addEventNameAndMethodName(\"close\", \"onClose\");\n        this.addEventNameAndMethodName(\"error\", \"onError\");\n        this.addEventNameAndMethodName(\"message\", \"onMessage\");\n        return this\n    }\n\n}.initThisClass());\n",
  "aC1GashxiJd1idAK9PoalDAbKkouIqa8B5tZyedi5Mk=": "\"use strict\";\n\n/*\n    WheelListener\n\n    Listens to a set of wheel (mouse or other wheel) events.\n\n*/\n\n(class WheelListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"wheel\",   \"onWheel\");\n        return this\n    }\n\n}.initThisClass());\n",
  "pH0BG80wv4iRX1RyG4zOskFGqxrLnuPibPW1AhQHZRo=": "\"use strict\";\n\n/*\n    WindowListener\n\n    Listens to a set of Window related events.\n\n    NOTE: the target of the event is the browser window and not a DOM element.\n\n*/\n\n(class WindowListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n\n    setupListeners () {\n        // See: https://developer.chrome.com/blog/page-lifecycle-api/\n\n        // window events\n        this.addEventNameAndMethodName(\"resize\", \"onWindowResize\"); // Document specific\n\n        this.addEventNameAndMethodName(\"pageshow\", \"onPageShow\"); // Window specific\n        this.addEventNameAndMethodName(\"pagehide\", \"onPageHide\"); // Window specific\n\n        this.addEventNameAndMethodName(\"beforeunload\", \"onDocumentBeforeUnload\"); // Window specific?\n        this.addEventNameAndMethodName(\"unload\", \"onDocumentUnload\"); // Window specific?\n\n        this.addEventNameAndMethodName(\"submit\", \"onFormSubmit\"); // FormElement specific\n\n        this.addEventNameAndMethodName(\"online\", \"onBrowserOnline\"); // Window specific\n        this.addEventNameAndMethodName(\"offline\", \"onBrowserOffline\"); // Window specific\n\n        //this.addEventNameAndMethodName(\"error\", \"onBrowserResourceLoadError\");\n\n        return this\n    }\n\n    listenTarget () {\n        return window // we need to target the window and not the element asssociated with a View\n    }\n    \n}.initThisClass());\n",
  "0D/YlTm9Bv2NJShpi0tHjr8hS/Rgnpx+819jA3eakWY=": "\"use strict\";\n\n/*\n    SpeechListener\n\n    Listens to events on a SpeechSynthesisUtterance instance.\n\n*/\n\n(class SpeechListener extends EventSetListener {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setIsDebugging(false)\n        return this\n    }\n\n    setupListeners () {\n        this.addEventNameAndMethodName(\"boundary\", \"onBoundary\");\n        this.addEventNameAndMethodName(\"end\", \"onEnd\");\n        this.addEventNameAndMethodName(\"error\", \"onError\");\n        this.addEventNameAndMethodName(\"mark\", \"onMark\");\n        this.addEventNameAndMethodName(\"pause\", \"onPause\");\n        this.addEventNameAndMethodName(\"resume\", \"onResume\");\n        this.addEventNameAndMethodName(\"start\", \"onStart\");\n        return this\n    }\n\n}.initThisClass());\n",
  "mlsSuGVKV31TVC9N8wsoVWhbfIC58tDlObC0fNprv+M=": "\"use strict\";\n\n/*\n    GestureManager\n\n    We typically only want one gesture to be active globally.\n    GestureManager helps to coordinate which gesture has control.\n\n    To pause all gestures:\n    \n        GestureManager.shared().pause()\n        GestureManager.shared().unpause()\n    \n    or:\n\n        GestureManager.shared().setIsPaused(aBool)\n\n    NOTES:\n\n    If a decendant view requests control, it can steal it.\n\n*/\n\n(class GestureManager extends ProtoClass {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"activeGesture\", null); // aGesture\n            slot.setSlotType(\"Gesture\");\n        }\n        {\n            const slot = this.newSlot(\"begunGesturesMap\", null) \n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"isPaused\", false); // used to pause gestures while editing text fields\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setBegunGesturesMap(new Map());\n        return this;\n    }\n\n    hasActiveGesture () {\n        return this.activeGesture() && this.activeGesture().isActive();\n    }\n\n    pause () {\n        this.setIsPaused(true);\n        return this;\n    }\n\n    unpause () {\n        this.setIsPaused(false);\n        return this;\n    }\n\n    setIsPaused (aBool) {\n        if (this._isPaused !== aBool) {\n            this._isPaused = aBool;\n\n            this.debugLog(this.type() + \".setIsPaused(\" + aBool + \")\");\n\n            if (aBool) {\n                this.cancelAllGestures();\n            }\n        }\n        return this;\n    }\n\n    cancelAllGestures () {\n        this.cancelAllBegunGestures();\n        const ag = this.activeGesture();\n        if (ag) {\n            ag.cancel();\n        }\n    }\n\n    requestActiveGesture (aGesture) { // sent by gestures themselves\n        this.debugLog(\"requestActiveGesture(\" + aGesture.description() + \")\");\n\n        if (this.isPaused()) {\n            return false;\n        }\n\n        assert(aGesture)\n        const ag = this.activeGesture();\n\n        if (!ag) {\n            this.acceptGesture(aGesture);\n            return true;\n        }\n\n        //this.releaseActiveGestureIfInactive()\n        if (aGesture === ag) { // error\n            console.warn(\"request to activate an already active gesture \", aGesture.description());\n            return false;\n        }\n\n        // see if active gesture has lower priority\n        if (ag) {\n            // allow child views to steal the active gesture\n            const childViewIsRequesting = ag.viewTarget().hasSubviewDescendant(aGesture.viewTarget());\n            if (childViewIsRequesting) {\n                this.acceptGesture(aGesture);\n                return true;\n            }\n        }\n\n\n        // already have active gesture, so reject this request\n        this.rejectGesture(aGesture);\n        return false;\n    }\n\n    acceptGesture (aGesture) { // private method\n        aGesture.viewTarget().cancelAllGesturesExcept(aGesture);\n        this.cancelBegunGesturesExcept(aGesture);\n        this.setActiveGesture(aGesture);\n        this.debugLog(\"acceptGesture(\" + aGesture.description() + \")\");\n        return this;\n    }\n\n    rejectGesture (aGesture) { // private method\n        this.debugLog(\"rejectGesture(\" + aGesture.description() + \")\");\n        this.debugLog(\"already active \" + this.activeGesture().description());\n        return this;\n    }\n\n    deactivateGesture (aGesture) {\n        if (this.activeGesture() === aGesture) {\n            this.setActiveGesture(null);\n        }\n        return this;\n    }\n\n    addBegunGesture (aGesture) {\n        this.begunGesturesMap().set(aGesture.typeId(), aGesture);\n        return this;\n    }\n\n    removeBegunGesture (aGesture) {\n        this.begunGesturesMap().delete(aGesture.typeId());\n        return this;\n    }\n\n    cancelAllBegunGestures () {\n        this.begunGesturesMap().forEachV(g => g.requestCancel());\n        return this;\n    }\n\n    cancelBegunGesturesExcept (aGesture) {\n        this.begunGesturesMap().forEachV(g => {\n            if (g !== aGesture) {\n                g.requestCancel();\n            }\n        });\n        return this;\n    }\n\n    debugTypeId () {\n        const s = this.isPaused() ? \"(paused)\" : \"(not paused)\";\n        return super.debugTypeId() + s;\n    }\n    \n}.initThisClass());\n",
  "y5j/D9CXmDBi+nPy2U0zr2BCfSL6xNZgcThu/yofy8U=": "\"use strict\";\n\n/*\n    GestureRecognizer\n\n    This class:\n     - listens for events \n     - uses logic to detect gestures\n     - coordinates which gestures are active with a GestureManager\n     - sends delegate messages for gesture state changes\n    \n    This class supports general gesture logic & helper methods\n    and is intended to be sublclassed to implement particular gesture types. \n    See SlideGestureRecognizer, for an example subclass.\n\n    Event Listeners\n\n    Listeners are typically on a particular view's element. \n    document.body listeners are usually added once the gesture has begun, \n    in order to track events outside the element. \n    The document listeners are then removed once the gesture has ended or cancelled.\n\n    Delegate Messages\n\n    State change delegate messages are sent to the viewTarget. These are typically:\n    \n        accepts<GestureType>(aGesture)\n        on<GestureType>Begin(aGesture)\n        on<GestureType>Move(aGesture)\n        on<GestureType>End(aGesture)\n        on<GestureType>Cancel(aGesture)\n\n    Simulating Touches with the Mouse\n\n    Holding the SHIFT key and click-dragging the mouse can be used to simulate 2 finger \n    gestures on non-touch devices.\n\n    State to track event semantics:\n\n        downEvent - set onDownEvent *if* number of touchs is in correct range\n        beginEvent - set when sending begin message - typically in onMove: \n        activePoints() - returns downEvent points for fingers contained in currentEvent\n        upEvent - usually set on complete, not used much yet\n\n    NOTES\n\n    Browsers may implement their own touch gestures. To prevent these from \n    interfering with our own, be sure to call:\n\n        aView.setTouchAction(\"none\")\n\n    On related views (or probably all views, to be safe) or set these in the CSS e.g.\n\n        html * { touch-action: none; }\n\n    TODO: \n    \n    - rename methods to clearly identify Doc and View related methods\n    - move visualizer to separate class?\n\n    QUESTIONS:\n    If a view has the active gesture control, and a decendent view requests becoming the active\n    gesture, the GestureManager will detect this and let the child steal control.\n    \n*/\n\n(class GestureRecognizer extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"viewTarget\", null);\n            slot.setSlotType(\"DomeView\");\n        }\n        {\n            const slot = this.newSlot(\"shouldRemoveOnComplete\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        // listener classes\n\n        {\n            const slot = this.newSlot(\"listenerClasses\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"moveListenerClasses\", [\"MouseMoveListener\", \"TouchMoveListener\"]);\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"defaultListenerClasses\", [\"MouseListener\", \"TouchListener\"]);\n            slot.setSlotType(\"Array\");\n        }\n\n        // listeners\n\n        {\n            const slot = this.newSlot(\"viewListeners\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"docListeners\", null);\n            slot.setSlotType(\"Array\");\n        }\n\n        // move listeners\n\n        {\n            const slot = this.newSlot(\"viewMoveListeners\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"docMoveListeners\", null);\n            slot.setSlotType(\"Array\");\n        }\n\n        // events\n\n        {\n            const slot = this.newSlot(\"overEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"leaveEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"didBegin\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"downEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"beginEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"currentEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"lastEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n        {\n            const slot = this.newSlot(\"upEvent\", null);\n            slot.setSlotType(\"Event\");\n        }\n\n        // standard messages\n\n        {\n            const slot = this.newSlot(\"gestureName\", null); // sets <GestureType> name used for messages\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"acceptMessage\", null);  //\"accepts<GestureType>\"\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"beginMessage\", null); //\"on<GestureType>Begin\",\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"moveMessage\", null); //\"on<GestureType>Move\",\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"requestCancelMessage\", null); // \"on<GestureType>RequestCancel\"\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"cancelledMessage\", null); // \"on<GestureType>Cancelled\",\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"completeMessage\", null); // \"on<GestureType>Complete\",\n            slot.setSlotType(\"String\");\n        }\n        \n        // debugging\n\n        {\n            const slot = this.newSlot(\"isEmulatingTouch\", false); // assumes touch and mouse events aren't mixed\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isVisualDebugging\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"fingerViewMap\", null);\n            slot.setSlotType(\"Map\");\n        }\n\n        // begin pressing \n\n        {\n            const slot = this.newSlot(\"isPressing\", false);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"minFingersRequired\", 2);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"maxFingersAllowed\", 4);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"minDistToBegin\", 10);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"allowsKeyboardKeys\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"requiresKeyboardKeys\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"shouldRequestActivation\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"shouldAcceptCancelRequest\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isActive\", false); // only used if shouldRequestActivation === false\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses([]) // subclasses override this in their\n\n        this.setViewListeners([])\n        this.setDocListeners([])\n\n        this.setViewMoveListeners([])\n        this.setDocMoveListeners([])\n\n        //this.setGestureName(this.type().before(\"GestureRecognizer\"))\n        this.autoSetMessageNames()\n        this.setIsEmulatingTouch(true)\n        this.setFingerViewMap(new Map())\n\n        this.setIsDebugging(false)\n        //this.setIsVisualDebugging(true)\n        return this\n    }\n\n \n    // -- event helpers --\n\n    clearEvents () {\n        this.setDownEvent(null);\n        this.setBeginEvent(null);\n        this.setCurrentEvent(null);\n        return this;\n    }\n    \n    setCurrentEvent (event) {\n        if (this._currentEvent !== event) {\n            this.setLastEvent(this._currentEvent);\n            this._currentEvent = event;\n        }\n        return this;\n    }\n\n    currentPosition () {\n        return this.pointsForEvent(this.currentEvent()).first();\n    }\n\n    downPosition () {\n        return this.pointsForEvent(this.downEvent()).first();\n    }\n\n    beginPosition () {\n        return this.pointsForEvent(this.beginEvent()).first();\n    }\n\n    upPosition () {\n        return this.pointsForEvent(this.upEvent()).first();\n    }\n\n    numberOfFingersDown () {\n        const points = this.pointsForEvent(this.currentEvent());\n        return points.length;\n    }\n\n    currentEventIsOnTargetView () {\n        const points = this.pointsForEvent(this.currentEvent())\n        const p = points.first()\n        const view = this.viewTarget()\n        return view.containsPoint(p)\n        //return points.canDetect(p1 => !view.containsPoint(p1))\n    }\n\n    // --- listener classes ---\n\n    setListenerClasses (classNames) {\n        this._listenerClasses = classNames\n        this.filterListenerClassesForTouch()\n        return this\n    }\n\n    filterListenerClassesForTouch () {\n        // if we don't have a touch screen, avoid registering for touch events\n        if (!TouchScreen.shared().isSupported()) {\n            const results = this.listenerClasses().filter(name => !name.beginsWith(\"Touch\"))\n            this._listenerClasses = results\n        }\n    }\n\n    // --- new listeners ---\n\n    newListenersForClasses (classesArray) {\n        return classesArray.map((className) => {\n            const proto = Object.getClassNamed(className);\n            const listener = proto.clone();\n            listener.setDelegate(this);\n            return listener\n        })\n    }\n\n    startNewViewListenersForClasses (classesArray) {\n        const listeners = this.newListenersForClasses(classesArray)\n        listeners.forEach(listener => {\n            listener.setListenTarget(this.viewTarget().element())\n            listener.setIsDebugging(this.isDebugging())\n            listener.start()\n        })\n        return listeners\n    }\n    \n    startNewDocListenersForClasses (classesArray) {\n        const listeners = this.newListenersForClasses(classesArray)\n        listeners.forEach(listener => {\n            listener.setUseCapture(true)\n            listener.setListenTarget(window)\n            listener.setIsDebugging(this.isDebugging())\n            listener.start()\n        })\n        return listeners\n    }\n\n    // --- view listeners ---\n\n    startViewListeners () {\n        //debugger;\n        this.stopViewListeners()\n        this.setViewListeners(this.startNewViewListenersForClasses(this.listenerClasses()))\n        return this\n    }\n\n    stopViewListeners () {\n        this.viewListeners().forEach(listener => listener.stop())\n        this.viewListeners().clear()\n        return this\n    }\n\n    // --- doc listeners ---\n\n    startDocListeners () {\n        this.stopDocListeners()\n        this.setDocListeners(this.startNewDocListenersForClasses(this.listenerClasses()))\n        return this\n    }\n\n    stopDocListeners () {\n        this.docListeners().forEach(listener => listener.stop())\n        this.docListeners().clear()\n        return this\n    }\n\n    // -- special case for mouse and touch move events ---\n\n    didUpdateSlotIsPressing (oldValue, newValue) {\n        if (newValue === true) {\n            this.startViewMoveListeners()\n            this.startDocMoveListeners() // is this correct?\n        } else {\n            this.stopViewMoveListeners()\n            this.stopDocMoveListeners() // is this correct?\n        }\n    }\n\n    // --- view move listeners ---\n\n    newMoveListeners () {\n        return this.listenersForClasses(this.moveListenerClasses())\n    }\n\n    stopViewMoveListeners () {\n        this.viewMoveListeners().forEach(listener => listener.stop())\n        this.viewMoveListeners().clear()\n        return this\n    }\n\n    startViewMoveListeners () {\n        //debugger;\n        this.stopViewMoveListeners()\n        this.setViewMoveListeners(this.startNewViewListenersForClasses(this.moveListenerClasses()))\n        return this\n    }\n\n    // --- doc move listeners ---\n\n    stopDocMoveListeners () {\n        this.docMoveListeners().forEach(listener => listener.stop())\n        this.docMoveListeners().clear()\n        return this\n    }\n\n    startDocMoveListeners () {\n        this.stopDocMoveListeners()\n        this.setDocMoveListeners(this.startNewDocListenersForClasses(this.moveListenerClasses()))\n        return this\n    }\n\n    // ---------------------\n\n    // condition helpers\n\n    hasMovedEnough () {\n        // intended to be overridden by subclasses\n        // e.g. a rotation recognizer might look at how much first two fingers have rotated\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        return d >= m\n    }\n\n    hasAcceptableFingerCount () {\n        const n = this.numberOfFingersDown()\n        return  n >= this.minFingersRequired() &&\n                n <= this.maxFingersAllowed();\n    }\n\n    hasAcceptableKeyboardState () {\n        if (!this.allowsKeyboardKeys()) {\n            if (BMKeyboard.shared().hasKeysDown()) {\n                // make exception for shift key since we use it to emulate multi-touch\n                if (BMKeyboard.shared().shiftKey().isOnlyKeyDown()) {\n                    return true\n                }\n                return false\n            }\n        }\n        return true\n    }\n\n    canBegin () {\n        return !this.isActive() && \n                this.hasMovedEnough() && \n                this.hasAcceptableFingerCount() &&\n                this.hasAcceptableKeyboardState();\n    }\n\n    // --- start / stop ---\n\n    start () {\n        this.startViewListeners()\n        // We typically don't want to listen to document level events all the time.\n        // Instead, some view events will start and stop the doc listeners.\n        //this.startViewMoveListeners() \n        return this\n    }\n\n    stop () {\n        this.stopViewListeners()\n        this.stopDocListeners()\n        this.stopViewMoveListeners() // is this correct?\n        this.stopDocMoveListeners() // is this correct?\n        return this\n    }\n\n    allEventListeners () {\n        const sets = [this.viewListeners(), this.docListeners(), this.viewMoveListeners(), this.docMoveListeners()].flat()\n        return sets.map(eventListenerSet => eventListenerSet.allEventListeners()).flat()\n    }\n\n    // active\n\n    requestActivationIfNeeded () {\n        if (this.shouldRequestActivation()) {\n            return GestureManager.shared().requestActiveGesture(this);\n        }\n        this.setIsActive(true)\n        return true\n    }\n\n    isActive () {\n        if (this.shouldRequestActivation()) {\n            return GestureManager.shared().activeGesture() === this\n        }\n        return this._isActive\n    }\n\n    deactivate () {\n        if (this.shouldRequestActivation()) {\n            GestureManager.shared().deactivateGesture(this);\n        }\n        this.setIsActive(false)\n        return this\n    }\n\n    // finish\n\n    didFinish () {\n        this.setDidBegin(false)\n        GestureManager.shared().removeBegunGesture(this)\n\n        // why do we do this with a delay?\n        // is it needed now to prevent a move\n        this.addTimeout(() => { \n            GestureManager.shared().removeBegunGesture(this)\n            this.deactivate();\n        }, 0)\n\n        if (this.shouldRemoveOnComplete() && this.viewTarget()) {\n            this.stop()\n            this.viewTarget().removeGestureRecognizer(this)\n        }\n\n        this.removeFingerViews()\n        return this\n    }\n\n    // subclass helpers\n\n    sendDelegateMessage (methodName, argument) {\n        let result = undefined\n        assert(methodName !== null)\n        const vt = this.viewTarget()\n\n        if (this.isDebugging()) {\n            console.log(this.shortTypeId() + \" sending \" + methodName + \" to \" + vt.typeId())\n        }\n\n        //try {\n        if (vt) {\n            if (vt[methodName]) {\n                result = vt[methodName].call(vt, this, argument)\n            } else {\n                if (this.isDebugging()) {\n                    console.log(\"gesture delegate missing method \" + methodName)\n                }\n                result = false\n            }\n        }\n        /*\n        } catch(e) {\n            console.error(this.typeId() + \".sendDelegateMessage(\" + methodName + \") caught exception \", e.stack)\n            result = false\n            //this.cancel() // how to do this without potentially cause a loop?\n            e.rethrow();\n        }\n        */\n\n        return result\n    }\n\n    // points helper\n    // maps mouse and touch events to a common list of points (with times and ids) format\n    // so we can share the event handling code for both devices \n\n    pointsForEvent (event) {\n        if (Type.isNullOrUndefined(event)) {\n            throw new Error(this.type() + \".pointsForEvent(event) event is missing\")\n        }\n\n        const eventClass = event.__proto__.constructor;\n\n        if (eventClass === MouseEvent) {\n            //this.debugLog(\" got mouse\")\n            return Mouse.shared().pointsForEvent(event)\n        } else if (eventClass === TouchEvent) {   \n            //this.debugLog(\" got touch\")\n            return TouchScreen.shared().pointsForEvent(event)\n        }\n        \n        console.warn(this.type() + \" can't handle this event type yet: \", event)\n\n        return []\n    }\n\n    // all events hook\n\n    onEvent (event) {\n        if (this.isVisualDebugging()) {\n            this.updateOutlineView()\n            this.updateFingerViews()\n            //this.updateDebugTimer()\n        }\n    }\n\n    // --- events ---\n\n    onOver (event) {\n        this.setOverEvent(event)\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    onDown (event) {\n        this.setDownEvent(event)\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    onMove (event) {\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    onUp (event) {\n        this.setUpEvent(event)\n        //this.setCurrentEvent(event) // on Windows, the up event may not have any positions\n        this.onEvent(event)\n    }\n\n    onLeave (event) {\n        this.setLeaveEvent(event)\n        this.setCurrentEvent(event)\n        this.onEvent(event)\n    }\n\n    // --- mouse events ---\n\n    shouldEmulateEvent (event) {\n        return this.isEmulatingTouch() && \n                event.shiftKey && \n                event.__proto__.constructor === MouseEvent &&\n                this.pointsForEvent(event).length === 1;\n    }\n\n    emulateDownIfNeeded (event) {\n        const p1 = this.pointsForEvent(event).first()\n\n        if (this.shouldEmulateEvent(event)) {\n            // make a duplicate of the down event point with a different id\n            const p2 = p1.copy().setId(\"emulatedTouch\")\n            p2.setX(p2.x() + 10)\n            p2.setY(p2.y() + 10)\n            event.pushCachedPoint(p2)\n        }\n        return this\n    }\n\n    onMouseDown (event) {      \n        //debugger;  \n        this.emulateDownIfNeeded(event)\n        this.setDownEvent(event)\n        this.onDown(event)\n    }\n\n    emulateMoveIfNeeded (event) {\n        const p2 = this.pointsForEvent(event).first()\n\n        if (this.shouldEmulateEvent(event) && this.downEvent()) {      \n            // get down point and current point and add an emulated point on the other side\n            const p1 = this.pointsForEvent(this.downEvent()).first()\n            const v = p2.subtract(p1).negated()\n            const emulatedPoint = p1.add(v).setId(\"emulatedTouch\")\n            event.pushCachedPoint(emulatedPoint)\n        }\n\n        return this\n    }\n\n    onMouseMove (event) {\n        this.emulateMoveIfNeeded(event)\n        this.onMove(event)\n    }\n\n    onMouseUp (event) {\n        this.onUp(event)\n    }\n\n    onMouseLeave (event) {\n        this.onLeave(event)\n    }\n\n    // mouse capture events\n\n    onMouseOverCapture (event) {\n        this.onOver(event)\n    }\n\n    onMouseDownCapture (event) {\n        this.emulateDownIfNeeded(event)\n        this.onDown(event)\n    }\n\n    onMouseMoveCapture (event) {\n        this.emulateMoveIfNeeded(event)\n        this.onMove(event)\n    }\n\n    onMouseUpCapture (event) {\n        this.onUp(event)\n    }\n\n    onMouseLeaveCapture (event) {\n        this.onLeave(event)\n    }\n\n    // touch events\n\n    onTouchStart (event) {\n        this.onDown(event)\n    }\n\n    onTouchMove (event) {\n        this.onMove(event)\n    }\n\n    onTouchEnd (event) {\n        this.onUp(event)\n    }\n\n    onTouchCancel (event) { \n        //this.onUp(event)\n        this.cancel()\n    }\n    \n    // touch capture events\n\n    onTouchStartCapture (event) {\n        this.onDown(event)\n    }\n\n    onTouchMoveCapture (event) {\n        this.onMove(event)\n    }\n\n    onTouchEndCapture (event) {\n        this.onUp(event)\n    }\n\n    onTouchCancelCapture (event) {\n        //this.onUp(event)\n        this.cancel()\n    }\n\n    // diff position helper\n\n    diffPos () {\n        return this.currentPosition().subtract(this.beginPosition()).floorInPlace() // floor here?\n    }\n\n    distance () {\n        const dp = this.diffPos()\n        const dx = Math.abs(dp.x())\n        const dy = Math.abs(dp.y())\n        const funcs = {\n            left: (dx, dy) => dx,\n            right: (dx, dy) => dx,\n            up: (dx, dy) => dy,\n            down: (dx, dy) => dy,\n            x: (dx, dy) => dx,\n            y: (dx, dy) => dy\n        }\n        return funcs[this.direction()](dx, dy)\n    }\n\n    setGestureName (aName) {\n        this._gestureName = aName\n        this.autoSetMessageNames()\n        return this\n    }\n\n    gestureName () {\n        if (this._gestureName) {\n            return this._gestureName\n        }\n        return this.type().before(\"GestureRecognizer\")\n    }\n\n    defaultMessageForState (state) {\n        return \"on\" + this.gestureName() + state.capitalized()\n    }\n\n    autoSetMessageNames () {\n        this.setAcceptMessage(\"accepts\" + this.gestureName())\n        this.setBeginMessage(this.defaultMessageForState(\"Begin\"))\n        this.setMoveMessage(this.defaultMessageForState(\"Move\"))\n        this.setRequestCancelMessage(\"on\" + this.gestureName() + \"RequestCancel\")\n        this.setCancelledMessage(this.defaultMessageForState(\"Cancelled\"))\n        this.setCompleteMessage(this.defaultMessageForState(\"Complete\"))\n        return this\n    }\n\n    // sending delegate messages\n\n    doesTargetAccept () {\n\n        // see if view accepts the gesture before we begin\n        // for now, assume it accepts if it doesn't implement the accept<GestureType> method\n        const vt = this.viewTarget()\n        if (vt[this.acceptMessage()]) {\n            if (!this.sendDelegateMessage(this.acceptMessage())) {\n                this.cancel()\n                return false\n            }\n        }\n\n        return true\n    }\n\n    sendBeginMessage () {\n        if (!this.doesTargetAccept()) {\n            return this\n        }\n        \n        this.setDidBegin(true)\n        this.setBeginEvent(this.currentEvent())\n        this.sendDelegateMessage(this.beginMessage())\n        GestureManager.shared().addBegunGesture(this)\n        return this\n    }\n\n    sendMoveMessage () {\n        this.sendDelegateMessage(this.moveMessage())\n        //this.didMove()\n        return this\n    }\n\n    sendCompleteMessage () {\n        this.sendDelegateMessage(this.completeMessage())\n        this.didFinish()\n        return this\n    }\n\n    sendCancelledMessage () {\n        this.sendDelegateMessage(this.cancelledMessage())\n        this.didFinish()\n        return this\n    }\n\n    requestCancel (byGesture) {\n        if (this.shouldAcceptCancelRequest()) {\n            this.cancel()\n        }\n        /*\n        const shouldCancel = this.sendDelegateMessage(this.requestCancelMessage(), byGesture)\n        //console.log(\"this.requestCancelMessage() =================== \", this.requestCancelMessage(), \" -> \", shouldCancel)\n        if (shouldCancel || Type.isUndefined(shouldCancel)) { \n            this.cancel()\n        }\n        */\n    }\n\n    cancel () {\n        this.debugLog(\" cancel\")\n        //this.willCancel()\n        this.sendCancelledMessage()\n        //this.didCancel()\n    }\n\n    /*\\\n    willCancel () {\n\n    }\n\n    didCancel () {\n        //this.didFinish()\n    }\n    */\n\n    // ---\n\n    cleanup () {\n        this.setDownEvent(null)\n        this.setCurrentEvent(null)\n        this.setUpEvent(null)\n        return this\n    }\n\n    shouldShowVisualDebugger () {\n        return this.hasDownPointsInView() || this.isActive() // || this.isPressing());\n    }\n\n    // ---  outline view for debugging ---\n\n    newOutlineView () {\n        const v = DomView.clone()\n        v.setPointerEvents(\"none\")\n        v.setBorder(\"1px dashed white\")\n        v.setBackgroundColor(\"transparent\")\n        v.setPosition(\"absolute\")\n        v.setZIndex(10000)\n        return v\n    }\n\n    outlineView () {\n        if (!this._outlineView) {\n            const v = this.newOutlineView()\n            this._outlineView = v\n        }\n        return this._outlineView\n    }\n\n    updateOutlineView () {\n        /*\n        if (this.shouldShowVisualDebugger()) {\n            this.showOutlineView()\n        } else {\n            const v = this.outlineView()\n            if (v.parentView()) {\n                v.removeFromParentView()\n            }\n        }\n        */\n    }\n\n    showOutlineView () {\n        const v = this.outlineView()\n        if (!v.parentView()) {\n            DocumentBody.shared().addSubview(v)\n        }\n        const vt = this.viewTarget()\n        const bounds = vt.frameInDocument()\n\n        v.setMinAndMaxHeight(bounds.height())\n        v.setMinAndMaxWidth(bounds.width())\n        v.setLeftPx(bounds.x())\n        v.setTopPx(bounds.y())\n    }\n\n\n\n    // --- finger views for debugging ---\n\n    newFingerView () {\n        const v = DomView.clone()\n        v.setPointerEvents(\"none\")\n\n        const size = 50\n        v.setMinAndMaxHeight(size)\n        v.setMinAndMaxWidth(size)\n        v.setBorderRadiusPx(Math.round(size/2) + \"px\")\n        v.setBorder(\"1px dashed white\")\n        //v.setBackgroundColor(\"rgba(255, 255, 255, 0.5)\")\n        v.setPosition(\"absolute\")\n        v.setTextAlign(\"center\")\n        v.setZIndex(10000)\n        v.setInnerHtml(this.type())\n        v.setPxFontSize(10)\n        v.setColor(\"white\")\n        return v\n    }\n\n    viewForFingerId (id) {\n        const fvs = this.fingerViewMap();\n        let v = fvs.get(id);\n        if (!v) {\n            v = this.newFingerView();\n            DocumentBody.shared().addSubview(v);\n            fvs.atPut(id, v);\n        }\n        return v;\n    }\n\n    removeFingerViews () {\n        const map = this.fingerViewMap();\n        map.keysArray().forEach((id) => {\n            const fingerView = map.get(id);\n            fingerView.removeFromParentView();\n        })\n        map.clear();\n        return this;\n    }\n\n    titleForFingerNumber (n) {\n        return \"&nbsp;\".repeat(26) + this.type() + \"&nbsp;\" + n + \"&nbsp;of&nbsp;\" + this.numberOfFingersDown() \n    }\n\n    showFingers () {\n        const points = this.pointsForEvent(this.currentEvent());\n        const idsToRemoveSet = this.fingerViewMap().keysSet(); \n        let count = 1\n\n        points.forEach((point) => {\n            const id = point.id();\n            const v = this.viewForFingerId(id);\n            idsToRemoveSet.delete(id);\n            const nx = point.x() - v.clientWidth()/2;\n            const ny = point.y() - v.clientHeight()/2;\n            v.setLeftPx(nx);\n            v.setTopPx(ny);\n            v.setInnerHtml(this.titleForFingerNumber(count));\n            v.setBorder(\"1px dashed white\");\n            if (this.isPressing()) {\n                v.setBorder(\"1px solid white\");\n                v.setColor(\"white\");\n            } else {\n                v.setBorder(\"1px dashed #888\");\n                v.setColor(\"#888\");\n            }\n            count ++;\n        })\n\n        const fvd = this.fingerViewMap();\n        idsToRemoveSet.forEach((id) => {\n            const fingerView = fvd.get(id);\n            assert(fingerView);\n            fingerView.removeFromParentView();\n            fvd.delete(id);\n        })\n\n        return this;\n    }\n\n    updateFingerViews () {\n        if (this.shouldShowVisualDebugger()) {\n            this.showFingers();\n        } else {            \n            this.removeFingerViews();\n        }\n\n        return this;\n    }\n\n    updateDebugger () {\n        this.updateOutlineView();\n        this.updateFingerViews();\n        if (this.viewTarget()) {\n            console.log(this.viewTarget().typeId() + \".updateDebugger\");\n        }\n    }\n\n    updateDebuggerTimeoutName () {\n        return \"updateDebugger\";\n    }\n\n    updateDebuggerTimeoutSeconds () {\n        return 0.1;\n    }\n\n    updateDebugTimer () {\n        const ms = this.updateDebuggerTimeoutSeconds() * 1000;\n        this.addTimeout(() => this.updateDebugger(), ms, this.updateDebuggerTimeoutName());\n        return this;\n    }\n\n    // down points\n\n    hasDownPointsInView () {\n        if (!this.viewTarget()) {\n            return false;\n        }\n\n        const view = this.viewTarget();\n        const points = this.allDownPoints();\n        //console.log(\"all points.length:\", points.length, \" has match:\", match != null)\n        return points.canDetect(p => view.containsPoint(p));\n    }\n\n    allPoints () { // TODO: some better abstraction for Touch+Mouse?\n        const points = [];\n        points.appendItems(TouchScreen.shared().currentPoints());\n        points.appendItems(Mouse.shared().currentPoints());\n        return points;\n    }\n\n    allDownPoints () { // TODO: some better abstraction for Touch+Mouse?\n        return this.allPoints().select(p => p.isDown());\n    }\n\n    shortTypeId () {\n        return this.typeId().replaceAll(\"GestureRecognizer\", \"\");\n    }\n\n    description () {\n        return this.shortTypeId() + \" on \" + (this.viewTarget() ? this.viewTarget().typeId() : \"null view target\");\n    }\n    \n}.initThisClass());\n\n",
  "L39bVGUJIbrveYnjbMXdgG1dK5ewat+8zqM/4Dl2Jzo=": "\"use strict\";\n\n/*\n\n    LongPressGestureRecognizer\n\n    Recognize a long press and hold in (roughly) one location.\n\n    Notes:\n\n        Should gesture cancel if press moves?:\n        \n            1. outside of a distance from start point or\n            2. outside of the view\n\n\n    Delegate messages:\n\n        onLongPressBegin\n        onLongPressComplete\n        onLongPressCancelled\n\n*/\n\n(class LongPressGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"timePeriod\", 500);\n            slot.setComment(\"milliseconds\");\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"timeoutId\", null);\n            slot.setIsPrivate(true);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setListenerClasses(this.defaultListenerClasses());\n        this.setIsDebugging(false);\n\n        this.setMinFingersRequired(1);\n        this.setMaxFingersAllowed(1);\n        this.setMinDistToBegin(null);\n        return this;\n    }\n\n    // --- timer ---\n\n    startTimer () {\n        if (this.hasTimer()) {\n            this.stopTimer();\n        }\n\n        const tid = this.addTimeout(() => { this.onLongPress() }, this.timePeriod());\n        this.setTimeoutId(tid);\n        this.startDocListeners(); // didFinish will stop listening\n        return this;\n    }\n\n    stopTimer () {\n        if (this.hasTimer()) {\n            this.clearTimeout(this.timeoutId());\n            this.setTimeoutId(null)\n        }\n        return this\n    }\n\n    hasTimer () {\n        return this.timeoutId() !== null\n    }\n\n    // -- the completed gesture ---\n    \n    onLongPress () {\n        this.setTimeoutId(null)\n\n        if (this.currentEventIsOnTargetView()) {\n            if (this.requestActivationIfNeeded()) {\n                this.sendCompleteMessage()\n                this.didFinish()\n            }\n        } else {\n            this.cancel()\n        }\n    }\n\n    // -- single action for mouse and touch up/down ---\n\n    onDown (event) {\n        super.onDown(event)\n        \n        const isWithin = this.currentEventIsOnTargetView();\n\n        if (isWithin && \n            this.hasAcceptableFingerCount() && \n            !GestureManager.shared().hasActiveGesture()) {\n            this.startTimer()\n            this.sendBeginMessage()\n        }\n    }\n\n    onMove (event) {\n        super.onMove(event)\n    \n        if (this.hasTimer()) { // TODO: also check move distance?\n            if (this.currentEventIsOnTargetView()) {\n                this.setCurrentEvent(event)\n            } else {\n                this.cancel()\n            }\n        }\n\n    }\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.hasTimer()) {\n            this.cancel()\n        }\n    }\n\n    cancel () {\n        if (this.hasTimer()) {\n            this.stopTimer()\n            this.sendCancelledMessage()\n            this.didFinish()\n        }\n        return this\n    }\n\n    /*\n\n    shouldCancel () {\n        return this.hasTimer()\n    }\n\n    willCancel () {\n        this.stopTimer()\n    }\n\n    didCancel () {\n        this.didFinish()\n    }\n    */\n    \n}.initThisClass());\n",
  "VtM0L4Lsq7uLERs366jI/0UyhhMJd61uYIZGkEXkoEA=": "\"use strict\";\n\n/*\n\n    SlideGestureRecognizer\n\n    This gets tricky as we need to follow movement outside the view.\n    To do this, we add special event move and up handlers to the document after getting\n    a down event and then remove them after the up event. \n    \n    We ignore the view's own move and up events.\n\n    Delegate messages :\n\n        onSlideBegin\n        onSlideMove\n        onSlideComplete\n        onSlideCancelled\n    \n    Gesture state info methods:\n\n        direction()\n        distance() \n        downPosInView()\n\n    TODO\n\n        make multitouch\n\n        optimization: floor the move event points and only send delegate messages if\n        new position is different from last?\n\n*/\n\n\n(class SlideGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"direction\", \"left\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"validDirectionsMap\", new Map([\n                [\"left\", 1], \n                [\"right\", 2], \n                [\"up\", 3], \n                [\"down\", 4]\n            ]));\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"maxPerpendicularDistToBegin\", 10) // will not begin if this is exceeded\n            slot.setSlotType(\"Number\")\n        }\n        //downPositionInTarget: null, Point\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())     \n        this.setMinFingersRequired(1)\n        this.setMaxFingersAllowed(1)\n        this.setMinDistToBegin(10)\n        //this.setIsDebugging(false)\n        return this\n    }\n\n    setDirection (directionName) {\n        assert(this.validDirectionsMap().has(directionName));\n        this._direction = directionName\n        return this\n    }\n\n    setNumberOfTouchesRequired (n) {\n        assert(n === 1) // need to add multi-touch support\n        this._numberOfTouchesRequired = n\n        return this\n    }\n\n    // --- events --------------------------------------------------------------------\n\n    onDown (event) {\n        super.onDown(event)\n\n        if (!this.isPressing()) {\n            if (this.hasAcceptableFingerCount()) {\n                this.setIsPressing(true)\n                this.setBeginEvent(event)\n                this.startDocListeners()\n            }\n        }\n    }\n\n    onMove (event) {\n        super.onMove(event)\n\n        if (this.isPressing()) {\n            if (!this.isActive() && this.hasMovedTooMuchPerpendicular()) {\n                this.cancel()\n                return this\n            }\n\n            if (!this.isActive() && this.hasMovedEnough()) {\n                if (this.requestActivationIfNeeded()) {\n                    //this.setIsActive(true)\n                    this.sendBeginMessage() // being\n                }\n            }\n        \n            if (this.isActive()) {\n                this.sendMoveMessage() // move\n            }\n        }\n    }\n\n    // -----------\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.isPressing()) {\n            this.setIsPressing(false)\n            if (this.isActive()) {\n                this.sendCompleteMessage() // complete\n            }\n            this.finish()\n        }\n\n        return true\n    }\n\n    cancel () {\n        if (this.isActive()) {\n            this.sendCancelledMessage()\n        }\n        this.finish()\n        return this\n    }\n\n    finish () {\n        //this.debugLog(\".finish()\")\n        this.setIsPressing(false)\n        this.deactivate()\n        this.stopDocListeners()\n        this.didFinish()\n        return this\n    }\n\n    // ----------------------------------\n\n    hasMovedTooMuchPerpendicular () {\n        let m = this.maxPerpendicularDistToBegin()\n        let dp = this.diffPos()\n\n        let funcs = {\n            left: (dx, dy) => dy,\n            right: (dx, dy) => dy,\n            up: (dx, dy) => dx,\n            down: (dx, dy) => dx\n        }\n\n        let r = Math.abs(funcs[this.direction()](dp.x(), dp.y())) > m\n        return r\n    }\n\n    hasMovedEnough () {\n        let m = this.minDistToBegin()\n        let dp = this.diffPos()\n\n        let funcs = {\n            left: (dx, dy) => -dx,\n            right: (dx, dy) =>  dx,\n            up: (dx, dy) =>  dy,\n            down: (dx, dy) => -dy\n        }\n\n        let r = funcs[this.direction()](dp.x(), dp.y()) > m\n        return r\n    }\n\n    // --- helpers ----\n\n    diffPos () {\n        let cp = this.currentPosition()\n        let bp = this.beginPosition()\n\n        assert(cp)\n        assert(bp)\n        \n        let p = cp.subtract(bp).floorInPlace() // floor here?\n        let dx = p.x()\n        let dy = p.y()\n        let funcs = {\n            left: (p) => p.setX(Math.min(dx, 0)),\n            right: (p) => p.setX(Math.max(dx, 0)),\n            up: (p) => p.setY(Math.max(dy, 0)),\n            down: (p) => p.setY(Math.min(dy, 0))\n        }\n\n        funcs[this.direction()](p)\n        return p\n    }\n\n    distance () {\n        let p = this.diffPos()\n        let dx = p.x()\n        let dy = p.y()\n        let funcs = {\n            left: (dx, dy) => dx,\n            right: (dx, dy) => dx,\n            up: (dx, dy) => dy,\n            down: (dx, dy) => dy\n        }\n        return Math.abs(funcs[this.direction()](dx, dy))\n    }\n\n}.initThisClass());\n",
  "G6IkKiIWO1447MjdutoNxbq0ayGS9rSwefS3kfdy76c=": "\"use strict\";\n\n/*\n\n    TapGestureRecognizer\n\n    Recognize a number of taps inside a viewTarget and within a maxHoldPeriod.\n        \n    On first tap for finger count, start timer. \n    If second tap for finger count occurs before it's expired, it's recognized. \n    Otherwise, restart timer.\n\n    Delegate messages:\n\n        onTapBegin\n        onTapComplete\n        onTapCancelled\n\n        Typically, delegate will ignore onTapBegin & onTapCancelled.\n\n    The names of the delegate messages can be specified. Example:\n\n        const tg = TapGestureRecognizer.clone()\n        tg.setNumberOfTapsRequired(2)\n        tg.setNumberOfFingersRequired(2)\n        tg.setGestureName(\"DoubleFingerDoubleTap\") // on recognize, will send a onDoubleFingerDoubleTapComplete() message\n        this.addGestureRecognizer(tg)\n\n*/\n\n(class TapGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"maxHoldPeriod\", 1000);\n            slot.setComment(\"milliseconds per tap down hold\");\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"timeoutId\", null); // private\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"numberOfTapsRequired\", 1);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"numberOfFingersRequired\", 1);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"tapCount\", 0);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())\n        this.setIsDebugging(false) \n        this.resetTapCount()\n        this.setShouldRequestActivation(false) // allow multiple tap targets?\n        this.setIsDebugging(false)\n        return this\n    }\n\n    resetTapCount () {\n        this.setTapCount(0)\n        return this\n    }\n\n    // --- timer ---\n\n    startTimer (event) {\n        if (this.timeoutId()) {\n            this.stopTimer()\n        }\n\n        const tid = this.addTimeout(() => this.cancel(), this.maxHoldPeriod());\n        this.setTimeoutId(tid)\n        return this\n    }\n\n    stopTimer () {\n        if (this.hasTimer()) {\n            this.clearTimeout(this.timeoutId());\n            this.setTimeoutId(null)\n            this.resetTapCount()\n        }\n        return this\n    }\n\n    hasTimer () {\n        return this.timeoutId() !== null\n    }\n\n    // -- single action for mouse and touch up/down ---\n\n    onDown (event) {\n        super.onDown(event)\n        \n        if (this.numberOfFingersDown() < this.numberOfFingersRequired()) {\n            return this\n        }\n\n        if (!this.hasTimer()) {\n            this.setTapCount(1)\n            this.startTimer()\n            this.sendBeginMessage() // begin\n        } else {\n            this.setTapCount(this.tapCount() + 1)\n        }\n\n        return true\n    }\n\n    onUp (event) {\n        super.onUp(event)\n \n        if (true || this.isDebugging()) {\n            this.debugLog(\".onUp()  tapCount:\" + this.tapCount() + \" viewTarget:\" + this.viewTarget().typeId())\n        }\n\n        if (this.hasTimer()) {\n            if (this.tapCount() === this.numberOfTapsRequired()) {\n                this.stopTimer()\n                this.complete()\n            }\n        } else {\n            //this.cancel()\n        }\n    }\n\n    // end states\n\n    complete () {\n        this.stopTimer()\n        if (this.requestActivationIfNeeded()) {\n            this.sendCompleteMessage() // complete\n        }\n    }\n\n    cancel () {\n        /*\n        if (this.isDebugging() && this.numberOfTapsRequired() === 2) {\n            debugger;\n        }\n        */\n\n        if (this.hasTimer()) {\n            this.stopTimer()\n            this.sendCancelledMessage() // cancelled\n        }\n        return this\n    }\n\n    /*\n    // was going to do some auto-naming but decided against it for now\n    // too many names for point tap count and number of fingers?\n    // 3 taps * 10 fingers?\n\n    incrementTapCountForFingerCount (n) {\n        const d = this.tapCountDict()\n        if (d.hasOwnProperty(n)) { \n            d.atPut(n, d.at(n)+1)\n        } else {\n            d.atPut(n, 1)\n        }\n        return this\n    }\n\n    nameForCount (n) {\n        if (n === 1) { return \"Single\" }\n        if (n === 2) { return \"Double\" }\n        if (n === 3) { return \"Triple\"; }\n        return n + \"x\"\n    }\n    beginMessageForCount (n) {\n        return \"on\" + this.nameForCount(n) + \"TapBegin\"\n    }\n\n    completeMessageForCount (n) {\n        return \"on\" + this.nameForCount(n) + \"TapComplete\"\n    }\n\n    cancelledMessageForCount (n) {\n        return \"on\" + this.nameForCount(n) + \"TapCancelled\"\n    }\n    */\n\n}.initThisClass());\n",
  "NGeQVI0XRvphCE6Wo0O/+GDN8DinY8wClgu/AaiVDCg=": "\"use strict\";\n\n/*\n\n    OrientGestureRecognizer\n\n    - on down, note 1st and 2nd fingers\n    - on move, use noted 1st and 2nd finger for pinch info\n        if either disappear, gesture ends\n\n    - track center point of 1st & 2nd finger for translation info\n\n    Delegate messages:\n\n        onOrientBegin\n        onOrientMove\n        onOrientComplete\n        onOrientCancelled\n\n    Helper methods:\n\n        points:\n            downPoints // initial 1st two fingers down\n            beginPoints // location (of 1st two fingers down) when gesture began\n            activePoints // current locations of the 1st two fingers down\n\n        position:\n            beginCenterPosition //  initial midpoint between 1st two fingers down\n            currentCenterPosition // current midpoint between 1st two fingers down\n            diffPosition // currentCenterPosition - beginCenterPosition\n\n        rotation:\n            activeAngleInDegress // current angle between 1st two fingers down\n            rotationInDegrees // difference between initial angle between 1st two fingers down and their current angle\n\n        scale:\n            scale // current distance between 1st to fingers down divided by their intitial distance  \n\n*/\n\n\n(class OrientGestureRecognizer extends GestureRecognizer {\n\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses())\n\n        this.setMinFingersRequired(2)\n        this.setMaxFingersAllowed(4)\n        this.setMinDistToBegin(10)\n\n        this.setIsDebugging(false)\n        return this\n    }\n\n    // events\n\n    onDown (event) {\n        super.onDown(event)\n        //console.log(this.shortTypeId() + \".onDown() this.isPressing() = \", this.isPressing())\n\n        if (!this.isPressing()) {\n            const downCount = this.numberOfFingersDown()\n            if (downCount >= this.minFingersRequired() &&\n                downCount <= this.maxFingersAllowed()\n            ) {\n                this.setIsPressing(true)\n                //this.setBeginEvent(event)\n                this.startDocListeners()\n            }\n        }\n    }\n\n    /*\n    hasMovedEnough () {\n        // intended to be overridden by subclasses\n        // e.g. a rotation recognizer might look at how much first two fingers have rotated\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        return d >= m\n    }\n\n    hasAcceptableFingerCount () {\n        const n = this.numberOfFingersDown()\n        return  n >= this.minFingersRequired() &&\n                n <= this.maxFingersAllowed();\n    }\n\n    canBegin () {\n        return !this.isActive() && \n                this.hasMovedEnough() && \n                this.hasAcceptableFingerCount();\n    }\n    */\n\n    onMove (event) {\n        super.onMove(event)\n\n        if (this.isPressing()) {\n            if (this.canBegin()) {\n                if (this.requestActivationIfNeeded()) {\n                    this.sendBeginMessage()\n                }\n            }\n\n            if (this.activePoints().length < this.minFingersRequired()) {\n                this.onUp(event)\n                return\n            }\n\n            if (this.isActive()) {\n                if (this.activePoints().length >= this.minFingersRequired()) {\n                    this.sendMoveMessage()\n                } else {\n                    this.onUp(event)\n                }\n            }\n        }\n    }\n\n    // -----------\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.isPressing()) {\n            this.setIsPressing(false)\n            if (this.isActive()) {\n                this.sendCompleteMessage()\n            }\n            this.didFinish()\n        }\n    }\n\n    cancel () {\n        if (this.isActive()) {\n            this.sendCancelledMessage()\n        }\n        this.didFinish()\n        return this\n    }\n\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        this.deactivate()\n        this.stopDocListeners()\n        return this\n    }\n\n    // points - move to GestureRecognizer?\n\n    downPoints () {\n        const p = this.pointsForEvent(this.downEvent())\n        return [p[0], p[1]]\n    }\n\n    activeForEvent (event) {\n        // looks for two points whose id matchs those of the two down points\n        const points = this.pointsForEvent(event)\n        const ids = this.downPoints().map(p => p.id())\n        return points.select(p => ids.contains(p.id()))\n    }\n\n    beginPoints () {\n        return this.activeForEvent(this.beginEvent())\n    }\n\n    lastPoints () {\n        return this.activeForEvent(this.lastEvent())\n    }\n\n    activePoints () { // current points that were in down points\n        return this.activeForEvent(this.currentEvent())\n    }\n\n    // position\n\n    centerForPoints (p) {\n        return p[0].midpointTo(p[1])\n    }\n\n    downCenterPosition () {\n        return this.centerForPoints(this.downPoints())\n    }\n\n    beginCenterPosition () {\n        return this.centerForPoints(this.beginPoints())\n    }\n\n    currentCenterPosition () {\n        return this.centerForPoints(this.activePoints())\n    }\n\n    diffPosition () {\n        return this.currentCenterPosition().subtract(this.beginCenterPosition())\n    }\n\n    // rotation\n\n    angleInDegreesForPoints (p) {\n        return p[0].angleInDegreesTo(p[1])\n    }\n\n    downAngleInDegress () {\n        return this.angleInDegreesForPoints(this.downPoints())\n    }\n\n    beginAngleInDegress () {\n        return this.angleInDegreesForPoints(this.beginPoints())\n    }\n\n    activeAngleInDegress () {\n        return this.angleInDegreesForPoints(this.activePoints())\n    }\n\n    rotationInDegrees () {\n        // difference between initial angle between 1st two fingers down and their current angle\n        const a1 = this.beginAngleInDegress();\n        const a2 = this.activeAngleInDegress();\n        return a2 - a2;\n    }\n\n    // scale\n\n    spreadForPoints (p) {\n        return p[0].distanceFrom(p[1])\n    }\n\n    downSpread () {\n        // initial distance between first two fingers down\n        return this.spreadForPoints(this.downPoints())\n    }\n\n    beginSpread () {\n        // initial distance between first two fingers down\n        return this.spreadForPoints(this.beginPoints())\n    }\n\n    currentSpread () {\n        // current distance between first two fingers down\n        return this.spreadForPoints(this.activePoints())\n    }\n\n    spread () {\n        const s = this.currentSpread() - this.beginSpread();\n        //console.log(\"spread = \" + s + \" = \" + this.currentSpread() + \" - \" + this.beginSpread() )\n        return s\n    }\n\n    downSpreadX () {\n        const p = this.downPoints()\n        return Math.abs(p[0].x() - p[1].x())\n    }\n\n    downSpreadY () {\n        const p = this.downPoints()\n        return Math.abs(p[0].y() - p[1].y())\n    }\n\n    currentSpreadX () {\n        const p = this.activePoints()\n        return Math.abs(p[0].x() - p[1].x())\n    }\n\n    currentSpreadY () {\n        const p = this.activePoints()\n        return Math.abs(p[0].y() - p[1].y())\n    }\n\n    spreadX () {\n        return this.currentSpreadX() - this.downSpreadX()\n    }\n\n    spreadY () {\n        return this.currentSpreadY() - this.downSpreadY()\n    }\n\n    scale () {\n        const s = this.currentSpread() / this.beginSpread();\n        //console.log(\"scale = \" + s + \" = \" + this.currentSpread() + \"/\" + this.beginSpread() )\n        return s\n    }\n\n    // show\n\n    debugJson () {\n        const dp = this.diffPosition()\n        return {\n            id: this.typeId(),\n            dx: dp.x(),\n            dy: dp.y(),\n            scale: this.scale(),\n            rotation: this.rotationInDegrees()\n        }\n    }\n\n    show () {\n        console.log(this.debugJson())\n    }\n\n}.initThisClass());\n",
  "l+eWa1hq+ECJRbX4g3QTNmZNgy9O0lTcI5IqV3xskgs=": "\"use strict\";\n\n/*\n\n    PanGestureRecognizer\n\n    Gesture begins when the minimal number of fingers have moved the minimal distance.\n    Will requestActive before beginning.\n\n    Delegate messages:\n\n        onPanBegin\n        onPanMove\n        onPanComplete\n        onPanCancelled\n\n*/\n\n(class PanGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"minNumberOfFingersRequired\", 1);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"maxNumberOfFingersAllowed\", 1);\n            slot.setSlotType(\"Number\");\n        }\n        //downPositionInTarget: null, Point\n    }\n\n    init () {\n        super.init();\n        this.setListenerClasses(this.defaultListenerClasses());\n        //this.setIsDebugging(false);\n        return this;\n    }\n\n    // --- events --------------------------------------------------------------------\n\n    // tap events\n\n    hasOkFingerCount () {\n        const n = this.numberOfFingersDown();\n        const min = this.minNumberOfFingersRequired();\n        const max = this.maxNumberOfFingersAllowed();\n        return (n >= min && n <= max);\n    }\n\n    isReadyToBegin () {\n        return this.hasOkFingerCount();\n    }\n\n    doPress (event) { \n        this.debugLog(\"doPress\");\n        this.setIsPressing(true);\n        this.setDownEvent(event);\n        this.startDocListeners();\n        return this;\n    }\n\n    onDown (event) {\n        super.onDown(event);\n\n        if (!this.isPressing()) {\n            if (this.isReadyToBegin()) {\n                this.doPress(event);\n            }\n        }\n        \n        return this;\n    }\n\n    attemptBegin () {\n        this.debugLog(\"attemptBegin\")\n\n        if (!this.doesTargetAccept()) {\n            return;\n        }\n\n        if (this.requestActivationIfNeeded()) {\n            this.sendBeginMessage() // begin\n        } else {\n            if (this.isDebugging()) {\n                console.log(this.shortTypeId() + \".attemptBegin() FAILED\")\n            }\n        }\n    }\n\n    onMouseMoveCapture (event) { // tmp for debugging dragview\n        this.debugLog(\"onMouseMoveCapture\")\n        super.onMouseMoveCapture(event)\n    }\n\n    onMove (event) {\n        super.onMove(event)\n\n        if (this.isPressing()) {\n            if (this.isActive()) {\n                this.sendMoveMessage() // move\n            } else {\n                if (this.hasMovedEnough()) {\n                    this.attemptBegin()\n                }\n            }\n        }\n        return this\n    }\n\n    onUp (event) {\n        super.onUp(event)\n\n        if (this.isPressing()) {\n            if (this.isActive()) {\n                this.sendCompleteMessage() // complete\n            }\n            this.didFinish() // will set isPressing to false\n        }\n        return this\n    }\n\n    // ----------------------------------\n\n    cancel () {\n        if (this.isActive()) {\n            this.sendCancelledMessage()\n        }\n        this.didFinish()\n        return this\n    }\n\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        this.stopDocListeners()\n        return this\n    }\n\n    // ----------------------------------\n\n    hasMovedEnough () {\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        return d >= m\n    }\n\n    distance () {\n        return this.currentPosition().distanceFrom(this.beginPosition())\n    }\n\n}.initThisClass());\n",
  "S0jthWAFfu4k7kyMMcfbNsnwysrehhGFvDJqUw8FwyE=": "\"use strict\";\n\n/*\n\n    PinchGestureRecognizer\n\n    Subclass of OrientGestureRecognizer that overrides hasMovedEnough() to \n    check for minDistToBegin.\n\n    Delegate messages:\n\n        onPinchBegin\n        onPinchMove\n        onPinchComplete\n        onPinchCancelled\n\n    Helper methods:\n\n        scale:\n            scale // current distance between 1st to fingers down divided by their intitial distance  \n\n*/\n\n\n(class PinchGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        //this.setIsDebugging(false)\n        //this.setIsVisualDebugging(true)\n        this.setMinFingersRequired(2)\n        this.setMaxFingersAllowed(2)\n        return this\n    }\n\n    hasMovedEnough () {\n        const m = this.minDistToBegin()\n        const d = this.currentPosition().distanceFrom(this.downPosition())\n        //console.log(this.shortTypeId() + \".hasMovedEnough() \" + d + \">= min \" + m)\n        return d >= m\n    }\n    \n}.initThisClass());\n",
  "6FEkfVWeG/zJiHi1NhImO7Xmt1/0f8ICmKKHJOP/klY=": "\"use strict\";\n\n/*\n\n    RotationGestureRecognizer\n\n    Overrides OrientGestureRecognizer's hasMovedEnough() method to \n    check for minRotationInDegreesToBegin.\n    \n    Delegate messages:\n\n        onRotationBegin\n        onRotationMove\n        onRotationComplete\n        onRotationCancelled\n\n    Helper methods:\n    \n        rotation:\n            activeAngleInDegress // current angle between 1st two fingers down\n            rotationInDegrees // difference between initial angle between 1st two fingers down and their current angle\n\n*/\n\n(class RotationGestureRecognizer extends GestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        this.setIsDebugging(false)\n        return this\n    }\n\n    hasMovedEnough () {\n        const ma = this.minRotatationInDegreesToBegin()\n        const a = this.activeAngleInDegress()\n        return a >= ma\n    }\n    \n}.initThisClass());\n",
  "U3F/f+Xao3WwbHkppCYerVvZxPa46vVFsbR8xKPaAV4=": "\"use strict\";\n\n/*\n\n    EdgePanGestureRecognizer\n\n    Subclass of PanGestureRecognizer that limits pan detection to gestures starting at the edge fo the view. \n    Don't use this class directed - instead use it's subclass for the edge you're interested in.\n\n    Delegate messages:\n\n        onEdgePanBegin\n        onEdgePanMove\n        onEdgePanComplete\n        onEdgePanCancelled\n        \n*/\n\n(class EdgePanGestureRecognizer extends PanGestureRecognizer {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"edgeName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"maxStartDistance\", 15);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses());\n        this.setMinDistToBegin(5);\n        this.setIsDebugging(false);\n        return this;\n    }\n\n    start () {\n        return super.start();\n    }\n\n    /*\n    start () {\n        this.startDocListeners() // only want to listen to the document\n        // TODO: do we always want to listen outside the view? \n        // is listening only inside both more efficient and good enough?\n        return this\n    }\n    */\n\n    // --- events --------------------------------------------------------------------\n\n    /*\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        this.stopDocListeners()\n        return this\n    }\n    */\n\n    /*\n    onDown (event) {\n        super.onDown(event)\n\n        if (this.isReadyToBegin()) {\n            this.doPress(event)\n        }\n\n        return this\n    }\n    */\n\n\n    isReadyToBegin () {\n        return this.hasOkFingerCount() &&\n            this.distanceFromEdge() <= this.maxStartDistance();\n    }\n\n    distanceFromEdge () {\n        const name = this.edgeName()\n        //assert(name)\n        const d = this.currentEdgeDistances()[name]\n        //assertDefined(d)\n        //console.log(\"distanceFromEdge \", d)\n        return d\n    }\n\n    // -------------\n\n    maxEdgeDistance () {\n        return 100000\n    }\n\n    currentEdgeDistances () {\n        const max = this.maxEdgeDistance()\n        const points = this.allPoints() // event points are in document coordinates\n        const vt = this.viewTarget()\n\n        if (!vt) {\n            this.debugLog(\" missing viewTarget\")\n            return max\n        }\n\n        const f = vt.frameInDocument()\n\n        // use maxValue to make sure all fingers are close to the edge\n\n        return {\n            top: points.maxValue(p => Math.abs(f.top() - p.y()), max),\n            bottom: points.maxValue(p => Math.abs(f.bottom() - p.y()), max),\n            left: points.maxValue(p => Math.abs(f.left() - p.x()), max),\n            right: points.maxValue(p => Math.abs(f.right() - p.x()), max)\n        }\n    }\n\n}.initThisClass());\n",
  "QfJFJotghltLKd/EYTBf1797XFiYhGBqo09jdyORh8U=": "\"use strict\";\n\n/*\n\n    TopEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onTopEdgePanBegin\n        onTopEdgePanMove\n        onTopEdgePanComplete\n        onTopEdgePanCancelled\n\n*/\n\n(class TopEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"top\")\n        return this\n    }\n\n}.initThisClass());\n",
  "WK4fW8n6Oqe01fZkLDSIStAQTvZbU1Zkmo3DRKphhpU=": "\"use strict\";\n\n/*\n\n    BottomEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onBottomEdgePanBegin\n        onBottomEdgePanMove\n        onBottomEdgePanComplete\n        onBottomEdgePanCancelled\n\n*/\n\n(class BottomEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"bottom\")\n        this.setIsDebugging(false)\n        return this\n    }\n    \n    \n}.initThisClass());\n",
  "oyrM9tiQ1+JeMaPQN0cvRShW0wlwgzoimu/YKUqLrhA=": "\"use strict\";\n\n/*\n\n    LeftEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onLeftEdgePanBegin\n        onLeftEdgePanMove\n        onLeftEdgePanComplete\n        onLeftEdgePanCancelled\n\n*/\n\n(class LeftEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"left\")\n        return this\n    }\n\n}.initThisClass());\n",
  "bPllA5BIds/fgVy4zVyPnvefQx3B34nGKro4j6S7gfY=": "\"use strict\";\n\n/*\n\n    RightEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onRightEdgePanBegin\n        onRightEdgePanMove\n        onRightEdgePanComplete\n        onRightEdgePanCancelled\n\n*/\n\n(class RightEdgePanGestureRecognizer extends EdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"right\")\n        return this\n    }\n\n}.initThisClass());\n",
  "zuKddN3ttAn4li37iLYsNZ/yRurIeausBH9E/YCO6Ck=": "\"use strict\";\n\n/*\n\n    ScreenEdgePanGestureRecognizer\n\n    Subclass of PanGestureRecognizer that limits pan detection to gestures starting at the edge. \n    Don't use this class directly - instead use it's subclass for the edge you're interested in.\n\n    Delegate messages:\n\n        onScreenEdgePanBegin\n        onScreenEdgePanMove\n        onScreenEdgePanComplete\n        onScreenEdgePanCancelled\n\n\n    for distance, ask the target for it's frameInViewport and compare with\n    event's posInWindow:\n\n        const frame = target.frameInDocument()\n        frame.top()\n        frame.bottom()\n        frame.left()\n        frame.right()\n        \n*/\n\n(class ScreenEdgePanGestureRecognizer extends PanGestureRecognizer { // TODO abstract PanEdgeGestureRecognizer\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"edgeName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"maxStartDistance\", 15);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setListenerClasses(this.defaultListenerClasses()) \n        this.setMinDistToBegin(5)\n        this.setIsDebugging(false)\n        return this\n    }\n\n    start () {\n        this.startDocListeners() // only want to listen to the document\n        return this\n    }\n\n    // --- events --------------------------------------------------------------------\n\n    didFinish () {\n        super.didFinish()\n        this.setIsPressing(false)\n        //this.stopDocListeners()\n        return this\n    }\n\n    isReadyToBegin () {\n        return this.hasOkFingerCount() &&\n                this.distanceFromEdge() <= this.maxStartDistance();\n    }\n\n    distanceFromEdge () {\n        const name = this.edgeName()\n        assert(name)\n        const d = this.currentEdgeDistances()[name]\n        assertDefined(d)\n        return d\n    }\n\n    // -------------\n\n    maxEdgeDistance () {\n        return 100000\n    }\n\n    currentEdgeDistances () {\n        const max = this.maxEdgeDistance()\n        const points = this.allPoints()\n        return {\n            top:    points.minValue(p => p.distFromTopOfViewport(),    max),\n            bottom: points.minValue(p => p.distFromBottomOfViewport(), max),\n            left:   points.minValue(p => p.distFromLeftOfViewport(),   max),\n            right:  points.minValue(p => p.distFromRightOfViewport(),  max)\n        }\n    }\n    \n}.initThisClass());\n",
  "DALpc8UEiMkQr6+Hax9dYaummT+O3UeZj4N3SdUmPIw=": "\"use strict\";\n\n/*\n\n    ScreenTopEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenTopEdgePanBegin\n        onScreenTopEdgePanMove\n        onScreenTopEdgePanComplete\n        onScreenTopEdgePanCancelled\n\n*/\n\n(class ScreenTopEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"top\")\n        return this\n    }\n\n}.initThisClass());\n",
  "dyqDMtv3bsuatvZWNaseAJ9mzw+MGUPTGeQhDLJp3AE=": "\"use strict\";\n\n/*\n\n    ScreenBottomEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenBottomEdgePanBegin\n        onScreenBottomEdgePanMove\n        onScreenBottomEdgePanComplete\n        onScreenBottomEdgePanCancelled\n\n*/\n\n(class ScreenBottomEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"bottom\")\n        return this\n    }\n\n}.initThisClass());\n",
  "abwOwpklY3t1zh03lBf6cIxfJ6hwkTRK3J7HowHYxIU=": "\"use strict\";\n\n/*\n\n    ScreenLeftEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenLeftEdgePanBegin\n        onScreenLeftEdgePanMove\n        onScreenLeftEdgePanComplete\n        onScreenLeftEdgePanCancelled\n\n*/\n\n(class ScreenLeftEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"left\")\n        return this\n    }\n\n}.initThisClass());\n",
  "h3JqGOsu93iJzNlAuX/gdPpLkMCi50pxizbGKeHjUsA=": "\"use strict\";\n\n/*\n\n    ScreenRightEdgePanGestureRecognizer\n\n    Delegate messages:\n\n        onScreenRightEdgePanBegin\n        onScreenRightEdgePanMove\n        onScreenRightEdgePanComplete\n        onScreenRightEdgePanCancelled\n\n*/\n\n(class ScreenRightEdgePanGestureRecognizer extends ScreenEdgePanGestureRecognizer {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.setEdgeName(\"right\")\n        return this\n    }\n\n}.initThisClass());\n",
  "/l5Kzz3RJpCNA5loeswbk8w5ejdCxv8Q6Kw2j1a8Ygo=": "\"use strict\";\n\n/*\n\n    WebBrowserScreen\n\n*/\n\n(class WebBrowserScreen extends ProtoClass {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        assert(!this.thisClass().hasShared()) // enforce singleton\n        super.init()\n    }\n\n    width () {\n        return screen.width\n    }\n\n    height () {\n        return screen.height\n    }\n    \n    aspectRatio () {\n        return this.width() / this.height()\n    }\n    \n    isRotated () { // screen aspect doesn't match window (only works on mobile)\n        const a = this.aspectRatio() > 1 \n        const b = WebBrowserWindow.shared().aspectRatio() > 1\n        return a !== b && WebBrowserWindow.shared().isOnMobile()\n    }\n    \n    orientedWidth () {\n        return this.isRotated() ? this.height() : this.width()\n    }\n    \n    orientedHeight () {\n        return this.isRotated() ? this.width() : this.height()\n    }\n        \n    show () {\n        this.debugLog(\" size \" + this.width() + \"x\" + this.height())\n    }\n\n    lesserOrientedSize () {\n        // lesser of window and oriented screen size\n        const w = Math.min(this.orientedWidth(), WebBrowserWindow.shared().width())\n        const h = Math.min(this.orientedHeight(), WebBrowserWindow.shared().height())\n        return { width: w, height: h }\n    }\n\n    userPrefersDarkMode () {\n        // should we add a timer to monitor this value and post notifications on changes?\n        // how about an NoteMonitor object that does this? example:\n        // const m = NoteMonitor.clone().setTarget(this).setMethod(\"userPrefersDarkMode\")\n        // m.setName(\"didChangeDarkMode\").setPeriodInSeconds(1).start()\n        const prefersDark = window.matchMedia && window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n        return prefersDark\n    }\n\n}.initThisClass());\n\n",
  "eHIGt36OaWQp42bnXFbHREWi/ea6l37KhvLhrTZL8JU=": "\"use strict\";\n\n/*\n\n    WebBrowserWindow\n\n    Abstraction for the main web browser window. \n    Owns a DocumentBody view.\n\n    WebBrowserWindow.shared().storeSelectionRange();\n    // do stuff\n    WebBrowserWindow.shared().restoreSelectionRange();\n\n*/\n\n(class WebBrowserWindow extends ProtoClass {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"windowListener\", null);\n            slot.setSlotType(\"WindowListener\");\n        }\n\n        {\n            const slot = this.newSlot(\"storedSelectionRange\", null);\n            slot.setSlotType(\"Range\");\n        }\n    }\n    \n    init () {\n        //throw new Error(\"this class is meant to be used as singleton, for now\")\n        super.init()\n        //this.showAgent()\n        this.setupWindowListener()\n        return this\n    }\n\n    setupWindowListener () {\n        this.setWindowListener(WindowListener.clone().setDelegate(this).setIsListening(true))\n        return this\n    }\n\n    documentBody () {\n        return DocumentBody.shared()\n    }\n    \n    /*  \n    electronWindow () {\n        if (!this._electronWindow) {\n            const remote = require(\"electron\").remote;\n            this._electronWindow = remote.getCurrentWindow()\n        }\n        return this._electronWindow\n    }\n    */\n\t\n    // attributes\n    \n    width () {\n        return window.innerWidth\n    }\n\n    height () {\n        return window.innerHeight\n    }\n    \n    aspectRatio () {\n        return this.width() / this.height()\n    }\n    \n    setWidth (w) {\n        console.warn(\"warning: WebBrowserWindow.setWidth() unavailable in browser\")\n        return this\n    }\n    \n    setHeight (h) {\n        console.warn(\"warning: WebBrowserWindow.setHeight() unavailable in browser\")\n        return this\n    }\n    \n    show () {\n        console.log(\"Window size \" + this.width() + \"x\" + this.height())\n    }\n\n    showAgent () {\n        console.log(\"navigator.userAgent = \", navigator.userAgent);\n        console.log(\"   agentIsSafari: \", this.agentIsSafari())\n        console.log(\"   agentIsChrome: \", this.agentIsChrome())\n        console.log(\"  agentIsFirefox: \", this.agentIsFirefox())\n        console.log(\"      isOnMobile: \", this.isOnMobile())\n        console.log(\"   isTouchDevice: \", this.isTouchDevice())\n    }\n    \n    mobileNames () {\n        return [\"android\", \"webos\", \"iphone\", \"ipad\", \"ipod\", \"blackBerry\", \"windows phone\"]  \n    }\n\n    agent () {\n        return navigator.userAgent.toLowerCase()\n    }\n\n    vendor () {\n        return navigator.vendor.toLowerCase()\n    }\n\n    agentIsFirefox () {\n        const agent = navigator.userAgent;\n        return agent.contains(\"Firefox\")\n    }\n\n    agentIsSafari () {\n        const vendor = navigator.vendor;\n        const agent = navigator.userAgent;\n        \n        const isSafari = !Type.isNullOrUndefined(vendor) && \n                vendor.contains(\"Apple\") &&\n                !Type.isNullOrUndefined(agent) &&\n                !agent.contains(\"CriOS\") &&\n                !agent.contains(\"FxiOS\");\n        return isSafari\n    }\n\n    agentIsChrome () {\n        const isChrome = Boolean(window.chrome) //&& \n        //!navigator.userAgent.contains('Brave');\n        //console.log(\"window.chrome = \", window.chrome);\n        return isChrome\n    }\n    \n    isOnMobile () { \n        const agent = this.agent();\n        const match = this.mobileNames().detect((name) => { return agent.contains(name); })\n        return match !== null\n    }\n\n    isTouchDevice () {\n        //return TouchScreen.shared().isSupported()\n\n        // via https://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript\n        let result = false \n        if (\"ontouchstart\" in window) { result = true; }        // works on most browsers \n        if (navigator.maxTouchPoints) { result = true; }       // works on IE10/11 and Surface\t\n        //console.log(\"WebBrowserWindow.isTouchDevice() = \", result)\n        return result\n    }\n\n    // --- url hash ---\n\n    urlHash () {\n        return decodeURI(window.location.hash.substr(1)) // return string after # character\n    }\n    \n    setUrlHash (aString) {\n        if (this.urlHash() !== aString) {\n            window.location.hash = encodeURI(aString)\n            //console.log(\"window.location.hash = [\" + window.location.hash + \"]\")\n        }\n        return this\n    }\n    \n    descriptionDict () {\n        const dict = {\n            agent: this.agent(),\n            size: this.width() + \"x\" + this.height(),\n            isOnMobile: this.isOnMobile()\n        }\n        return dict\n    }\n\n    // --- url ---\n    \n    pageUrl () {\n        // returns full URL including path and query\n        return new URL(window.location.href)\n    }\n\n    rootUrl () {\n        const urlWithoutPathOrQuery = window.location.protocol + \"//\" + window.location.hostname + (window.location.port ? ':' + window.location.port : '');\n        return urlWithoutPathOrQuery\n    }\n\n    baseUrl () {\n        /*\n          Returns URL with no parameters or hash.\n\n          Example:\n          for URL:    http://localhost:3000/page?param=value#section, \n          baseUrl is: http://localhost:3000/page\n\n        */\n        const url = new URL(window.location.href);\n        let basePath = url.pathname;\n\n        // Remove trailing \"index.html\" if present\n        if (basePath.endsWith('/index.html')) {\n            basePath = basePath.substring(0, basePath.lastIndexOf('index.html'));\n        }\n\n        return url.origin + basePath;\n    }\n\n    urlHostname () {\n        const parser = document.createElement(\"a\")\n        parser.href = window.location.href\n        let name = parser.hostname\n        if (!name) {\n\t\t    name = \"\"\n        }\n        return name\n    }\n\n    /*\n    getUrlParametersDict () {\n        const parser = document.createElement('a');\n        parser.href = window.location.href;\n        debugger\n\n        const query = parser.search.substring(1);\n        const vars = query.split('&');\n        const params = {};\n        for (let i = 0; i < vars.length; i++) {\n            const pair = vars[i].split('=');\n            params[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n        return params;\n    }\n    */\n\n    // --- title ---\n\t\n    setTitle (aName) {\n        document.title = aName\n        return this\n    }\n\n    title () {\n        return document.title\n    }\n    \n    activeDomView () {\n        const e = document.activeElement\n        if (e && e.domView()) {\n            return e.domView()\n        }\n        return null\n    }\n\n\n    /*\n        We listen for these Window/Page/Browser events and post them as notifications\n        so non-UI objects can easily listen for them as they are app\n        startup/shutdown events which are needed outside of the UI as well.\n\n        For example: when the app terminates or goes offline, \n        WebRTC connections ideally should explicitly close their DataConnections \n        so the other side doesn't have to wait until a timeout or send error.\n\n    */\n\n    onDocumentBeforeUnload (event) {\n        this.postNoteNamed(\"onDocumentBeforeUnload\")\n    }\n\n    onDocumentUnload (event) {\n        this.postNoteNamed(\"onDocumentUnload\")\n    }\n\n    onPageShow (event) {\n        this.postNoteNamed(\"onPageShow\")\n    }\n    \n    onPageHide (event) {\n        this.postNoteNamed(\"onPageHide\")\n    }\n\n    onFormSubmit (event) {\n        this.postNoteNamed(\"onFormSubmit\")\n    }\n\n    onBrowserOnline (event) {\n        this.postNoteNamed(\"onBrowserOnline\")\n    }\n\n    onBrowserOffline (event) {\n        this.postNoteNamed(\"onBrowserOffline\")\n    }\n\n    isOnline () {\n        return navigator.onLine\n    }\n\n    /*\n    onWindowResize (event) {\n        super.onWindowResize(event)\n    }\n    */\n\n    // --- selection ----\n\n    getSelectionRange () {\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.getRangeAt && sel.rangeCount) {\n                return sel.getRangeAt(0);\n            }\n        } else if (document.selection && document.selection.createRange) {\n            return document.selection.createRange();\n        }\n        return null;\n    }\n\n    setSelectionRange (range) {\n        if (range) {\n            if (window.getSelection) {\n                const sel = window.getSelection();\n                sel.removeAllRanges();\n                sel.addRange(range);\n            } else if (document.selection && range.select) {\n                range.select();\n            }\n\n            assert(this.getSelectionRange().isEqual(range));\n        }\n        return this;\n    }\n\n    // --- save / restore selection ----\n\n    storeSelectionRange () {\n        const range = this.getSelectionRange();\n        if (range) {\n            console.log(this.typeId() + \"--- storing selection ---\")\n            this.setStoredSelectionRange(range);\n            return true;\n        }\n        return false;\n    }\n\n    restoreSelectionRange () {\n        if (this.storedSelectionRange()) {\n            console.log(this.typeId() + \"--- restoring selection ---\");\n            this.setSelectionRange(this.storedSelectionRange()); // may be null\n            assert(this.storedSelectionRange().isEqual(this.getSelectionRange()));\n            this.setStoredSelectionRange(null);\n            return true;\n        }\n        return false;\n    }\n\n    safelyRunBlockWhileRestoringSelection (aBlock) {\n        this.storeSelectionRange()\n        try {\n            aBlock()\n        } catch (error) {\n            this.restoreSelectionRange()\n            console.error(\"error running block while restoring selection:\", error);\n            error.rethrow();\n        }\n        return this\n    }\n\n}.initThisClass());\n\n\n",
  "BBdlHDW1AG2FYwmQfq9H2oU4XQ72jaU2skCGEYJI8oU=": "\"use strict\";\n\n/*\n\n    WebBrowserNotification\n\n    Don't instantiate these directly. \n    See WebBrowserNotifications example code.\n\n\n        Example actions:\n\n            [{action: 'reply', title: 'Reply'}, ...]\n\n*/\n\n(class WebBrowserNotification extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"title\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"body\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"icon\", null);\n            slot.setComment(\"a url to an image\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"actions\", null);\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"notificationRef\", null);\n            slot.setSlotType(\"BMNotification\");\n        }\n        {\n            const slot = this.newSlot(\"error\", null);\n            slot.setSlotType(\"Error\");\n        }\n        {\n            const slot = this.newSlot(\"choice\", null); // Event.action\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setActions([]);\n        this.setIsDebugging(true);\n        return this\n    }\n\n    tryToPost () {\n        WebBrowserNotifications.shared().postNote(this);\n        return this;\n    }\n\n    justPost () { // private - only WebBrowserNotifications should call this\n        const ref = new Notification(this.title(), { \n            body: this.body(), \n            icon: this.icon(),\n            actions: this.actions()\n        });\n\n        ref.onshow = () => { this.onShow(); };\n        ref.onclick = () => { this.onClick(); };\n        ref.onclose = () => { this.onClose(); };\n        ref.onerror = (error) => { this.onError(error); };\n        ref.onaction = (event) => { this.onAction(event); };\n        \n        this.setNotificationRef(ref);\n        //debugger;\n        return this\n    }\n\n    onShow () {\n        this.debugLog(\"onShow\");\n    }\n\n    onClick () {\n        this.debugLog(\"onClick\");\n    }\n\n    onClose () {\n        this.debugLog(\"onClose\");\n    }\n\n    onError (error) {\n        this.debugLog(\"onError \" + error);\n        this.setError(error);\n    }\n\n    onAction (event) {\n        this.debugLog(\"onAction '\" + event.action + \"'\");\n        this.setChoice(event.action);\n    }\n\n}.initThisClass());\n",
  "Y+9LDBgXYNwcUTZERhtXqOUuPfF8UGHpcAcysWmt94M=": "\"use strict\";\n\n/*\n\n    WebBrowserNotifications\n\n    Simple interface to browser notifications. Takes care of:\n    - only checking for permissions once\n    - sending any waiting notifications after permission is gained\n    - notification timeouts\n\n    Todo: \n    - support for multiple waiting notes? waiting note limit\n    - add any abstractions specific to special Chrome/Android notifications\n\n    example use:\n\n    WebBrowserNotifications.shared().newNote().setTitle(\"hello\").setBody(\"...\").tryToPost()\n\n*/\n\n\n(class WebBrowserNotifications extends ProtoClass {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"permissionPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n        this.setIsDebugging(true);\n    }\n\n    // --- getting permission ---\n\n    async requestPermission () {\n        if (!this.permissionPromise()) {\n            const promise = Promise.clone();\n            this.setPermissionPromise(promise);\n            \n            if (!this.isSupported()) {\n                const msg = this.type() + \" sending browser notifications is not supported\";\n                console.warn(msg);\n                promise.callResolveFunc(false);\n            } else {\n                const result = await Notification.requestPermission();\n                this.debugLog(\"requestPermission:\", result);\n                const gotPermission = result === \"granted\";\n                if (!gotPermission) {\n                    console.warn(this.type() + \" permission denied\");\n                }\n                promise.callResolveFunc(gotPermission);\n            }\n        }\n        return this.permissionPromise();\n    }\n\n    isSupported () {\n        return window.hasOwnProperty(\"Notification\");\n    }\n\n    // --- posting ---\n\n    async postNote (aNote) {\n        if (await this.requestPermission()) {\n            aNote.justPost();\n        }\n    }\n\n    newNote () {\n        return WebBrowserNotification.clone();\n    }\n    \n}.initThisClass());\n\n//WebBrowserNotifications.shared();\n\n//WebBrowserNotifications.shared().newNote().setTitle(\"hello\").setBody(\"world!\").tryToPost();\n",
  "h060DnrTiEal1UUHp6fg/JctLv7qPi9MtbAlm9S8ObI=": "\"use strict\";\n\n/*\n\n    WebDocument\n\n    Abstraction for web document object.\n\n*/\n\n(class WebDocument extends ProtoClass {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n    \n    initPrototypeSlots () {\n    }\n\n\n    body () {\n        return DocumentBody.shared();\n    }\n\n    styleSheets () {\n        const elements = document.styleSheets;\n        const sheets = [];\n\n        for (let i = 0; i < elements.length; i ++) {\n            const sheetElement = elements[i];\n            sheets.push(StyleSheet.clone().setSheetElement(sheetElement));\n        }\n\n        return sheets;\n    }\n\n    addStyleSheetString (cssCode) {\n        const styleElement = document.createElement('style');\n        styleElement.innerHTML = cssCode;\n        document.head.appendChild(styleElement);\n        return this;\n    }\n\n    show () {\n        this.debugLog(\":\");\n        this.styleSheets().forEach(sheet => sheet.show());\n        return this;\n    }\n\n}.initThisClass());",
  "nJXDOvgK+ng2q+4LKJ4GvogzTHNjnG//sPqs2nS2FgI=": "\"use strict\";\n\n/*\n\n    BMStyleSheet\n\n    const sheet = DocumentBody.shared().styleSheets().first()\n    sheet.setSelectorProperty(\"body\", \"color\", \"red\")\n*/\n\n(class BMStyleSheet extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"sheetElement\", null);\n            slot.setSlotType(\"CSSStyleSheet\");\n        }\n    }\n\n    href () {\n        return this.sheetElement().href\n    }\n\n    changeStylesheetRule (selector, property, value) {\n        const sheet = this.sheetElement()\n\n        selector = selector.toLowerCase();\n        property = property.toLowerCase();\n        value = value.toLowerCase(); // assumed to be a string?\n\n        // Change it if it exists\n        for(let i = 0; i < sheet.cssRules.length; i++) {\n            const rule = sheet.cssRules[i];\n            if (rule.selectorText === selector) {\n                rule.style[property] = value;\n                return this;\n            }\n        }\n\n        // Add it if it does not\n        sheet.insertRule(selector + \" { \" + property + \": \" + value + \"; }\", 0);\n        return this;\n    }\n\n    show () {\n        console.log(\"sheetElement:\", this.sheetElement())\n    }\n\n}.initThisClass());\n\n",
  "lw3QHgAOyqgg+H/HKCJpVcKVi8I9A9y4XGdRiXNZ0o0=": "\"use strict\";\n\n/*\n\n    ThrashDetector\n\n    The DOM can be slow if (layout dependent) read and (layout modifying) write operations are interleaved,\n    as the read will require a re-layout or \"reflow\" of the DOM rendering engine.\n\n    This detector helps minimize this issue by warning when interleaving is detected.\n\n    When possible, it's best to do all read operations first, then do any write operations\n    as this allows for a single reflow of the DOM at the end of the frame.\n\n    USE:\n\n    When doing DOM Node reads, call:\n\n        ThrashDetector.shared().didRead(\"opName\")\n\n    and on DOM Node writes, call:\n\n        ThrashDetector.shared().didWrite(\"opName\")\n\n    NOTES:\n\n    See:\n    What forces layout / reflow\n    https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n\n    All style properties:\n    const slot = this.newSlot(\"styleProperties\", new Set(\n                \"color\",\n                \"border\",\n                \"margin\",\n                \"font-style\",\n                \"transform\",\n                \"background-color\",\n                \"align-content\",\n                \"align-items\",\n                \"align-self\",\n                \"all\",\n                \"animation\",\n                \"animation-delay\",\n                \"animation-direction\",\n                \"animation-duration\",\n                \"animation-fill-mode\",\n                \"animation-iteration-count\",\n                \"animation-name\",\n                \"animation-play-state\",\n                \"animation-timing-function\",\n                \"backface-visibility\",\n                \"background\",\n                \"background-attachment\",\n                \"background-blend-mode\",\n                \"background-clip\",\n                \"background-color\",\n                \"background-image\",\n                \"background-origin\",\n                \"background-position\",\n                \"background-repeat\",\n                \"background-size\",\n                \"border\",\n                \"border-bottom\",\n                \"border-bottom-color\",\n                \"border-bottom-left-radius\",\n                \"border-bottom-right-radius\",\n                \"border-bottom-style\",\n                \"border-bottom-width\",\n                \"border-collapse\",\n                \"border-color\",\n                \"border-image\",\n                \"border-image-outset\",\n                \"border-image-repeat\",\n                \"border-image-slice\",\n                \"border-image-source\",\n                \"border-image-width\",\n                \"border-left\",\n                \"border-left-color\",\n                \"border-left-style\",\n                \"border-left-width\",\n                \"border-radius\",\n                \"border-right\",\n                \"border-right-color\",\n                \"border-right-style\",\n                \"border-right-width\",\n                \"border-spacing\",\n                \"border-style\",\n                \"border-top\",\n                \"border-top-color\",\n                \"border-top-left-radius\",\n                \"border-top-right-radius\",\n                \"border-top-style\",\n                \"border-top-width\",\n                \"border-width\",\n                \"bottom\",\n                \"box-shadow\",\n                \"box-sizing\",\n                \"caption-side\",\n                \"caret-color\",\n                \"@charset\",\n                \"clear\",\n                \"clip\",\n                \"clip-path\",\n                \"color\",\n                \"column-count\",\n                \"column-fill\",\n                \"column-gap\",\n                \"column-rule\",\n                \"column-rule-color\",\n                \"column-rule-style\",\n                \"column-rule-width\",\n                \"column-span\",\n                \"column-width\",\n                \"columns\",\n                \"content\",\n                \"counter-increment\",\n                \"counter-reset\",\n                \"cursor\",\n                \"direction\",\n                \"display\",\n                \"empty-cells\",\n                \"filter\",\n                \"flex\",\n                \"flex-basis\",\n                \"flex-direction\",\n                \"flex-flow\",\n                \"flex-grow\",\n                \"flex-shrink\",\n                \"flex-wrap\",\n                \"float\",\n                \"font\",\n                \"@font-face\",\n                \"font-family\",\n                \"font-kerning\",\n                \"font-size\",\n                \"font-size-adjust\",\n                \"font-stretch\",\n                \"font-style\",\n                \"font-variant\",\n                \"font-weight\",\n                \"grid\",\n                \"grid-area\",\n                \"grid-auto-columns\",\n                \"grid-auto-flow\",\n                \"grid-auto-rows\",\n                \"grid-column\",\n                \"grid-column-end\",\n                \"grid-column-gap\",\n                \"grid-column-start\",\n                \"grid-gap\",\n                \"grid-row\",\n                \"grid-row-end\",\n                \"grid-row-gap\",\n                \"grid-row-start\",\n                \"grid-template\",\n                \"grid-template-areas\",\n                \"grid-template-columns\",\n                \"grid-template-rows\",\n                \"height\",\n                \"hyphens\",\n                \"@import\",\n                \"justify-content\",\n                \"@keyframes\",\n                \"left\",\n                \"letter-spacing\",\n                \"line-height\",\n                \"list-style\",\n                \"list-style-image\",\n                \"list-style-position\",\n                \"list-style-type\",\n                \"margin\",\n                \"margin-bottom\",\n                \"margin-left\",\n                \"margin-right\",\n                \"margin-top\",\n                \"max-height\",\n                \"max-width\",\n                \"@media\",\n                \"min-height\",\n                \"min-width\",\n                \"object-fit\",\n                \"object-position\",\n                \"opacity\",\n                \"order\",\n                \"outline\",\n                \"outline-color\",\n                \"outline-offset\",\n                \"outline-style\",\n                \"outline-width\",\n                \"overflow\",\n                \"overflow-x\",\n                \"overflow-y\",\n                \"padding\",\n                \"padding-bottom\",\n                \"padding-left\",\n                \"padding-right\",\n                \"padding-top\",\n                \"page-break-after\",\n                \"page-break-before\",\n                \"page-break-inside\",\n                \"perspective\",\n                \"perspective-origin\",\n                \"pointer-events\",\n                \"position\",\n                \"quotes\",\n                \"right\",\n                \"scroll-behavior\",\n                \"table-layout\",\n                \"text-align\",\n                \"text-align-last\",\n                \"text-decoration\",\n                \"text-decoration-color\",\n                \"text-decoration-line\",\n                \"text-decoration-style\",\n                \"text-indent\",\n                \"text-justify\",\n                \"text-overflow\",\n                \"text-shadow\",\n                \"text-transform\",\n                \"top\",\n                \"transform\",\n                \"transform-origin\",\n                \"transform-style\",\n                \"transition\",\n                \"transition-delay\",\n                \"transition-duration\",\n                \"transition-property\",\n                \"transition-timing-function\",\n                \"user-select\",\n                \"vertical-align\",\n                \"visibility\",\n                \"white-space\",\n                \"width\",\n                \"word-break\",\n                \"word-spacing\",\n                \"word-wrap\",\n                \"writing-mode\",\n                \"z-index\"\n        ))\n        \n*/\n\n(class ThrashDetector extends ProtoClass {\n        \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n\n    initPrototypeSlots () {\n\n        /*\n        const slot = this.newSlot(\"writeStyleProperties\", new Set([\n                \"border\",\n                \"margin\",\n                \"font-style\",\n                \"transform\",\n                \"align-content\",\n                \"align-items\",\n                \"align-self\",\n                \"all\",\n                \"border\",\n                \"border-bottom\",\n                \"border-bottom-color\",\n                \"border-bottom-left-radius\",\n                \"border-bottom-right-radius\",\n                \"border-bottom-style\",\n                \"border-bottom-width\",\n                \"border-collapse\",\n                \"border-color\",\n                \"border-image\",\n                \"border-image-outset\",\n                \"border-image-repeat\",\n                \"border-image-slice\",\n                \"border-image-source\",\n                \"border-image-width\",\n                \"border-left\",\n                \"border-left-color\",\n                \"border-left-style\",\n                \"border-left-width\",\n                \"border-radius\",\n                \"border-right\",\n                \"border-right-color\",\n                \"border-right-style\",\n                \"border-right-width\",\n                \"border-spacing\",\n                \"border-style\",\n                \"border-top\",\n                \"border-top-color\",\n                \"border-top-left-radius\",\n                \"border-top-right-radius\",\n                \"border-top-style\",\n                \"border-top-width\",\n                \"border-width\",\n                \"bottom\",\n                \"box-shadow\",\n                \"box-sizing\",\n                \"caption-side\",\n                \"@charset\",\n                \"clear\",\n                \"clip\",\n                \"clip-path\",\n                \"column-count\",\n                \"column-fill\",\n                \"column-gap\",\n                \"column-rule\",\n                \"column-rule-color\",\n                \"column-rule-style\",\n                \"column-rule-width\",\n                \"column-span\",\n                \"column-width\",\n                \"columns\",\n                \"content\",\n                \"counter-increment\",\n                \"counter-reset\",\n                \"direction\",\n                \"display\",\n                \"empty-cells\",\n                \"flex\",\n                \"flex-basis\",\n                \"flex-direction\",\n                \"flex-flow\",\n                \"flex-grow\",\n                \"flex-shrink\",\n                \"flex-wrap\",\n                \"float\",\n                \"font\",\n                \"@font-face\",\n                \"font-family\",\n                \"font-kerning\",\n                \"font-size\",\n                \"font-size-adjust\",\n                \"font-stretch\",\n                \"font-style\",\n                \"font-variant\",\n                \"font-weight\",\n                \"grid\",\n                \"grid-area\",\n                \"grid-auto-columns\",\n                \"grid-auto-flow\",\n                \"grid-auto-rows\",\n                \"grid-column\",\n                \"grid-column-end\",\n                \"grid-column-gap\",\n                \"grid-column-start\",\n                \"grid-gap\",\n                \"grid-row\",\n                \"grid-row-end\",\n                \"grid-row-gap\",\n                \"grid-row-start\",\n                \"grid-template\",\n                \"grid-template-areas\",\n                \"grid-template-columns\",\n                \"grid-template-rows\",\n                \"height\",\n                \"hyphens\",\n                \"@import\",\n                \"justify-content\",\n                \"@keyframes\",\n                \"left\",\n                \"letter-spacing\",\n                \"line-height\",\n                \"list-style\",\n                \"list-style-image\",\n                \"list-style-position\",\n                \"list-style-type\",\n                \"margin\",\n                \"margin-bottom\",\n                \"margin-left\",\n                \"margin-right\",\n                \"margin-top\",\n                \"max-height\",\n                \"max-width\",\n                \"@media\",\n                \"min-height\",\n                \"min-width\",\n                \"object-fit\",\n                \"object-position\",\n                \"opacity\",\n                \"order\",\n                \"outline\",\n                \"outline-color\",\n                \"outline-offset\",\n                \"outline-style\",\n                \"outline-width\",\n                \"overflow\",\n                \"overflow-x\",\n                \"overflow-y\",\n                \"padding\",\n                \"padding-bottom\",\n                \"padding-left\",\n                \"padding-right\",\n                \"padding-top\",\n                \"page-break-after\",\n                \"page-break-before\",\n                \"page-break-inside\",\n                \"perspective\",\n                \"perspective-origin\",\n                \"pointer-events\",\n                \"position\",\n                \"quotes\",\n                \"right\",\n                \"scroll-behavior\",\n                \"table-layout\",\n                \"text-align\",\n                \"text-align-last\",\n                \"text-decoration\",\n                \"text-decoration-color\",\n                \"text-decoration-line\",\n                \"text-decoration-style\",\n                \"text-indent\",\n                \"text-justify\",\n                \"text-overflow\",\n                \"text-shadow\",\n                \"text-transform\",\n                \"top\",\n                \"transform\",\n                \"transform-origin\",\n                \"transform-style\",\n                \"transition\",\n                \"transition-delay\",\n                \"transition-duration\",\n                \"transition-property\",\n                \"transition-timing-function\",\n                \"user-select\",\n                \"vertical-align\",\n                \"visibility\",\n                \"white-space\",\n                \"width\",\n                \"word-break\",\n                \"word-spacing\",\n                \"word-wrap\",\n                \"writing-mode\",\n                \"z-index\"\n        ]))\n        */\n        \n        {\n            const slot = this.newSlot(\"readOpSet\", new Set([\n                // on Elements\n                \"offsetTop\", \"offsetLeft\", \"offsetWidth\", \"offsetHeight\", \"offsetParent\", // offset\n                \"scrollTop\", \"scrollLeft\", \"scrollWidth\", \"scrollHeight\", // scroll\n                \"scrollBy\", \"scrollTo\", \"scrollIntoView\", \"scrollIntoViewIfNeeded\", // scroll animations\n                \"clientTop\", \"clientLeft\", \"clientWidth\", \"clientHeight\", // client\n                \"getComputedStyle\", \n                \"getClientRects\", \"getBoundingClientRect\", // rects\n                \"computeRole\", \"computedName\", \"innerText\",\n\n                // on Window\n                \"scrollX\", \"scrollY\", \"innerHeight\", \"innerWidth\", \"visualViewPort\", // window\n                //\"getComputedStyle\", \n\n                // on Document\n                \"scrollingElement\", \"elementFromPoint\", // document\n\n                /*\n                // on Forms\n                \"focus\", \"select\", // on inputElement\n                \"select\" // on textAreaElement\n                */\n\n                // on Mouse Event\n                \"layerX\", \"layerY\", \"offsetX\", \"offsetY\",\n\n                // on Range\n                //\"getClientRects\", \"getBoundingClientRect\", // rects\n\n                // on SVG\n\n                \"computeCTM\", \"getBBox\", \"getCharNumAtPosition\", \"getComputedTextLength\", \n                \"getEndPositionOfChar\", \"getExtentOfChar\", \"getNumberOfChars\", \"getRotationOfChar\", \n                \"getStartPositionOfChar\", \"getSubStringLength\", \"selectSubString\", \"instanceRoot\"\n            ]));\n            slot.setSlotType(\"Set\");\n        }\n\n        {\n            const slot = this.newSlot(\"writeOpSet\", new Set([\n                \"focus\",\n                \"appendChild\",\n                \"atInsertElement\",\n                \"removeChild\",\n                \"className\",\n                \"display\",\n                \"position\",\n                \"width\",\n                \"height\",\n                \"min-width\",\n                \"min-height\",\n                \"max-width\",\n                \"max-height\"\n            ]));\n            slot.setSlotType(\"Set\");\n        }\n\n        \n        {\n            const slot = this.newSlot(\"noReflowWriteOpSet\", new Set(\n                \"color\",\n                \"backface-visibility\",\n                \"background\",\n                \"background-attachment\",\n                \"background-blend-mode\",\n                \"background-clip\",\n                \"background-color\",\n                \"background-image\",\n                \"background-origin\",\n                \"background-position\",\n                \"background-repeat\",\n                \"background-size\",\n                \"border-left-color\",\n                \"border-left-style\",\n                \"border-radius\",\n                \"border-right\",\n                \"border-right-color\",\n                \"border-right-style\",\n                \"border-style\",\n                \"border-top-color\",\n                \"border-top-left-radius\",\n                \"border-top-right-radius\",\n                \"border-top-style\",\n                \"caret-color\",               \n                \"color\",\n                \"filter\",\n                \"outline-color\",\n                \"scroll-behavior\",\n                \"user-select\"\n            ));\n            slot.setSlotType(\"Set\");\n        }\n\n        {\n            const slot = this.newSlot(\"needsReflow\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"reflowCount\", false);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"triggers\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"lastWrite\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"enabled\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    beginFrame () {\n        //console.log(\"--- new frame ---\")\n        this.setNeedsReflow(false)\n        this.setReflowCount(0)\n        this.setTriggers([])\n        this.setLastWrite(null)\n    }\n\n    didRead (opName, optionalView) {\n        if (this.readOpSet().has(opName)) {\n            //console.log(this.type() + \".didRead('\" + opName + \"')\")\n            if (this.needsReflow()) {\n                this.setReflowCount(this.reflowCount() + 1);\n                this.setNeedsReflow(false);\n                let m = opName ;\n                if (optionalView) {\n                    m = optionalView.debugTypeId() + \" get \" + opName;\n                }\n                const s = this.lastWrite() + \" -> \" + m;\n                //console.log(s)\n                this.triggers().push(s);\n                this.onThrash();\n            }\n        } \n        return this;\n    }\n\n    didWrite (opName, optionalView) {\n        if (!this.noReflowWriteOpSet().has(opName)) {\n            this.setNeedsReflow(true)\n            let m = opName \n            if (optionalView) {\n                m = optionalView.debugTypeId() + \" set \" + opName\n            }\n            //console.log(m)\n            this.setLastWrite(m)\n        }\n        return this\n    }\n\n    onThrash () {\n        //console.log(this.type() + \" reflowCount: \", this.reflowCount())\n    }\n\n    endFrame () {\n        if (this.enabled() && this.reflowCount()) {\n            console.log(\">>> \" +  this.type() + \" reflowCount: \", this.reflowCount() + \" triggers: \", JSON.stringify(this.triggers(), 2, 2))\n        }\n    }\n\n }.initThisClass());\n",
  "Y8EX1aZAViSiF2ZQQvPYgAYJP8/tcMaJbRg7G6Uk4PA=": "\n\"use strict\";\n\n/*\n\n    DomTransition\n         \n\n*/\n\n(class DomTransition extends ProtoClass {\n    \n    static initClass () {\n        const globalValues = [\"inherit\", \"initial\", \"revert\", \"revert-layer\", \"unset\"].asSet();\n        this.newClassSlot(\"globalValues\", globalValues)\n    }\n\n    static validPropertyValues () {\n        return [  \"background-color\",  \"background-position\",  \"border-color\",  \"border-width\",  \"border-spacing\",  \n        \"bottom\",  \"color\",  \"font-size\",  \"font-weight\",  \"height\",  \"left\",  \"letter-spacing\",  \"line-height\",  \n        \"margin\",  \"margin-bottom\",  \"margin-left\",  \"margin-right\",  \"margin-top\",  \"max-height\",  \"max-width\",  \n        \"min-height\",  \"min-width\",  \"opacity\",  \"outline-color\",  \"outline-offset\",  \"outline-width\",  \"padding\",  \n        \"padding-bottom\",  \"padding-left\",  \"padding-right\",  \"padding-top\",  \"right\",  \"text-indent\",  \"text-shadow\",  \n        \"top\",  \"vertical-align\",  \"visibility\",  \"width\",  \"word-spacing\",  \"z-index\"]\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"global\", null);\n            slot.setSlotType(\"Object\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"property\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"duration\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"timingFunction\", \"ease-in-out\") // \"linear\", \"ease\", \"ease-in\", cubic-bezier(n, n, n, n)\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"delay\", 0) // set to number type (unit = seconds)\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"transitions\", null);\n            slot.setSlotType(\"DomTransitions\");\n            slot.setAllowsNullValue(true);\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    clear () {\n        this.setGlobal(null)\n        this.setProperty(null)\n        this.setDuration(0)\n        this.setTimingFunction(\"\")\n        this.setDelay(0)\n        return this\n    }\n\n    updateDuration (s) {\n        if (Type.isNumber(s)) {\n            s = s + \"s\"\n        }\n        this.setDuration(s)\n        this.syncToDomView()\n        return this\n    }\n\n    updateDelay (s) {\n        this.setDelay(s)\n        this.syncToDomView()\n        return this\n    }\n\n    updateTimingFunction (s) {\n        this.setTimingFunction(s)\n        this.syncToDomView()\n        return this\n    }\n\n    durationString () {\n        const v = this.duration()\n        if (Type.isNumber(v)) {\n            return v + \"s\"\n        }\n        return v\n    }\n\n    delayString () {\n        const v = this.delay()\n        if (Type.isNumber(v)) {\n            return v + \"s\"\n        }\n        return v\n    }\n\n    asString () {\n        if (this.global()) {\n            return this.global()\n        }\n\n        const parts = [\n            this.property(),\n            this.durationString(),\n            this.timingFunction()\n            //this.delayString(),\n        ]\n\n        const s = parts.join(\" \")\n        console.log(this.type() + \" asString() = '\" + s + \"'\")\n        return s\n    }\n\n    setFromString (aString) {\n        // ordering of parts: \n        //   transition-property, \n        //   transition-duration, \n        //   transition-timing-function, \n        //   transition-delay.\n        //\n\n        const startsWithNumber = function (s) {\n            if (s.length) {\n                const c = s[0]\n                return (c >= '0' && c <= '9');\n            }\n            return false\n        }\n\n        const parts = aString.split(\" \").select(part => part !== \"\")\n\n        this.clear()\n\n        if (parts.length === 1 && this.thisClass().validGlobalValues().has(parts[0])) {\n            this.setGlobal(parts[0])\n            return this\n        }\n\n        debugger;\n        let v = parts.removeFirst()\n        assert(!Type.isNull(v))\n        this.setProperty(v)\n\n        v = parts.removeFirst()\n        if (!Type.isNull(v)) {\n            assert(startsWithNumber(v))\n            this.setDuration(v)\n        }\n\n        v = parts.removeFirst()\n        if (!Type.isNull(v)) {\n            this.setTimingFunction(v)\n        }\n\n        v = parts.removeFirst()\n        if (!Type.isNull(v)) {\n            assert(startsWithNumber(v))\n            this.setDelay(v)\n        }\n\n        return this\n    }\n\n    syncToDomView () {\n        this.transitions().syncToDomView()\n        return this\n    }\n\n}.initThisClass());\n\n\n",
  "3n5PQxnZDOfSt/2NmXA+zvNj4CAMgk4BSLsxyRUgnJA=": "\"use strict\";\n\n/*\n\n    DomTransition\n         \n    Example use in a DomView:\n\n            aDomView.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n\n        updates the opacity time without changing other transition settings\n        \n\n    NOTES:\n\n        CSS transition value example:\n        \n            transition: width 2s linear 1s, height 2s ease 1s; \n        \n        1st time value is the duration, \n        2nd time value is the delay\n\n\n*/\n\n\n(class DomTransitions extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"properties\", null);\n            slot.setSlotType(\"Object\"); // JSON Object\n        }\n        {\n            const slot = this.newSlot(\"domView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setProperties({});\n    }\n\n    at (aName) {\n        const d = this.properties();\n        if (!d.hasOwnProperty(name)) {\n            d[name] = DomTransition.clone().setProperty(aName).setTransitions(this);\n        }\n        return d[name];\n    }\n\n    propertiesAsList () {\n        return Object.values(this.properties());\n    }\n\n    asString () {\n        return this.propertiesAsList().map(t => t.asString()).join(\", \");\n    }\n\n    syncToDomView () {\n        //console.log(\".setTransition('\" + this.asString() + \"')\");\n        this.domView().justSetTransition(this.asString());\n        return this;\n    }\n\n    syncFromDomView () {\n        this.setProperties({})\n\n        const s = this.domView().transition()\n\n        if (s !== \"\") {\n            const transitionStrings = s.split(\",\")\n\n            transitionStrings.forEach((tString) => {\n                const t = DomTransition.clone().setFromString(tString)\n                this.properties()[t.property()] = t\n            })\n        }\n\n        return this\n    }\n}.initThisClass());\n\n\n",
  "oBbzJBkW4SG9iY1qjwfDCNZfvvYLiRnxkUWwxOGmZEA=": "\n\"use strict\";\n\n/*\n\n    DomBorderRadius\n         \n\n    // this.titleView().setBorderRadius(\"8px 8px 0px 8px\") // top-left, top-right,  bottom-right, bottom-left\n    // TODO: em vs px support?\n\n*/\n\n\n(class DomBorderRadius extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"divView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"topLeft\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"topRight\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"bottomRight\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"bottomLeft\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"partNames\", [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"]);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    clear () {\n        this.setAll(0)\n        return this\n    }\n\n    setAll (v) {\n        if (!v) {\n            v = 0\n        }\n\n        this.partSetters().forEach((setter) => {\n            this[setter].apply(this, [v])\n        })\n        return this\n    }\n\n    partSetters () {\n        return this.partNames().map(k => k.asSetter())\n    }\n\n    partValues () {\n        return this.partNames().map(k => this[k].apply(this))\n    }\n\n    asString (aString) {\n        return this.partValues().map(v => v + \"px\").join(\" \")\n    }\n\n    setFromString (aString) {\n        const parts = aString.split(\" \").select(part => part !== \"\")\n\n        this.clear()\n\n        if (parts.length === 1) {\n            this.setAll(Number(parts[0]))\n        }\n\n        let v;\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setTopLeft(Number(v))\n        }\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setTopRight(Number(v))\n        }\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setBottomRight(Number(v))\n        }\n\n        v = parts.removeFirst()\n        if (Type.isString(v)) {\n            this.setBottomLeft(Number(v))\n        }\n\n        return this\n    }\n\n    syncToDomView () {\n        this.divView().setBorderRadius(this.asString())\n        return this\n    }\n\n    syncFromDomView () {\n        const s = this.divView().borderRadius()\n\n        if (s) {\n            this.setFromString(s)\n        } else {\n            this.clear()\n        }\n\n        return this\n    }\n}.initThisClass());\n\n",
  "dUbX7uWSFcwLdGWd44Dd+gUSypH/963YSEJKqAk8Aag=": "\n\"use strict\";\n\n/*\n\n    ViewAnimator\n         \n\n*/\n\n(class ViewAnimator extends ProtoClass {\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"startValue\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"targetValue\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"viewProperty\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"duration\", 200);\n            slot.setComment(\"milliseconds\");\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"easing\", \"linear\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"view\", null);\n            slot.setSlotType(\"DomView\");\n        }\n    }\n\n    currentValue () {\n        const view = this.view()\n        return view[this.viewProperty()].apply(view)\n    }\n\n    start () {\n        this.setStartValue(this.currentValue())\n        this.setStartTime(new Date().getTime())\n        this.nextFrame()\n        return this\n    }\n\n    timeRatioDone () {\n        const now = new Date().getTime();\n        return Math.min(1, ((now - this.startTime()) / this.duration()));\n    }\n\n    setterName () {\n        if (!this._setterName) {\n            this._setterName = this.viewProperty().asSetter()\n        }\n        return this._setterName\n    }\n\n    setValue (v) {\n        view[this.setterName()].call(view, v)\n        return this\n    }\n\n    nextFrame () {\n        const tr = this.timeRatioDone()\n        const newValue = Math.ceil((this.timeRatioDone() * (this.currentValue() - this.startValue())) + this.startValue());\n        this.setValue(newValue)\n\n        if (tr !== 1) {\n            requestAnimationFrame(() => { this.nextFrame() })\n        } else {\n            this.didComplete()\n        }\n        return this\n    }\n\n    didComplete () {\n\n    }\n\n    /*\n    EasingsFunctions () {\n        linear(t) {\n            return t;\n        }\n        easeInQuad(t) {\n            return t * t;\n        }\n        easeOutQuad(t) {\n            return t * (2 - t);\n        }\n        easeInOutQuad(t) {\n            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n        }\n        easeInCubic(t) {\n            return t * t * t;\n        }\n        easeOutCubic(t) {\n            return (--t) * t * t + 1;\n        }\n        easeInOutCubic(t) {\n            return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n        }\n        easeInQuart(t) {\n            return t * t * t * t;\n        }\n        easeOutQuart(t) {\n            return 1 - (--t) * t * t * t;\n        }\n        easeInOutQuart(t) {\n            return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t;\n        }\n        easeInQuint(t) {\n            return t * t * t * t * t;\n        }\n        easeOutQuint(t) {\n            return 1 + (--t) * t * t * t * t;\n        }\n        easeInOutQuint(t) {\n            return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;\n        }\n    }\n    */\n}.initThisClass());\n\n\n",
  "nI/rkqI33gSsvs9mp6LtNR7znaw3ZpSB40TYH1hNsh4=": "\n\"use strict\";\n\n/*\n\n    CssAnimation\n\n    Encapsulation of CSS animation rule and animation control properties on a view.\n    It will also start an animationListener on the target view, \n    which will send a onAnimationStart, and onAnimationEnd messages to the view.\n\n    It works by composing a CSS animation rule and inserting it into the document's first style sheet.\n    The rule name is a hash of the rule content, and the CssAnimation class keeps a set of names\n    it's already registered, so it doesn't register them again.\n\n    Example use:\n         \n        CssAnimation.clone().setPropertyName(\"right\").setTargetValue(\"10px\").setView(aView).start()\n\n    */\n\n(class CssAnimation extends ProtoClass {\n\n\n    static insertRuleForAnimation (cssAnimation) {\n        const name = cssAnimation.ruleName()\n        const rules = this.insertedRuleNamesSet()\n        if (!rules.has(name)) { // name is a hash of rule, so this should be safe\n            const css = window.document.styleSheets[0];\n            css.insertRule(cssAnimation.composedRule(), css.cssRules.length); // is this allowed or will some security nonsense block it?\n            rules.add(name)\n        }\n        return this\n    }\n\n    static initClass () {\n        this.newClassSlot(\"insertedRuleNamesSet\", new Set())\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"view\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"propertyName\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"startValue\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"targetValue\", 0);\n            slot.setSlotType(\"String\");\n        }\n\n        // animation name is computed from hash of animation css rule string\n        {\n            const slot = this.newSlot(\"duration\", 1);\n            slot.setComment(\"seconds\");\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"timingFunction\", \"ease\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"iterationCount\", 1) // animation-iteration-count\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"delay\", 0); // animation-delay\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"direction\", \"normal\"); // animation-direction (normal or alternate)\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"fillMode\", \"forwards\");  // animation-fill-mode (none|forwards|backwards|both|initial|inherit)\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"playState\", \"running\");  // animation-play-state (paused|running|initial|inherit)\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"animationPropertyNames\", [\n                \"animation-name\",\n                \"animation-duration\",\n                \"animation-timing-function\",\n                \"animation-delay\",\n                \"animation-iteration-count\",\n                \"animation-direction\",\n                \"animation-fill-mode\",\n                \"animation-play-state\"\n            ]);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"propertySlotsDict\", null);\n            slot.setSlotType(\"Object\");\n        }\n    }\n\n    initPrototype () {\n        this.propertySlotsDict(); // cache it on the prototype\n    }\n\n    init () {\n        super.init();\n    }\n\n    insertRule () {\n        assert(this.isValidRule());\n        this.thisClass().insertRuleForAnimation(this);\n    }\n\n    composedRule () {\n        return \"@keyframes \" + this.name() + \" { \" + this.ruleContent() + \"}\";\n    }\n\n    name () {\n        return \"animation\" + this.ruleContent().hashCode();\n    }\n\n    ruleContent () {\n        const k = this.propertyName();\n        let s = \"\";\n        if (!Type.isNullOrUndefined(this.startValue())) {\n            s += \" from {\" + k + \": \" + this.startValue() + \"; }\\n\";\n        }\n        s += \"to {\" + k + \": \" + this.targetValue() + \"; }\";\n        s += \"\";\n        return s;\n    }\n\n    isValidRule () {\n        return !Type.isNullOrUndefined(this.startValue()) && Type.isNullOrUndefined(this.targetValue());\n    }\n\n    propertySlotsDict () {\n        if (!this._propertySlotsDict) {\n            const dict = {};\n            this.animationPropertyNames().forEach(k => dict[k] = this.slotNameForPropertyName(k));\n            this._propertySlotsDict = dict;\n        }\n        return this._propertySlotsDict;\n    }\n\n    slotNameForPropertyName (k) {\n        const parts = k.split(\"-\");\n        parts.removeFirst();\n        const result = parts.map(p => p.capitalized()).join(\"\").uncapitalized();\n        //console.log(\"slotNameForPropertyName('\" + k + \"') -> '\" + result + \"'\");\n        return result;\n    }\n\n    applyToView (aView) { \n        const dict = this.propertySlotsDict();\n        const e = this.view().element();\n        Reflect.ownKeys(dict).forEach(attributeName => {\n            const slotName = dict[attributeName];\n            const value = this[slotName].apply(this);\n            e.setAttribute(attributeName, value);\n        })\n    }\n\n    start () {\n        this.insertRule();\n        const v = this.view();\n        v.animationListener().setIsListening(true);\n        this.applyToView(v);\n        return this;\n    }\n\n    didComplete () {\n    }\n\n}.initThisClass());\n\n\n",
  "Cjo5r/tjpnbXnZ8INiPBWQwCM/NJwhx1cglegoGDDuc=": "\"use strict\";\n\n/*\n    DomCssInspector\n    Used to inspect class styles since css hides stylesheet.cssRules.\n    \n    example use:\n    const value = DomCssInspector.shared().setElementClassName(\"..\").cssStyle.fontFamily\n\n*/\n\n(class DomCssInspector extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"idName\", \"DomCssInspector\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    testElement () {\n        if (!this._testElement) {\n            this._testElement = this.createTestElement()\n            document.body.appendChild(this._testElement);\n            if (!document.getElementById(this.idName())) {\n                throw new Error(\"missing element '\" + this.idName() + \"'\")\n            }\n        }\n        return this._testElement\n    }\n\t\n    createTestElement () {\n        const e = document.createElement(\"div\");\n\t    e.setAttribute(\"id\", this.idName());\n        e.style.display = \"none\";\n        e.style.visibility = \"hidden\";\n        return e\n    }\n\n    setElementClassName (aName) {\n        this.testElement().setAttribute(\"class\", aName);\n        return this\n    }\n\n    cssStyle (key) {\n        return this.testElement().style\n    }\n    \n}.initThisClass());\n",
  "q62puJQyA/QKZFln/NbDJxtKCYE7JrluefPwG0Yzq5g=": "\"use strict\";\n\n/*\n    \n    CssColor\n    \n    Helpful for manipulating css colors.\n\t\n*/\n\n// RGB2HSV and HSV2RGB are based on Color Match Remix see: http://color.twysted.net/\n// which is based on or copied from ColorMatch 5K see: http://colormatch.dk/\n\nconst RGB2HSV = function (rgb) { \n    // rgb is a dict in form { r: 0-255, g: 0-255, b: 0-255 }\n    const hsv = new Object();\n    const max = max3(rgb.r, rgb.g, rgb.b);\n    const dif = max - min3(rgb.r, rgb.g, rgb.b);\n    hsv.saturation = (max == 0.0) ? 0 : (100 * dif / max);\n    if (hsv.saturation == 0) hsv.hue = 0;\n    else if (rgb.r == max) hsv.hue = 60.0 * (rgb.g - rgb.b) / dif;\n    else if (rgb.g == max) hsv.hue = 120.0 + 60.0 * (rgb.b - rgb.r) / dif;\n    else if (rgb.b == max) hsv.hue = 240.0 + 60.0 * (rgb.r - rgb.g) / dif;\n    if (hsv.hue < 0.0) hsv.hue += 360.0;\n    hsv.value = Math.round(max * 100 / 255);\n    hsv.hue = Math.round(hsv.hue);\n    hsv.saturation = Math.round(hsv.saturation);\n    return hsv;\n}\n\n\nconst HSV2RGB = function (hsv) {\n    const rgb = new Object();\n    if (hsv.saturation == 0) {\n        rgb.r = rgb.g = rgb.b = Math.round(hsv.value * 2.55);\n    } else {\n        hsv.hue /= 60;\n        hsv.saturation /= 100;\n        hsv.value /= 100;\n        let i = Math.floor(hsv.hue);\n        let f = hsv.hue - i;\n        let p = hsv.value * (1 - hsv.saturation);\n        let q = hsv.value * (1 - hsv.saturation * f);\n        let t = hsv.value * (1 - hsv.saturation * (1 - f));\n        switch (i) {\n        case 0: rgb.r = hsv.value; rgb.g = t; rgb.b = p; break;\n        case 1: rgb.r = q; rgb.g = hsv.value; rgb.b = p; break;\n        case 2: rgb.r = p; rgb.g = hsv.value; rgb.b = t; break;\n        case 3: rgb.r = p; rgb.g = q; rgb.b = hsv.value; break;\n        case 4: rgb.r = t; rgb.g = p; rgb.b = hsv.value; break;\n        default: rgb.r = hsv.value; rgb.g = p; rgb.b = q;\n        }\n        rgb.r = Math.round(rgb.r * 255);\n        rgb.g = Math.round(rgb.g * 255);\n        rgb.b = Math.round(rgb.b * 255);\n    }\n    return rgb;\n}\n\n//Adding HueShift via Jacob (see comments)\nconst HueShift = function (h, s) {\n    h += s; \n    while (h >= 360.0) { \n        h -= 360.0; \n    }\n    while (h < 0.0) { \n        h += 360.0; \n    }\n    return h;\n}\n\n//min max via Hairgami_Master (see comments)\nconst min3 = function(a, b, c) {\n    return (a < b) ? ((a < c) ? a : c) : ((b < c) ? b : c);\n}\nconst max3 = function(a, b, c) {\n    return (a > b) ? ((a > c) ? a : c) : ((b > c) ? b : c);\n}\n\n// ----------------------------------------------------------------------------------\n\n(class CssColor extends ProtoClass {\n    \n    initPrototypeSlots () {\n        // values between 0.0 and 1.0\n        {\n            const slot = this.newSlot(\"red\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"green\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"blue\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"opacity\", 1);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"colorCacheMap\", null);\n            slot.setSlotType(\"Map\");\n        }\n        //isMutable: true,\n    }\n    \n    init () {\n        super.init()\n        this.setColorCacheMap(new Map())\n        return this\n    }\n\n    randomize () {\n        this.setRed(Math.random())\n        this.setGreen(Math.random())\n        this.setBlue(Math.random())\n        return this\n    }\n\n    copyFrom (aColor, copyDict) {\n        return CssColor.clone().set(aColor.red(), aColor.green(), aColor.blue(), aColor.opacity())\n    }\n\n    justParseColorString (aColorString) { // private\n        // TODO: test if this is expensive\n        // also, check for any risk of causing an event?\n        const div = document.createElement(\"div\");\n        document.body.appendChild(div);\n        div.style.color = aColorString;\n        const style = window.getComputedStyle(div); debugger;\n        const color = style.color;\n        document.body.removeChild(div);\n\n        assert(color.startsWith(\"rgb\"))\n        const inner = color.between(\"(\", \")\");\n        const parts = inner.split(\",\");\n        const numbers = parts.map((v) => parseInt(v));\n\n        // add an alpha of 1 if no alpha is specified\n        // in order to make returned array format consistent\n\n        if (numbers.length === 3) {\n            numbers.push(1)\n        }\n\n        assert(numbers.length === 4)\n\n        numbers[0] /= 255\n        numbers[1] /= 255\n        numbers[2] /= 255\n        return numbers\n    }\n\n    parseColorString (string) {\n        const cache = CssColor.colorCacheMap()\n        const cachedResult = cache.at(string)\n        if (!Type.isUndefined(cachedResult)) {\n            return cachedResult\n        }\n\n        if (Type.isNull(cachedResult)) {\n            throw new Error(\"invalid color string '\" + string + \"'\")\n        }\n\n        const result = this.justParseColorString(string)\n\n        cache.atPut(string, result)\n        return result\n    }\n\n    setCssColorString (aString) {\n        const array = this.parseColorString(aString)\n        this.set(array.at(0), array.at(1), array.at(2), array.at(3))\n        return this\n    }\n\n    setHex (hex) {\n        return this.setCssColorString(hex)\n    }\n\n    set (r, g, b, opacity) {\n        this.setRed(r)\n        this.setGreen(g)\n        this.setBlue(b)\n\n        if (!opacity) {\n            this.setOpacity(0)\n        } else {\n            this.setOpacity(opacity)\n        }\n\n        return this\n    }\n\n    // conversion helpers\n\n    v255toUnit (v) {\n        return v / 255;\n    }\n\n    unitTo255 (v) {\n        return Math.round(v * 255)\n    }\n\n    red255 () {\n        return this.unitTo255(this.red());\n    }\n\n    green255 () {\n        return this.unitTo255(this.green());\n    }\n\n    blue255 () {\n        return this.unitTo255(this.blue());\n    }\n\n    /*\n    setCssColorString (s) {\n\n    }\n    */\n\n    cssColorString () {\n        return \"rgba(\" + this.red255() + \", \" + this.green255() + \", \" + this.blue255() + \", \" + this.opacity()  + \")\"\n    }\n\n    // operations\n\n    interpV1V2Ratio(v1, v2, r) {\n        const diff = v2 - v1;\n        if (v1 > v2) {\n            return v1 - (v1 - v2)*r\n        }\n        return v2 - (v2 - v1)*r\n    }\n\n    interpolateWithColorTo (other, v) {\n        const r1 = this.red()\n        const g1 = this.green()\n        const b1 = this.blue()\n        const o1 = this.opacity()\n\n        const r2 = other.red()\n        const g2 = other.green()\n        const b2 = other.blue()\n        const o2 = other.opacity()\n\n        const r = this.interpV1V2Ratio(r1, r2, v)\n        const g = this.interpV1V2Ratio(g1, g2, v)\n        const b = this.interpV1V2Ratio(b1, b2, v)\n        const o = this.interpV1V2Ratio(o1, o2, v)\n\n        const result = CssColor.clone().set(r, g, b, o)\n        return result\n    }\n\n    darken (v) {\n        assertDefined(v)\n        assert(v <= 1)\n        const r = this.red()\n        const g = this.green()\n        const b = this.blue()\n        this.setRed(r * v)\n        this.setGreen(g * v)\n        this.setBlue(b * v)\n        return this\n    }\n\n    lighten (v) {\n        assertDefined(v)\n        const r = this.red()\n        const g = this.green()\n        const b = this.blue()\n        this.setRed(r + (1 - r) * v)\n        this.setGreen(g + (1 - g) * v)\n        this.setBlue(b + (1 - b) * v)\n        return this\n    }\n\n    brightness () {  \n        // return value between 0.0 and 1.0\n        return (this.red() + this.green() + this.blue() ) / 3.0;\n    }\n\n    whiteColor () {\n        return CssColor.clone().set(1, 1, 1, 1)\n    }\n\n    blackColor () {\n        return CssColor.clone().set(0, 0, 0, 1)\n    }\n\n    lightGrayColor () {\n        return CssColor.clone().set(0.75, 0.75, 0.55, 1)\n    }\n\n    grayColor () {\n        return CssColor.clone().set(0.5, 0.5, 0.5, 1)\n    }\n\n    darkGrayColor () {\n        return CssColor.clone().set(0.25, 0.25, 0.25, 1)\n    }\n\n    redColor () {\n        return CssColor.clone().set(1, 0, 0, 1)\n    }\n\n    greenColor () {\n        return CssColor.clone().set(0, 1, 0, 1)\n    }\n\n    blueColor () {\n        return CssColor.clone().set(0, 0, 1, 1)\n    }\n\n    yellowColor () {\n        return CssColor.clone().set(1, 1, 0, 1)\n    }\n\n    randomColor () {\n        return CssColor.clone().randomize()\n    }\n\n    asDict255 () {\n        return { r:this.red255(), g:this.green255(), b:this.blue255() }\n    }\n\n    fromDict255 (d) {\n        this.setRed(  d.r / 255)\n        this.setGreen(d.g / 255)\n        this.setBlue( d.b / 255)\n        return this\n    }\n\n    complement () {\n        const temprgb = this.asDict255();\n        const temphsv = RGB2HSV(temprgb);\n        temphsv.hue = HueShift(temphsv.hue, 180.0);\n        temprgb = HSV2RGB(temphsv);\n        return CssColor.clone().fromDict255(temprgb)\n    }\n\n    contrastComplement (v) { // v should be a value in the range of 0.0 to 1.0\n        // returns another CssColor object which is the same as the receiver but darkened\n        //\n\n        const b = this.brightness() \n\n        if (b < 0.55) {\n            const lightened = this.copy().lighten(v)\n            return lightened\n        } else {\n            const darkened = this.copy().darken(v)\n            return darkened\n        }\n    }\n\n}.initThisClass());\n\n",
  "oyPT2fMe2CfYoT6nK5t2TPnIMGFn6xcZvhhX1xnCF1I=": "\"use strict\";\n\n/*\n`\n    Helper methods DOM nodes.\n    Mostly for use inside DomView.\n    Not for general consumption as elements typically shouldn't be interacted with directly. \n\n*/\n\nif (getGlobalThis()[\"Node\"]) { // DOM Node\n\n    Object.defineSlots(Node.prototype, {\n\n        // --- weakref to domView ---\n\n        _domViewWeakRef: null,\n\n        setDomView: function (aView) {\n            this._domViewWeakRef = aView ? new WeakRef(aView) : null;\n            return this\n        },\n\n        domView: function () { \n            const ref = this._domViewWeakRef;\n            const v = ref ? ref.deref() : undefined;\n            return v\n        },\n\n        // --- children ---\n\n        removeAllChildren: function () {\n            while (this.firstChild) {\n                this.removeChild(this.lastChild);\n            }\n            return this\n        },\n\n        moveChildrenTo: function (e) {\n            while (this.firstChild) {\n                e.appendChild(this.firstChild);\n            }\n        },\n\n        atInsertElement: function (index, child) {\n            const children = this.children\n            \n            if (index < children.length) {\n                this.insertBefore(child, children[index])\n                return\n            }\n            \n            if (index === children.length) {\n                this.appendChild(child)\n                return\n            }\n            \n            throw new Error(\"invalid dom child index\")\n        },\n\n        // --- description ---\n\n        description: function () {\n            let s = false\n        \n            if (this === window) {\n                s = \"window\"\n            }\n        \n            if (!s) {\n                s = this.getAttribute(\"id\")\n            }\n        \n            if (!s) {\n                s = this.getAttribute(\"class\")\n            }\n        \n            if (!s) {\n                s = this.tagName\n            }\n        \n            return s\n        },\n\n        // --- forEach ---\n\n        forEachChild (fn) {\n            for(let i = 0; i < this.childNodes.length; i ++) {\n                const child = this.childNodes[i]\n                fn(child)\n            }\n        },\n        \n        forEachDecendant: function (fn) {\n            this.forEachChild(child => {\n                fn(child)\n                child.forEachDecendant(fn)\n            })\n        },\n\n        forEachAncestor: function (fn) {\n            const pn = this.parentNode()\n            if (pn) {\n                fn(pn)\n                pn.forEachAncestor(fn)\n            }\n        },\n\n        hasAncestor: function (anElement) {\n            const pn = this.parentNode()\n            if (pn) {\n                if (pn === anElement) {\n                    return true\n                }\n\n                return pn.hasAncestor(anElement)\n            }\n\n            return false\n        }, \n\n        // --- style ---\n\n        copyComputedStyleFrom: function (e) {\n            debugger; // getComputedStyle can force a reflow\n            const style = window.getComputedStyle(e, null).cssText;\n            this.style.cssText = style;\n            return this\n        },\n\n        copyStyleFrom: function (e) {\n            const style = e.style.cssText;\n            this.style.cssText = style;\n            return this\n        },\n\n        // --- set / remove attributes ---\n\n        copyAttributesFrom: function (e) {\n            for (const attr of e.attributes) {\n                if (attr.namespace) {\n                    this.setAttributeNS(attr.namespace, attr.name, attr.value)\n                } else {\n                    this.setAttribute(attr.name, attr.value)\n                }\n            }\n\n            return this\n        },\n\n        attributesMap: function () {\n            const map = new Map()\n            for (const attr of this.attributes) {\n                map.set(attr.name, attr.value)\n            }\n            return map\n        },\n\n        setAttributesMap: function (map) {\n            if (this.setAttribute) {\n                map.forEachKV((k, v) => {\n                    this.setAttribute(k, v)\n                })\n            }\n        },\n\n        removeAttributes: function (names) {\n            if (this.removeAttribute) {\n                names.forEach(k => this.removeAttribute(k))\n            }\n        },\n        \n        setAttributesAndRemoveFromDecendants: function (attributeMap) {\n            this.setAttributesMap(attributeMap)\n            const names = attributeMap.keysArray()\n            this.forEachDecendant(e => {\n                e.removeAttributes(names)\n            })\n        },\n\n        // --- layers ---\n\n        addSvgGroupLayer: function () {\n            const xmlns = \"http://www.w3.org/2000/svg\";\n            const symbol = document.createElementNS(xmlns, \"g\");\n            //const symbol = document.createElement(\"g\");\n            this.moveChildrenTo(symbol)\n            this.appendChild(symbol)\n            return symbol\n        },\n\n        containsPointXY: function (x, y) {\n            // this assumes ancestors geographically contain descendant elements\n            // which isn't always the case, but document.elementFromPoint might typically clip \n            // subviews such that this is usually true\n            const topElement = document.elementFromPoint(x, y)\n            if (topElement === this) {\n                return true\n            }\n            return topElement.hasAncestor(this)\n        }\n\n    })\n\n}",
  "HV5MzLjktXkjmZkqr6AK9dMwYD10ybo+JlOmlufahHg=": "\"use strict\";\n\n/*\n\n    CanvasTextTapeMeasure\n\n    Used to measure rendered text dimensions given a string and a style.\n    \n    Example uses:\n\n            const width = CanvasTextTapeMeasure.shared().getTextWidth(text, fontString);\n\n*/\n\n(class CanvasTextTapeMeasure extends ProtoClass {\n    \n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"cache\", new Map());\n            slot.setSlotType(\"Map\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"canvas\", null);\n            slot.setSlotType(\"Element\");\n        }\n        {\n            const slot = this.newSlot(\"context\", null);\n            slot.setSlotType(\"CanvasRenderingContext2D\");\n        }\n    }\n\t\n    init () {\n        super.init()\n        this.setCanvas(document.createElement(\"canvas\"))\n        this.setContext(this.canvas().getContext(\"2d\"))\n        return this\n    }\n\n    getTextWidth (text, fontString) {\n        //font The css font descriptor that text is to be rendered with (e.g. \"14px verdana\").\n        const context = this.context()\n        context.font = fontString;\n        const metrics = context.measureText(text)\n        return metrics.width\n    }       \n\n    static selfTest () {\n        const tape = CanvasTextTapeMeasure.clone()\n        const w = tape.getTextWidth(\"hello there!\", \"bold 12pt arial\");\n        assert(Math.round(w) === 86)\n        //console.log(getTextWidth(\"hello there!\", \"bold 12pt arial\"));  // close to 86\n        return this\t\n    }\n\t\n}.initThisClass());\n\n//CanvasTextTapeMeasure.selfTest()\n\n",
  "bJ+6X2WRQoDGKytFh+GJTpaawd3gyNQU2Snz3kZ0DKw=": "\"use strict\";\n\n/*\n\n    DomTextTapeMeasure\n\n    Used to measure rendered text dimensions given a string and a style.\n    \n    Example uses:\n\n            const size1 = DomTextTapeMeasure.shared().sizeOfCssClassWithHtmlString(this.elementClassName(), text);\n            const h = size1.height;\n\n            const size2 = DomTextTapeMeasure.shared().sizeOfElementWithHtmlString(domElement, text);\n            const w = size2.width;\n    \n    TODO: move to using separate document\n\n*/\n\n(class DomTextTapeMeasure extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"document\", null);\n            slot.setSlotType(\"Document\");\n        }\n        {\n            const slot = this.newSlot(\"testElement\", null);\n            slot.setSlotType(\"Element\");\n        }\n\n        {\n            const slot = this.newSlot(\"stylesToCopy\", [\n                \"fontSize\",\n                \"fontStyle\", \n                \"fontWeight\", \n                \"fontFamily\",\n                \"lineHeight\", \n                \"textTransform\", \n                \"letterSpacing\"\n            ]);\n            slot.setSlotType(\"Array\");\n        }\n        \n        {\n            const slot = this.newSlot(\"cache\", new Map());\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"cacheKeys\", new Array());\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"maxCacheKeys\", 100);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    document () {\n        // return document\n        if (!this._document) {\n            this.setDocument(new Document())\n        }\n        return this._document\n    }\n\t\n    testElement () {\n        if (!this._testElement) {\n            this._testElement = this.createTestElement()\n        }\n        return this._testElement\n    }\n\t\n    createTestElement () {\n        const e = document.createElement(\"div\");\n\t    e.setAttribute(\"id\", this.typeId());\n        e.style.display = \"block\";\n        e.style.position = \"absolute\";\n        e.style.width = \"auto\";\n        e.style.left = -1000;\n        e.style.top  = -1000;\n        e.style.visibility = \"hidden\";\n        this.document().body.appendChild(e);\n        return e\t\t\n    }\n\n    addToCache (k, v) {\n        const keys = this.cacheKeys()\n        \n        if (keys.length > this.maxCacheKeys()) {\n            const oldKey = keys.shift() // first in, first out\n            this.cache().delete(oldKey)\n        }\n\n        this.cache().set(k, v)\n        keys.push(k)\n        console.log(this.type() + \" caching: \" + keys.length)\n    }\n\n    sizeOfElementWithHtmlString (element, text) {\n        if (this.cache().has(text)) {\n            return this.cache().get(text)\n        }\n\n        const e = this.testElement()\n        //e.cssText = element.cssText // this would force reflow?\n\t\t\n        this.stylesToCopy().forEach(function (styleName) {\n            const v = element.style[styleName]\n            if (v) {\n                e.style[styleName] = v\n            } else {\n                delete e.style[styleName]\n            }\n        })\n\t\t\n        e.innerHTML = element.innerHTML\n\t\t\n        const width = (e.clientWidth + 1) \n        const height = (e.clientHeight + 1) \n        this.clean()\n\n        const result = { width: width, height: height }\n        this.addToCache(text, result)\n        return result\n    }\n\t\n    clean () {\n        const e = this.testElement()\n        e.innerHTML = \"\"\n        e.className = \"\"\n        this.stylesToCopy().forEach(styleName => delete e.style[styleName] )\n        return this\t\n    }\n\t\n}.initThisClass());\n",
  "rslhAKkU52ZytpjrbYXRg0tGYDS7qJ8WaqnczyDVbqk=": "\"use strict\";\n\n/*\n    DomView\n\n    Base view class. Wraps a dom element. \n    This is wrapped instead of a category or subclass of Element/etc because:\n      - The DOM doesn't play nicely with such extensions.\n      - Keep open possibility of being ability swap out DOM as a render/event layer \n    \n    TODO: add class variable validPropertyValues[propertyName] -> validValueSet and check css values if available?\n\n*/\n\n(class ElementDomView extends ProtoClass {\n\n    /*\n    static initClass () {\n        this.newClassSlot(\"viewsWithoutParents\", new Set()) // track these so we can retire them, but not during drag & drop \n        this.newClassSlot(\"isPausingRetires\", false) // when true, retireQueue is paused\n    }\n\n    static pauseRetires () {\n        this.setIsPausingRetires(true)\n    }\n\n    static unpauseRetires () {\n        this.setIsPausingRetires(false)\n    }\n\n    static retireParentlessViews () {\n        debugger;\n        const parentless = this.viewsWithoutParents()\n\n        while (parentless.size) { // do this effective \"pop\" loop, so it's ok to delete items inside a prepareToRetire\n            if (this.isPausingRetires()) {\n                console.log(\"retireParentlessViews  isPausingRetires\")\n                return\n            }\n\n            const view = parentless.pop();\n            view.prepareToRetire()\n            parentless.delete(view)\n        }\n    }\n    */\n\n    static documentBodyView () {\n        return DocumentBody.shared()\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"elementClassName\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"elementType\", \"div\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"element\", null);\n            slot.setSlotType(\"Element\");\n        }\n        {\n            const slot = this.newSlot(\"usesSmoothScrolling\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setupElement()\n        return this\n    }\n\n    // retiring\n\n    gestureRecognizerListeners () {\n        const results = this.gestureRecognizers().map(gr => gr.allEventListeners()).flat();\n        /*\n        results.forEach(result => {\n            assert(result.thisClass().isKindOf(EventListener));\n        });\n        */\n        return results;\n    }\n\n    allEventListeners () {\n        const results = [this.eventListeners(), this.gestureRecognizerListeners()].flat();\n        /*\n        results.forEach(result => {\n            assert(result.thisClass().isKindOf(EventListener))\n        })\n        */\n        return results;\n    }\n\n    fullActiveEventListenerCount () {\n        return this.allEventListeners().filter(v => v.isListening()).length;\n    }\n\n    externalFullActiveEventListenerCount () {\n        return EventListener.activeListenersForOwner(this).length;\n    }\n\n    /*\n    assertEventListenerCountsMatch () {\n        let internal = this.fullActiveEventListenerCount()\n        if (isNaN(internal)) {\n            debugger;\n            this.fullActiveEventListenerCount()\n        }\n        let external = this.externalFullActiveEventListenerCount()\n        if (internal !== external) {\n            console.log(this.typeId() + \" internal: \" + internal + \" \", this.allEventListeners().filter(v => v.isListening()).map(v => v.fullMethodName()) )\n            console.log(this.typeId() + \" external: \" + external + \" \", EventListener.activeListenersForOwner(this).map(v => v.fullMethodName()))\n            this.fullActiveEventListenerCount();\n            EventListener.activeListenersForOwner(this);\n            debugger;\n        }\n        //assert(internal === external)\n    }\n    */\n\n    prepareToRetire () {\n        //debugger;\n        console.log(this.typeId() + \" prepareToRetire\");\n        assert(!this.hasParentView());\n\n        // if view has no parent at the end of event loop, \n        // our policy is to retire the view\n\n        this.setIsRegisteredForVisibility(false); // this one isn't a listener\n        \n        this.retireSubviewTree();\n\n        // do this after removing subviews, just in case events where added by those changes\n        this.removeAllGestureRecognizers();\n        this.removeAllListeners();\n        this.cancelAllTimeouts();\n\n        //this.assertEventListenerCountsMatch();\n\n        /*\n        if (this.externalFullActiveEventListenerCount()) {\n            console.warn(this.typeId() + \" was unable to remove the following event listeners:\");\n            EventListener.showActiveForOwner(this);\n            debugger;\n        }\n        */\n\n        //assert(!EventListener.activeOwners().has(this));\n\n        SyncScheduler.shared().unscheduleTarget(this);\n\n        //if (this.isFirstResponder()) {\n        //    this.blur(); / is this needed?\n        //}\n\n        this.detachFromElement();\n\n        super.prepareToRetire(); // call on super\n        return this;\n    }\n\n    detachFromElement () {\n        const e = this.element();\n        //e.style.transition = \"all 0s\" // probably not needed\n        if (e) {\n            e.setDomView(null);\n            this._element = null;\n        }\n        e.removeAllChildren();\n    }\n\n    retireSubviewTree () {\n        // this should be called by:\n        //   scheduleRetireIfReady() -> prepareToRetire()\n        // will this cause a SyncAction loop issue as this will result in adding:\n        //   scheduleMethod(\"retireIfReady\")\n        // on subviews, so we do it in a way that avoids this.\n\n        this.subviews().forEach(sv => {\n            sv.setParentView(null)\n            sv.prepareToRetire()\n        })\n    }\n\n    // --- element ---\n\n    setElementId (aString) {\n        this.setAttribute(\"id\", aString)\n        return this\n    }\n\n    elementId () {\n        return this.getAttribute(\"id\")\n    }\n\n    setElement (e) {\n        if (e === this._element) {\n            console.warn(\"attempt to set to same element\")\n        } else {\n            if (Type.isNullOrUndefined(e)) {\n                console.warn(this.debugTypeId() + \" setElement null\")\n                debugger;\n            }\n            \n            //assert(!this._element) // element shouldn't change, if only to avoid dealing with listener issues\n            \n            if (this._element) {\n                this.removeAllListeners()\n            }\n            \n            const oldValue = this._element\n            this._element = e\n            e.setDomView(this)\n\n            this.didUpdateSlotElement(oldValue, e)\n            \n            /*\n            if (e) {\n                // use timer as focus listener can't be set up yet - why not?\n                this.addTimeout(() => { this.setIsRegisteredForFocus(true); }, 0) \n            }\n            */\n        }\n        return this\n    }\n\n    didUpdateSlotElement (e) {\n        // for subclasses to override\n        return this\n    }\n\n\n    hasElement () {\n        return !Type.isNullOrUndefined(this.element())\n    }\n\n    createElement () {\n        const e = document.createElement(this.elementType())\n        return e\n    }\n\n    setupElement () {\n        const e = this.createElement()\n        this.setElement(e)\n        this.setElementId(this.debugTypeId())\n        //this.setupElementClassName()\n        return this\n    }\n\n    escapedElementId () {\n        const id = this.elementId()\n        const escapedId = id.replace(/[^a-z|\\d]/gi, '\\\\$&');\n        return escapedId\n    }\n\n    setupElementClassName () {\n        const e = this.element()\n        const ancestorNames = this.thisClass().ancestorClassesIncludingSelf().map(obj => obj.type())\n        ancestorNames.forEach(name => e.classList.add(name))\n        return this\n    }\n\n    insertElementClassName (aName) {\n        const e = this.element()\n        e.classList.add(aName)\n        return this\n    }\n\n    removeElementClassName (aName) {\n        const e = this.element()\n        e.classList.remove(aName)\n        return this\n    }\n\n    setElementClassNames (names) {\n        this.setElementClassName(names.join(\" \"))\n        return this\n    }\n  \n    // --- element class name ---\n\n    setElementClassName (aName) {\n        if (this._elementClassName !== aName) {\n            this._elementClassName = aName\n            if (this.element()) {\n                this.setAttribute(\"class\", aName);\n            }\n        }\n        return this\n    }\n\n    elementClassName () {\n        if (this.element()) {\n            const className = this.getAttribute(\"class\");\n            this._elementClassName = className\n            return className\n        }\n        return this._elementClassName\n    }\n\n    loremIpsum (maxWordCount) {\n        this.setInnerHtml(\"\".loremIpsum(10, 40))\n        return this\n    }\n\n    // --- editing - abstracted from content editable for use in non text views ---\n\n    setIsEditable (aBool) {\n        // subclasses can override for non text editing behaviors e.g. a checkbox, toggle switch, etc\n        this.setContentEditable(aBool)\n        return this\n    }\n\n    isEditable () {\n        return this.isContentEditable()\n    }\n\n    // --- content editing ---\n\n    setContentEditable (aBool) {\n        //console.log(this.elementClassName() + \" setContentEditable(\" + aBool + \")\")\n        if (aBool) {\n            this.makeCursorText()\n        } else {\n            this.makeCursorDefault() // is this correct?\n        }\n\n        this.setAttribute(\"contentEditable\", aBool ? \"true\" : \"false\")\n\n        /*\n        if (this.showsHaloWhenEditable()) {\n            this.setBoxShadow(aBool ? \"0px 0px 5px #ddd\" : \"none\")\n        }\n        */\n\n        this.setCssProperty(\"outline\", \"none\")\n\n        this.setIsRegisteredForKeyboard(aBool)\n\n        if (aBool) {\n            this.turnOnUserSelect()\n        } else {\n            this.setUserSelect(\"auto\")\n        }\n\n        this.setIsRegisteredForClipboard(aBool) // so we receive onPaste events from clipboard\n\n        return this\n    }\n\n    isContentEditable () { \n        // there's a separate method for contentEditable() that just accesses element attribute\n        //const v = window.getComputedStyle(this.element(), null).getPropertyValue(\"contentEditable\");\n        const s = this.getAttribute(\"contentEditable\");\n        if (s === \"inherit\" && this.parentView()) {\n            return this.parentView().isContentEditable();\n        }\n        const aBool = (s === \"true\" || s === true);\n        return aBool;\n    }\n\n    contentEditable () {\n        return this.getAttribute(\"contentEditable\") === \"true\";\n    }\n\n\n}.initThisClass());\n",
  "waoyEXFG4kS4at8/HBSqS4VJ9lf49WoYwFceXPokCqQ=": "\"use strict\";\n\n/*\n    CssDomView\n\n    CSS related state and behavior.\n\n*/\n\n(class CssDomView extends ElementDomView {\n    \n    initPrototypeSlots () {\n        // css hidden values\n        {\n            const slot = this.newSlot(\"hiddenDisplayMode\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"hiddenDisplayValue\", null);\n            slot.setSlotType(\"String\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"hiddenMinHeight\", undefined);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"hiddenMaxHeight\", undefined);\n            slot.setSlotType(\"String\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"hiddenTransitionValue\", undefined);\n            slot.setSlotType(\"String\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"pushedAttributes\", undefined);\n            slot.setSlotType(\"Array\");\n\n        }\n        {\n            const slot = this.newSlot(\"pushedSlotValues\", undefined);\n            slot.setSlotType(\"Array\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"cachedSize\", null);\n            slot.setSlotType(\"Point\");\n        }\n    }\n\n    \n    init () {\n        super.init()\n        //this.setDisplay(\"block\")\n        return this\n    }\n\n    // --- push/pop slot values ---\n    // useful for pushing a css attribute using it's normal getter/setter methods\n\n    /*\n    pushedSlotValues () {\n        if (Type.isUndefined(this._pushedSlotValues)) {\n            this._pushedSlotValues = new Map()\n        }\n        return this._pushedSlotValues\n    }\n\n    pushedSlotValuesAt (slotName) {\n        const p = this.pushedSlotValues()\n        if (!p.has(slotName)) {\n            p.set(slotName, [])\n        }\n        return p.get(slotName)\n    }\n\n    pushSlotValue (slotName, newValue) {\n        const stack = this.pushedSlotValuesAt(slotName)\n        const oldValue = this[slotName].apply(this)\n        stack.push(oldValue)\n        const setterName = \"set\" + slotName.capitalized()\n        this[setterName].call(this, newValue)\n        return this\n    }\n\n    popSlotValue (slotName) {\n        const a = this.pushedSlotValuesAt(slotName)\n        if (a.length === 0) {\n            throw new Error(\"attempt to pop empty slot value stack\")\n        }\n        const oldValue = a.pop()\n        const setterName = \"set\" + slotName.capitalized()\n        this[setterName].call(this, oldValue)\n        return this\n    }\n    */\n\n    /*\n    // --- push and pop attribute stacks ---\n\n    pushedAttributes () {\n        if (Type.isUndefined(this._pushedAttributes)) {\n            this._pushedAttributes = new Map()\n        }\n        return this._pushedAttributes\n    }\n\n    pushedAttributesAt (name) {\n        const p = this.pushedAttributes()\n        if (!p.has(name)) {\n            p.set(name, [])\n        }\n        return p.get(name)\n    }\n\n    pushAttribute (name, newValue) {\n        const stack = this.pushedAttributesAt(name)\n        const oldValue = this.getCssProperty(name)\n        stack.push(oldValue)\n        this.setCssProperty(name, newValue) // NOTE: bypasses css change callbacks\n        return this\n    }\n\n    popAttribute (name) {\n        const a = this.pushedAttributesAt(name)\n        if (a.length === 0) {\n            throw new Error(\"attempt to pop empty css attribute stack\")\n        }\n        const oldValue = a.pop()\n        this.setCssProperty(name, oldValue) // NOTE: bypasses css change callbacks\n        return this\n    }\n    */\n\n    // ------------------------------\n    \n    /*    \n    applyCSS (ruleName) {\n        if (ruleName == null) { \n            ruleName = this.elementClassName()\n        }\n        CSS.ruleAt(ruleName).applyToElement(this.element())\n        return this\n    }\n    */\n\n    stylesheetWithClassName (className) {\n        for (let i = 0; i < document.styleSheets.length; i++) {\n            const stylesheet = document.styleSheets[i];\n\n            if (\"cssRules\" in stylesheet) {\n                try {\n                    const rules = stylesheet.cssRules;\n                    for (let j = 0; j < rules.length; j++) {\n                        const rule = rules[j];\n                        const ruleClassName = rule.selectorText.split(\" \")[0];\n                        console.log(\"rule.selectorText: \", rule.selectorText);\n                        if (ruleClassName === className) {\n                            return stylesheet;\n                        }\n                    }\n                } catch (e) {\n                    //console.log(\"couldn't add CSS rule: \" + rule + \"\")\n                }\n            }\n        }\n        return null;\n    }\n\n    setCssDict (aDict) {\n        Reflect.ownKeys(aDict).forEach((k) => {\n            const v = aDict[k]\n            this.setCssProperty(k, v)\n        })\n        return this\n    }\n\n    // --- attributes ---\n\n    setAttribute (k, v) {\n        //ThrashDetector.shared().didWrite(k, this)\n        this.element().setAttribute(k, v)\n        return this\n    }\n\n    getAttribute (k) {\n        this.didDomRead(k, this)\n        const v = this.element().getAttribute(k)\n        if (v === null) {\n            let result = this.element()[k]\n            assert(result !== null)\n            //console.log(\"getAttribute('\" + k + \"') = \", v)\n            //console.log(\"element['\" + k + \"'] = \", result)\n            //console.log(\"-----------------------> getAttribute '\" + k + \"' \", result) \n            //throw new Error(\"move this to another method\")\n            return result\n        }\n        return v\n    }\n\n    removeAttribute (k) {\n        if (this.element().hasAttribute(k)) {\n            //ThrashDetector.shared().didWrite(k, this)\n            this.element().removeAttribute(k)\n        }\n        return this\n    }\n\n    // --- css properties ---\n\n    setSpecialCssProperty (k, newValue) {\n        //ThrashDetector.shared().didWrite(k, this)\n\n        assert(k[0] === \"-\" && !k.beginsWith(\"--\")) // sanity check\n\n        this.cssStyle()[k] = newValue\n        return this\n    }\n\n    getSpecialCssProperty (k) {\n        this.didDomRead(k)\n\n        assert(k[0] === \"-\" && !k.beginsWith(\"--\")) // sanity check\n\n        return this.cssStyle()[k]\n    }\n\n    removeCssProperty (k) {\n        //ThrashDetector.shared().didWrite(k, this)\n        this.element().style.removeProperty(k)\n        return this\n    }\n\n    setCssProperty (key, newValue, didChangeCallbackFunc) {\n\n        // sanity checks\n        assert(Type.isString(key))\n\n        if (key[0] === \"-\" && key[1] !== \"-\") { // no dash, and double dash are ok\n            throw new Error(\"use setSpecialCssProperty for single dash options\")\n            //this.setSpecialCssProperty(key, newValue)\n            //return this\n        }\n\n        const style = this.cssStyle()\n        const doesSanityCheck = false\n        //const oldValue = style.getPropertyValue(key)\n\n        //if (String(oldValue) !== String(newValue)) {\n        if (true) {\n                if (newValue == null) {\n                this.removeCssProperty(key)\n            } else {\n                //style[key] = newValue\n                style.setProperty(key, newValue)\n                //ThrashDetector.shared().didWrite(key, this)\n\n                /*\n                if (doesSanityCheck) {\n                    // sanity check the result\n                    // but ignore these keys as they have equivalent functional values \n                    // that can have different string values\n                    const ignoredKeys = { \n                        \"background-position\": true,  \n                        \"transition\": true, \n                        \"color\": true , \n                        \"background-color\": true,\n                        \"box-shadow\": true,\n                        \"border-bottom\": true,\n                        \"transform-origin\": true,\n                        \"outline\": true,\n                        \"border\": true,\n                        \"border-color\": true\n                    }\n\n                    if (!(key in ignoredKeys)) {\n                        //const resultValue = style[key]\n                        const resultValue = style.getPropertyValue(key)\n                        if (resultValue != newValue) {\n                            let msg = \"DomView: style['\" + key + \"'] not set to expected value\\n\";\n                            msg += \"     set: <\" + typeof(newValue) + \"> '\" + newValue + \"'\\n\";\n                            msg += \"     got: <\" + typeof(resultValue) + \"> '\" + resultValue + \"'\\n\";\n                            console.warn(msg)\n                            //throw new Error(msg) \n                        }\n                    }\n                }\n                */\n            }\n\n            if (didChangeCallbackFunc) {\n                didChangeCallbackFunc()\n            }\n        }\n\n        return this\n    }\n\n    getCssProperty (key, errorCheck) {\n        /*\n        if (errorCheck) {\n            throw new Error(\"getCssProperty called with 2 arguments\")\n        }\n        */\n\n        /*\n        if (key[0] === \"-\") {\n            throw new Error(\"use getSpecialCssProperty instead\")\n            return this.getSpecialCssProperty(key)\n        }\n        */\n\n        this.didDomRead(key)\n\n        //return this.cssStyle()[key]\n        return this.cssStyle().getPropertyValue(key)\n    }\n\n    // css px attributes\n\n    setPxCssProperty (name, value, didChangeCallbackFunc) {\n        this.setCssProperty(name, this.pxNumberToString(value), didChangeCallbackFunc)\n        return this\n    }\n\n    getPxCssProperty (name, errorCheck) {\n        const s = this.getCssProperty(name, errorCheck)\n        if (s.length) {\n            return this.pxStringToNumber(s)\n        }\n        return 0\n    }\n\n    // computed style\n\n    getComputedCssProperty (name, errorCheck) {\n        //debugger; // getComputedStyle forces a layout - make sure it's needed \n        return window.getComputedStyle(this.element()).getPropertyValue(name)\n    }\n\n    getComputedPxCssProperty (name, errorCheck) {\n     //   debugger; // getComputedCssProperty forces a reflow? - make sure it's needed \n        const s = this.getComputedCssProperty(name, errorCheck)\n        if (s.length) {\n            return this.pxStringToNumber(s)\n        }\n        return 0\n    }\n\n    // --- css properties ---\n\n    setPosition (s) {\n        this.setCssProperty(\"position\", s)\n        return this\n    }\n\n    position () {\n        return this.getCssProperty(\"position\")\n    }\n\n    // inset\n\n    setInset (s) {\n        this.setCssProperty(\"position\", s)\n        return this\n    }\n\n    inset () {\n        return this.getCssProperty(\"inset\")\n    }\n\n    // pointer events\n\n    pointerEventsValidValues () {\n        return [null, \n            \"auto\", \n            \"none\", \n            \"visiblePainted\", \n            \"visibleFill\", \n            \"visibleStroke\", \n            \"visible\", \n            \"painted\", \n            \"fill\", \n            \"stroke\", \n            \"all\", \n            \"inherit\", \n            \"initial\", \n            \"unset\"]\n    }\n\n    setPointerEvents (s) {\n        assert(this.pointerEventsValidValues().contains(s))\n        return this.setCssProperty(\"pointer-events\", s)\n    }\n\n    pointerEvents () {\n        return this.getCssProperty(\"pointer-events\")\n    }\n\n    // transform\n\n    textTransformValidValues () {\n        return [null, \"none\", \"capitalize\", \"uppercase\", \"lowercase\", \"initial\", \"inherit\"]\n    }\n\n    setTextTransform (v) {\n        assert(this.textTransformValidValues().contains(v))\n        this.setCssProperty(\"text-transform\", v)\n        return this\n    }\n\n    textTransform () {\n        return this.getCssProperty(\"text-transform\")\n    }\n\n    // word wrap\n\n    wordWrapValidValues () {\n        return [null, \"normal\", \"break-word\", \"initial\", \"inherit\"]\n    }\n\n    setWordWrap (v) {\n        assert(this.wordWrapValidValues().contains(v))\n        this.setCssProperty(\"word-wrap\", v)\n        return this\n    }\n\n    wordWrap () {\n        return this.getCssProperty(\"word-wrap\")\n    }\n\n    // zoom\n\n    setZoom (s) {\n        this.setCssProperty(\"zoom\", s)\n        return this\n    }\n\n    zoom () {\n        return this.getCssProperty(\"zoom\")\n    }\n\n    zoomRatio () {\n        return Number(this.zoom().before(\"%\")) / 100\n    }\n\n    setZoomRatio (r) {\n        //console.log(\"setZoomRatio: \", r)\n        this.setZoomPercentage(r * 100)\n        return this\n    }\n\n    setZoomPercentage (aNumber) {\n        assert(Type.isNumber(aNumber))\n        this.setCssProperty(\"zoom\", aNumber + \"%\")\n        return this\n    }\n\n    // font family\n\n    setFontFamily (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"font-family\", s)\n        return this\n    }\n\n    fontFamily () {\n        return this.getCssProperty(\"font-family\")\n    }\n\n    // font style \n\n    setFontStyle (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"font-style\", s)\n        return this\n    }\n\n    fontStyle () {\n        return this.getCssProperty(\"font-style\")\n    }\n\n    // font stretch \n\n    setFontStretch (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"font-stretch\", s)\n        return this\n    }\n\n    fontStretch () {\n        return this.getCssProperty(\"font-stretch\")\n    }\n\n    // font weight\n\n    fontWeightValidatorFunction (v) {\n       return (v) => { Type.isNumber(v) || [null, \"normal\", \"bold\", \"bolder\", \"lighter\", \"initial\", \"inherit\"].contains(v) }\n    }\n\n    setFontWeight (v) {\n        //assert(this.fontWeightValidatorFunction()(v))\n        this.setCssProperty(\"font-weight\", v)\n        return this\n    }\n\n    fontWeight () {\n        return this.getCssProperty(\"font-weight\")\n    }\n\n    // font size\n\n    setFontSizeAndLineHeight (s) {\n        this.setFontSize(s)\n        this.setLineHeight(s)\n        return this\n    }\n\n    setFontSize (s) {\n        if (s === \"6px\") {\n            //debugger;\n        }\n        this.setCssProperty(\"font-size\", s)\n        return this\n    }\n\n    fontSize () {\n        return this.getCssProperty(\"font-size\")\n    }\n\n    computedFontSize () {\n        return this.getComputedCssProperty(\"font-size\")\n    }\n\n    // px font size\n\n    setPxFontSize (s) {\n        this.setPxCssProperty(\"font-size\", s)\n        return this\n    }\n\n    pxFontSize () {\n        return this.getPxCssProperty(\"font-size\")\n    }\n\n    computedPxFontSize () {\n        return this.getComputedPxCssProperty(\"font-size\")\n    }\n\n    // text-shadow\n\n    setTextShadow (s) {\n        this.setCssProperty(\"text-shadow\", s)\n        return this\n    }\n\n    textShadow () {\n        return this.getCssProperty(\"text-shadow\")\n    }\n\n    // ---\n\n    // letter spacing\n\n    setLetterSpacing (s) {\n        this.setCssProperty(\"letter-spacing\", s)\n        return this\n    }\n\n    letterSpacing () {\n        return this.getCssProperty(\"letter-spacing\")\n    }\n\n    computedLetterSpacing () {\n        return this.getComputedCssProperty(\"letter-spacing\")\n    }\n\n    // margin\n\n    setMarginString (s) {\n        this.setCssProperty(\"margin\", s)\n        return this\n    }\n\n    // margin\n\n    setMargin (s) {\n        this.setCssProperty(\"margin\", s)\n        this.setMarginTop(null)\n        this.setMarginBottom(null)\n        this.setMarginLeft(null)\n        this.setMarginRight(null)\n        return this\n    }\n\n    margin () {\n        return this.getCssProperty(\"margin\")\n    }\n\n    // margin px\n\n    setMarginPx (s) {\n        this.setPxCssProperty(\"margin\", s)\n        this.setMarginTop(null)\n        this.setMarginBottom(null)\n        this.setMarginLeft(null)\n        this.setMarginRight(null)\n        return this\n    }\n\n    marginPx () {\n        return this.getPxCssProperty(\"margin\")\n    }\n\n    // margin top\n\n    setMarginTop (m) {\n        if (Type.isNumber(m)) {\n            this.setPxCssProperty(\"margin-top\", m)\n        } else {\n            this.setCssProperty(\"margin-top\", m)\n        }\n        return this\n    }\n\n    // margin bottom\n\n    setMarginBottom (m) {\n        if (Type.isNumber(m)) {\n            this.setPxCssProperty(\"margin-bottom\", m)\n        } else {\n            this.setCssProperty(\"margin-bottom\", m)\n        }\n        return this\n    }\n\n    // margin left\n\n    setMarginLeft (m) {\n        if (Type.isNumber(m)) {\n            this.setPxCssProperty(\"margin-left\", m)\n        } else {\n            this.setCssProperty(\"margin-left\", m)\n        }\n        return this\n    }\n\n    // margin right\n\n    setMarginRight (m) {\n        this.setCssProperty(\"margin-right\", m)\n        return this\n    }\n\n    marginRight () {\n        return this.getCssProperty(\"margin-right\")\n    }\n\n    // margin right px\n\n    setMarginRightPx (m) {\n        this.setPxCssProperty(\"margin-right\", m)\n        return this\n    }\n\n    marginRightPx () {\n        return this.getPxCssProperty(\"margin-right\")\n    }\n\n    // padding\n\n    setPadding (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setPaddingTop(null)\n        this.setPaddingBottom(null)\n        this.setPaddingLeft(null)\n        this.setPaddingRight(null)\n        this.setCssProperty(\"padding\", v)\n        return this\n    }\n    \n    padding () {\n        return this.getCssProperty(\"padding\")\n    }\n\n    // top\n\n    setPaddingTop (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-top\", v)\n        return this\n    }\n\n    paddingTop () {\n        return this.getCssProperty(\"padding-top\")\n    }\n    // bottom\n\n    setPaddingBottom (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-bottom\", v)\n        return this\n    }\n\n    paddingBottom () {\n        return this.getCssProperty(\"padding-bottom\")\n    }\n\n    // left\n\n    setPaddingLeft (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-left\", v)\n        return this\n    }\n\n    paddingLeft () {\n        return this.getCssProperty(\"padding-left\")\n    }\n\n    // right\n    \n    setPaddingRight (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"padding-right\", v)\n        return this\n    }\n\n    paddingRight () {\n        return this.getCssProperty(\"padding-right\")\n    }\n\n    // padding px\n\n    setPaddingPx (aNumber) {\n        this.setPxCssProperty(\"padding\", aNumber)\n        return this\n    }\n\n    paddingPx () {\n        return this.getPxCssProperty(\"padding\")\n    }\n\n    // padding right px\n\n    setPaddingRightPx (aNumber) {\n        this.setPxCssProperty(\"padding-right\", aNumber)\n        return this\n    }\n\n    paddingRightPx () {\n        return this.getPxCssProperty(\"padding-right\")\n    }\n\n    // padding left px\n\n    setPaddingLeftPx (aNumber) {\n        this.setPxCssProperty(\"padding-left\", aNumber)\n        return this\n    }\n\n    paddingLeftPx () {\n        return this.getPxCssProperty(\"padding-left\")\n    }\n\n    // padding top px\n\n    setPaddingTopPx (aNumber) {\n        this.setPxCssProperty(\"padding-top\", aNumber)\n        return this\n    }\n\n    paddingTopPx () {\n        return this.getPxCssProperty(\"padding-top\")\n    }\n\n    // padding bottom px\n\n    setPaddingBottomPx (aNumber) {\n        this.setPxCssProperty(\"padding-bottom\", aNumber)\n        return this\n    }\n\n    paddingBottomPx () {\n        return this.getPxCssProperty(\"padding-bottom\")\n    }\n\n    // background color\n\n    setBackgroundColor (v) {\n        this.setCssProperty(\"background-color\", v)\n        return this\n    }\n\n    backgroundColor () {\n        return this.getCssProperty(\"background-color\")\n    }\n\n    computedBackgroundColor () {\n        return this.getComputedCssProperty(\"background-color\")\n    }\n\n    // background image\n\n    setBackgroundImage (v) {\n        this.setCssProperty(\"background-image\", v)\n        return this\n    }\n\n    backgroundImage () {\n        return this.getCssProperty(\"background-image\")\n    }\n\n    setBackgroundImageUrlPath (path) {\n        this.setBackgroundImage(\"url(\\\"\" + path + \"\\\")\")\n        return this\n    }\n\n    // background size\n\n    setBackgroundSizeWH (x, y) {\n        this.setCssProperty(\"background-size\", x + \"px \" + y + \"px\")\n        return this\n    }\n\n    setBackgroundSize (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"background-size\", v)\n        return this\n    }\n\n    makeBackgroundCover () {\n        this.setBackgroundSize(\"cover\")\n        return this\n    }\n\n    makeBackgroundContain () {\n        this.setBackgroundSize(\"contain\")\n        return this\n    }\n\n    // background repeat\n\n    makeBackgroundNoRepeat () {\n        this.setBackgroundRepeat(\"no-repeat\")\n        return this\n    }\n\n    setBackgroundRepeat (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"background-repeat\", s)\n        return this\n    }\n\n    backgroundRepeat () {\n        return this.getCssProperty(\"background-repeat\")\n    }\n\n    // background position\n\n    makeBackgroundCentered () {\n        this.setBackgroundPosition(\"center\")\n        return this\n    }\n\n    setBackgroundPosition (s) {\n        this.setCssProperty(\"background-position\", s)\n        return this\n    }\n\n    backgroundPosition () {\n        return this.getCssProperty(\"background-position\")\n    }\n\n    // icons - TODO: find a better place for this\n\n    pathForIconName (aName) {\n        const pathSeparator = \"/\"\n        return [\"strvct\", \"resources\", \"icons\", aName + \".svg\"].join(pathSeparator)\n    }\n\n    // transition\n\n    justSetTransition (s) {\n        this.setCssProperty(\"transition\", s)\n        return this\n    }\n\n    setTransition (s) {\n        this.justSetTransition(s)\n\n        if (this._transitions) {\n            //debugger;\n            this.transitions().syncFromDomView()\n        }\n\n        return this\n    }\n\n    transition () {\n        return this.getCssProperty(\"transition\")\n    }\n\n    // --- transition duration ---\n\n    setTransitionDuration (s) {\n        this.setCssProperty(\"transition-duration\", s);\n        return this;\n    }\n\n    transitionDuration () {\n        return this.getCssProperty(\"transition-duration\");\n    }\n\n    // --- transition timing function ---\n\n    setTransitionTimingFunction (s) {\n        this.setCssProperty(\"transition-timing-function\", s);\n        return this;\n    }\n\n    transitionTimingFunction () {\n        return this.getCssProperty(\"transition-timing-function\");\n    }\n\n    // --- transition delay ---\n\n    setTransitionDelay (s) {\n        this.setCssProperty(\"transition-delay\", s);\n        return this;\n    }\n\n    transitionDelay () {\n        return this.getCssProperty(\"transition-delay\");\n    }\n\n    // helper for hide/unhide transition\n\n    isTransitionHidden () {\n        return !Type.isNullOrUndefined(this.hiddenTransitionValue())\n    }\n\n    hideTransition () {\n        if (!this.isTransitionHidden()) {\n            this.setHiddenTransitionValue(this.transition())\n            this.setTransition(\"all 0s\")\n            this.subviews().forEach(sv => sv.hideTransition())\n        }\n        return this\n    }\n\n    unhideTransition () {\n        if (this.isTransitionHidden()) {\n            this.setTransition(this.hiddenTransitionValue())\n            this.setHiddenTransitionValue(null)\n            this.subviews().forEach(sv => sv.unhideTransition())\n        } else {\n            this.setTransition(null)\n        }\n        return this\n    }\n\n    // hide/unhide transition\n\n    /*\n    hideTransition () {\n        if (!Type.isNull(this.transition())) {\n            this.setHiddenTransitionValue(this.transition())\n            this.setTransition(null)\n            this.subviews().forEach(sv => sv.hideTransition())\n        }\n        return this\n    }\n\n    unhideTransition () {\n        if (Type.isNull(this.transition())) {\n            if (this.hiddenTransitionValue()) {\n                this.setTransition(this.hiddenTransitionValue())\n                this.setHiddenTransitionValue(null)\n                this.subviews().forEach(sv => sv.unhideTransition())\n            }\n        }\n        return this\n    }\n    */\n\n    // transitions\n\n    transitions () {\n        if (this._transitions == null) {\n            this._transitions = DomTransitions.clone().setDomView(this).syncFromDomView()\n        }\n        return this._transitions\n    }\n\n    // transforms\n\n    setTransform (s) {\n        this.setCssProperty(\"transform\", s)\n        return this\n    }\n\n    setTransformOrigin (s) {\n        //transform-origin: x-axis y-axis z-axis|initial|inherit;\n        //const percentageString = this.percentageNumberToString(aNumber)\n        this.setCssProperty(\"transform-origin\", s)\n        return this\n    }\n\n    /*\n    TODO: add setter/getters for:\n\n        perspective-origin: x-axis y-axis|initial|inherit;\n        transform-style: flat|preserve-3d|initial|inherit;\n        backface-visibility: hidden | visible;\n\n    */\n\n    // perspective\n\n    setPerspective (n) {\n        this.setPxCssProperty(\"perspective\", n)\n        return this\n    }\n\n    // opacity\n\n    opacityValidatorFunction () {\n        return (v) => { return Type.isNumber(v) || [null, \"auto\", \"inherit\", \"initial\", \"unset\"].contains(v) }\n    }\n\n    setOpacity (v) {\n        //assert(this.opacityValidatorFunction()(v))\n        this.setCssProperty(\"opacity\", v)\n        return this\n    }\n\n    opacity () {\n        return this.getCssProperty(\"opacity\")\n    }\n\n    // z index \n\n    setZIndex (v) {\n        this.setCssProperty(\"z-index\", v)\n        return this\n    }\n\n    zIndex () {\n        return this.getCssProperty(\"z-index\")\n    }\n\n    // cursor \n\n    setCursor (s) {\n        this.setCssProperty(\"cursor\", s)\n        return this\n    }\n\n    cursor () {\n        return this.getCssProperty(\"cursor\")\n    }\n\n    makeCursorDefault () {\n        this.setCursor(\"default\")\n        return this\n    }\n\n    makeCursorPointer () {\n        this.setCursor(\"pointer\")\n        return this\n    }\n\n    makeCursorText () {\n        this.setCursor(\"text\")\n        return this\n    }\n\n    makeCursorGrab () {\n        this.setCursor(\"grab\")\n        return this\n    }\n\n    makeCursorGrabbing () {\n        this.setCursor(\"grabbing\")\n        return this\n    }\n\n    makeCursorColResize () {\n        this.setCursor(\"col-resize\")\n        return this\n    }\n\n    makeCursorTileResize () {\n        this.setCursor(\"row-resize\")\n        return this\n    }\n\n\n    // top\n\n    setTop (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"top\", v)\n        return this\n    }\n\n    top () {\n        return this.getCssProperty(\"top\")\n    }\n\n    // top px\n\n    setTopPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"top\", v)\n        return this\n    }\n\n    topPx () {\n        return this.getPxCssProperty(\"top\")\n    }\n\n    // left\n\n    setLeft (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"left\", v)\n        return this\n    }\n\n    left () {\n        return this.getCssProperty(\"left\")\n    }\n\n    // left px\n\n    setLeftPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"left\", v)\n        return this\n    }\n\n    leftPx () {\n        return this.getPxCssProperty(\"left\")\n    }\n\n    // right\n\n    setRight (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"right\", v)\n        return this\n    }\n\n\n    right () {\n        return this.getCssProperty(\"right\")\n    }\n\n    // right px\n\n    setRightPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"right\", v)\n        return this\n    }\n\n    rightPx () {\n        return this.getPxCssProperty(\"right\")\n    }\n\n    // bottom\n\n    setBottom (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"bottom\", v)\n        return this\n    }\n\n    bottom () {\n        return this.getCssProperty(\"bottom\")\n    }\n\n    // bottom px\n\n    setBottomPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"bottom\", v)\n        return this\n    }\n\n    bottomPx () {\n        return this.getPxCssProperty(\"bottom\")\n    }\n\n    // float\n\n    validFloatPropertyValues () {\n        return [null, \"left\", \"right\", \"none\", \"inline-start\", \"inline-end\", \"start\", \"end\", \"initial\", \"inherit\"]\n    }\n\n    setFloat (v) {\n        assert(this.validFloatPropertyValues().contains(v))\n        this.setCssProperty(\"float\", v)\n        return this\n    }\n\n    float () {\n        return this.getCssProperty(\"float\")\n    }\n\n    // box shadow\n\n    setBoxShadow (s) {\n        //this.debugLog(\".setBoxShadow(\" + s + \")\")\n        this.setCssProperty(\"box-shadow\", s)\n        return this\n    }\n\n    boxShadow () {\n        return this.getCssProperty(\"box-shadow\")\n    }\n\n    // sizing\n\n    validBoxSizingPropertyValues () {\n        return [null, \"inherit\", \"content-box\", \"border-box\"]\n    }\n\n    setBoxSizing (s) {\n        assert(this.validBoxSizingPropertyValues().contains(s))\n        return this.setCssProperty(\"box-sizing\", s)\n    }\n\n    boxSizing () {\n        return this.getCssProperty(\"box-sizing\")\n    }\n\n\n    // gap \n\n    setGap (s) {\n        this.setCssProperty(\"gap\", s)\n        return this\n    }\n\n    gap () {\n        return this.getCssProperty(\"gap\")\n    }\n\n\n    // border \n\n    setBorder (s) {\n        this.setCssProperty(\"border\", s)\n        return this\n    }\n\n    border () {\n        return this.getCssProperty(\"border\")\n    }\n\n    // border style\n\n    setBorderStyle (s) {\n        this.setCssProperty(\"border-style\", s)\n        return this\n    }\n\n    borderStyle () {\n        return this.getCssProperty(\"border-style\")\n    }\n\n    // border color\n\n    setBorderColor (s) {\n        this.setCssProperty(\"border-color\", s)\n        return this\n    }\n\n    borderColor () {\n        return this.getCssProperty(\"border-color\")\n    }\n\n    // border top\n\n    setBorderTop (s) {\n        this.setCssProperty(\"border-top\", s)\n        return this\n    }\n\n    borderTop () {\n        return this.getCssProperty(\"border-top\")\n    }\n\n    setBorderTopStyle (s) {\n        this.setCssProperty(\"border-top-style\", s)\n        return this\n    }\n\n    setBorderTopWidth (s) {\n        this.setCssProperty(\"border-top-width\", s)\n        return this\n    }\n\n    setBorderTopColor (s) {\n        this.setCssProperty(\"border-top-color\", s)\n        return this\n    }\n\n    // border bottom\n\n    setBorderBottom (s) {\n        this.setCssProperty(\"border-bottom\", s)\n        return this\n    }\n\n    borderBottom () {\n        return this.getCssProperty(\"border-bottom\")\n    }\n\n    setBorderBottomStyle (s) {\n        this.setCssProperty(\"border-bottom-style\", s)\n        return this\n    }\n\n    setBorderBottomWidth (s) {\n        this.setCssProperty(\"border-bottom-width\", s)\n        return this\n    }\n\n    setBorderBottomColor (s) {\n        this.setCssProperty(\"border-bottom-color\", s)\n        return this\n    }\n\n    // border left\n\n    setBorderLeft (s) {\n        //this.debugLog(\" border-left set '\", s, \"'\")\n        this.setCssProperty(\"border-left\", s)\n        return this\n    }\n\n    borderLeft () {\n        return this.getCssProperty(\"border-left\")\n    }\n\n    setBorderLeftStyle (s) {\n        this.setCssProperty(\"border-left-style\", s)\n        return this\n    }\n\n    setBorderLeftWidth (s) {\n        this.setCssProperty(\"border-left-width\", s)\n        return this\n    }\n\n    setBorderLeftColor (s) {\n        this.setCssProperty(\"border-left-color\", s)\n        return this\n    }\n\n    // border right\n\n    setBorderRight (s) {\n        this.setCssProperty(\"border-right\", s)\n        return this\n    }\n\n    borderRight () {\n        return this.getCssProperty(\"border-right\")\n    }\n\n    borderRightPx () {\n        return this.getPxCssProperty(\"border-right\")\n    }\n\n    setBorderRightStyle (s) {\n        this.setCssProperty(\"border-right-style\", s)\n        return this\n    }\n\n    setBorderRightWidth (s) {\n        this.setCssProperty(\"border-right-width\", s)\n        return this\n    }\n\n    setBorderRightColor (s) {\n        this.setCssProperty(\"border-right-color\", s)\n        return this\n    }\n\n\n    // border radius\n\n    setBorderRadius (v) {\n        assert(Type.isNull(v) || Type.isString(v))\n        this.setCssProperty(\"border-radius\", v)\n        return this\n    }\n\n    borderRadius () {\n        return this.getCssProperty(\"border-radius\")\n    }\n\n    // border radius\n\n    setBorderRadiusPx (v) {\n        assert(Type.isNull(v) || Type.isNumber(v))\n        this.setPxCssProperty(\"border-radius\", v)\n        return this\n    }\n\n    borderRadiusPx () {\n        return this.getPxCssProperty(\"border-radius\")\n    }\n\n    // outline\n\n    setOutline (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"outline\", s)\n        return this\n    }\n\n    outline () {\n        return this.getCssProperty(\"outline\")\n    }\n\n    // px line height\n\n    setPxLineHeight (aNumber) {\n        this.setPxCssProperty(\"line-height\", aNumber)\n        assert(this.lineHeight() === aNumber)\n        return this\n    }\n\n    pxLineHeight () {\n        return this.getPxCssProperty(\"line-height\")\n    }\n\n    // line height\n\n    setLineHeight (aString) {\n        assert(Type.isString(aString) || Type.isNull(aString))\n        this.setCssProperty(\"line-height\", aString)\n        return this\n    }\n\n    lineHeight () {\n        return this.getCssProperty(\"line-height\")\n    }\n\n    // alignment\n\n    validTextAlignValues () {\n        return [null, \"left\", \"right\", \"center\", \"justify\", \"justify-all\", \"start\", \"end\", \"match-parent\", \"initial\", \"inherit\", \"unset\"]\n    }\n\n    setTextAlign (v) {\n        assert(this.validTextAlignValues().contains(v))\n        this.setCssProperty(\"text-align\", v)\n        return this\n    }\n\n    textAlign () {\n        return this.getCssProperty(\"text-align\")\n    }\n\n    // clear\n\n    setClear (v) {\n        assert([null, \"none\", \"left\", \"right\", \"both\", \"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"clear\", v)\n        return this\n    }\n\n    clear () {\n        return this.getCssProperty(\"clear\")\n    }\n\n    // flex \n\n    setFlex (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"flex\", v)\n        return this\n    }\n\n    flex () {\n        return this.getCssProperty(\"flex\")\n    }\n\n    // flex wrap\n\n    setFlexWrap (v) {\n        assert([\"nowrap\", \"wrap\", \"wrap-reverse\", \"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"flex-wrap\", v)\n        return this\n    }\n\n    flex () {\n        return this.getCssProperty(\"flex-wrap\")\n    }\n\n    // flex order\n\n    setOrder (v) {\n        assert(Type.isNull(v) || Type.isNumber(v) || [\"initial\", \"inherit\"].contains(v))\n        this.setCssProperty(\"order\", v)\n        return this\n    }\n\n    order () {\n        return this.getCssProperty(\"order\")\n    }\n\n    // flex align-items (flex-start, center, flex-end) - NOTE: alignment depends on direct of flex!\n\n    validAlignItemsPropertyValues () {\n        return [null, \"flex-start\", \"center\", \"flex-end\", \"space-between\", \"space-around\", \"stretch\"]\n    }\n\n    setAlignItems (v) {\n        assert(this.validAlignItemsPropertyValues().contains(v))\n        this.setCssProperty(\"align-items\", v)\n        return this\n    }\n\n    alignItems () {\n        return this.getCssProperty(\"align-items\")\n    }\n\n    // flex justify-content (flex-start, center, flex-end) - NOTE: alignment depends on direct of flex!\n    \n    validJustifyContentPropertyValues () {\n        return [null, \"flex-start\", \"center\", \"flex-end\", \"space-between\", \"space-around\"]\n    }\n\n    setJustifyContent (v) {\n        assert(this.validJustifyContentPropertyValues().contains(v))\n        this.setCssProperty(\"justify-content\", v)\n        return this\n    }\n\n    justifyContent () {\n        return this.getCssProperty(\"justify-content\")\n    }\n\n    // flex direction - (row, column)\n\n    setFlexDirection (v) {\n        this.setCssProperty(\"flex-direction\", v)\n        return this\n    }\n\n    flexDirection () {\n        return this.getCssProperty(\"flex-direction\")\n    }\n\n    // flex grow\n\n    setFlexGrow (v) {\n        this.setCssProperty(\"flex-grow\", v)\n        return this\n    }\n\n    flexGrow () {\n        return this.getCssProperty(\"flex-grow\")\n    }\n\n    // flex shrink\n\n    setFlexShrink (v) {\n        this.setCssProperty(\"flex-shrink\", v)\n        return this\n    }\n\n    flexShrink () {\n        return this.getCssProperty(\"flex-shrink\")\n    }\n\n    // flex basis\n\n    setFlexBasis (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"flex-basis\", v)\n        return this\n    }\n\n    flexBasis () {\n        return this.getCssProperty(\"flex-basis\")\n    }\n\n    // color\n\n    setColor (v) {\n        this.setCssProperty(\"color\", v)\n        return this\n    }\n\n    color () {\n        return this.getCssProperty(\"color\")\n    }\n\n    // filters\n\n    setFilter (s) {\n        this.setCssProperty(\"filter\", s)\n        return this\n    }\n\n    filter () {\n        return this.getCssProperty(\"filter\")\n    }\n\n    // visibility\n\n    setIsVisible (aBool) {\n        const v = aBool ? \"visible\" : \"hidden\"\n        this.setCssProperty(\"visibility\", v)\n        return this\n    }\n\n    isVisible () {\n        return this.getCssProperty(\"visibility\") !== \"hidden\";\n    }\n\n    // display\n\n    setDisplay (s) {\n        //assert(s in { \"none\", ...} );\n        if (this.hiddenDisplayMode()) {\n            this.setHiddenDisplayValue(s);\n        } else {\n            this.setCssProperty(\"display\", s);\n        }\n        return this\n    }\n\n    display () {\n        return this.getCssProperty(\"display\")\n    }\n\n    // hide height\n\n    /*\n    hideHeight () {\n\t\tif (Type.isUndefined(this.hiddenMinHeight())) {\n            this.setHiddenMinHeight(this.minHeight())\n            this.setHiddenMaxHeight(this.maxHeight())\n            this.setMinAndMaxHeight(\"0em\")\n        }\n\t\treturn this\n\t}\n\t\n\tunhideHeight () {\n\t\tif (!Type.isUndefined(this.hiddenMinHeight())) {\n\t\t\tthis.setMinHeight(this.hiddenMaxHeight())\n\t\t\tthis.setHiddenMinHeight(undefined)\n\n\t\t\tthis.setMaxHeight(this.hiddenMaxHeight())\n\t\t\tthis.setHiddenMaxHeight(undefined)\n\t\t}\n\t\t\n\t\treturn this\n\t}\n    */\n\n    // helper for hide/show display\n\n    setIsDisplayHidden (aBool) {\n        if (aBool) {\n            this.hideDisplay()\n        } else {\n            this.unhideDisplay()\n        }\n        return this\n    }\n\n    isDisplayHidden () {\n        return this.hiddenDisplayMode()\n    }\n\n    hideDisplay () {\n        if (!this.hiddenDisplayMode()) {\n            this.setHiddenDisplayValue(this.display());\n            this.setDisplay(\"none\"); // must call *before* setHiddenDisplayMode(true)\n            this.setHiddenDisplayMode(true);\n        }\n        return this\n    }\n\n    unhideDisplay () {\n        if (this.hiddenDisplayMode()) {\n            const oldValue = this.hiddenDisplayValue();\n            this.setHiddenDisplayValue(null); \n            assert(oldValue);\n            if (oldValue) {\n                this.setHiddenDisplayMode(false); // must call *before* setDisplay()\n                this.setDisplay(oldValue);\n            }\n        }\n        this.setHiddenDisplayMode(false); // must call *before* setDisplay()\n        return this\n    }\n\n    // visibility\n\n    setVisibility (s) {\n        this.setCssProperty(\"visibility\", s)\n        return this\n    }\n\n    visibility () {\n        return this.getCssProperty(\"visibility\")\n    }\n\n    // white space\n\n    setWhiteSpace (s) {\n        this.setCssProperty(\"white-space\", s)\n        return this\n    }\n\n    whiteSpace () {\n        return this.getCssProperty(\"white-space\")\n    }\n\n\n    // word-break\n\n    setWordBreak (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"word-break\", s)\n        return this\n    }\n\n    wordBreak () {\n        return this.getCssProperty(\"word-break\")\n    }\n\n    // webkit specific\n\n    overflowScrollingValidValues () {\n        return [null, \"auto\", \"touch\", \"inherit\", \"initial\", \"unset\"];\n    }\n    \n    setOverflowScrolling (s) {\n        //assert(Type.isString(s))\n        assert(this.overflowScrollingValidValues().contains(s))\n        this.setCssProperty(\"overflow-scrolling\", s);\n        this.setWebkitOverflowScrolling(s);\n\n        //const style = this.cssStyle();\n        //style.setProperty(\"overflow-scrolling\", s, \"important\");\n        /*\n        if(this.overflowScrolling() !== s) {\n            // this happens even in Chrome v123.0.6312.87 (2024)\n            console.warn(this.type() + \" WARNING: setOverflowScrolling('\" + s + \"') failed (got '\" + this.overflowScrolling() + \"')\");\n        }\n        */\n        return this\n    }\n\n    overflowScrolling () {\n        return this.getCssProperty(\"overflow-scrolling\")\n    }\n\n    // webkit specific\n\n    setWebkitOverflowScrolling (s) {    \n        // NOTE: try to use setOverflowScrolling() instead, it will call this too\n        assert(Type.isString(s))\n        this.setSpecialCssProperty(\"-webkit-overflow-scrolling\", s)\n        if(this.webkitOverflowScrolling() !== s) {\n            console.warn(this.type() + \" WARNING: setWebkitOverflowScrolling failed\")\n        }\n        return this\n    }\n\n    webkitOverflowScrolling () {\n        return this.getSpecialCssProperty(\"-webkit-overflow-scrolling\")\n    }\n\n    // ms specific \n\n    setMsOverflowStyle (s) {\n        /* -ms-overflow-style: none; removes scrollbars on IE 10+  */\n        assert(Type.isString(s))\n        this.setSpecialCssProperty(\"-ms-overflow-style\", s)\n        assert(this.msOverflowStyle() === s)\n        return this\n    }\n\n    msOverflowStyle () {\n        return this.getSpecialCssProperty(\"-ms-overflow-style\")\n    }\n\n\n    // overflow\n\n    setOverflow (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow\", s)\n        return this\n    }\n\n    overflow () {\n        return this.getCssProperty(\"overflow\")\n    }\n\n    // overflow wrap\n\n    setOverflowWrap (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow-wrap\", s)\n        return this\n    }\n\n    overflowWrap () {\n        return this.getCssProperty(\"overflow-wrap\")\n    }\n\n    // overflow x\n\n    setOverflowX (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow-x\", s)\n        return this\n    }\n\n    overflowX () {\n        return this.getCssProperty(\"overflow-x\")\n    }\n\n    // overflow y\n\n    setOverflowY (s) {\n        assert(Type.isString(s))\n        this.setCssProperty(\"overflow-y\", s)\n        return this\n    }\n\n    overflowY () {\n        return this.getCssProperty(\"overflow-y\")\n    }\n\n    /*\t\n\n    // text over flow\n\n    // Overflow behavior at line end\n    // Right end if ltr, left end if rtl \n    text-overflow: clip;\n    text-overflow: ellipsis;\n    text-overflow: \"…\";\n    text-overflow: fade;\n    text-overflow: fade(10px);\n    text-overflow: fade(5%);\n\n    // Overflow behavior at left end | at right end\n    // Directionality has no influence \n    text-overflow: clip ellipsis;\n    text-overflow: \"…\" \"…\";\n    text-overflow: fade clip;\n    text-overflow: fade(10px) fade(10px);\n    text-overflow: fade(5%) fade(5%);\n\n    // Global values \n    text-overflow: inherit;\n    text-overflow: initial;\n    text-overflow: unset;\n    */\n\n    setTextOverflow (s) {\n        this.setCssProperty(\"text-overflow\", s)\n        return this\n    }\n\n    textOverflow () {\n        return this.getCssProperty(\"text-overflow\")\n    }\n\n\n    // user select\n\n    userSelectKeys () {\n        return [\n            \"-moz-user-select\",\n            \"-khtml-user-select\",\n            \"-webkit-user-select\",\n            \"-o-user-select\"\n        ]\n    }\n\n    userSelect () {\n        const style = this.cssStyle()\n        let result = this.userSelectKeys().detect(key => style[key])\n        result = result || style.userSelect\n        return result\n    }\n\n    turnOffUserSelect () {\n        this.setUserSelect(\"none\");\n        return this\n    }\n\n    turnOnUserSelect () {\n        this.setUserSelect(\"text\")\n        return this\n    }\n\n    // user selection \n\n    setUserSelect (aString) {\n        const style = this.cssStyle()\n        //console.log(\"'\" + aString + \"' this.userSelect() = '\" + this.userSelect() + \"' === \", this.userSelect() == aString)\n        if (this.userSelect() !== aString) {\n            style.userSelect = aString\n            this.userSelectKeys().forEach(key => style[key] = aString)\n        }\n        return this\n    }\n\n    // spell check\n\n    setSpellCheck (aBool) {\n        this.element().setAttribute(\"spellcheck\", aBool);\n        return this\n    }\n\n    // tool tip\n\n    setToolTip (aName) {\n        if (aName) {\n            this.element().setAttribute(\"title\", aName);\n        } else {\n            this.element().removeAttribute(\"title\");\n        }\n        return this\n    }\n\n    // width and height\n\n    computedWidth () {\n        //return this.calcSize().width()\n        return this.getComputedPxCssProperty(\"width\")\n    }\n\n    computedHeight () {\n        //return this.calcSize().height()\n        return this.getComputedPxCssProperty(\"height\")\n    }\n\n    // desired size\n\n    desiredWidth () {\n        return this.calcWidth()\n    }\n\n    desiredHeight () {\n        return this.calcHeight()\n    }\n\n    // calculated size (outside of parent view)\n\n    calcSize () {\n        assert(this.parentView())\n\n        const e = this.element()\n        assert(e.parentNode)\n\n        // reads\n        this.didDomRead(\"display\")\n        //this.didDomRead(\"position\")\n        //this.didDomRead(\"width\")\n        const display = e.style.display\n        const position = e.style.position\n        const width = e.style.width\n\n        // writes\n        this.didDomWrite(\"display\")\n        //this.didDomWrite(\"position\")\n        //this.didDomWrite(\"width\")\n        e.style.display = \"block\"\n        e.style.position = \"absolute\"\n        e.style.width = \"auto\"\n\n        // read calc\n        this.didDomRead(\"clientWidth\")\n        //this.didDomRead(\"clientHeight\")\n        const w = (e.clientWidth + 1) \n        const h = (e.clientHeight + 1) \n        //const size = { width: w, height: h }\n        const size = Point.clone().setXY(w, h).freeze()\n\n        // write\n        this.didDomWrite(\"display\")\n        //this.didDomWrite(\"position\")\n        //this.didDomWrite(\"width\")\n        e.style.display = display\n        e.style.position = position\n        e.style.width = width\n\n        if (w === 1 && h === 1) {\n            assert(e.hasAncestor(document.body)) // client measurements will be zero if it's not in a document\n        }\n\n        this.setCachedSize(size)\n        return size\n    }\n\n    cacheClientSize () {\n        if (this.display() === \"none\") {\n            return Point.clone().freeze()\n        }\n\n        const e = this.element()\n        this.setCachedSize(Point.clone().setXY(e.clientWidth, e.clientHeight).freeze())\n        return this\n    }\n\n    cachedSize () {\n        if (this.display() === \"none\") {\n            return Point.clone().freeze()\n        }\n        return this._cachedSize\n    }\n\n    // calculated size (within parent view)\n\n    calcWidth () {\n        if (this.display() === \"none\") {\n            return 0\n        }\n        return this.calcSize().width()\n    }\n\n    calcHeight () {\n        if (this.display() === \"none\") {\n            return 0\n        }\n        return this.calcSize().height()\n    }\n\n    // width\n\n    setWidthString (v) {\n        assert(Type.isString(v) || Type.isNull(v))\n        this.setCssProperty(\"width\", v, () => { this.didChangeWidth() })\n        return this\n    }\n\n    widthString () {\n        return this.getCssProperty(\"width\")\n    }\n\n    setWidth (s) {\n        this.setWidthString(s)\n        return this\n    }\n\n    setWidthPercentage (aNumber) {\n        const newValue = this.percentageNumberToString(aNumber)\n        this.setCssProperty(\"width\", newValue, () => { this.didChangeWidth() })\n        return this\n    }\n\n    /*\n    hideScrollbar () {\n        // need to do JS equivalent of: .class::-webkit-scrollbar { display: none; }\n\t    // this.setCssProperty(\"-webkit-scrollbar\", { display: \"none\" }) // doesn't work\n\t    return this\n    }\n    */\n\n    // clientX - includes padding but not scrollbar, border, or margin\n\n    clientWidth () {\n        return this.getAttribute(\"clientWidth\")\n    }\n\n    clientHeight () {\n        return this.getAttribute(\"clientHeight\")\n    }\n\n    // offsetX - includes borders, padding, scrollbar \n\n    offsetWidth () {\n        return this.getAttribute(\"offsetWidth\")\n    }\n\n    offsetHeight () {\n        return this.getAttribute(\"offsetHeight\")\n    }\n\n    // width px\n\n    minWidthPx () {\n        const s = this.getCssProperty(\"min-width\")\n        // TODO: support em to px translation \n        return this.pxStringToNumber(s)\n    }\n\n    maxWidthPx () {\n        const w = this.getCssProperty(\"max-width\")\n        if (w === \"\") {\n            return null\n        }\n        return this.pxStringToNumber(w)\n    }\n\n    // height px\n\n    minHeightPx () {\n        const s = this.getCssProperty(\"min-height\")\n        // TODO: support em to px translation \n        return this.pxStringToNumber(s)\n    }\n\n    maxHeightPx () {\n        const s = this.getCssProperty(\"max-height\")\n        if (s === \"\") {\n            return null\n        }\n        return this.pxStringToNumber(s)\n    }\n\n    // -----------\n\n    cssStyle () {\n        return this.element().style\n    }\n\n    setMinWidth (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"min-width\", v, () => { this.didChangeWidth() })\n        return this\n    }\n\n    didChangeWidth () {\n    }\n\n    didChangeHeight () {\n    }\n\n    // --- lock/unlock size ---\n\n    /*\n    lockSize () {\n        const h = this.computedHeight() \n        const w = this.computedWidth()\n        this.setMinAndMaxWidth(w)\n        this.setMinAndMaxHeight(h)\n        return this\n    }\n\n    unlockSize () {\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)\n        return this\n    }\n    */\n\n    // ----\n\n    displayIsFlex () {\n        // TODO: choose a better name for this method?\n        return (this.display() === \"flex\" || this.hiddenDisplayValue() === \"flex\")\n    }\n\n    // fixed width\n\n    /*\n    setFixedWidthPx (v) {\n        assert(Type.isNumber(v))\n        if (this.displayIsFlex()) {\n            this.setFlexGrow(0)\n            this.setFlexShrink(0)\n            this.setFlexBasis(v + \"px\")\n        } else {\n            this.setMinAndMaxWidth(v)\n        }\n        return this\n    }\n\n    fixedWidthPx () {\n        if (this.displayIsFlex()) {\n            const w = this.getPxCssProperty(\"flex-basis\")\n            assert(Type.isNumber(w))\n            return w\n        } else {\n            const w1 = this.getPxCssProperty(\"min-width\")\n            const w2 = this.getPxCssProperty(\"max-width\")\n            assert(Type.isNumber(w1) && w1 === w2)\n            return w1\n        }\n    }\n    */\n\n    // fixed height\n    /*\n    setFixedHeightPx (v) {\n        assert(Type.isNumber(v))\n        if (this.displayIsFlex()) {\n            this.setFlexGrow(0)\n            this.setFlexShrink(0)\n            this.setFlexBasis(v + \"px\")\n        } else {\n            this.setMinAndMaxWidth(v)\n        }\n        return this\n    }\n\n    fixedHeightPx () {\n        if (this.displayIsFlex()) {\n            const w = this.getPxCssProperty(\"flex-basis\")\n            assert(Type.isNumber(w))\n            return w\n        } else {\n            const w1 = this.getPxCssProperty(\"min-width\")\n            const w2 = this.getPxCssProperty(\"max-width\")\n            assert(Type.isNumber(w1) && w1 === w2)\n            return w1\n        }\n    }\n    */\n\n    // ----\n\n    setMinAndMaxSize (aSize) {\n        this.setMinAndMaxWidth(aSize.x())\n        this.setMinAndMaxHeight(aSize.y())\n        return this\n    }\n\n    setMaxWidth (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"max-width\", v, () => { this.didChangeWidth() })\n        return this\n    }\n\n    setMinAndMaxWidth (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"max-width\", v, () => { this.didChangeWidth() })\n        this.setCssProperty(\"min-width\", v, () => { this.didChangeWidth() })\n        if (!Type.isNull(v)) {\n            this.setCssProperty(\"width\", v, null) // avoids weird behavior but not ideal if min and max settings change do diff values\n        }\n        return this\n    }\n\n    setMinAndMaxHeight (v) {\n        if (Type.isNumber(v)) {\n            v = this.pxNumberToString(v)\n        }\n        this.setCssProperty(\"min-height\", v, () => { this.didChangeHeight() })\n        this.setCssProperty(\"max-height\", v, () => { this.didChangeHeight() })\n        if (!Type.isNull(v)) {\n            this.setCssProperty(\"height\", v, null) // avoids weird behavior but not ideal if min and max settings change do diff values\n        }\n        return this\n    }\n\n    setMinAndMaxWidthAndHeight (v) {\n        this.setMinAndMaxWidth(v)\n        this.setMinAndMaxHeight(v)\n        return this\n    }\n\n    percentageNumberToString (aNumber) {\n        assert(Type.isNumber(aNumber) && (aNumber >= 0) && (aNumber <= 100))\n        return aNumber + \"%\"\n    }\n\n    pxNumberToString (aNumber) {\n        if (Type.isNull(aNumber)) {\n            return null\n        }\n\n        if (Type.isString(aNumber)) {\n            if (aNumber.startsWith(\"calc\") || aNumber.endsWith(\"px\")) {\n                return aNumber\n            }\n        }\n\n        assert(Type.isNumber(aNumber))\n        return aNumber + \"px\"\n    }\n\n    pxStringToNumber (s) {\n        assert(Type.isString(s))\n        \n        if (s === \"\") {\n            return 0\n        }\n        \n        if (s === \"auto\") {\n            return 0\n        }\n\n        if (s.contains(\"%\")) {\n            return 0\n        }\n\n        assert(s.endsWith(\"px\"))\n        return Number(s.replace(\"px\", \"\"))\n    }\n\n    setMinAndMaxHeightPercentage (aNumber) {\n        const newValue = this.percentageNumberToString(aNumber)\n        this.setCssProperty(\"min-height\", newValue, () => { this.didChangeHeight() })\n        this.setCssProperty(\"max-height\", newValue, () => { this.didChangeHeight() })\n        return this\n    }\n\n    setHeightPercentage (aNumber) {\n        // NOTE: %s don't work unless same parent view dimension is defined\n        const newValue = this.percentageNumberToString(aNumber)\n        this.setHeightString(newValue)\n        return this\n    }\n\n    setMinWidthPx (aNumber) {\n        this.setMinWidth(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setMinHeightPx (aNumber) {\n        this.setMinHeight(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setMaxHeightPx (aNumber) {\n        this.setMaxHeight(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    maxHeight () {\n        return this.getCssProperty(\"max-height\")\n    }\n\n    minHeight () {\n        return this.getCssProperty(\"min-height\")\n    }\n\n    maxWidth () {\n        return this.getCssProperty(\"max-width\")\n    }\n\n    minWidth () {\n        return this.getCssProperty(\"min-width\")\n    }\n\n    setMinHeight (newValue) {\n        assert(Type.isString(newValue) || Type.isNull(newValue))\n        // <length> | <percentage> | auto | max-content | min-content | fit-content | fill-available\n        this.setCssProperty(\"min-height\", newValue, () => { this.didChangeHeight() })\n        return this\n    }\n\n    setMaxHeight (newValue) {\n        assert(Type.isString(newValue) || Type.isNull(newValue))\n        // <length> | <percentage> | none | max-content | min-content | fit-content | fill-available\n        this.setCssProperty(\"max-height\", newValue, () => { this.didChangeHeight() })\n        return this\n    }\n\n    setWidthPx (aNumber) {\n        this.setWidthString(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setHeightPx (aNumber) {\n        this.setHeightString(this.pxNumberToString(aNumber))\n        return this\n    }\n\n    setHeight (s) {\n        // height: auto|length|initial|inherit;\n\n        if (Type.isNumber(s)) {\n            return this.setHeightPx(s)\n        }\n        this.setHeightString(s)\n        return this\n    }\n\n    setWidthToAuto () {\n        this.setWidthString(\"auto\")\n        return this\n    }\n\n    setHeightToAuto () {\n        this.setHeightString(\"auto\")\n        return this\n    }\n\n    setHeightString (s) {\n        assert(Type.isString(s) || Type.isNull(s))\n        this.setCssProperty(\"height\", s, () => { this.didChangeHeight() })\n        return this\n    }\n\n    height () {\n        return this.getCssProperty(\"height\")\n    }\n\n    // --- string ---\n\n    setString (v) {\n        return this.setTextContent(v)\n        //return this.setInnerHtml(v)\n    }\n\n    string () {\n        return this.textContent()\n        //return this.innerHtml()\n    }\n\n    // --- innerHTML ---\n\n    innerHtml () {\n        return this.getAttribute(\"innerHTML\")\n        //return this.element().innerHTML\n    }\n\n    setInnerHtml (v) {\n        this.setAttribute(\"innerHTML\", v)\n        //this.element().innerHTML = v\n        return this\n    }\n\n    // --- innerText ---\n\n    setInnerText (v) {\n        const e = this.element().innerText = v\n        return this\n    }\n\n    innerText () {\n        const e = this.element()\n        return e.innerText \n        //return e.textContent || e.innerText || \"\";\n    }\n\n    // --- textContent ---\n\n    setTextContent (v) {\n        this.element().textContent = v\n        //this.setAttribute(\"textContent\", v)\n        return this\n    }\n\n    textContent () {\n        return this.element().textContent\n        //return this.getAttribute(\"textContent\")\n    }\n\n    // --- touch events ---\n\n    setTouchAction (s) {\n        this.setCssProperty(\"-ms-touch-action\", s) // needed?\n        this.setCssProperty(\"touch-action\", s)\n        return this\n    }\n\n    // scroll top\n\n    setScrollTop (v) {\n        this.setAttribute(\"scrollTop\", v)\n        return this\n    }\n\n    scrollTop () {\n        return this.getAttribute(\"scrollTop\")\n    }\n\n    // scroll width & scroll height\n\n    scrollWidth () { \n        // a read-only value\n        return this.getAttribute(\"scrollWidth\")\n    }\n\n    scrollHeight () {\n        // a read-only value\n        return this.getAttribute(\"scrollHeight\") \n    }\n\n    // offset width & offset height\n\n    offsetLeft () {\n        // a read-only value\n        return this.getAttribute(\"offsetLeft\")\n    }\n\n    offsetTop () {\n        // a read-only value\n        return this.getAttribute(\"offsetTop\")\n    }\n\n    boundingClientRect () {\n        this.didDomRead(\"boundingClientRect\")\n        return this.element().getBoundingClientRect()\n    }\n\n    viewportX () {\n        return this.boundingClientRect().x\n    }\n\n    viewportY () {\n        return this.boundingClientRect().y\n    }\n\n    /*\n    containsViewportPoint () {\n        throw new Error(\"unimplemented\")\n    }\n    */\n\n\n    // --------------------------------------------------------------\n    // --------------------------------------------------------------\n    // --------------------------------------------------------------\n\n\n    // view position helpers ----\n\n    setRelativePos (p) {\n        // why not a 2d transform?\n        this.setLeftPx(p.x())\n        this.setTopPx(p.y())\n        return this\n    }\n\n    containsPoint (aPoint) {\n        // point must be in document coordinates\n        return this.frameInDocument().containsPoint(aPoint)\n    }\n\n    // viewport coordinates helpers\n\n    frameInViewport () {\n        const origin = this.positionInViewport()\n        const size = this.sizeInViewport()\n        const frame = Rectangle.clone().setOrigin(origin).setSize(size)\n        return frame\n    }\n\n    positionInViewport () {\n        const box = this.boundingClientRect();\n        return Point.clone().set(Math.round(box.left), Math.round(box.top));\n    }\n\n    sizeInViewport () {\n        const box = this.boundingClientRect();\n        return Point.clone().set(Math.round(box.width), Math.round(box.height));\n    }\n\n    // document coordinates helpers\n\n    // --- document positioning ---\n\n    setFrameInDocument (aRect) {\n        this.setPosition(\"absolute\")\n        this.setLeftPx(aRect.origin().x())\n        this.setTopPx(aRect.origin().y())\n        this.setMinAndMaxSize(aRect.size())\n        return this\n    }\n\n    frameInDocument () {\n        const origin = this.positionInDocument()\n        const size = this.size()\n        const frame = Rectangle.clone().setOrigin(origin).setSize(size)\n\n        //const size = this.calcSize() // this.size()\n        //onst frame = Rectangle.clone().setOrigin(origin)\n        //frame.size().setX(size.width).setY(size.height)\n\n        return frame\n    }\n\n    // -------------------\n    // fixed - assumes position is absolute and width and height are fixed via min-width === max-width, etc\n    // -------------------\n\n    // fixed position\n\n    hasFixedX () {\n        return !Type.isNullOrUndefined(this.leftPx() ) \n    }\n\n    hasFixedY () {\n        return !Type.isNullOrUndefined(this.topPx() ) \n    }\n\n    hasFixedPosition () {\n        return this.position() === \"absolute\" && this.hasFixedX() && this.hasFixedY()\n    }\n\n    // fixed size\n\n    hasFixedSize () {\n        return this.hasFixedWidth() && this.hasFixedHeight()\n    }\n\n    hasFixedWidth () {\n        const v1 = this.minWidthPx()\n        const v2 = this.maxWidthPx()\n        return !Type.isNullOrUndefined(v1) && v1 === v2\n    }\n\n    hasFixedHeight () {\n        const v1 = this.minHeightPx()\n        const v2 = this.maxHeightPx()\n        return !Type.isNullOrUndefined(v1) && v1 === v2\n    }\n\n    decrementFixedWidth () {\n        assert(this.hasFixedWidth())\n        this.setMinAndMaxWidth(Math.max(0, this.minWidthPx()-1))\n        return this\n    }\n\n    decrementFixedHeight () {\n        assert(this.hasFixedHeight())\n        this.setMinAndMaxHeight(Math.max(0, this.minHeightPx()-1))\n        return this\n    }\n\n    // fixed frame\n\n    hasFixedFrame () {\n        return this.hasFixedPosition() && this.hasFixedSize()\n    }\n\n    fixedFrame () {\n        assert(this.hasFixedFrame())\n        const origin = Point.clone().set(Math.round(this.leftPx()), Math.round(this.topPx()))\n        const size   = Point.clone().set(Math.round(this.minWidthPx()), Math.round(this.minHeightPx()))\n        const frame  = Rectangle.clone().setOrigin(origin).setSize(size)\n        return frame\n    }\n\n    //--------------\n\n    estimatedWidthPx () {\n        const v1 = this.minWidthPx()\n        const v2 = this.maxWidthPx()\n        if (!Type.isNullOrUndefined(v1) && v1 === v2) {\n            return v1\n        }\n        return this.clientWidth()\n    }\n\n    estimatedHeightPx () {\n        const v1 = this.minHeightPx()\n        const v2 = this.maxHeightPx()\n        if (!Type.isNullOrUndefined(v1) && v1 === v2) {\n            return v1\n        }\n        return this.clientHeight()\n    }\n\n    // ------------------------\n\n    positionInDocument () {\n        this.didDomRead(\"scrollTop\")\n        //this.didDomRead(\"scrollLeft\")\n\n        const box = this.element().getBoundingClientRect();\n\n        // return Point.clone().set(Math.round(box.left), Math.round(box.top));\n\n        const body = document.body;\n        const docEl = document.documentElement;\n\n        const scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;\n        const scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;\n\n        const clientTop = docEl.clientTop || body.clientTop || 0;\n        const clientLeft = docEl.clientLeft || body.clientLeft || 0;\n\n        const top = box.top + scrollTop - clientTop;\n        const left = box.left + scrollLeft - clientLeft;\n\n        const p = Point.clone().set(Math.round(left), Math.round(top));\n        return p\n    }\n\n    size () {\n        return EventPoint.clone().set(this.clientWidth(), this.clientHeight());\n    }\n\n    // ---------------------\n\n    setFrameInParent (aRect) {\n        this.setPosition(\"absolute\")\n        this.setLeftPx(aRect.origin().x())\n        this.setTopPx(aRect.origin().y())\n        this.setMinAndMaxSize(aRect.size())\n        return this\n    }\n\n    frameInParentView () {\n        const origin = this.relativePos()\n        const size = this.size()\n        const frame = Rectangle.clone().setOrigin(origin).setSize(size)\n        return frame\n    }\n\n    // ---\n\n    relativePos () {\n        const pv = this.parentView()\n        if (pv) {\n            return this.positionInDocument().subtract(pv.positionInDocument())\n            //return pv.positionInDocument().subtract(this.positionInDocument())\n        }\n        return this.positionInDocument()\n    }\n\n    setRelativePos (p) {\n        //this.setPosition(\"absolute\")\n        this.setLeftPx(p.x())\n        this.setTopPx(p.y())\n        return this\n    }\n\n    // ---\n\n    viewPosForWindowPos (pos) {\n        return pos.subtract(this.positionInDocument())\n    }\n\n    // --------------\n\n    makeAbsolutePositionAndSize () {\n        const f = this.frameInParentView()\n        this.setFrameInParent(f)\n        return this \n    }\n\n    makeRelativePositionAndSize () {\n        // TODO: check if it's flex and set flex basis in flex direction instead?\n        this.setPosition(\"relative\")\n\n        this.setTopPx(null)\n        this.setLeftPx(null)\n        this.setRightPx(null)\n        this.setBottomPx(null)\n\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)  \n        return this \n    }\n\n    // --------------\n\n    /*\n    cancelVerticallyAlignAbsolute () {\n        this.setPosition(\"relative\")\n    }\n    */\n\n    // --- scroll actions ---\n\n    scrollToTop () {\n        this.setScrollTop(0)\n        return this\n    }\n\n    setVerticalAlign (s) {\n        this.setCssProperty(\"vertical-align\", s)\n        return this\n    }\n\n    // --- css :after :before ---\n\n    setContentAfterOrBeforeString (aString, afterOrBefore) {\n        const uniqueClassName = \"UniqueClass_\" + this.puuid()\n        const e = this.element()\n        if (e.className.indexOf(uniqueClassName) === -1) {\n            const newRuleKey = \"DomView\" + uniqueClassName + \":\" + afterOrBefore\n            const newRuleValue = \"content: \\\"\" + aString + \"\\;\"\n            //console.log(\"newRule '\" + newRuleKey + \"', '\" + newRuleValue + \"'\")\n            document.styleSheets[0].addRule(newRuleKey, newRuleValue);\n            e.className += \" \" + uniqueClassName\n        }\n        return this\n    }\n\n    setContentAfterString (s) {\n        this.setContentAfterOrBeforeString(s, \"after\")\n        return this\n    }\n\n    setContentBeforeString (s) {\n        this.setContentAfterOrBeforeString(s, \"before\")\n        return this\n    }\n\n    didDomRead (opName) {\n        //ThrashDetector.shared().didRead(opName, this)\n        return this\n    }\n\n    didDomWrite (opName) {\n        //ThrashDetector.shared().didWrite(opName, this)\n        return this\n    }\n\n    // reflow thrash avoidance helpers\n\n\n}.initThisClass());\n",
  "j0u05yor9mzxXCoxSS5cgh11N29vU5XvB/HSDjLPouA=": "\"use strict\";\n\n/*\n    SubviewsDomView\n\n    Deals with subviews and parents.\n\n*/\n\n(class SubviewsDomView extends CssDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"parentView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"subviews\", null);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setSubviews([])\n        return this\n    }\n\n    // --- parentView ---\n\n    hasParentView () {\n        return Type.isNullOrUndefined(this.parentView()) === false\n    }\n    \n    didUpdateSlotParentView (oldValue, newValue) {\n        return this\n    }\n    \n    /*\n    didUpdateSlotParentView (oldValue, newValue) {\n        const parentless = this.thisClass().viewsWithoutParents()\n\n        assert(oldValue !== newValue);\n\n        if (newValue) {\n            if (parentless.has(newValue)) {\n                console.log(\"removing \" + this.typeId() + \" from parentless\")\n            }\n            parentless.delete(this)\n        } else if (Type.isNullOrUndefined(oldValue) && !Type.isNullOrUndefined(newValue)) {\n            if (parentless.size === 0) { // is this always correct?\n                this.scheduleMethod(\"retireParentlessViews\")\n            }\n            console.log(\"adding \" + this.typeId() + \" to parentless\")\n            parentless.add(this)\n        }\n\n        return this\n    }\n\n    retireParentlessViews () {\n        this.thisClass().retireParentlessViews()\n    }\n\n    */\n\n    // --- subviews ---\n\n    hasParentViewAncestor (aView) {\n        const pv = this.parentView()\n        \n        if (!pv) {\n            return false\n        }\n\n        if (pv === aView) {\n            return true\n        }\n\n        return pv.hasParentViewAncestor(aView)\n    }\n\n    hasSubviewDescendant (aView) {\n        if (aView == this) {\n            return true\n        }\n        return this.subviews().canDetect(sv => sv.hasSubviewDescendant(aView))\n    }\n\n    allSubviewsRecursively (allViews = new Set()) {\n        allViews.add(this)\n        this.subviews().forEach(view => {\n            view.allSubviewsRecursively(allViews)\n        })\n        return allViews\n    }\n    \n    // view chains\n\n    forEachAncestorView (fn) { // should we call this ancestorViews?\n        // returned list in order of very top parent first\n        let p = this.parentView()\n        while (p) {\n            fn(p)\n            p = p.parentView()\n        }\n    }\n\n    parentViewChain () { // should we call this ancestorViews?\n        // returned list in order of very top parent first\n        const chain = []\n        let p = this.parentView()\n        while (p) {\n            chain.push(p)\n            p = p.parentView()\n        }\n        return chain.reversed()\n    }\n\n    parentViewsOfClass (aClass) {\n        return this.parentViewChain().filter(v => v.thisClass().isSubclassOf(aClass))\n    }\n\n    // --- subviews ---\n\n    subviewCount () {\n        return this.subviews().length\n    }\n\n    hasSubview (aSubview) {\n        return this.subviews().contains(aSubview)\n    }\n\n    addSubviewIfAbsent (aSubview) {\n        if (!this.hasSubview(aSubview)) {\n            this.addSubview(aSubview)\n        }\n        return this\n    }\n\n    addSubview (aSubview) {\n        assert(!Type.isNullOrUndefined(aSubview)) \n        assert(aSubview.hasElement()) \n\n        if (this.hasSubview(aSubview)) {\n            throw new Error(this.type() + \".addSubview(\" + aSubview.type() + \") attempt to add duplicate subview \")\n        }\n\n        assert(Type.isNullOrUndefined(aSubview.parentView()))\n        /*\n        if (aSubview.parentView()) {\n            aSubview.removeFromParent()\n        }\n        */\n\n        this.willAddSubview(aSubview)\n\n        this.subviews().append(aSubview)\n        //.shared().didWrite(\"appendChild\", this)\n        this.element().appendChild(aSubview.element());\n        aSubview.setParentView(this)\n\n        this.didChangeSubviewList()\n        return aSubview\n    }\n\n    addSubviews (someSubviews) {\n        someSubviews.forEach(sv => this.addSubview(sv))\n        return this\n    }\n\n    swapSubviews (sv1, sv2) {\n        assert(sv1 !== sv2)\n        assert(this.hasSubview(sv1))\n        assert(this.hasSubview(sv2))\n        \n        const i1 = this.indexOfSubview(sv1)\n        const i2 = this.indexOfSubview(sv2)\n\n        this.removeSubview(sv1)\n        this.removeSubview(sv2)\n\n        if (i1 < i2) {\n            this.atInsertSubview(i1, sv2) // i1 is smaller, so do it first\n            this.atInsertSubview(i2, sv1)\n        } else {\n            this.atInsertSubview(i2, sv1) // i2 is smaller, so do it first          \n            this.atInsertSubview(i1, sv2)\n        }\n\n        assert(this.indexOfSubview(sv1) === i2)\n        assert(this.indexOfSubview(sv2) === i1)\n\n        return this\n    }\n\n    orderSubviewFront (aSubview) {\n        if (this.subviews().last() !== aSubview) {\n            this.removeSubview(aSubview)\n            this.addSubview(aSubview)\n        }\n        return this\n    }\n\n    orderFront () {\n        const pv = this.parentView()\n        if (pv) {\n            pv.orderSubviewFront(this)\n        }\n        return this\n    }\n\n    orderSubviewBack (aSubview) {\n        this.removeSubview(aSubview)\n        this.atInsertSubview(0, aSubview)\n        return this\n    }\n\n    orderBack () {\n        const pv = this.parentView()\n        if (pv) {\n            pv.orderSubviewBack(this)\n        }\n        return this\n    }\n\n    replaceSubviewWith (oldSubview, newSubview) {\n        assert(this.hasSubview(oldSubview))\n        assert(!this.hasSubview(newSubview))\n        \n        const index = this.indexOfSubview(oldSubview)\n        this.removeSubview(oldSubview)\n        this.atInsertSubview(index, newSubview)\n\n        // TODO: remove this sanity check\n        assert(this.indexOfSubview(newSubview) === index)\n        assert(this.hasSubview(newSubview))\n        assert(!this.hasSubview(oldSubview))\n        return this\n    }\n\n    atInsertSubview (anIndex, aSubview) {\n        this.subviews().atInsert(anIndex, aSubview)\n        assert(this.subviews()[anIndex] === aSubview)\n\n        //ThrashDetector.shared().didWrite(\"atInsertElement\", this)\n        this.element().atInsertElement(anIndex, aSubview.element())\n        assert(this.element().childNodes[anIndex] === aSubview.element())\n\n        aSubview.setParentView(this) // TODO: unify with addSubview\n        this.didChangeSubviewList() // TODO:  unify with addSubview\n        return aSubview\n    }\n\n    moveSubviewToIndex (aSubview, i) {\n        assert(i < this.subviews().length)\n        assert(this.subviews().contains(aSubview))\n\n        if (this.subviews()[i] !== aSubview) {\n            this.removeSubview(aSubview)\n            this.atInsertSubview(i, aSubview)\n        }\n        return this\n    }\n\n    updateSubviewsToOrder (orderedSubviews) {\n        assert(this.subviews() !== orderedSubviews)\n        assert(this.subviews().length === orderedSubviews.length)\n\n        for (let i = 0; i < this.subviews().length; i ++) {\n            const v2 = orderedSubviews[i]\n            this.moveSubviewToIndex(v2, i)\n        }\n        \n        return this\n    }\n\n    // --- subview utilities ---\n\n    sumOfSubviewHeights () {\n        return this.subviews().sum(subview => subview.clientHeight())\n    }\n\n    performOnSubviewsExcept (methodName, exceptedSubview) {\n        this.subviews().forEach(subview => {\n            if (subview !== exceptedSubview) {\n                subview[methodName].apply(subview)\n            }\n        })\n\n        return this\n    }\n\n    // -----------------------\n\n    removeFromParentView () {\n        if (this.parentView()) {\n            this.parentView().removeSubview(this); // will set parentView to null\n        }\n        return this\n    }\n\n    removeAfterFadeDelay (delayInSeconds) {\n        // call removeSubview for a direct actions\n        // use justRemoteSubview for internal changes\n\n        this.setTransition(\"all \" + delayInSeconds + \"s\")\n\n        this.addTimeout(() => {\n            this.setOpacity(0)\n        }, 0)\n\n        this.addTimeout(() => {\n            this.parentView().removeSubview(this)\n        }, delayInSeconds * 1000)\n\n        return this\n    }\n\n    willRemove () {\n    }\n\n    didChangeSubviewList () {\n    }\n\n    hasSubview (aSubview) {\n        return this.subviews().indexOf(aSubview) !== -1;\n    }\n\n    hasChildElement (anElement) {\n        const children = this.element().childNodes\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i]\n            if (anElement === child) {\n                return true\n            }\n        }\n        return false\n    }\n\n    willAddSubview (aSubview) {\n        // for subclasses to over-ride\n    }\n\n    willRemoveSubview (aSubview) {\n        // for subclasses to over-ride\n    }\n\n    removeSubviewIfPresent (aSubview) {\n        if (this.hasSubview(aSubview)) {\n            this.removeSubview(aSubview)\n        }\n        return this\n    }\n\n    removeSubview (aSubview) {\n        //console.warn(\"WARNING: \" + this.type() + \" removeSubview \" + aSubview.type())\n\n        // sanity check - make sure it's in our subview list\n        if (!this.hasSubview(aSubview)) {\n            const msg = this.type() + \" removeSubview \" + aSubview.typeId() + \" failed - no child found among: \" + this.subviews().map(view => view.typeId())\n            //Error.showCurrentStack()\n            throw new Error(msg)\n            return aSubview\n        }\n\n        if (aSubview.parentView() !== this) {\n            throw new Error(\"attempt to remove subview by a non parent\")\n        }\n\n        // remove from subview list -  give subview a chance to deal with change\n        this.willRemoveSubview(aSubview)\n        aSubview.willRemove()\n\n        this.justRemoveSubview(aSubview)\n\n        this.didChangeSubviewList()\n\n        return aSubview\n    }\n\n    justRemoveSubview (aSubview) { // PRIVATE\n        this.subviews().remove(aSubview)\n\n        const e = aSubview.element()\n        if (this.hasChildElement(e)) { // sanity check - make we have child element \n            //ThrashDetector.shared().didWrite(\"removeChild\", this)\n            this.element().removeChild(e); // WARNING: this will trigger an immediate onBlur window event, which may cause sync actions\n\n            // sanity check - make sure element was removed\n            if (this.hasChildElement(e)) {\n                const msg = \"WARNING: \" + this.type() + \" removeSubview \" + aSubview.type() + \" failed - still has element after remove\"\n                //console.warn(msg)\n                //Error.showCurrentStack()\n                throw new Error(msg)\n            }\n        } else {\n            const msg = \"WARNING: \" + this.type() + \" removeSubview \" + aSubview.type() + \" parent element is missing this child element\"\n            throw new Error(msg)\n        }\n\n        aSubview.setParentView(null)\n        return this\n    }\n\n    removeAllSubviews () {\n        //const sv = this.subviews().shallowCopy()\n        //sv.forEach(subview => this.removeSubview(subview))\n        while(this.subviews().length) {\n            const sv = this.subviews().last()\n            this.removeSubview(sv)\n        }\n        assert(this.subviews().length === 0) // temp sanity check\n        return this\n    }\n\n    indexOfSubview (aSubview) {\n        return this.subviews().indexOf(aSubview)\n    }\n\n    subviewAfter (aSubview) {\n        const index = this.indexOfSubview(aSubview)\n        const nextIndex = index + 1\n        if (nextIndex < this.subviews().length) {\n            return this.subviews()[nextIndex]\n        }\n        return null\n    }\n\n    sendAllViewDecendants (methodName, argList) {\n        this.subviews().forEach((v) => {\n            v[methodName].apply(v, argList)\n            v.sendAllViewDecendants(methodName, argList)\n        })\n        return this\n    }\n\n    // --- updates ---\n\n    tellParentViews (msg, aView) {\n        const f = this[msg]\n        if (f) {\n            const r = f.call(this, aView) \n            if (r === true) {\n                return // stop propogation on first view returning non-false\n            }\n        }\n\n        const p = this.parentView()\n        if (p) {\n            p.tellParentViews(msg, aView)\n        }\n    }\n\n    askParentViews (msg, aView) {\n        const f = this[msg]\n        if (f) {\n            const r = f.call(this, aView)\n            return r\n        }\n\n        const p = this.parentView()\n        if (p) {\n            return p.getParentViewMethod(msg, aView)\n        }\n\n        return undefined\n    }\n\n    firstParentViewWithAncestorClass (aClass) {\n        const p = this.parentView()\n        if (p) {\n            if (p.isSubclassOf(aClass)) {\n                return p\n            }\n            return p.firstParentViewWithAncestorClass(aClass)\n        }\n        return undefined\n    }\n\n\n    // centering\n\n    fillParentView () {\n        this.setWidthPercentage(100)\n        this.setHeightPercentage(100)\n        return this\n    }\n\n    centerInParentView () {\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)\n        //this.setWidth(\"100%\")\n        //this.setHeight(\"100%\")\n        this.setOverflow(\"auto\")\n        this.setMarginString(\"auto\")\n        this.setPosition(\"absolute\")\n        this.setTopPx(0).setLeftPx(0).setRightPx(0).setBottomPx(0)\n    }\n\n    /*\n    verticallyCenterFromTopNow () {\n        if (this.parentView() === null) {\n            console.warn(\"verticallyCenterFromTopNow called on view with no superview\")\n            return this\n        }\n\n        this.setPosition(\"absolute\")\n        this.setDisplay(\"inline-block\")\n\n        // timeout used to make sure div is placed and laid out first\n        // TODO: consider ordering issue\n        this.addTimeout(() => { \n            let sh = this.parentView().clientHeight()\n            let h = this.clientHeight()\n            this.setTopPx(sh/2 - h/2)\n        }, 1)\n\n        return this\n    }\n\n    horiontallyCenterFromLeftNow () {\n        if (this.parentView() === null) {\n            console.warn(\"horiontallyCenterFromLeftNow called on view with no superview\")\n            return this\n        }\n\n        this.setPosition(\"absolute\")\n        this.setDisplay(\"inline-block\")\n\n        // timeout used to make sure div is placed and laid out first\n        // TODO: consider ordering issue\n        this.addTimeout(() => { \n            let sw = this.parentView().clientWidth()\n            let w = this.clientWidth()\n            this.setTopPx(sw/2 - w/2)\n        }, 1)\n\n        return this\n    }\n    */\n\n    rootView () {\n        const pv = this.parentView()\n        if (pv) {\n            return pv.rootView()\n        }\n        return this\n    }\n\n    isInDocument () {\n        return this.rootView() === DocumentBody.shared()\n    }\n\n    containerize () {\n        // create a subview of same size as parent and put all other subviews in it\n        const container = DomView.clone()\n        container.setMinAndMaxHeight(this.clientHeight())\n        container.setMinAndMaxWidth(this.clientWidth())\n        this.moveAllSubviewsToView(container)\n        this.addSubview(container)\n        return container\n    }\n\n    uncontainerize () {\n        assert(this.subviewCount() === 1)\n        const container = this.subviews().first()\n        this.removeSubview(container)\n        container.moveAllSubviewsToView(this)\n        return this\n    }\n\n    moveAllSubviewsToView (aView) {\n        this.subviews().shallowCopy().forEach((sv) => {\n            this.remove(sv)\n            aView.addSubview(sv)\n        })\n        return this\n    }\n\n    // auto fit \n    // need to be careful about interactions as some of these change \n    // display and position attributes\n    // NOTE: when we ask parent to fit child, should we make sure child position attribute allows this?\n\n    hasAbsolutePositionChild () {\n        return this.subviews().canDetect(sv => sv.position() === \"absolute\")\n    }\n\n    // auto fit width\n\n    autoFitParentWidth () {\n        this.setDisplay(\"block\")\n        this.setWidth(\"-webkit-fill-available\")\n        //this.setHeight(\"fill-available\")\n        return this\n    }\n\n    autoFitChildWidth () {\n        //assert(!this.hasAbsolutePositionChild()) // won't be able to autofit!\n        this.setDisplay(\"inline-block\")\n        this.setWidth(\"auto\")\n        this.setOverflow(\"auto\")\n        return this\n    }\n\n    // auto fit height\n\n    autoFitParentHeight () {\n        this.setPosition(\"absolute\")\n        //this.setHeightPercentage(100)\n        this.setHeight(\"-webkit-fill-available\")\n        //this.setHeight(\"fill-available\")\n        return this\n    }\n\n    autoFitChildHeight () {\n        //assert(!this.hasAbsolutePositionChild()) // won't be able to autofit!\n        this.setPosition(\"relative\") // or static? but can't be absolute\n        this.setHeight(\"fit-content\")\n        return this\n    }\n\n    // organizing\n\n    moveToAbsoluteDocumentBody () {\n        const f = this.frameInDocument()\n        this.setFrameInDocument(f)\n        this.removeFromParentView()\n        DocumentBody.shared().addSubview(this)\n        return this\n    }\n\n    // organizing\n\n    absoluteOrganizeSubviewsVertically () {\n        let top = 0\n        this.subviews().shallowCopy().forEach((sv) => {\n            const h = sv.clientHeight()\n            sv.setLeftPx(0)\n            sv.setTopPx(top)\n            top += h\n        })\n    }\n\n    absoluteOrganizeSubviewsHorizontally () {\n        let left = 0\n        this.subviews().shallowCopy().forEach((sv) => {\n            const w = sv.clientWidth()\n            sv.setLeftPx(left)\n            sv.setTopPx(0)\n            left += x\n        })\n    }\n\n    // html duplicates\n\n    htmlDuplicateView () {\n        const v = DomView.clone()\n        v.setFrameInParent(this.frameInParentView())\n        v.setInnerHtml(this.innerHtml())\n        return v\n    }\n\n    htmlDuplicateViewAndSubviews (selectedSubviews) {\n        selectedSubviews.forEach(sv => asset(sv.parentView() === this))\n\n        const v = DomView.clone()\n        v.setFrameInParent(this.frameInParentView())\n        selectedSubviews.forEach(sv => v.addSubview(sv.htmlDuplicateView()))\n        return v\n    }\n\n    htmlDuplicateViewWithSubviews () {\n        const v = DomView.clone()\n        v.setFrameInParent(this.frameInParentView())\n        this.subviews().forEach(sv => v.addSubview(sv.htmlDuplicateView()))\n        return v\n    }\n\n    // fitting\n\n    fitSubviews () {\n        const f = this.frameFittingSubviewsInParent()\n        this.setFrameInParent(f)\n        return this\n    }\n\n    frameFittingSubviewsInParent () {\n        let u = null\n\n        this.subviews().forEach(sv => {\n            const f = sv.frameInParent()\n            if (u === null) {\n                u = f\n            } else {\n                u = u.unionWith(f)\n            }\n        })\n\n        return u\n    }\n\n    fixedFrameFittingSubviews () {\n        let u = null\n\n        this.subviews().forEach(sv => {\n            const f = sv.fixedFrame()\n            if (u === null) {\n                u = f\n            } else {\n                u = u.unionWith(f)\n            }\n        })\n\n        return u\n    }\n\n    convertFrameToDocument (aRect) {\n        const p = this.positionInDocument()\n        const newOrigin = aRect.origin().add(p)\n        return aRect.copy().setOrigin(newOrigin)\n    }\n\n    // ----\n\n    updateSubviews () {\n\n    }\n\n    resyncAllViews () {\n        this.updateSubviews() // NodeView already does this when it schedules syncFromNode, so don't call from NodeView\n        this.subviews().forEach(sv => sv.resyncAllViews())\n        return this\n    }\n\n    // ---- adding and removing a view to enable/disable it ---\n\n    setParentViewIfTrue (parentView, aBool) {\n        /*\n         This is a helper method to easily add/remove view instead of using setDisplay(\"none\"),\n         which useful to avoid an excessively larger DOM tree, especially in repeated elements like Tiles in a ScrollView.\n\n         NOTES:\n         The problem is that layout is dependent on ordering and adding a subview to the end of the subviews\n         may change layout. So it's usually better to use setIsDisplayHidden() instead. But \n        */\n\n        if (aBool) {\n            this.addToParentViewIfNeeded(parentView);\n        } else {\n            this.removeFromParentView();\n        }\n        return this;\n    }\n\n    addToParentViewIfNeeded (parentView) {\n        if (this.parentView() !== parentView) {\n            parentView.addSubview(this);\n        }\n        return this;\n    }\n\n\n}.initThisClass());\n",
  "9Md5KveiZAeLQ2/vqMZXRgT9EzQHrhVQtmpZ04nPRPY=": "\"use strict\";\n\n/*\n    ListenerDomView\n\n    Dealing with EventListers\n\n*/\n\n(class ListenerDomView extends SubviewsDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"eventListenersMap\", null);\n            slot.setSlotType(\"Map\");\n        }\n    }\n\n    init () {\n        super.init()\n        //this.setEventListenersMap(new Map())\n        return this\n    }\n\n    eventListenersMap () {\n        if (!this._eventListenersMap) {\n            this.setEventListenersMap(new Map())\n        }\n        return this._eventListenersMap;\n    }\n\n    // --- event listener management ---\n\n    eventListeners () {\n        return this.eventListenersMap().valuesArray().map(v => v.allEventListeners()).flat()\n    }\n\n    removeAllListeners () {\n        const map = this.eventListenersMap()\n        map.forEachKV( (k, listener) => { \n            listener.setIsListening(false) \n        } )\n        map.clear()\n        return this\n    }\n\n    hasListenerNamed (className) {\n        const map = this.eventListenersMap()\n        return map.has(className)\n    }\n\n    listenerNamed (className) {\n        const map = this.eventListenersMap()\n        if (!map.has(className)) {\n            const proto = Object.getClassNamed(className)\n            assert(!Type.isNullOrUndefined(proto))\n            const instance = proto.clone().setListenTarget(this.element()).setDelegate(this)\n            map.set(className, instance)\n        }\n        return map.get(className)\n    }\n\n    // --- specific event listeners ---\n\n    animationListener () {\n        return this.listenerNamed(\"AnimationListener\")\n    }\n\n    clipboardListener () {\n        return this.listenerNamed(\"ClipboardListener\")\n    }\n\n    windowListener () {\n        return this.listenerNamed(\"WindowListener\") // listen target will be the window\n    }\n\n    documentListener () {\n        return this.listenerNamed(\"DocumentListener\") // listen target will be the window\n    }\n\n    browserDragListener () {\n        return this.listenerNamed(\"DragListener\")\n    }\n\n    dropListener () {\n        return this.listenerNamed(\"DropListener\")\n    }\n\n    focusListener () {\n        return this.listenerNamed(\"FocusListener\")\n    }\n\n    mouseListener () {\n        return this.listenerNamed(\"MouseListener\")\n    }\n\n    mouseMoveListener () {\n        return this.listenerNamed(\"MouseMoveListener\")\n    }\n\n    keyboardListener () {\n        return this.listenerNamed(\"KeyboardListener\")\n    }\n\n    scrollListener () {\n        return this.listenerNamed(\"ScrollListener\")\n    }\n\n    selectListener () {\n        return this.listenerNamed(\"SelectListener\");\n    }\n\n    touchListener () {\n        return this.listenerNamed(\"TouchListener\")\n    }\n\n    transitionListener () {\n        return this.listenerNamed(\"TransitionListener\")\n    }\n\n    // --- invoking event handler methods ---\n\n    invokeMethodNameForEvent (methodName, event) {\n        //this.debugLog(\".invokeMethodNameForEvent('\" + methodName + \"')\")\n        //console.log(this.typeId() + \".invokeMethodNameForEvent('\" + methodName + \"')\")\n        if (this[methodName]) {\n            //console.log(this.typeId() + \".invokeMethodNameForEvent('\" + methodName + \"')\")\n            const continueProp = this[methodName].apply(this, [event])\n            if (continueProp === false) {\n                //event.preventDefault()\n                event.stopPropagation()\n                return false\n            }\n        }\n\n        return true\n    }\n\n    // --- register window resize events ---\n\n    isRegisteredForWindowResize () {\n        return this.windowListener().isListening()\n    }\n\n    setIsRegisteredForWindowResize (aBool) {\n        this.windowListener().setIsListening(aBool)\n        return this\n    }\n\n    // --- handle window resize events ---\n\n    onWindowResize (event) {\n        return true\n    }\n\n    // --- register onClick events ---\n\n    isRegisteredForClicks () {\n        //return this.mouseListener().isListening()\n        return this.defaultTapGesture().isListening()\n    }\n\n    setIsRegisteredForClicks (aBool) {\n        //this.mouseListener().setIsListening(aBool)\n        this.setHasDefaultTapGesture(aBool) // use tap gesture instead of mouse click\n\n        if (aBool) {\n            this.makeCursorPointer()\n        } else {\n            this.makeCursorDefault()\n        }\n\n        return this\n    }\n\n\n    // --- registering for mouse events ---\n    /*\n        NOTE: onTap... is now used instead?\n    */\n\n    isRegisteredForMouse () {\n        return this.mouseListener().isListening()\n    }\n\n    setIsRegisteredForMouse (aBool, useCapture) {\n        debugger;\n        this.mouseListener().setUseCapture(useCapture).setIsListening(aBool) \n        return this\n    }\n\n    // --- mouse events ---\n\n    /*\n    // avoid declaring these as it will cause all views registered for mouse events to register for mousemove\n\n    onMouseMove (event) {\n        return true\n    }\n\n    onMouseOver (event) {\n        return true\n    }\n\n    onMouseLeave (event) {\n        return true\n    }\n\n    onMouseOver (event) {\n        return true\n    }\n    */\n\n    onMouseDown (event) {\n        const methodName = Mouse.shared().downMethodNameForEvent(event)\n        if (methodName !== \"onMouseDown\") {\n            this.debugLog(\".onMouseDown calling: \", methodName)\n            this.invokeMethodNameForEvent(methodName, event)\n        }\n        return true\n    }\n\n    onMouseUp (event) {\n        const methodName = Mouse.shared().upMethodNameForEvent(event)\n        if (methodName !== \"onMouseUp\") {\n            this.debugLog(\".onMouseUp calling: \", methodName)\n            this.invokeMethodNameForEvent(methodName, event)\n        }\n        return true\n    }\n\n    // --- registering for keyboard events ---\n\n    isRegisteredForKeyboard () {\n        return this.keyboardListener().isListening()\n    }\n\n    setIsRegisteredForKeyboard (aBool, useCapture) {\n        this.keyboardListener().setUseCapture(useCapture).setIsListening(aBool)\n\n        const e = this.element()\n        if (aBool) {\n            DomView.setTabCount(DomView.tabCount() + 1)\n            e.tabIndex = DomView.tabCount()  // need this in order for focus to work on BrowserColumn?\n            //this.setCssProperty(\"outline\", \"none\"); // needed?\n        } else {\n            delete e.tabindex\n        }\n\n        return this\n    }\n\n    // --- keyboard events ---\n\n    onKeyDown (event) {\n        //BMKeyboard.shared().showEvent(event)\n        // expand the method name to include combinations of meta keys (e.g. shift, function, control, option, command, etc)\n        const methodName = BMKeyboard.shared().downMethodNameForEvent(event);\n        //console.log(\" onKeyDown \", methodName);\n        //assert(methodName !== \"onKeyDown\");\n        const result = this.invokeMethodNameForEvent(methodName, event);\n        /*\n        if (event.repeat) { // should this be a different method name?\n            this.forceRedisplay() // can't tell if this works without disabling color transitions on tiles\n        }\n        */\n\n        return result;\n    }\n\n    onKeyUp (event) {\n        let shouldPropogate = true\n        //this.debugLog(\" onKeyUp \", event._id)\n        const methodName = BMKeyboard.shared().upMethodNameForEvent(event)\n        //console.log(this.typeId() + \" onKeyUp methodName: \", methodName)\n        shouldPropogate = this.invokeMethodNameForEvent(methodName, event)\n        return shouldPropogate\n    }\n\n    // --- registering for focus / blur events ---\n\n    isRegisteredForFocus () {\n        return this.focusListener().isListening()\n    }\n\n    setIsRegisteredForFocus (aBool) {\n        if (aBool === false && !this.hasListenerNamed(\"FocusListener\")) { // todo: clean this up\n            return\n        }\n        this.focusListener().setIsListening(aBool)\n        return this\n    }\n\n    // --- focus events ---\n\n    onFocusIn (event) {\n        return true\n    }\n\n    onFocusOut (event) {\n        return true\n    }\n\n    onFocus (event) {\n        //console.log(this.typeId() + \" onFocus\")\n        this.willAcceptFirstResponder();\n        // subclasses can override \n        //this.debugLog(\" onFocus\")\n        return true\n    }\n\n    onBlur (event) {\n        //console.log(this.typeId() + \" onBlur\")\n        this.didReleaseFirstResponder();\n        // subclasses can override \n        //this.debugLog(\" onBlur\")\n        return true\n    }\n\n    // --- registering for clipboard events ---\n\n    isRegisteredForClipboard () {\n        return this.clipboardListener().isListening()\n    }\n\n    setIsRegisteredForClipboard (aBool) {\n        this.clipboardListener().setIsListening(aBool)\n        return this\n    }\n        \n\n}.initThisClass());\n",
  "hPRgx0L1Yg5QGp9u2fsV6kh+GqfWYOJbrxcrcBZJ+rI=": "\"use strict\";\n\n/*\n    VisibleDomView\n\n    Support for visibility events.\n\n*/\n\n(class VisibleDomView extends ListenerDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isRegisteredForVisibility\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"intersectionObserver\", null);\n            slot.setSlotType(\"IntersectionObserver\");\n        }\n        {\n            const slot = this.newSlot(\"onVisibilityCallback\", null);\n            slot.setSlotType(\"Function\");\n        }\n    }\n\n    // visibility event\n\n    onVisibility () {\n        //this.debugLog(\".onVisibility()\")\n        const callback = this.onVisibilityCallback()\n        if (callback) {\n            callback()\n\n        }\n\n        this.unregisterForVisibility()\n        return true\n    }\n\n    isRegisteredForVisibility () {\n        return !Type.isNull(this.intersectionObserver())\n    }\n\n    setIsRegisteredForVisibility (aBool) {\n        if (aBool !== this.isRegisteredForVisibility()) {\n            if (aBool) {\n                this.registerForVisibility()\n            } else {\n                this.unregisterForVisibility()\n            }\n        }\n        return this\n    }\n\n    unregisterForVisibility () {\n        const obs = this.intersectionObserver()\n        if (obs) {\n            obs.disconnect()\n            this.setIntersectionObserver(null);\n            this._isRegisteredForVisibility = false\n        }\n        return this\n    }\n\n    visibilityRoot () {\n        // our element must be a decendant of the visibility root element\n        let root = document.body\n\n        if (this.parentView()) {\n            root = this.parentView().parentView().element() // hack for tile in scroll view - TODO: make more general\n            //root = this.parentView().element()\n        }\n        return root\n    }\n\n    registerForVisibility () { // this is a oneShot event, as onVisibility() unregisters\n        if (this.isRegisteredForVisibility()) {\n            return this\n        }\n\n        const intersectionObserverOptions = {\n            root: this.visibilityRoot(), // watch for visibility in the viewport \n            rootMargin: \"0px\",\n            threshold: 1.0\n        }\n\n        const obs = new IntersectionObserver((entries, observer) => {\n            EventManager.shared().safeWrapEvent(() => { this.handleIntersection(entries, observer) }, \"IntersectionObserverEvent\")\n            //this.handleIntersection(entries, observer)\n        }, intersectionObserverOptions)\n\n        this.setIntersectionObserver(obs);\n        obs.observe(this.element());\n\n        this._isRegisteredForVisibility = true\n        return this\n    }\n\n    handleIntersection (entries, observer) {\n        entries.forEach(entry => {\n            if (entry.isIntersecting) {\n                //  if (entries[0].intersectionRatio <= 0) return;\n\n                //console.log(\"onVisibility!\")\n   \n                this.onVisibility()\n            }\n        })\n    }\n\n\n}.initThisClass());\n",
  "Xq9Pq3yiP8z5NL0QB7BkdWU9xio3rSuPggAwnVLfu3g=": "\"use strict\";\n\n/*\n    GesturableDomView\n\n    Handling gestures\n    \n*/\n\n(class GesturableDomView extends VisibleDomView {\n    \n    initPrototypeSlots () {\n        {\n            // Array - not a map as we might have multiple GRs of same type, but...\n            // would it be better to give GRs labels to use for map key?\n            // this could replace \"default\" gesture ivars?\n            // Set would make for faster lookup, but we may need to maintain order\n            const slot = this.newSlot(\"gestureRecognizers\", null);\n            slot.setSlotType(\"Array\");\n        }\n\n        // default gestures with typical settings \n        {\n            const slot = this.newSlot(\"defaultTapGesture\", null);\n            slot.setSlotType(\"TapGestureRecognizer\");\n        }\n        {\n            const slot = this.newSlot(\"defaultDoubleTapGesture\", null);\n            slot.setSlotType(\"TapGestureRecognizer\");\n        }\n        {\n            const slot = this.newSlot(\"defaultPanGesture\", null);\n            slot.setSlotType(\"PanGestureRecognizer\");\n        }\n    }\n\n    // gestures\n\n    gestureRecognizers () {\n        if (this._gestureRecognizers === null) {\n            this._gestureRecognizers = [];\n        }\n        return this._gestureRecognizers;\n    }\n\n    // --- GestureRecognizers ---\n\n    hasGestureRecognizer (gr) {\n        return this.gestureRecognizers().contains(gr)\n    }\n\n    addGestureRecognizer (gr) {\n        assert(!this.hasGestureRecognizer(gr))\n        this.gestureRecognizers().append(gr)\n        gr.setViewTarget(this)\n        gr.start()\n        //console.log(this.typeId() + \" addGestureRecognizer(\" + gr.type() + \")\")\n        return gr\n    }\n\n    removeGestureRecognizer (gr) {\n        if (this.gestureRecognizers()) {\n            gr.stop()\n            gr.setViewTarget(null)\n            this.gestureRecognizers().remove(gr)\n        }\n        return this\n    }\n\n    /*\n    hasGestureType (typeName) {\n        return this.gesturesOfType(typeName).length > 0\n    }\n\n    addGestureRecognizerIfAbsent (gr) {\n        if (!this.hasGestureRecognizer(gr)) {\n            this.addGestureRecognizer(gr)\n        }\n        return this\n    }\n    \n    gesturesOfType (typeName) {\n        return this.gestureRecognizers().select(gr => gr.type() == typeName)\n    }\n\n    removeGestureRecognizersOfType (typeName) {\n        if (this.gestureRecognizers()) {\n            this.gestureRecognizers().select(gr => gr.type() == typeName).forEach(gr => this.removeGestureRecognizer(gr))\n        }\n        return this\n    }\n    */\n\n    removeAllGestureRecognizers () {\n        const grs = this.gestureRecognizers()\n        if (grs.length) {\n            //console.log(this.typeId() + \" removeAllGestureRecognizers \", grs.length)\n            grs.shallowCopy().forEach(gr => this.removeGestureRecognizer(gr))\n        }\n        return this\n    }\n\n    // default tap gesture\n\n    setHasDefaultTapGesture (aBool) {\n        if (aBool) {\n            this.addDefaultTapGesture()\n        } else {\n            this.removeDefaultTapGesture()\n        }\n        return this\n    }\n\n    addDefaultTapGesture () {\n        if (!this.defaultTapGesture()) {\n            const g = this.addGestureRecognizer(TapGestureRecognizer.clone())\n            g.setShouldRequestActivation(true) // TODO: this is usually what we want?\n            this.setDefaultTapGesture(g)\n        }\n        return this.defaultTapGesture()\n    }\n\n    removeDefaultTapGesture () {\n        if (this.defaultTapGesture()) {\n            this.removeGestureRecognizer(this.defaultTapGesture())\n            this.setDefaultTapGesture(null)\n        }\n        return this\n    }\n\n    // default double tap gesture\n\n    newDoubleTapGestureRecognizer () { // private\n        const tg = TapGestureRecognizer.clone();\n        tg.setNumberOfTapsRequired(2);\n        tg.setNumberOfFingersRequired(1);\n        tg.setGestureName(\"DoubleTap\");\n\n        // Do we want this, which allows single tap event and double tap, or do\n        // we want to wait to send single tap until double tap wait period expires?\n        tg.setShouldAcceptCancelRequest(false); // so single click doesn't cancel double click. \n        return tg;\n    }\n\n    addDefaultDoubleTapGesture () { \n        if (!this.defaultDoubleTapGesture()) {\n            const gr = this.newDoubleTapGestureRecognizer();\n            this.setDefaultDoubleTapGesture(gr);\n            this.addGestureRecognizer(gr);\n        }\n        return this.defaultDoubleTapGesture();\n    }\n\n    removeDefaultDoubleTapGesture () { \n        if (this.defaultDoubleTapGesture()) {\n            this.removeGestureRecognizer(this.defaultDoubleTapGesture());\n            this.setDefaultDoubleTapGesture(null);\n        }\n        return this;\n    }\n\n    // default pan gesture\n\n    addDefaultPanGesture () {\n        if (!this._defaultPanGesture) {\n            this._defaultPanGesture = this.addGestureRecognizer(PanGestureRecognizer.clone());\n        }\n        return this._defaultPanGesture;\n    }\n\n    defaultPanGesture () {\n        return this._defaultPanGesture;\n    }\n\n    removeDefaultPanGesture () {\n        if (this._defaultPanGesture) {\n            this.removeGestureRecognizer(this._defaultPanGesture);\n            this._defaultPanGesture = null;\n        }\n        return this;\n    }\n\n    // orient testing\n\n    /*\n    onOrientBegin (aGesture) {\n        this.debugLog(\".onOrientBegin()\")\n        aGesture.show()\n    }\n\n    onOrientMove (aGesture) {\n        this.debugLog(\".onOrientMove()\")\n        aGesture.show()\n    }\n\n    onOrientComplete (aGesture) {\n        this.debugLog(\".onOrientComplete()\")\n        aGesture.show()\n    }\n    */\n\n    cancelAllGesturesExcept (aGesture) {\n        this.gestureRecognizers().forEach((gr) => {\n            //if (gr.type() !== aGesture.type()) {\n            if (gr !== aGesture) {\n                //this.debugLog(\"cancelling gesture \", gr.type())\n                gr.cancel()\n            }\n        })\n        return this\n    }\n\n\n}.initThisClass());\n",
  "q16SXC0p6R8vYjz2OvxB8VAePxe/tUwPxUDKao715rs=": "\"use strict\";\n\n/*\n    ResponderDomView\n\n    Dealing with controlling focus and handling focus events,\n    manaing firstResponder, tabbing between key views\n    \n*/\n\n(class ResponderDomView extends GesturableDomView {\n    \n    static initClass () {\n        this.newClassSlot(\"tabCount\", 0)\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"acceptsFirstResponder\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        // browser looks at element.tabindex to find next element \n        // to focus on tab press, but we may want more behavior\n        /*\n        {\n            const slot = this.newSlot(\"interceptsTab\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"nextKeyView\", null);\n            slot.setSlotType(\"ResponderDomView\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"canMakeKey\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        */\n    }\n\n    // --- focus ---\n\n    scheduleRegisterForFocus () {\n        if (this.element().parentElement) {\n            this.setIsRegisteredForFocus(true);\n        } else {\n            // only need timeout when create dom element in same event?\n            this.addTimeout(() => { \n                this.setIsRegisteredForFocus(true); \n            }, 0);\n        }\n    }\n\n    hasFocusedDecendantView () {\n        const focusedView = WebBrowserWindow.shared().activeDomView();\n        if (focusedView) {\n            return this.hasSubviewDescendant(focusedView);\n        }\n        return false;\n    }\n\n    focus () {\n        //console.log(this.typeId() + \" focus\")\n        if (!this.isActiveElement()) { // document.activeElement might have browser specific behaviors\n            //console.log(this.typeId() + \" focus <<<<<<<<<<<<<<<<<<\")\n            /*\n            const focusedView = WebBrowserWindow.shared().activeDomView()\n\n            // TODO: need a better solution to this problem\n            if (focusedView && !this.hasFocusedDecendantView()) {\n                \n                if (focusedView && focusedView.type() === \"TextField\") {\n                    console.log(\"  -- taking focus from \" + focusedView.typeId())\n                }\n                \n                //this.debugLog(\".focus() \" + document.activeElement.domView())\n                this.addTimeout(() => { this.element().focus() }, 0)\n            }\n            */\n            //this.addTimeout(() => { this.element().focus() }, 0)\n\n            //ThrashDetector.shared().didWrite(\"focus\", this)\n            this.element().focus();\n        }\n        return this;\n    }\n\n    focusAfterDelay (seconds) {\n        this.addTimeout(() => {\n            const e = this.element()\n            if (e) {\n                // in case element has retired during the timeout\n                e.focus()\n            }\n        }, seconds * 1000)\n        return this\n    }\n\n    hasFocus () {\n        return this.isActiveElement()\n    }\n\n    blur () { \n        //console.log(this.typeId() + \".blur()\");\n        // i.e. unfocus\n        this.element().blur()\n        return this\n    }\n\n    // --- active element ---\n\n    isActiveElement () {\n        return document.activeElement === this.element()\n    }\n\n    isActiveElementAndEditable () {\n        return this.isActiveElement() && this.contentEditable()\n    }\n\n    isFocused () {\n        return this.isActiveElement()\n    }\n\n    // --- inner html ---\n\n    setInnerHtml (v) {\n        const oldValue = this.element().innerHTML;\n\n        if (Type.isNullOrUndefined(v)) {\n            v = \"\";\n        }\n        if (!Type.isString(v)) {\n            v = \"\" + v; // coerce to string\n        }\n\n        const newValue = v.asNormalizedHtml();\n\n        if (newValue === oldValue) {\n            return this;\n        }\n\n        if (this.isActiveElementAndEditable()) {\n            //debugger;\n        }\n\n        //assert(this.element().innerHTML === v, \"innerHTML was not set\"); // doesn't work as it may reformat the html\n\n        updateElementHTML(this.element(), newValue);\n\n        /*\n        if (newValue !== \"\" && \n            this.isActiveElementAndEditable() && \n            this.containsSelection()) {\n\n                console.log(\"oldValue: [\", oldValue, \"]\");\n                console.log(\"newValue: [\", newValue, \"]\");\n\n                //const diff = oldValue.diff(newValue);\n                //console.log(\"DIFF: \", JSON.stringify(diff, 2, 2));\n\n                //assert(this.storeSelectionRange());\n                updateElementHTML(this.element(), newValue);\n                //this.element().innerHTML = newValue;\n                //assert(this.restoreSelectionRange());\n                console.log(\">>>>>>>>>>>>>>>>>>>>>>>>>>>>> restored selection\");\n\n            //this.focus();\n        } else {\n            this.element().innerHTML = newValue;\n        }\n        */\n\n        return this\n    }\n\n    forceRedisplay () {\n        // NOTE: not sure this works\n        const p = this.parentView()\n        if (p) {\n            const d = p.display()\n            p.setDisplay(\"none\")\n            p.setDisplay(d)  \n        }\n        return this\n    }\n\n    /*\n    onInput (event) {\n        // sent after the content is changed\n    }\n    */\n\n    didInput () {\n        this.debugLog(\"didInput\")\n        this.tellParentViews(\"onDidInput\", this)\n        return this\n    }\n\n    didEdit () {\n        this.debugLog(\"didEdit\")\n        this.tellParentViews(\"onDidEdit\", this)\n        return this\n    }\n\n    onEnterKeyUp (event) {\n        return true\n    }\n\n    // --- tabs and next key view ----\n\n    onTabKeyDown (event) {\n        // need to implement this on key down to prevent browser from handling tab?\n        //this.debugLog(\" onTabKeyDown \", event._id)\n\n        if (this.selectNextKeyView()) {\n            //event.stopImmediatePropagation() // prevent other listeners from getting this event\n            //console.log(\"stopImmediatePropagation \")\n        }\n        return false\n    }\n\n    onTabKeyUp (event) {\n        //this.debugLog(\" onTabKeyUp \", event._id)\n        return false\n    }\n\n    becomeKeyView () { \n        // use this method instead of focus() in order to give the receiver \n        // a chance to give focus to one of it's decendant views\n        this.focus()\n        return this\n    }\n\n    selectNextKeyView () {\n        // returns true if something is selected, false otherwise\n\n        //this.debugLog(\" selectNextKeyView\")\n        const nkv = this.nextKeyView()\n        if (nkv) {\n            nkv.becomeKeyView()\n            return true\n        } else {\n            const p = this.parentView()\n            if (p) {\n                return p.selectNextKeyView()\n            }\n        }\n        return false\n    }\n\n    // --- error checking ---\n\n    isValid () {\n        return true\n    }\n\n    // --- focus and blur event handling ---\n\n    willAcceptFirstResponder () {\n        //this.debugLog(\".willAcceptFirstResponder()\")\n        return this\n    }\n\n    didReleaseFirstResponder () {\n        // called on blur event from browser?\n        return this\n    }\n\n    // --- firstResponder --- \n\n    isFirstResponder () {\n        return document.activeElement === this.element()\n    }\n\n    willBecomeFirstResponder () {\n        // called if becomeFirstResponder accepts\n    }\n\n    becomeFirstResponder () {\n        if (this.acceptsFirstResponder()) {\n            this.willBecomeFirstResponder()\n            this.focus()\n        } else if (this.parentView()) {\n            this.parentView().becomeFirstResponder()\n        }\n        return this\n    }\n\n    releaseFirstResponder () {\n        // walk up parent view chain and focus on the first view to \n        // answer true for the acceptsFirstResponder message\n        //this.debugLog(\".releaseFirstResponder()\")\n\n        if (this.isFocused()) { \n            this.blur()\n        }\n\n        this.tellParentViews(\"decendantReleasedFocus\", this)\n        /*\n        if (this.parentView()) {\n            this.parentView().becomeFirstResponder()\n        }\n        */\n        return this\n    }\n\n\n\n    // helpers\n\n    /*\n    mouseUpPos () { \n        return this.viewPosForWindowPos(Mouse.shared().upPos())\n    }\n\n    mouseCurrentPos () { \n        return this.viewPosForWindowPos(Mouse.shared().currentPos())\n    }\n    */\n\n    /*\n    mouseDownPos () {\n        return this.viewPosForWindowPos(Mouse.shared().downPos())\n    }\n    */\n\n\n    // ------------------------------------------------\n\n    disablePointerEventsUntilTimeout (ms) {\n        // typically used to disbale view until an animation is complete\n\n        this.setPointerEvents(\"none\")\n        this.debugLog(\" disabling pointer events\")\n\n        this.addTimeout(() => {\n            this.debugLog(\" enabling pointer events\")\n            this.setPointerEvents(\"inherit\")\n        }, ms)\n\n        return this\n    }\n\n}.initThisClass());\n\n\n\nfunction updateElementHTML(element, htmlContent) {\n    // Check if the element is currently focused\n    let isFocused = (document.activeElement === element);\n\n    // Save the current scrolling position to restore later if needed\n    //let scrollTop = element.scrollTop;\n    //let scrollLeft = element.scrollLeft;\n\n    // Check if the element is contenteditable or an input/textarea\n    let isEditable = element.contentEditable === 'true' || element.tagName === 'INPUT' || element.tagName === 'TEXTAREA';\n\n    if (isEditable && isFocused) {\n        // Save the selection or cursor position\n        let selectionStart = element.selectionStart;\n        let selectionEnd = element.selectionEnd;\n\n        // Set the innerHTML or value\n        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {\n            element.value = htmlContent;\n        } else {\n            element.innerHTML = htmlContent;\n        }\n\n        // Restore the selection or cursor position\n        element.selectionStart = selectionStart;\n        element.selectionEnd = selectionEnd;\n    } else {\n        // Set the innerHTML or value\n        if (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA') {\n            element.value = htmlContent;\n        } else {\n            element.innerHTML = htmlContent;\n        }\n    }\n\n    // Restore the original focus state if it was focused before\n    if (isFocused) {\n        element.focus();\n        //element.scrollTop = scrollTop;\n        //element.scrollLeft = scrollLeft;\n    }\n}",
  "iuwcHx5DXAZ698xwR1RBgvPUK9Qwiz/sNZQ9DkCTR24=": "\"use strict\";\n\n/*\n    ControlDomView\n\n    Target / action state and behavior.\n\n*/\n\n(class ControlDomView extends ResponderDomView {\n    \n    initPrototypeSlots () {\n        // Targetable - target / action\n        {\n            const slot = this.newSlot(\"target\", null);\n            slot.setSlotType(\"Object\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"action\", null);\n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    // --- target/action ---\n\n    hasTargetAndAction () {\n        return (this.target() !== null) && (this.action() !== null)\n    }\n\n    setTarget (anObject) {\n        this._target = anObject\n        this.setIsRegisteredForClicks(this.hasTargetAndAction())\n        return this\n    }\n\n    setAction (anActionString) {\n        this._action = anActionString\n        this.setIsRegisteredForClicks(this.hasTargetAndAction())\n        return this\n    }\n\n    // ---\n\n    onClick (event) {\n        debugger;\n        this.debugLog(\".onClick()\")\n        this.sendActionToTarget()\n        event.stopPropagation()\n        return false\n    }\n\n    onTapComplete (aGesture) {\n        this.debugLog(\".onTapComplete()\")\n        this.sendActionToTarget()\n        return this\n    }\n\n    sendActionToTarget () {\n        if (!this.action()) {\n            return null\n        }\n\n        const t = this.target()\n        if (!t) {\n            throw new Error(\"no target for action \" + this.action())\n        }\n\n        const method = t[this.action()]\n        if (!method) {\n            throw new Error(\"no target for action \" + this.action())\n        }\n\n        return method.call(t, this)\n    }\n\n    onDoubleClick (event) {\n        return true\n    }\n    \n}.initThisClass());\n",
  "SfG0DRKiesy0QyFmiKAKBY3FzF/IQblQVR/xWEY4f0w=": "\"use strict\";\n\n/*\n    SelectableDomView\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class SelectableDomView extends ControlDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"storedSelectionRange\", null);\n            slot.setSlotType(\"Range\");\n        }\n    }\n\n    getSelectedText () {\n        if (this.containsSelection()) { // this.isFocused() should be true\n            const selection = window.getSelection();\n            return selection.toString();\n        } else {\n            console.warn(this.type() + \" attempt to get selection on unfocused text\")\n        }\n        return \"\"\n    }\n\n    // --- save / restore selection ----\n\n    storeSelectionRange () {\n        const range = this.getSelectionRange();\n        if (range) {\n            console.log(this.typeId() + \"--- storing selection ---\")\n            this.setStoredSelectionRange(range);\n            return true;\n        }\n        return false;\n    }\n\n    restoreSelectionRange () {\n        if (this.storedSelectionRange()) {\n            console.log(this.typeId() + \"--- restoring selection ---\");\n            this.setSelectionRange(this.storedSelectionRange()); // may be null\n            assert(this.storedSelectionRange().isEqual(this.getWindowSelectionRange()));\n            this.setStoredSelectionRange(null);\n            return true;\n        }\n        return false;\n    }\n\n    // --- window selection range ----\n\n    getWindowSelectionRange () {\n        if (window.getSelection) {\n            const selection = window.getSelection();\n            //selection.collapse(<node>); // safe?\n            if (selection.getRangeAt && selection.rangeCount) {\n                return selection.getRangeAt(0);\n            }\n        } else if (document.selection && document.selection.createRange) {\n            return document.selection.createRange();\n        }\n        return null;\n    }\n\n    setWindowSelectionRange (range) {\n        if (range) {\n            if (window.getSelection) {\n                const sel = window.getSelection();\n                sel.removeAllRanges();\n                sel.addRange(range);\n            } else if (document.selection && range.select) {\n                range.select();\n            }\n        }\n        return this;\n    }\n\n    // --- get / set selection range ----\n\n    getSelectionRange () {\n        if (!this.containsSelection()) {\n            return null;\n        }\n\n        return this.getWindowSelectionRange();\n    }\n    \n    setSelectionRange (range) {\n        if (!this.isContainedBySelectionRange(range)) {\n            return null;\n        }\n\n        this.setWindowSelectionRange(range);\n        return this;\n    }\n\n    // --- set caret ----\n\n    placeCaretAtEnd () {\n        const el = this.element()\n        el.focus();\n\n        if (typeof window.getSelection !== \"undefined\" && typeof document.createRange !== \"undefined\") {\n            var range = document.createRange();\n            range.selectNodeContents(el);\n            range.collapse(false);\n            var sel = window.getSelection();\n            sel.removeAllRanges();\n            sel.addRange(range);\n        } else if (typeof document.body.createTextRange !== \"undefined\") {\n            var textRange = document.body.createTextRange();\n            textRange.moveToElementText(el);\n            textRange.collapse(false);\n            textRange.select();\n        }\n        return this\n    }\n\n    \n    moveCaretToEnd () {\n        const contentEditableElement = this.element()\n        let range, selection;\n\n        if (document.createRange) {\n            //Firefox, Chrome, Opera, Safari, IE 9+\n            range = document.createRange(); //Create a range (a range is a like the selection but invisible)\n            range.selectNodeContents(contentEditableElement); //Select the entire contents of the element with the range\n            range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start\n            selection = window.getSelection(); //get the selection object (allows you to change selection)\n            selection.removeAllRanges(); //remove any selections already made\n            selection.addRange(range); //make the range you have just created the visible selection\n        }\n        else if (document.selection) {\n            //IE 8 and lower\n            range = document.body.createTextRange(); //Create a range (a range is a like the selection but invisible)\n            range.moveToElementText(contentEditableElement); //Select the entire contents of the element with the range\n            range.collapse(false); //collapse the range to the end point. false means collapse to end rather than the start\n            range.select();//Select the range (make it the visible selection\n        }\n        return this\n    }\n\n    // --- text selection ------------------\n\n    selectAll () {\n        if (document.selection) {\n            const range = document.body.createTextRange();\n            range.moveToElementText(this.element());\n            range.select();\n        } else if (window.getSelection) {\n            const selection = window.getSelection(); \n            const range = document.createRange();\n            range.selectNodeContents(this.element());\n            selection.removeAllRanges();\n            selection.addRange(range);  \n        }\n    }\n\n     // ------------\n\n     replaceSelectedText (replacementText) {\n        let range;\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.rangeCount) {\n                range = sel.getRangeAt(0);\n                range.deleteContents();\n                range.insertNode(document.createTextNode(replacementText));\n            }\n\n            console.log(\"inserted node\")\n        } else if (document.selection && document.selection.createRange) {\n            range = document.selection.createRange();\n            range.text = replacementText;\n            console.log(\"set range.text\")\n        }\n\n        if (range) {\n            // now move the selection to just the end of the range\n            range.setStart(range.endContainer, range.endOffset);\n        }\n\n        this.didEdit();\n\n        return this\n    }\n\n    // untested\n\n    getCaretPosition () {\n        const editableElement = this.element()\n        let caretPos = 0\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.rangeCount) {\n                const range = sel.getRangeAt(0);\n                if (range.commonAncestorContainer.parentNode == editableElement) {\n                    caretPos = range.endOffset;\n                }\n            }\n        } else if (document.selection && document.selection.createRange) {\n            const range = document.selection.createRange();\n            if (range.parentElement() == editableElement) {\n                const tempEl = document.createElement(\"span\");\n                editableElement.insertBefore(tempEl, editableElement.firstChild);\n                const tempRange = range.duplicate();\n                tempRange.moveToElementText(tempEl);\n                tempRange.setEndPoint(\"EndToEnd\", range);\n                caretPos = tempRange.text.length;\n            }\n        }\n        return caretPos;\n    }\n\n    setCaretPosition (caretPos) {\n        const e = this.element();\n\n        if (e != null) {\n            if (e.createTextRange) {\n                const range = e.createTextRange();\n                range.move(\"character\", caretPos);\n                range.select();\n            }\n            else {\n                if (e.selectionStart) {\n                    e.focus();\n                    e.setSelectionRange(caretPos, caretPos);\n                } else {\n                    e.focus();\n                }\n            }\n        }\n    }\n\n    // ---------------\n\n    clearSelection () { // only clear it if the selection is in this view\n        if (!this.containsSelection()) {\n            return this;\n        }\n\n        if (window.getSelection) {\n            window.getSelection().removeAllRanges();\n        } else if (document.selection) {\n            document.selection.empty();\n        }\n        return this;\n    }\n\n    // --- selection ---\n\n    isContainedBySelectionRange (range) {\n        if (range) {\n            const containsElement = range.intersectsNode(this.element(), true);\n            return containsElement;\n        }\n        return false;\n    }\n\n    isInWindowSelection () {\n        const selection = window.getSelection();\n        const range = selection.getRangeAt(0);\n        return this.isContainedBySelectionRange(range);\n    }\n\n    containsSelection () {\n        const selection = window.getSelection();\n        const range = selection.getRangeAt(0);\n        const startContainer = range.startContainer;\n        const endContainer = range.endContainer;\n        const element = this.element();\n        return element.contains(startContainer) && element.contains(endContainer);\n    }\n\n}.initThisClass());\n",
  "ecOL7Nhn16kApAtMW274dglrsanwf/opbwx45c8R1lM=": "\"use strict\";\n\n/*\n    EditableDomView\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class EditableDomView extends SelectableDomView {\n    \n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"unfocusOnEnterKey\", false);\n            slot.setSlotType(\"Boolean\");    \n        }\n        {\n            const slot = this.newSlot(\"showsHaloWhenEditable\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        */\n    }\n\n    /*\n    onEnterKeyDown (event) {\n        this.debugLog(\" onEnterKeyDown\")\n        if (this.unfocusOnEnterKey() && this.isFocused()) {\n            this.debugLog(\" releasing focus\")\n            // this.releaseFocus() // TODO: implement something to pass focus up view chain to whoever wants it\n            //this.element().parentElement.focus()\n            if (this.parentView()) {\n                this.parentView().focus()\n            }\n        }\n        return this\n    }\n    */\n\n    // --- set caret ----\n\n    consolidateTextNodesAndPreserveSelection () {\n        const div = this.element()\n\n        const selection = window.getSelection();\n        if (!selection.rangeCount) return;\n    \n        const range = selection.getRangeAt(0);\n        \n        // Helper function to calculate offset within the parent\n        function getOffsetWithinParent(node, offset) {\n            if (node === div) return offset;\n            \n            let length = 0;\n            while (node.previousSibling) {\n                node = node.previousSibling;\n                length += node.textContent.length;\n            }\n            return length + offset;\n        }\n\n        // Get current selection's start and end positions relative to the entire text content of the div\n        const startOffset = getOffsetWithinParent(range.startContainer, range.startOffset);\n        const endOffset = getOffsetWithinParent(range.endContainer, range.endOffset);\n    \n        // Merge all text nodes into a single text node\n        const combinedText = Array.from(div.childNodes)\n            .map(node => node.textContent)\n            .join('');\n        while (div.firstChild) {\n            div.removeChild(div.firstChild);\n        }\n        div.appendChild(document.createTextNode(combinedText));\n    \n        // Restore the selection or cursor position\n        const newRange = document.createRange();\n        newRange.setStart(div.firstChild, startOffset);\n        newRange.setEnd(div.firstChild, endOffset);\n        selection.removeAllRanges();\n        selection.addRange(newRange);\n\n        return this\n    }\n\n    insertTextAtCursorAndConsolidate (text) {\n        const el = this.element();\n        var sel, range, textNode, insertedTextLength = text.length;\n\n        if (window.getSelection) {\n            sel = window.getSelection();\n    \n            if (sel.getRangeAt && sel.rangeCount) {\n                range = sel.getRangeAt(0);\n    \n                // Remember the position before insertion\n                var positionBeforeInsertion = range.startOffset;\n    \n                // Create a new text node containing the text to insert\n                textNode = document.createTextNode(text);\n                range.insertNode(textNode);\n    \n                // Adjust the selection to be at the end of the new text node\n                range.setStartAfter(textNode);\n                range.setEndAfter(textNode);\n                sel.removeAllRanges();\n                sel.addRange(range);\n    \n                // Calculate new position after consolidation\n                var positionAfterConsolidation = positionBeforeInsertion + insertedTextLength;\n    \n                // Now, consolidate all text nodes in the div\n                el.textContent = el.textContent;\n    \n                // Restore the position\n                var newRange = document.createRange();\n                var newSel = window.getSelection();\n                newRange.setStart(el.childNodes[0], positionAfterConsolidation);\n                newRange.collapse(true);\n                newSel.removeAllRanges();\n                newSel.addRange(newRange);\n            }\n        } else if (document.selection && document.selection.createRange) {\n            // For older versions of IE\n            document.selection.createRange().text = text;\n        }\n    }\n    \n    insertTextAtCursorSimple (text) { // assumes content *ONLY* has text\n        this.consolidateTextNodesAndPreserveSelection()\n\n        const selection = window.getSelection();\n        const range = selection.getRangeAt(0);\n    \n        // Extract text content before and after the cursor/selection\n        const startText = range.startContainer.textContent.substring(0, range.startOffset);\n        const endText = range.startContainer.textContent.substring(range.endOffset);\n    \n        // Reconstruct the full text content with the inserted text\n        range.startContainer.textContent = startText + text + endText;\n    \n        // Position the cursor after the inserted text\n        range.setStart(range.startContainer, startText.length + text.length);\n        range.setEnd(range.startContainer, startText.length + text.length);\n        selection.removeAllRanges();\n        selection.addRange(range);\n        return this\n    }\n    \n    /*\n    insertTextAtCursorSimple (text) {\n        const el = this.element();\n        // First, ensure that all text is consolidated into a single node\n        el.textContent = el.textContent;\n    \n        var sel, range;\n        if (window.getSelection) {\n            sel = window.getSelection();\n            if (sel.getRangeAt && sel.rangeCount) {\n                range = sel.getRangeAt(0);\n                \n                range.deleteContents();\n                \n                var textNode = document.createTextNode(text);\n                range.insertNode(textNode);\n    \n                // Move the caret to the end of the newly inserted text node\n                range = document.createRange();\n                range.selectNodeContents(textNode);\n                range.collapse(false);\n                sel.removeAllRanges();\n                sel.addRange(range);\n            }\n        } else if (document.selection && document.selection.createRange) {\n            // For older versions of IE\n            document.selection.createRange().text = text;\n        }\n    }\n    */\n    \n\n    /*\n    insertTextAtCursor (text) {\n        const savedSelection = this.getSelectionRange()\n\n        if (window.getSelection) {\n            const sel = window.getSelection();\n            if (sel.getRangeAt && sel.rangeCount) {\n                const range = sel.getRangeAt(0);\n                range.deleteContents();\n                range.insertNode( document.createTextNode(text) );\n            }\n        } else if (document.selection && document.selection.createRange) {\n            document.selection.createRange().text = text;\n        }\n        savedSelection.collapse()\n        this.setSelectionRange(savedSelection)\n        return this\n    }\n    */\n\n\n    // --- paste from clipboardListener ---\n\n    onPaste (event) {\n        //debugger;\n        // prevent pasting text by default after event\n        event.preventDefault();\n\n        const clip = event.clipboardData;\n        const html = clip.getData(\"text/html\");\n        const text = clip.getData(\"text/plain\");\n\n        const htmlToPlainTextFunc = function (html) {\n            const e = document.createElement(\"DIV\");\n            e.innerHTML = html;\n            return e.textContent || e.innerText || \"\";\n        }\n\n        if (html && html.trim().length !== 0) {\n            const s = htmlToPlainTextFunc(html)\n            this.replaceSelectedText(s)\n            return false; // prevent returning text in clipboard\n        }\n\n        if (text && text.trim().length !== 0) {\n            const s = htmlToPlainTextFunc(text)\n            this.replaceSelectedText(s)\n            return false; // prevent returning text in clipboard\n        }\n\n        return true\n    }\n\n   \n\n}.initThisClass());\n",
  "Ov6PCLdjNPHK6Lw4UhFHdD0GWZvXVrTSMTybxChsEXw=": "\"use strict\";\n\n/*\n    DomView\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class DomView extends EditableDomView {\n    \n    initPrototypeSlots () {\n    }\n\n    /*\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n}.initThisClass());\n",
  "Rz/+gtohrwLJ+L+ZZFK1+WuDRA8xmJ580BXTlp8LNCU=": "\"use strict\";\n\n/*\n    DomViewanimations\n\n    Helper methods for animations.\n\n*/\n\n(class DomView_animations extends DomView {\n\n    // --- movement animations ---\n\n    immediatelyScrollToBottom () {\n        const focusedElement = document.activeElement\n        const needsRefocus = focusedElement !== this.element()\n        // console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".scrollToTop() needsRefocus = \", needsRefocus)\n\n        //this.setScrollTop(this.scrollHeight() + \"px\")\n        this.element().scrollTop = this.element().scrollHeight;\n\n        //if (needsRefocus) {\n        if (focusedElement !== document.activeElement) {\n            focusedElement.focus();\n        }\n        //e.animate({ scrollTop: offset }, 500); // TODO: why doesn't this work?\n        return this;\n    }\n\n    scrollToBottom () {\n        this.immediatelyScrollToBottom();\n        return this;\n    }\n\n    scrollSubviewToTop (aSubview) {\n        console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".scrollSubviewToTop()\")\n        assert(this.hasSubview(aSubview))\n        //this.setScrollTop(aSubview.offsetTop())\n        //this.setScrollTopSmooth(aSubview.offsetTop())\n        //this.setScrollTop(aSubview.offsetTop() + aSubview.scrollHeight())\n        this.animateValue(\n            () => { return aSubview.offsetTop() },\n            () => { return this.scrollTop() },\n            (v) => { this.setScrollTop(v) },\n            200)\n        return this\n    }\n\n    // --- animation ---\n\n    animateValue (targetFunc, valueFunc, setterFunc, duration) { // duration in milliseconds         \n        console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".animateValue()\")\n        if (duration == null) {\n            duration = 200\n        }\n        //duration = 1500\n        const startTime = Date.now();\n\n        const step = () => {\n            const dt = (Date.now() - startTime)\n            let r = dt / duration\n            r = Math.sin(r * Math.PI / 2)\n            r = r * r * r\n\n            const currentValue = valueFunc()\n            const currentTargetValue = targetFunc()\n\n            //console.log(\"time: \", dt, \" /\", duration, \" r:\", r, \" top:\", currentValue, \"/\", currentTargetValue)\n\n            if (dt > duration) {\n                setterFunc(currentTargetValue)\n            } else {\n                const newValue = currentValue + (currentTargetValue - currentValue) * r\n                setterFunc(newValue)\n                window.requestAnimationFrame(step);\n            }\n        }\n\n        window.requestAnimationFrame(step);\n        return this\n    }\n\n    setScrollTopSmooth (newScrollTop, scrollDuration) {\n        this.animateValue(() => { return newScrollTop }, () => { return this.scrollTop() }, (v) => { this.setScrollTop(v) }, scrollDuration)\n        return this\n    }\n\n    dynamicScrollIntoView () {\n        this.parentView().scrollSubviewToTop(this)\n        return this\n    }\n\n    scrollIntoView () {\n        // TODO: return immediately if already visible\n        if (this.isScrolledIntoView()) {\n            return false\n        }\n\n        const focusedView = WebBrowserWindow.shared().activeDomView()\n        //console.log(\"]]]]]]]]]]]] \" + this.typeId() + \".scrollIntoView() needsRefocus = \", focusedView !== this)\n\n        // if another view is focused, the scrolling will unfocus it, so we\n        // need a way to return focus after scrolling is complete\n        if (focusedView && focusedView !== this) {\n            //console.log(\"scrollIntoView - registerForVisibility\")\n            // this hack is needed to return focus that scrollIntoView grabs from other elements\n            // need to do this before element().scrollIntoView appearently\n            this.registerForVisibility()\n            // hack around lack of end of scrollIntoView event \n            // needed to return focus that scrollIntoView grabs from other elements\n            this.setOnVisibilityCallback(() => {\n                //console.log(\"_endScrollIntoViewFunc - returning focus\")\n                //focusedView.focus()\n                // need delay to allow scroll to finish - hack - TODO: check for full visibility\n                focusedView.focusAfterDelay(0.2)\n            })\n        }\n\n        this.addTimeout(() => {\n            // have browser do scroll\n            //ThrashDetector.shared().didOp(\"scrollIntoView\")\n            this.element().scrollIntoView({ \n                block: \"start\", \n                inline: \"nearest\", \n                behavior: this.usesSmoothScrolling() ? \"smooth\" : \"auto\", \n            })\n        }, 0)\n\n        this.element().addEventListener('transitionend', (transitionEvent) => {\n            console.log(\"completed scrollIntoView transition?:\", transitionEvent.propertyName)\n        });\n\n        /*\n        if (focusedView !== this) {\n            focusedView.focusAfterDelay(0.5) // TODO: get this value from transition property\n        }\n        */\n        return this\n    }\n    \n    isScrolledIntoView () {\n        const r = this.boundingClientRect()\n        const isVisible = (r.top >= 0) && (r.bottom <= window.innerHeight);\n        return isVisible;\n    }\n\n    verticallyAlignAbsoluteNow () {\n        const pv = this.parentView()\n        if (pv) {\n            this.setPosition(\"absolute\")\n            const parentHeight = pv.computedHeight() //pv.calcHeight() // computedHeight?\n            const height = this.computedHeight()\n            this.setTopPx((parentHeight / 2) - (height / 2))\n        } else {\n            throw new Error(\"missing parentView\")\n        }\n        return this\n    }\n\n    horizontallyAlignAbsoluteNow () {\n        const pv = this.parentView()\n        if (pv) {\n            this.setPosition(\"absolute\")\n            this.addTimeout(() => {\n                this.setRightPx(pv.clientWidth() / 2 - this.clientWidth() / 2)\n            }, 0)\n        }\n        return this\n    }\n    // ----------------------\n\n    animateToDocumentFrame (destinationFrame, seconds, completionCallback) {\n        this.setTransition(\"all \" + seconds + \"s\")\n        assert(this.position() === \"absolute\")\n        this.addTimeout(() => {\n            this.setTopPx(destinationFrame.origin().y())\n            this.setLeftPx(destinationFrame.origin().x())\n            this.setMinAndMaxWidth(destinationFrame.size().width())\n            this.setMinAndMaxHeight(destinationFrame.size().height())\n        }, 0)\n\n        this.addTimeout(() => {\n            completionCallback()\n        }, seconds * 1000)\n        return this\n    }\n\n    animateToDocumentPoint (destinationPoint, seconds, completionCallback) {\n        this.setTransition(\"all \" + seconds + \"s\")\n        assert(this.position() === \"absolute\")\n        this.addTimeout(() => {\n            this.setTopPx(destinationPoint.y())\n            this.setLeftPx(destinationPoint.x())\n        }, 0)\n\n        this.addTimeout(() => {\n            completionCallback()\n        }, seconds * 1000)\n        return this\n    }\n\n    // --- hide and fade animations ---\n\n    hideAndFadeIn () {\n        this.setOpacity(0)\n        //this.setTransition(\"all 0.5s\")\n        this.addTimeout(() => {\n            this.setOpacity(1)\n        }, 0)\n    }\n\n    fadeInToDisplayInlineBlock () {\n        this.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n        this.setDisplay(\"inline-block\")\n        this.setOpacity(0)\n        this.addTimeout(() => {\n            this.setOpacity(1)\n        }, 0)\n        return this\n    }\n\n    fadeOutToDisplayNone () {\n        this.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n        this.setOpacity(0)\n        this.addTimeout(() => {\n            this.setDisplay(\"none\")\n        }, 200)\n        return this\n    }\n\n    // --- fade + height animations ----\n\n    fadeInHeightToDisplayBlock () {\n        this.setDisplay(\"block\")\n        this.setOpacity(1)\n        this.setMinHeight(\"100%\")\n        this.setMaxHeight(\"100%\")\n        return this\n/*\n        this.setMinHeight(\"100%\")\n        this.setMaxHeight(\"100%\")\n        const targetHeight = this.calcHeight()\n\n        this.setOverflow(\"hidden\")\n        this.transitions().at(\"opacity\").updateDuration(\"0.3s\")\n        this.transitions().at(\"min-height\").updateDuration(\"0.2s\")\n        this.transitions().at(\"max-height\").updateDuration(\"0.2s\")\n\n        this.setDisplay(\"block\")\n        this.setOpacity(0)\n        this.setMinAndMaxHeight(0)\n\n        this.addTimeout(() => {\n            this.setOpacity(1)\n            this.setMinAndMaxHeight(targetHeight)\n        }, 0)\n        */\n        return this\n    }\n\n    fadeOutHeightToDisplayNone () {\n        this.setOverflow(\"hidden\")\n        this.transitions().at(\"opacity\").updateDuration(\"0.2s\")\n        this.transitions().at(\"min-height\").updateDuration(\"0.3s\")\n        this.transitions().at(\"max-height\").updateDuration(\"0.3s\")\n\n        this.addTimeout(() => {\n            this.setOpacity(0)\n            this.setMinAndMaxHeight(0)\n        }, 1)\n\n        /*\n        this.addTimeout(() => {\n            this.setDisplay(\"none\")\n        }, 300)\n        */\n        return this\n    }\n\n\n}.initThisCategory());\n",
  "YXZZpK+06fwBmSRexuSlfvPeChymw7Udouk5iiSYeFk=": "\"use strict\";\n\n/*\n    DomView_browserDragAndDrop\n\n    For subclasses to extend. Ancestors of this class are organizational parts of DomView.\n\n*/\n\n(class DomView_browserDragAndDrop extends DomView {\n    \n    // -- browser register for drop ---\n\n    isRegisteredForBrowserDrop () {\n        return this.dropListener().isListening()\n    }\n\n    setIsRegisteredForBrowserDrop (aBool) {\n        this.dropListener().setIsListening(aBool)\n        return this\n    }\n\n    acceptsDrop () {\n        return true // make ivar?\n    }\n\n    // ---------------------\n\n    onBrowserDragEnter (event) {\n        // triggered on drop target\n        //console.log(\"onBrowserDragEnter acceptsDrop: \", this.acceptsDrop());\n        event.preventDefault() // needed?\n\n        if (this.acceptsDrop(event)) {\n            this.onBrowserDragOverAccept(event)\n            return true\n        }\n\n        return false;\n    }\n\n    onBrowserDragOver (event) {\n        // triggered on drop target\n        //console.log(\"onBrowserDragOver acceptsDrop: \", this.acceptsDrop(event), \" event:\", event);\n\n        event.preventDefault()\n\n        if (this.acceptsDrop(event)) {\n            event.dataTransfer.dropEffect = \"copy\";\n            event.dataTransfer.effectAllowed = \"copy\";\n            this.onBrowserDragOverAccept(event)\n            return true\n        }\n\n        return false;\n    }\n\n    onBrowserDragOverAccept (event) {\n        //console.log(\"onBrowserDragOverAccept \");\n        this.dragHighlight()\n    }\n\n    onBrowserDragLeave (event) {\n        // triggered on drop target\n        //console.log(\"onBrowserDragLeave \", this.acceptsDrop(event));\n        this.dragUnhighlight()\n        return this.acceptsDrop(event);\n    }\n\n    dragHighlight () {\n\n    }\n\n    dragUnhighlight () {\n\n    }\n\n    // --- browser drop ---\n\n    onBrowserDrop (event) {\n        if (this.acceptsDrop(event)) {\n            //const file = event.dataTransfer.files[0];\n            //console.log('onDrop ' + file.path);\n            this.onBrowserDataTransfer(event.dataTransfer)\n            this.dragUnhighlight()\n            event.preventDefault();\n            event.stopPropagation()\n            return true;\n        }\n        event.preventDefault();\n        return false\n    }\n\n    dropMethodForMimeType (mimeType) {\n        let s = mimeType.replaceAll(\"/\", \" \")\n        s = s.replaceAll(\"-\", \" \")\n        s = s.capitalizeWords()\n        s = s.replaceAll(\" \", \"\")\n        return \"onBrowserDrop\" + s\n    }\n\n    onBrowserDataTransfer (dataTransfer) {\n        // TODO: we need a way to avoid handling the same item twice...\n\n        if (dataTransfer.files.length) {\n            for (let i = 0; i < dataTransfer.files.length; i++) {\n                const file = dataTransfer.files[i]\n                this.onBrowserDropFile(file)\n            }\n        } else if (dataTransfer.items) {\n            let data = dataTransfer.items\n\n            let dataTransferItems = []\n            for (let i = 0; i < data.length; i++) {\n                dataTransferItems.push(data[i])\n            }\n\n            dataTransferItems = dataTransferItems.reversed()\n\n            for (let i = 0; i < dataTransferItems.length; i++) {\n                const dataTransferItem = dataTransferItems[i]\n                const mimeType = dataTransferItem.type\n\n                // Example MIME types: \n                // text/plain, text/html, text/uri-list\n\n                if (mimeType) {\n                    dataTransferItem.getAsString((s) => {\n                        const chunk = BMDataUrl.clone()\n                        chunk.setMimeType(mimeType)\n                        chunk.setDecodedData(s)\n                        console.log(\"Drag mimeType: '\" + mimeType + \"'\")\n                        console.log(\"    data: \" + s.length + \" bytes\")\n                        this.onBrowserDropChunk(chunk)\n                    })\n                }\n                break; // only send the first MIME type for now\n            }\n        }\n    }\n\n    async onBrowserDropFile (file) {\n        const mimeType = file.type;\n        const data = await FileReader.promiseReadAsDataURL(file);\n        this.onBrowserDropMimeTypeAndRawData(mimeType, data);\n    }\n\n    onBrowserDropMimeTypeAndRawData (mimeType, dataUrl) {\n        const dd = BMDataUrl.clone().setDataUrlString(dataUrl)\n        this.onBrowserDropChunk(dd)\n    }\n\n    onBrowserDropChunk (dataChunk) {\n        // if the view has a method for the mime type of the file\n        // e.g. onBrowserDropImageJpeg\n        // then we call it. If the view wants to handle all types,\n        // it can override this method.\n\n        const methodName = this.dropMethodForMimeType(dataChunk.mimeType())\n        const method = this[methodName]\n        console.log(\"onBrowserDropFile => \", methodName)\n\n        if (method) {\n            method.call(this, dataChunk)\n        }\n    }\n\n    // --- browser dragging ---\n\n    setDraggable (aBool) {\n        assert(Type.isBoolean(aBool))\n        this.element().setAttribute(\"draggable\", aBool)\n        return this\n    }\n\n    draggable () {\n        return this.element().getAttribute(\"draggable\")\n    }\n\n    isRegisteredForBrowserDrag () {\n        return this.browserDragListener().isListening()\n    }\n\n    setIsRegisteredForBrowserDrag (aBool) {\n        this.browserDragListener().setIsListening(aBool)\n        this.setDraggable(aBool)\n        return this\n    }\n\n    onBrowserDragStart (event) {\n        return false;\n    }\n\n    onBrowserDragEnd (event) {\n        // triggered in element being dragged\n        this.dragUnhighlight();\n        //console.log(\"onDragEnd\");\n    }\n\n}.initThisCategory());\n",
  "rm5QAKeAO4Eiyi0CiJ+kGiEaMokQgHx68tQANYeO8BQ=": "\"use strict\";\n\n/*\n    FlexDomView\n\n\n*/\n\n(class FlexDomView extends DomView {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        return this\n    }\n\n    makeFlexAndCenterContent () {\n        this.setDisplay(\"flex\")\n        this.setAlignItems(\"center\")\n        this.setJustifyContent(\"center\")\n        return this\n    }\n\n    canSplit () {\n        return this.subviews().length === 0\n    }\n\n    addSubviewCount (count) {\n        for (let i = 0; i < count; i++) {\n            this.newFlexSubview()     \n        }\n        return this\n    }\n\n    newFlexSubview () {\n        const v = FlexDomView.clone()\n        v.setDisplay(\"flex\")\n        v.setMinHeight(\"0em\")\n        v.setMinWidth(\"0em\")\n        const order = this.subviews().length\n        v.setOrder(order)\n        this.addSubview(v) \n        return v\n    }\n\n    makeSubviewsOrdered () {\n        this.subviews().forEachKV((i, sv) => {\n            sv.setOrder(i)\n        })\n    }\n\n    makeSubviewsReverseOrdered () {\n        const count = this.subviews().length\n        this.subviews().forEachKV((i, sv) => {\n            sv.setOrder(count - 1 - i)\n        })\n    }\n\n    flexSplitIntoTiles (count) {\n        assert(this.canSplit()) // temporary\n        this.setDisplay(\"flex\")\n        this.setFlexDirection(\"column\")\n        this.addSubviewCount(count)\n        this.debugBorders()\n        return this\n    }\n\n    flexSplitIntoColumns (count) {\n        assert(this.canSplit()) // temporary\n        this.setDisplay(\"flex\")\n        this.setFlexDirection(\"row\")\n        this.addSubviewCount(count)\n        this.debugBorders()\n        return this\n    }\n\n    flexCenterContent () {\n        this.setJustifyContent(\"center\")\n        this.setAlignItems(\"center\")\n        return this\n    }\n\n    makeStandardFlexView () {\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.flexCenterContent()\n        this.setOverflow(\"hidden\")\n        return this\n    }\n\n    debugBorders () {\n        //this.subviews().forEach(sv => sv.setBorder(\"1px solid rgba(255, 255, 255, 0.2)\"))\n    }\n\n}.initThisClass());\n",
  "p+DJUpRCJjIM74TBQRU+HbhtAaRWJCJxLp9W4o83lm0=": "\"use strict\";\n\n/*\n    StyledDomView\n\n    (a step towards eliminating the remaining css files)\n\n    A base view to handle styles in a uniform way. \n    Holds an instance of BMViewStyles which holds a set of BMViewStyle instances, one for each style.\n\n    Overview:\n\n        StyledDomView\n          styles -> BMViewStyles\n                        selected -> BMViewStyle\n                        unselected -> BMViewStyle\n                                        color\n                                        backgroundColor\n                                        opacity\n                                        borderLeft\n                                        borderRight\n\n                       \n    \n\n    Supported styles:\n\n    - unselected\n    - selected\n    - active \n    - disabled\n\n*/\n\n\n(class StyledDomView extends FlexDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"themeClassName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"isSelected\", false);\n            slot.setOwnsSetter(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isActive\", false);\n            slot.setOwnsSetter(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isDisabled\", false);\n            slot.setOwnsSetter(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"lockedStyleAttributeSet\", null);\n            slot.setSlotType(\"Set\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setLockedStyleAttributeSet(new Set());\n        Broadcaster.shared().addListenerForName(this, \"onActivateView\"); // NOTE: do we want *every* view to do this \n        return this;\n    }\n\n    syncStateFrom (aView) {\n        this.setIsSelected(aView.isSelected())\n        this.setIsActive(aView.isActive())\n        return this\n    }\n\n    // theme path\n\n    themeClassNamePath () {\n        // search up the view ancestors and compose a path\n        if (this.themeClassName()) {\n            const path = [this.themeClassName()]\n            this.forEachAncestorView(view => {\n                if (view.themeClassName) {\n                    const k = view.themeClassName()\n                    if (k) {\n                        path.push(k)\n                    }\n                }\n            })\n            path.reverse()\n            return path\n        }\n        return null\n    }\n\n    // styles\n\n    /*\n    recursivelyApplyStyles () {\n        this.applyStyles()\n        this.allSubviewsRecursively().forEach(view => {\n            if (view.applyStyles) {\n                view.applyStyles()\n            }\n        })\n        return this\n    }\n    */\n\t\n    applyStyles () {\n        // we default to using the current theme, but \n        // we need to give view a chance to override style\n        // also, NodeView should override this method to give node a chance to override style\n\n        const state = this.currentThemeState()\n        if (state) {\n            state.applyToView(this)\n        }\n        return this\n    }\n\n    // --- activate ---\n\n    didUpdateSlotIsActive (oldValue, newValue) {\n        // sent by hooked setter\n        this.updateSubviews()\n        return this\n    }\n\n    activate () {\n        this.select()\n        this.setIsActive(true)\n        Broadcaster.shared().broadcastNameAndArgument(\"onActivateView\", this)\n    }\n\n    onActivateView (aView) {\n        if (aView !== this & this.isActive()) {\n            this.setIsActive(false)\n        }\n    }\n\n    // --- select ---\n\n    didUpdateSlotIsSelected (oldValue, newValue) {\n        // sent by hooked setter\n        this.updateSubviews()\n        return this\n    }\n\n    toggleSelection () {\n        if (this.isSelected()) {\n            this.unselect()\n        } else {\n            this.select()\n        }\n        return this\n    }\n\n    select () {\n        this.setIsSelected(true)\n        return this\n    }\n\n    unselect () {\n        if (this.isSelected()) { // for debugging \n            this.setIsSelected(false)\n        }\n        return this\n    }\n\n    // --- path array for debugging --------------------------------------\n    \n    themePathArray () {\n        // using this is problematic as we may want to make the path \n        // dependent of complex things e.g. if the themeClassName isn't\n        // found, we will default to DefaultThemeClass - or we may want\n        // to continue the search for a themeClass by walking up the View's\n        // class hierarchy names\n\n        const path = []\n\n        const themeClassName = this.themeClassName()\n        if (themeClassName) {\n            path.push(themeClassName)\n        } else {\n            path.push(\"DefaultThemeClass\")\n        }\n\n        const stateName = this.currentThemeStateName() \n        path.push(stateName)\n\n        return path\n    }\n\n    themePathString () {\n        return this.themePathArray().join(\" / \")\n    }\n    \n    // --- getting current theme/state/attribute ---\n\n    // --- theme class ---\n\n    currentThemeClass () {\n        const theme = BMThemeResources.shared().activeTheme()\n        if (!theme) {\n            return null\n        }\n        const className = this.themeClassName() ? this.themeClassName() : \"DefaultThemeClass\"\n        const themeClass = theme.themeClassNamed(className)\n        return themeClass\n    }\n\n    // --- theme state ---\n\n    currentThemeStateName () {\n        let stateName = \"unselected\"\n\n        if (this.isDisabled()) {\n            stateName = \"disabled\" // should this mix with selected?\n        }\n\n        if (this.isSelected()) {\n            stateName = \"selected\"\n        }\n\n        if (this.isActive()) {\n            stateName = \"active\"\n        }\n\n        return stateName\n    }\n\n    currentThemeState () {\n        const tc = this.currentThemeClass() \n        if (tc) {\n            const stateName = this.currentThemeStateName()\n            const state = tc.stateWithName(stateName)\n            assert(state)\n            return state\n        }\n        return null\n    }\n\n    // --- theme attribute ---\n\n    themeValueForAttribute (attributeName) {\n        const stateNode = this.currentThemeState()\n        if (stateNode) {\n            const attribtueNode = stateNode.attributeNamed(attributeName)\n            if (attribtueNode) {\n                const value = attribtueNode.value()\n                if (!value) {\n                    console.log(\"no attribute found for \", this.themePathString() + \" / \" + attributeName)\n                    return null\n                }\n                //console.log(\"theme: \" + fullPathString + \" = \" + value)\n                return value\n            }\n        }\n\n        //console.log(\"no attribute node found for \", this.themePathString() + \" / \" + attributeName)\n        return null\n    }\n\n    // --- theme attribute helpers ----------------------------------\n\n    currentColor () {\n        const v = this.themeValueForAttribute(\"color\")\n        if (v) {\n            return v\n        }\n        return \"inherit\"\n    }\n\n    currentBgColor () {\n        const v = this.themeValueForAttribute(\"backgroundColor\")\n        if (v) {\n            return v\n        }\n        return \"inherit\"\n    }\n\n    resyncAllViews () {\n        this.syncStylesToSubviews()\n        this.applyStyles()\n        super.resyncAllViews()\n        return this\n    }\n\n    syncStylesToSubviews () {\n        return this\n    }\n\t\n}.initThisClass());\n",
  "SFO5fxSBvPyrgwyvKxPR22hZ3QD4TppaHgj1qdPJhQE=": "\"use strict\";\n\n/*\n\n    BooleanView\n\n    The checkbox is composed of 2 overlapping inner views,\n    one for the inner check itself, and one for the outer border around.\n    The check components are rendered with scalable SVG and \n    are synced to match the color of the parent view's text color by\n    getting the computed color and applying it to the fill or stroke of the\n    svg views.\n\n    TODO: support disabled/uneditable color style?\n\n*/\n\n(class BooleanView extends StyledDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"doesClearOnReturn\", false); // needed?\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"doesHoldFocusOnReturn\", false);  // needed?\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"value\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isEditable\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"innerCheckView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"outerCheckView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setFilter(\"blur(0.2px)\")\n        this.flexCenterContent()\n        //this.setBorder(\"1px dashed red\")\n       \n        this.turnOffUserSelect()\n        this.setSpellCheck(false)\n        this.setContentEditable(false)\n\n        const size = this.checkboxSize()\n        this.setMinAndMaxWidthAndHeight(size)\n        //this.setMinAndMaxWidthAndHeight(\"fit-content\")\n\n        this.setOverflow(\"hidden\")\n\n        /*\n        const iconSetView = DomView.clone().setElementClassName(\"IconSetView\")\n        //this.setBorder(\"1px dashed white\")\n        iconSetView.setDisplay(\"flex\")\n        iconSetView.setPosition(\"relative\")\n        //iconSetView.setWidth(\"fit-content\").setHeight(\"fit-content\")\n        iconSetView.setMinAndMaxWidthAndHeight(size)\n        this.addSubview(iconSetView)\n        */\n\n        {\n            const inner = SvgIconView.clone().setIconName(\"inner-checkbox\")\n            //inner.setBorder(\"1px dashed blue\")\n            inner.setDisplay(\"flex\")\n            inner.setPosition(\"absolute\")\n            inner.setTopPx(0)\n            inner.setLeftPx(0)\n            inner.setMinAndMaxWidthAndHeight(size)\n            inner.setStrokeColor(\"transparent\")\n            this.setInnerCheckView(inner)\n            this.addSubview(inner)\n        }\n\n        {\n            const outer = SvgIconView.clone().setIconName(\"outer-checkbox\")\n            //outer.setBorder(\"1px dashed green\")\n            outer.setDisplay(\"flex\")\n            outer.setPosition(\"absolute\")\n            outer.setTopPx(0)\n            outer.setLeftPx(0)\n            outer.setMinAndMaxWidthAndHeight(size)\n            outer.setFillColor(\"transparent\")\n            this.setOuterCheckView(outer)\n            this.addSubview(outer)\n        }\n        \n        this.setIsEditable(this.isEditable())\n\n        return this\n    }\n\n    checkboxSize () {\n        return \"1em\"\n    }\n\n    // editable\n    \n    setIsEditable (aBool) {        \n        this._isEditable = aBool\n        \n        if (this._isEditable) {\n            const g = this.addDefaultTapGesture()\n            g.setShouldRequestActivation(false) // so the tile doesn't block the initial tap\n        } else {\n            this.removeDefaultTapGesture()\n        }\n        \n        this.updateAppearance()\n        \n        return this\n    }\n    \n    toggle () {\n        this.setValue(!this.value())\n        this.didEdit()\n        return this\n    }\n    \n    activate () {\n        this.toggle()\n        return this\n    }\n    \n    // ------------------\n    \n    setValue (v) {\n        if (Type.isNullOrUndefined(v)) {\n            v = false;\n        }\n        \n\t    this._value = v\n\n        this.updateAppearance()\n        return this\n    }\n\t\n    value () {\n\t    return this._value\n    }\n\t\n    isChecked () {\n\t    return this.value()\n    }\n    \n    setBackgroundColor (s) {\n        // needed?\n        return this\n    }\n\t\n    // svg icon\n\n    updateAppearance () {\n        // sent by superview when it changes or syncs to a node\n        // so we can update our appearance to match changes to the parent view's style\n\n        //const color = this.getComputedCssProperty(\"color\") // this can cause a reflow, so avoid it\n        const color = \"white\"\n\n        this.outerCheckView().setStrokeColor(color)\n        this.innerCheckView().setFillColor(this.value() ? color : \"transparent\")\n        \n        return this\n    }\n\n    onTapComplete (aGesture) {\n        super.sendActionToTarget()\n        this.toggle()\n        return false\n    }\n    \n}.initThisClass());\n",
  "nOH3FRG8UR8615lgYb4Zs7DwllNlURHzBOjfLECQ1sc=": "\"use strict\";\n\n/*\n\n    ButtonView\n\n    A simple push button view with a TextView label.\n\n\n    .BMActionFieldView {\n        min-height: 28px;\n\n        padding-top: 8px;\n        padding-bottom: 8px;\n\n        background-color: #888;\n        color: #ccc;\n\n        border-style: none;\n        border-radius: 5px;\n        border-width: 1px;\n        border-color:#888;\n        \n        text-align: center;\n        vertical-align: center;\n\n    }\n\n    .BMActionFieldView:hover {\n        color: white;\n        background-color: #888;\n    }\n\n*/\n\n(class ButtonView extends FlexDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"titleView\", null);\n            slot.setSlotType(\"TextField\");\n        }\n        {\n            const slot = this.newSlot(\"subtitleView\", null);\n            slot.setSlotType(\"TextField\");\n        }\n        {\n            const slot = this.newSlot(\"isEnabled\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"iconView\", null);\n            slot.setSlotType(\"SvgIconView\");\n        }\n        {\n            const slot = this.newSlot(\"info\", null);\n            slot.setSlotType(\"Object\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setFlexDirection(\"column\")\n        this.flexCenterContent()\n        this.setHeight(\"fit-content\")\n        this.setWidth(\"100%\")\n        this.setMinHeight(\"1em\")\n\n        this.setPaddingTop(\"0.75em\")\n        this.setPaddingBottom(\"0.85em\")\n\n        this.setPaddingLeft(\"1em\")\n        this.setPaddingRight(\"1em\")\n\n        this.turnOffUserSelect()\n        this.setBorderRadiusPx(1)\n\n        {\n            const view = TextField.clone()\n            this.setTitleView(view)\n            this.addSubview(view)\n            view.fillParentView()\n            view.setPaddingTop(\"0.1em\").setPaddingBottom(\"0.1em\")\n            view.setPaddingLeft(\"1em\").setPaddingRight(\"1em\")\n            view.flexCenterContent()\n            view.setTextAlign(\"center\")\n            view.setMinHeight(\"1em\")\n            view.setWhiteSpace(\"nowrap\")\n            view.setTextOverflow(\"ellipsis\")\n        }\n\n        {\n            const view = TextField.clone()\n            this.setSubtitleView(view)\n            this.addSubview(view)\n            view.fillParentView()\n            view.setPaddingTop(\"0.1em\").setPaddingBottom(\"0.1em\")\n            view.setPaddingLeft(\"1em\").setPaddingRight(\"1em\")\n            view.flexCenterContent()\n            view.setTextAlign(\"center\")\n            view.setMinHeight(\"fit-content\")\n            view.setWhiteSpace(\"pre-wrap\")\n            view.setTextOverflow(\"ellipsis\")\n            view.setFontSize(\"80%\")\n            view.setIsDisplayHidden(true);\n        }\n\n        this.setTitle(\"\")\n\n        const icon = SvgIconView.clone() //.setElementClassName(\"RightActionView\")\n        icon.setMinAndMaxWidth(12)\n        icon.setMinAndMaxHeight(15)\n        icon.setFillColor(\"white\")\n        icon.setStrokeColor(\"white\")\n        icon.setOpacity(1)\n        icon.hideDisplay()\n        this.setIconView(this.addSubview(icon))\n\n        this.addDefaultTapGesture()\n\n        return this\n    }\n\n    setIconName (aName) {\n        this.iconView().setIconName(aName)\n        return this\n    }\n\n    // --- title ---\n\n    setTitle (s) {\n        if (s === \"\" || Type.isNullOrUndefined(s)) { \n            s = \" \"; // to avoid weird html layout issues\n        }\n\n        this.titleView().setValue(s)\n        //this.titleView().setIsDisplayHidden(!s)\n        return this\n    }\n\n    title () {\n        return this.titleView().value()\n    }\n\n    // --- subtitle ---\n\n    setSubtitle (s) {\n        //console.log(this.typeId() + \".setSubtitle('\" + s + \"')\")\n        const isEmpty = (s === \"\" || Type.isNullOrUndefined(s));\n        this.subtitleView().setValue(s)\n        this.subtitleView().setIsDisplayHidden(isEmpty)\n        return this\n    }\n\n    subtitle () {\n        return this.subtitleView().value()\n    }\n\n    // ------\n\n    setHasOutline (aBool) {\n        if (aBool) {\n            this.setBoxShadow(\"0px 0px 1px 1px rgba(255, 255, 255, 0.2)\")\n        } else {\n            this.setBoxShadow(\"none\")\n        }\n        return this\n    }\n\n    setTitleIsVisible (aBool) {\n        this.titleView().setIsDisplayHidden(!aBool)\n        return this\n    }\n\n    setIsEditable (aBool) {\n        this.titleView().setIsEditable(aBool)\n        return this\n    }\n\n    isEditable () {\n        return this.titleView().isEditable()\n    }\n\n    sendActionToTarget () {\n        if (!this.isEditable()) {\n            super.sendActionToTarget()\n        }\n        return this\n    }\n\n    onTapBegin (aGesture) {\n        if (!this.isEnabled()) {\n            aGesture.cancel()\n            return\n        }\n        this.setBackgroundColor(\"rgba(255, 255, 255, 0.1)\")\n        //SimpleSynth.clone().playButtonDown()\n    }\n\n    onTapCancelled (aGesture) {\n        this.setBackgroundColor(\"rgba(255, 255, 255, 0.0)\")\n        //SimpleSynth.clone().playButtonCancelled()\n    }\n\n    onTapComplete (aGesture) {\n        //this.debugLog(\".onTapComplete()\")\n        //const bgColor = this.backgroundColor();\n        //setTimeout(() => { this.setBackgroundColor(bgColor) }, 100);\n        //this.setBackgroundColor(\"rgba(255, 255, 255, 0.2)\")\n        this.setBackgroundColor(\"rgba(255, 255, 255, 0.0)\")\n        this.sendActionToTarget()\n        //SimpleSynth.clone().playButtonUp()\n        SimpleSynth.clone().playButtonTap()\n        return false\n    }\n    \n}.initThisClass());\n",
  "nB4jl2AGgUPMy8sS/lHek62jOOV709+g1Mq5bF2d/7A=": "\"use strict\";\n\n\n/* \n\n    CloseButton\n\n    TODO: make subclass of ButtonView?\n\n*/\n\n(class CloseButton extends FlexDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isEnabled\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"iconView\", null);\n            slot.setSlotType(\"SvgIconView\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.makeFlexAndCenterContent()\n        this.setPadding(\"0em\")\n        this.turnOffUserSelect()\n        //this.setDisplay(\"table\") // to center svg\n\n        const iv = SvgIconView.clone().setIconName(\"close\")\n        iv.setColor(\"white\")\n\n        iv.setMinAndMaxWidth(10)\n        iv.setMinAndMaxHeight(10)\n                \n        //iv.setWidth(\"fit-content\")\n        //iv.setHeight(\"fit-content\")\n\n        iv.makeFlexAndCenterContent()\n        //iv.setTopPx(0)\n        //iv.setLeftPx(0)\n        //iv.setMarginBottom(\"1px\") // TODO: fix the SVG for this icon so this isn't needed?\n\n\n        this.setIconView(iv)\n        this.addSubview(iv)\n\n        this.setAction(\"close\")\n        this.addDefaultTapGesture()\n        return this\n    }\n\n    setIconName (aString) {\n        this.iconView().setIconName(aString)\n        return this\n    }\n\n    // --- editable ---\n    \n    setIsEnabled (aBool) {\n        if (this._isEnabled !== aBool) {\n            this._isEnabled = aBool\n            this.syncEnabled()\n        }\n\n        return this\n    }\n\n    syncEnabled () {\n        //this.setIsDisplayHidden(!this.isEnabled())\n        return this\n    }\n\n    onTapComplete (aGesture) {\n        //this.debugLog(\".onTapComplete()\")\n        if (!this.isEditable()) {\n            this.sendActionToTarget()\n        }\n        return false\n    }\n    \n}.initThisClass());\n",
  "x/KkFLXc3xf43IllgQfkL8Ner2Vvhw4k4bUVkTxIRBg=": "\"use strict\";\n\n/*\n\n    DocumentBody\n\n*/\n\n(class DocumentBody extends DomView {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n\n        // setup shared devices for later use\n        Devices.shared().setupIfNeeded()\n        \n        //this.documentListener().setIsListening(true)\n        this.setIsRegisteredForBrowserDrop(true) // to avoid dropping on window\n\n        return this\n    }\n\n    acceptsDrop (event) { // to avoid dropping on window\n        event.preventDefault();\n        return false\n    }\n    \n    setupElement () {\n        //document.body.setDomView(this)\n        this._element = document.body\n        this._element.setDomView(this)\n        // get this from element override\n        return this\n    }\n    \n    element () {\n        return document.body\n    }\n    \n    zoomAdjustedWidth () {\n        return WebBrowserWindow.shared().width() * this.zoomRatio()\n    }\n    \n    zoomAdjustedHeight () {\n        return WebBrowserWindow.shared().width() * this.zoomRatio()\n    }\n    \n    zoomAdjustedSize () { // TODO: move to Point\n        return { width: this.zoomAdjustedWidth(), height: this.zoomAdjustedHeight() }\n    }\n\n    allDomElements () {\n        const domElements = this.element().getElementsByTagName(\"*\");\n        return domElements\n    }\n\n    viewsUnderPoint (aPoint) {\n        const elements = document.elementsFromPoint(aPoint.x(), aPoint.y())\n        const views = elements.map(e => this.firstViewForElement(e)).nullsRemoved()\n        return views\n    }\n\n    firstViewForElement (e) {\n        // search up the dom element parents to find one\n        // associated with a DomView instance \n\n        while (e) {\n            const view = e.domView()\n            if (view) {\n                return view\n            }\n            e = e.parentElement\n        }\n\n        return null\n    }\n\n   \n}.initThisClass());\n\n",
  "K1vbmweT+3CflPm2zWeU6IZpKZIj0L28A7bNuhtShuc=": "\"use strict\";\n\n/* \n\n    DragBarView\n\n*/\n\n\n(class DragBarView extends DomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isEnabled\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isHighlighted\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isDragging\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"normalColor\", \"#333\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"highlightColor\", \"#555\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"dragColor\", \"#999\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"delegate\", null);\n            slot.setSlotType(\"Object\"); //<DragBarViewDelegate>\n        }\n        {\n            const slot = this.newSlot(\"thickness\", 2);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"isVerticalDrag\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init()\n\n        this.turnOffUserSelect()\n\n        this.setElementClassName(\"DragBarView\")\n        this.setDisplay(\"inline-block\")\n\n        this.setIsRegisteredForMouse(true)\n        this.syncHighlighted()\n        this.syncEnabled()\n\n        this._mouseMoveTrackerFunc = (event) => {\n            this.mouseMoveTracker(event)\n            return true\n        }\n\n        this._mouseUpTrackerFunc = (event) => {\n            this.mouseUpTracker(event)\n            return true\n        }\n\n        this.setBackgroundColor(this.normalColor())\n        return this\n    }\n\n    hoverCursorType () {\n        if (this.isVerticalDrag()) {\n            return \"row-resize\"\n        }\n\n        return \"col-resize\"\n    }\n\n    setIsVertical (aBool) {\n        if (this._isVertical !== aBool) {\n            this._isVertical = aBool\n            //console.log(\"this.hoverCursorType() = \", this.hoverCursorType())\n            this.setCursor(this.hoverCursorType())\n        }\n        return this\n    }\n\n    // --- editable ---\n    \n    setIsEnabled (aBool) {\n        if (this._isEnabled !== aBool) {\n            this._isEnabled = aBool\n            this.syncEnabled()\n        }\n\n        return this\n    }\n\n    syncEnabled () {\n        this.setIsDisplayHidden(!this.isEnabled())\n        return this\n    }\n\n    // --- highlighted ---\n    \n    setIsHighlighted (aBool) {\n        if (this._isHighlighted !== aBool) {\n            this._isHighlighted = aBool\n            this.syncHighlighted()\n        }\n\n        return this\n    }\n\n    syncHighlighted () {\n        if (this.isDragging()) {\n            return this\n        }\n\n        if (this.isHighlighted()) {\n            this.setBackgroundColor(this.highlightColor())\n        } else {\n            this.setBackgroundColor(this.normalColor())\n        }\n        this.syncCursor()\n\n        return this\n    }\n\n    syncCursor () {\n        if (this.isHighlighted()) {\n            this.setCursor(this.hoverCursorType())\n        } else {\n            this.setCursor(null)\n        }\n        return this\n    }\n\n    // --- mouse ---\n\n    mouseMoveTracker (event) {\n        //console.log(\"mouse pos: \", event.clientX, \" x \", event.clientY)\n        if (this.delegate()) {\n            this.delegate().didDragDivider(Math.floor(event.clientX), Math.floor(event.clientY))\n        }\n    }\n\n    mouseUpTracker (event) {\n        //console.log(\"mouse pos: \", event.clientX, \" x \", event.clientY)\n        this.onMouseUp(event)\n    }\n\n    setIsDragging (b) {\n        this._isDragging = b;\n        if (b) {\n            this.setBackgroundColor(this.dragColor())\n            this.parentView().setBorder(\"1px dashed white\")\n        } else {\n            this.setBackgroundColor(this.normalColor())\n            this.parentView().setBorder(\"0px dashed white\")\n        }\n        return this\n    }\n\n    onMouseDown (event) {\n        //this.debugLog(\" onMouseDown\")\n        this.setIsDragging(true)\n\n        this.removeParentTracking()\n        return false\n    }\n\n    addParentTracking () {\n        const r = this.documentBodyView()\n        r.element().removeEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n        r.element().removeEventListener(\"mouseup\", this._mouseUpTrackerFunc, false);\n        return this\n    }\n\n    removeParentTracking () {\n        const r = this.documentBodyView()\n        r.element().addEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n        r.element().addEventListener(\"mouseup\", this._mouseUpTrackerFunc, false);\n        return this\n    }\n\n    onMouseMove (event) {\n        return false\n    }\n\n    onMouseOver (event) {\n        //this.debugLog(\" onMouseOver\")\n        this.setIsHighlighted(true)\n        return false\n    }\n\n    onMouseLeave (event) {\n        //this.debugLog(\" onMouseLeave\")\n        this.setIsHighlighted(false)\n        return false\n    }\n\n    onMouseUp (event) {\n        this.setIsDragging(false)\n        this.addParentTracking()\n        return false\n    }\n    \n}.initThisClass());\n",
  "HLdFawosnamM5nz1zMFHMk5g7YiKtQw3L8RIUPoFmCk=": "\"use strict\";\n\n/*\n\n    DragView\n    \n    A view to globally drag and drop another view or data.\n\n    Dragging Protocol\n\n        Messages sent to the Item \n            \n            - onDragItemBegin\n            - onDragItemCancelled\n            - onDragItemDropped   \n\n        Messages sent to Source \n            \n            - onDragSourceBegin\n            - onDragSourceHover\n            - onDragSourceCancelled // dropped on a view that doesn't accept it\n            - onDragSourceDropped\n            - onDragSourceEnd\n\n            // using these messages avoids a bunch of conditions in the receiver \n            // the source is repsonsible for completing the drag operation\n            // the DragView will set it's destination slot before calling these\n            \n            - onDragSourceMoveToDestination \n            - onDragSourceCopyToDestination\n            - onDragSourceLinkToDestination\n            \n            - onDragSourceMoveToSelf\n            - onDragSourceCopyToSelf\n            - onDragSourceLinkToSelf\n        \n            \n        Messages sent to Destination or Hover target \n            \n            - acceptsDropHover\n            - onDragDestinationEnter // not sent if destination === source\n            - onDragDestinationHover\n            - onDragDestinationExit\n            - acceptsDropHoverComplete\n            - onDragDestinationDropped\n            - onDragDestinationEnd\n\n        Messages sent by Destination to item\n\n            - onDragRequestRemove() // return true if approved\n\n        Notifications sent\n\n            - onDragViewOpen\n            - onDragViewClose\n\n    Example use (from within a view to be dragged):\n\n    onLongPressComplete (longPressGesture) {\n        const dv = DragView.clone().setItem(this).setSource(this.column())\n        dv.openWithEvent(longPressGesture.currentEvent()) // TODO: eliminate this step?\n    } \n\n*/\n\n(class DragView extends StyledDomView {\n    \n    initPrototypeSlots () {\n        // the view that will be dragged when operation is complete\n        //this.newSlot(\"item\", null)\n\n        // the set of views that will be dragged\n        {\n            const slot = this.newSlot(\"items\", []);\n            slot.setSlotType(\"Array\");\n        }\n\n        // a place for the source to store any extra info about the drag operation,\n        // such as the indexes of the items\n        {\n            const slot = this.newSlot(\"info\", null);\n            slot.setSlotType(\"Object\");\n        }\n\n        // the view which is the owner of the view being dragged that implements the source protocol\n        {\n            const slot = this.newSlot(\"source\", null);\n            slot.setSlotType(\"DomView\"); // TODO: make this a protocol\n        }\n\n        // the view on which the item is dropped\n        {\n            const slot = this.newSlot(\"destination\", null);\n            slot.setSlotType(\"DomView\");\n        }\n\n        {\n            const slot = this.newSlot(\"validOperations\", new Set([\"move\", \"copy\", \"link\", \"delete\"]));\n            slot.setSlotType(\"Set\");\n        }\n\n        // a list of views that self is currently hovering over\n        {\n            const slot = this.newSlot(\"hoverViews\", null);\n            slot.setSlotType(\"Array\");\n        }\n\n        // start position in screen coordinates \n        {\n            const slot = this.newSlot(\"dragStartPos\", null);\n            slot.setSlotType(\"Point\");\n        }\n\n        // the drag operation type: move, copy, link, delete\n        {\n            const slot = this.newSlot(\"dragOperation\", \"move\")\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"slideBackPeriod\", 0.2); // seconds\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"isClosed\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    didUpdateSlotDragOperation () {\n        assert(this.validOperations().has(this.dragOperation()));\n    }\n\n    init () {\n        super.init();\n        this.setHoverViews([]);\n\n        this.setDisplay(\"flex\");\n        this.setPosition(\"absolute\");\n        this.turnOffUserSelect();\n        this.setOverflow(\"hidden\");\n        this.setMinWidthPx(10);\n        this.setMinHeightPx(10);\n        this.setWidth(\"fit-content\");\n        this.setMinHeight(\"fit-content\");\n        this.setOpacity(0.9);\n        this.setInfo({});\n\n        this.setIsDebugging(false);\n        return this;\n    }\n\n    // operation type helpers\n\n    isCopyOp () {\n        return this.dragOperation() === \"copy\";\n    }\n\n    isMoveOp () {\n        return this.dragOperation() === \"move\";\n    }\n\n    isLinkOp () {\n        return this.dragOperation() === \"link\";\n    }\n\n    isDeleteOp () {\n        return this.dragOperation() === \"delete\";\n    }\n\n    // ----\n\n    setItem (aView) {\n        this.setItems([aView]);\n        return this;\n    }\n\n    item () {\n        return this.items().first();\n    }\n\n    // ----\n\n    setupView () {\n        if (this.items().length === 1) {\n            this.setupSingleItemView();\n        } else {\n            this.setupMultiItemView();\n        }\n        this.setZIndex(10);\n        return this;\n    }\n\n    setupMultiItemView () {\n        const parentView = this.items().first().parentView()\n\n        // copy parent frame\n        const f = parentView.frameInDocument()\n        this.setFrameInDocument(f)\n        this.setBackgroundColor(\"transparent\")\n\n        // duplicate item subviews\n        this.items().forEach(sv => {\n            const dup = sv.htmlDuplicateView()\n            this.addSubview(dup)\n            assert(dup.hasFixedFrame())\n            //console.log(\"item dup subview frameInDocument: \" + dup.frameInDocument().asString())\n            //console.log(\"item dup subview frameInParentView: \" + dup.frameInParentView().asString())\n        })\n\n        const ff = this.fixedFrameFittingSubviews()\n        const nf = parentView.convertFrameToDocument(ff)\n        this.setFrameInDocument(nf)\n        //this.setFrameInDocument(this.fixedFrameFittingSubviewsInDocument())\n        //this.setBorder(\"1px dashed yellow\")\n\n        // make subviews inline-block\n        this.subviews().forEach(sv => {\n            sv.setDisplay(\"inline-block\")\n            sv.setPosition(\"relative\")\n            sv.setTop(null)\n            sv.setLeft(null)\n            sv.setBorder(null)\n            sv.setFloat(\"left\")\n            /*\n            sv.decrementFixedWidth()\n            sv.decrementFixedHeight()\n            sv.decrementFixedWidth()\n            sv.decrementFixedHeight()\n            sv.setMinAndMaxWidth(150)\n            sv.setBorder(\"1px dashed blue\")\n            */\n            //sv.setMinAndMaxHeight(30)\n        })\n        \n        this.setDisplay(\"block\")\n        this.setWhiteSpace(\"normal\")\n        this.setOverflow(\"hidden\")\n        this.setWidth(null)\n        this.setHeight(null)\n\n        this.setWidth(\"fit-content\")\n        this.setHeight(\"fit-content\")\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)\n        /*\n        let maxWidth = this.items().map(v => v.frameInDocument().width()).maxValue()\n        let minX = this.items().map(v => v.frameInDocument().left()).minValue()\n        let minY = this.items().map(v => v.frameInDocument().top()).minValue()\n        //let maxY = this.items().map(v => v.frameInDocument().bottom()).maxValue()\n\n        //this.setMinAndMaxHeight(maxY - minY)\n        let offset = minY - f.top()\n        this.setTopPx(minY)\n\n        // initial positions\n        let y = 0\n        this.items().map((item) => {\n            const h = item.frameInDocument().height()\n            const v = item.htmlDuplicateView()\n            const vf = item.frameInParentView()\n            v.setPosition(\"absolute\")\n            v.setLeftPx(vf.x())\n            v.setTopPx(vf.y() - offset)\n            v._targetTop = y\n            y += h\n            v.setTransition(\"top 0.2s\")\n            this.addSubview(v)\n        })\n        this.setMinAndMaxHeight(y)\n        this.setOverflow(\"visible\")\n\n        this.addTimeout(() => {\n            this.subviews().forEach(v => v.setTopPx(v._targetTop))\n        }, 1)\n        */\n\n        /*\n        // target positions\n        let y = 0\n        this.items().map((item) => {\n            const h = item.frameInDocument().height()\n            const v = item.htmlDuplicateView()\n            const vf = item.frameInParentView()\n            v.setPosition(\"absolute\")\n            v.setTopPx(y)\n            y += h\n            //this.addSubview(v)\n        })\n        this.setMinAndMaxHeight(y)\n        */\n\n    }\n\n    setupSingleItemView () {\n        const aView = this.item()\n        this.setFrameInDocument(aView.frameInDocument())\n        this.setInnerHtml(aView.innerHtml())\n        //const clonedElement = aView.element().cloneNode(true);\n        this.setOverflow(\"visible\")\n    }\n\n    // --- \n\n    hasPan () {\n        return !Type.isNull(this.defaultPanGesture())\n    }\n\n    openWithEvent (event) {\n        // TODO: this is a hack, find a way to init pan without this\n        // setup the Pan Gesture to already be started\n\n        const pan = this.addDefaultPanGesture()\n        pan.setShouldRemoveOnComplete(true)\n        pan.setMinDistToBegin(0)\n        pan.onDown(event)\n        pan.attemptBegin()\n\n        this.setTransition(\"all 0s, transform 0.1s, box-shadow 0.1s\")\n        this.open()\n        \n        return this\n    }\n\n    acceptsPan () {\n        return true\n    }\n\n    // --------------------------\n\n    open () {        \n        this.setupView()\n        DocumentBody.shared().addSubview(this)\n        this.orderFront()\n        this.onBegin()\n        this.postNoteNamed(\"onDragViewOpen\")\n        return this\n    }\n\n    onBegin () {\n        this.sendProtocolMessage(this.source(), \"onDragSourceBegin\")\n    }\n    \n    // --- panning ---\n\n    onPanBegin (aGesture) {\n        this.debugLog(\"onPanBegin\")\n        this.setDragStartPos(this.item().positionInDocument())\n\n        // animate the start of the drag\n\n        this.addTimeout(() => {\n            this.addPanStyle()\n        })\n\n        this.onPanMove(aGesture)\n    }\n\n    updatePosition () {\n        const newPosition = this.dragStartPos().add(this.defaultPanGesture().diffPos()) \n        this.setLeftPx(newPosition.x())\n        this.setTopPx(newPosition.y())\n    }\n\n    onPanMove (aGesture) {\n        this.updatePosition()\n        \n        this.addTimeout(() => { \n            this.hoverOverViews()\n        })\n    }\n\n    onPanCancelled (aGesture) {\n        const destFrame = this.source().dropCompleteDocumentFrame()\n\n        const completionCallback = () => { \n            this.sendProtocolMessage(this.source(), \"onDragSourceCancelled\")\n            this.sendProtocolMessage(this.source(), \"onDragSourceEnd\")\n            this.close() \n        }\n\n        this.animateToDocumentFrame(destFrame, this.slideBackPeriod(), completionCallback)\n        this.removePanStyle()\n    }\n\n    firstAcceptingDropTarget () {\n        return this.hoverViews().detect((v) => {\n            return v.acceptsDropHoverComplete && v.acceptsDropHoverComplete(this)\n        })\n    }\n\n    currentOperation () {\n        const keyboard = BMKeyboard.shared()\n\n        if (keyboard.alternateKey().isDown()) {\n            return \"copy\"\n        }\n\n        if (keyboard.alternateKey().isDown()) {\n            return \"link\"\n        }\n\n        return \"move\"\n    }\n\n    onPanComplete (aGesture) {\n        this.debugLog(\"onPanComplete\")\n\n        //this.setDragOperation(this.currentOperation())\n\n        const destView = this.firstAcceptingDropTarget()\n        \n        if (!destView) {\n            this.onPanCancelled(aGesture)\n            return;\n        }\n\n        const isSource = (destView === this.source())\n\n        this.setDestination(destView)\n\n        if (destView) {\n            const completionCallback = () => {\n                this.sendProtocolAction(destView, \"Dropped\") // onDragSourceDropped onDragDestinationDropped\n\n                this.sendProtocolMessage(this.source(), \"onDragSourceEnd\")\n                if (destView !== this.source()) {\n                    this.sendProtocolMessage(destView, \"onDragDestinationEnd\")\n                }\n\n                this.close()\n            }\n            const destFrame = destView.dropCompleteDocumentFrame()\n            this.animateToDocumentFrame(destFrame, this.slideBackPeriod(), completionCallback)\n            this.removePanStyle()\n            this.hoverViews().remove(destView) // so no exit hover message will be sent to it\n        } else {\n            this.close()\n        }\n    }\n\n    // --- hovering behaviors ---\n\n    viewsUnderDefaultPan () {\n        return DocumentBody.shared().viewsUnderPoint(this.dropPoint())\n    }\n\n    dropPoint () {\n        return this.defaultPanGesture().currentPosition()\n    }\n\n    newHoverViews () {\n        //console.log(\"dropPoint: \" + this.dropPoint().asString())\n        return this.viewsUnderDefaultPan().select(v => v.acceptsDropHover && v.acceptsDropHover(this))\n    }\n\n    hoverOverViews () {\n        const oldViews = this.hoverViews()\n        const newViews = this.newHoverViews()\n\n        // if new view was not in old one's, we must be entering it\n        const enteringViews = newViews.select(v => !oldViews.contains(v))\n\n        // if new view was in old one's, we're still hovering\n        const hoveringViews = newViews.select(v => oldViews.contains(v))\n\n        // if old view isn't in new ones, we must have exited it\n        const exitingViews = oldViews.select(v => !newViews.contains(v))\n \n        // onDragSourceEnter onDragDestinationEnter \n        enteringViews.forEach(aView => this.sendProtocolAction(aView, \"Enter\"))\n\n        // onDragSourceHover onDragDestinationHover\n        hoveringViews.forEach(aView => this.sendProtocolAction(aView, \"Hover\"))\n\n        // onDragSourceExit onDragDestinationExit \n        exitingViews.forEach(aView =>  this.sendProtocolAction(aView, \"Exit\")) \n\n        this.setHoverViews(newViews)\n        return this\n    }\n\n    exitAllHovers () {\n        this.hoverViews().forEach((aView) => { this.sendProtocolAction(aView, \"Exit\") })\n        this.setHoverViews([])\n    }\n\n    // drop hover protocol\n\n    sendProtocolAction (aView, action) {\n        // onDragSourceHover & onDragDestinationHover\n        const isSource = aView === this.source()\n        const methodName = \"onDrag\" + (isSource ? \"Source\" : \"Destination\") + action\n        //this.debugLog(aView.node().title() + \" \" + methodName)\n        this.sendProtocolMessage(aView, methodName)\n    }\n\n    sendProtocolMessage (receiver, methodName) {\n        if (!methodName.contains(\"Hover\") && this.isDebugging()) {\n\n            let msg = receiver.typeId() + \" \" + methodName \n\n            if (methodName.contains(\"Dropped\")) {\n                msg += \" \" + this.dragOperation()\n            }\n    \n            if (!receiver[methodName]) {\n                msg += \" <<<<<<<<<<<<<< NOT FOUND \"\n            }\n\n            this.debugLog(msg)\n        }\n\n        if (receiver[methodName]) {\n            // this fails on onDragDestinationEnd method triggered by onMouseUpCapture\n            receiver[methodName].call(receiver, this)\n        }\n    }\n    \n    // close\n\n    close () {\n        this.debugLog(\"close\")\n        this.postNoteNamed(\"onDragViewClose\")\n        // handle calling this out of seqence?\n\n        this.exitAllHovers()\n        // TODO: animate move to end location before removing\n\n        this.removePanStyle()\n        DocumentBody.shared().removeSubview(this)\n        assert(Type.isNullOrUndefined(this.element().parentNode)) // sanity check\n        this.setItems([])\n        this.setIsClosed(true)\n\n\n        return this\n    }\n\n    // --- drag style ---\n\n    addPanStyle () {\n        const s = \"0px 0px 10px 10px rgba(0, 0, 0, 0.5)\"\n        const r = 1.05 // 1.1 * (1/Math.sqrt(this.items().length))\n        this.setTransform(\"scale(\" + r + \")\")\n        if (this.subviews().length) {\n            this.subviews().forEach(v => v.setBoxShadow(s))\n        } else {\n            this.setBoxShadow(s)\n        }\n        return this\n    }\n\n    removePanStyle () {\n        const s = \"none\"\n        this.setTransform(\"scale(1)\")\n        if (this.subviews().length) {\n            this.subviews().forEach(v => v.setBoxShadow(s))\n        } else {\n            this.setBoxShadow(s)\n        }\n        return this\n    }\n\n}.initThisClass());\n",
  "CP1nqzw7SOypTvCkqcWLkgUY9BCDcjbzmXJzUPHn6AI=": "\"use strict\";\n\n/*\n\n    PanelView\n\n*/\n\n(class PanelView extends DomView { \n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"titleView\", null);\n            slot.setSlotType(\"TextField\");\n        }\n        {\n            const slot = this.newSlot(\"subtitleView\", null);\n            slot.setSlotType(\"TextField\");\n        }\n        {\n            const slot = this.newSlot(\"button1\", null);\n            slot.setSlotType(\"ButtonView\");\n        }\n        {\n            const slot = this.newSlot(\"isDragging\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    setCssOnSubview (view) {\n        //view.setPadding(\"10px\");\n        //view.setBorder(\"1px solid #ddd\");\n        view.setMarginBottom(\"5px\");\n        view.setPaddingLeft(\"1em\");\n        view.setPaddingRight(\"1em\");\n        view.setWidth(\"fit-content\");\n        view.setHeight(\"fit-content\");\n        view.setInset(null);\n        return this;\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\");\n        this.setPosition(\"absolute\");\n\n        this.setAlignItems(\"center\");\n        this.setJustifyContent(\"center\");\n        this.setTop(\"0%\");\n        this.setLeft(\"50%\");\n        this.setTransform(\"translate(-50%, -50%)\");\n        this.setFlexDirection(\"column\");\n        //this.setMinAndMaxHeight(\"fit-content\");\n        this.setWidth(\"fit-content\");\n        this.setHeight(\"fit-content\");\n        this.setZIndex(1000);\n\n        {\n            // title view\n            const view = TextField.clone().setElementClassName(\"PanelTitleView\");\n            this.setTitleView(view);\n            this.addSubview(view);\n            view.setTextAlign(\"center\")\n            view.setHeight(\"3em\");\n            view.setWhiteSpace(\"normal\");\n            view.centerInParentView();\n            view.setValue(\"\");\n            view.setColor(\"white\");\n            this.setCssOnSubview(view);\n        }\n\n        //this.setSubtitleView(TextField.clone().setElementClassName(\"PanelSubtitleView\"))\n        //this.addSubview(this.subtitleView())\n\n        {\n            // button 1\n            const view = ButtonView.clone();\n            this.setButton1(view);\n            this.addSubview(view);\n            //view.setPosition(\"absolute\").setRightPx(10).setBottomPx(10);\n            //view.setMinAndMaxWidth(100);\n            view.setTitle(\"OK\");\n            view.setTarget(this).setAction(\"hitButton1\");\n            view.setBorder(\"1px solid rgba(255,255,255,0.5)\");\n            view.setPaddingTop(\"0em\");\n            view.setPaddingBottom(\"0em\");\n\n            this.setCssOnSubview(view);\n        }\n\n        return this\n    }\n\n    setTitle (s) {\n        this.titleView().setValue(s)\n        return this\n    }\n\n    openInWindow () {\n        App.shared().mainWindow().documentBody().addSubview(this);\n        return this\n    }\n\n    static showError (error) {\n        const panel = PanelView.clone().setTitle(error.message)\n        //.setMinAndMaxWidth(300).setMinAndMaxHeight(200);\n        panel.centerInParentView();\n        panel.setTopPx(0);\n        panel.setBackgroundColor(\"red\");\n        panel.setColor(\"white\");\n        panel.openInWindow();\n        return panel;\n    }\n\n    /*\n    // --- dragging ---\n\n    setupForDraggingWithMouse () {\n        this.setIsRegisteredForMouse(true)\n    }\n\n    mouseMoveTracker (event) {\n        //console.log(\"mouse pos: \", event.clientX, \" x \", event.clientY)\n        if (this.isDragging()) {\n            this.setLeftPx(event.clientX - (this._startClientX - this._startLeft))\n            this.setTopPx(event.clientY  - (this._startClientY - this._startTop))\n        }\n    }\n\n    onMouseDown (event) {\n        //console.log(\"onMouseDown\")\n        this.setIsDragging(true)\n\n        this.parentView().element().addEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n\n        this._startLeft = this.left()\n        this._startTop = this.top()\n        this._startClientX = event.clientX\n        this._startClientY = event.clientY\n    }\n\n    onMouseMove (event) {\n    }\n\n    onMouseUp (event) {\n        this.setIsDragging(false)\n        //this.setBackgroundColor(this.normalColor())\n        this.parentView().element().removeEventListener(\"mousemove\", this._mouseMoveTrackerFunc, false);\n    }\n    */\n\n    hitButton1 () {\n        this.close()\n        return this\n    }\n\n    close () {\n        this.removeFromParentView()\n        return this\n    }\n    \n}.initThisClass());\n",
  "yklolvJ58ydbAYMIIMPM7Q8AlHKfO9FCXdfSzxHrjtQ=": "\"use strict\";\n\n/*\n\n    SvgIconCache\n\n    Singleton that manages cached Svg objects in document.\n\n*/\n\n(class SvgIconCache extends ProtoClass {\n\n    static initClass () {\n        this.setIsSingleton(true)\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"hashToElementMap\", new Map());\n            slot.setSlotType(\"Map\");\n        }\n        {\n            const slot = this.newSlot(\"svgCacheElement\", null);\n            slot.setSlotType(\"Element\");\n        }\n    }\n\n    svgIdForString (s) {\n        return \"SvgId-\" + s.hashCode();\n    }\n\n    svgContentIdForString (s) {\n        return \"SvgContentId-\" + s.hashCode();\n    }\n\n    cacheSvgForStringIfNeeded (s) {\n        const map = this.hashToElementMap()\n        const h = this.svgIdForString(s)\n        if (!map.has(h)) {\n            assert(document.getElementById(h) === null)\n            const e = this.elementForSvgString(s)\n            assert(e.id === h)\n            this.svgCacheElement().appendChild(e)\n            assert(document.getElementById(h) !== null)\n            map.set(h, e)\n        }\n        return map.at(h)\n    }\n\n    svgCacheElement () {\n        if (!this._svgCacheElement) {\n            const e = document.createElement(\"defs\");\n            e.id = \"SvgIconCache\"\n            e.style.display = \"none\"\n            document.body.appendChild(e)\n            this._svgCacheElement = e\n        }\n        return this._svgCacheElement\n    }\n\n    elementForSvgString (s) {\n        // NOTES: \n        // - style.position of SVG needs to be absolute if in a flex container\n        // - need to use createElementNS and setAttributeNS or things silently fail (e.g. width being 0)\n \n        const xmlns = \"http://www.w3.org/2000/svg\";\n\n        // create a temporary element to put innerHTML in so we can extract svg element\n        const e = document.createElement(\"g\"); \n        e.innerHTML = s\n\n        // get the SVG element (as there may be comments, etc\n        const svg = e.getElementsByTagName(\"svg\")[0]\n        svg.id = this.svgIdForString(s)\n        svg.style.position = \"absolute\" \n\n        // to be able to reference the svg content from a use tag, \n        // we need to group the content into a g tag and add an id\n        //const content = svg.addSymbolLayer()\n        const content = svg.addSvgGroupLayer()\n        content.id = this.svgContentIdForString(s)\n\n        // set up fill, stroke as variables and remove them from descendants\n        // this only works if we want them to be uniform, as we typically do for icons\n        // and it lets us set the colors without creating a new icon\n        svg.setAttributesAndRemoveFromDecendants(this.variableAttributeMap()) \n        //svg.setAttribute(\"preserveAspectRatio\", \"xMidYMin slice\")\n        return svg\n    }\n\n    newLinkElementForSvgString (s) {\n        const cachedSvg = this.cacheSvgForStringIfNeeded(s)\n        // e.g. <use xlink:href=\"#fire\" />\n        const xmlns = \"http://www.w3.org/2000/svg\";\n        const svg = document.createElementNS(xmlns, \"svg\");\n        svg.copyAttributesFrom(cachedSvg)\n        /*\n        svg.setAttributeNS(xmlns, \"x\", \"0\")\n        svg.setAttributeNS(xmlns, \"y\", \"0\")\n        svg.setAttributeNS(xmlns, \"width\", \"100%\")\n        svg.setAttributeNS(xmlns, \"height\", \"100%\")\n        */\n        svg.copyStyleFrom(cachedSvg)\n\n        // need this to avoid zero width issue\n        // https://stackoverflow.com/questions/58792503/why-is-svg-width-0-if-container-is-display-flex\n        svg.style.position = \"absolute\" \n\n        const use = document.createElementNS(xmlns, \"use\"); // is document.createElementNS needed?\n        use.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"xlink:href\", \"#\" + this.svgContentIdForString(s))\n        //use.style.width = \"100%\"\n        //use.style.height = \"100%\"\n        //use.style.width = \"15px\"\n        //use.style.height = \"15px\"\n        //use.style.overflow = \"visible\"\n        //use.setAttribute(\"width\", \"100%\")\n        //use.setAttribute(\"height\", \"100%\")\n        svg.appendChild(use)\n        return svg\n    }\n \n    // --- variable maps ---\n    \n    variableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--fillColor)\")\n        m.set(\"stroke\", \"var(--strokeColor)\")\n        //m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        //m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n\n    /*\n    parentVariableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--color)\")\n        m.set(\"stroke\", \"var(--color)\")\n        m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n    */\n\n\n}.initThisClass());\n",
  "eZBodGKv7np9IuLtPN1UXlaJLu/nmTU78ZIUNL52ms4=": "\"use strict\";\n\n/*\n\n    SvgIconView\n\n    A view to render scalable SVG within a view that can be \n    synced to match the color of the parent view's text color by\n    getting the computed color and applying it to the fill or stroke of the\n    svg views.\n\n    TODO: support disabled/uneditable color style?\n\n\n    Example use:\n\n    SvgIconView.clone().setIconName(\"add\")\n\n*/\n\n(class SvgIconView extends FlexDomView {\n    \n    static initClass () {\n        this.newClassSlot(\"sharedSvgMap\", new Map()) // svgStringHash -> hidden svg element defined in document\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"svgElement\", null);\n            slot.setSlotType(\"Element\");\n        }\n        {\n            const slot = this.newSlot(\"svgString\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"url\", null);\n            slot.setSlotType(\"URL\");\n        }\n        {\n            const slot = this.newSlot(\"iconName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"doesMatchParentColor\", false);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"strokeColor\", \"white\");\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"fillColor\", \"white\");\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"strokeWidth\", 1);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setElementClassName(\"SvgIconView\")\n        this.turnOffUserSelect()\n        this.setOverflow(\"hidden\")\n\n        //this.setPosition(\"absolute\")\n        //this.setTopPx(0)\n        //this.setLeftPx(0)\n\n        this.setPadding(\"0em\")\n        this.setMargin(\"0em\")\n        \n        // /this.setOverflow(\"hidden\")\n        this.setOverflow(\"visible\")\n        //this.setBorder(\"1px yellow dashed\")\n        this.syncColors()\n\n        return this\n    }\n\n    debugTypeId () {\n        const name = this.iconName()\n        return  super.debugTypeId() + (name ? \" '\" + name + \"'\" : \"\")\n    }\n\n    clear () {\n        this.setSvgString(null)\n        this.hideDisplay()\n    }\n\n    setIconName (name) {\n        if (this._iconName !== name) {\n            this._iconName = name\n\n            if (name === null) {\n                this.clear()\n                return this\n            }\n\n            const icons = BMIconResources.shared()\n            const iconNode = icons.firstSubnodeWithTitle(name)\n\n            if (iconNode) {\n                this.setSvgString(iconNode.svgString())\n                this.unhideDisplay()\n            } else {\n                const error = \"can't find icon '\" + name + \"'\"\n                console.log(error)\n                debugger;\n                //throw new Error(error) \n                this.clear()\n                return this\n            }\n\n            this.setElementId(this.debugTypeId() + \" '\" + this.svgId() + \"'\")\n        }\n\n        return this\n    }\n\n    svgId () {\n        return \"svgid-\" + this.iconName() \n        //return \"svgid-\" + this.svgString().hashCode()\n    }\n\n    setSvgString (s) {\n        this._svgString = s\n\n        if (s) {\n            // remove and old svg element\n            while (this.element().lastChild) {\n                this.element().removeChild(this.element().lastChild);\n            }\n\n            // add svg element\n            const e = SvgIconCache.shared().newLinkElementForSvgString(s)\n            this.element().appendChild(e)\n            this.setSvgElement(e)\n            //e.style.border = \"1px blue dashed\"\n        }\n\n        return this\n    }\n\n    // --- color ---\n\n    setColor (aColor) {\n        this.setFillColor(aColor)\n        this.setStrokeColor(aColor)\n        return this\n    }\n        \n    // --- didUpdateSlot hooks ---\n\n    syncColors () {\n        const style = this.element().style\n        style.setProperty(\"--fillColor\", this.fillColor())\n        style.setProperty(\"--strokeColor\", this.strokeColor())\n        style.setProperty(\"--strokeWidth\", this.strokeWidth())\n    }\n\n    didUpdateSlotFillColor (oldValue, newValue) {\n        this.setCssProperty(\"--fillColor\", newValue)\n    }\n\n    didUpdateSlotStrokeColor (oldValue, newValue) {\n        this.setCssProperty(\"--strokeColor\", newValue)\n    }\n\n    didUpdateSlotStrokeWidth (oldValue, newValue) {\n        this.setCssProperty(\"--strokeWidth\", newValue)\n    }\n\n    // --- variable maps ---\n    \n    variableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--fillColor)\")\n        m.set(\"stroke\", \"var(--strokeColor)\")\n        m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n\n    parentVariableAttributeMap () {\n        const m = new Map()\n        m.set(\"fill\", \"var(--color)\")\n        m.set(\"stroke\", \"var(--color)\")\n        m.set(\"strokeWidth\", \"var(--strokeWidth)\")\n        m.set(\"transition\", \"var(--transition)\")\n        return m\n    }\n\n}.initThisClass());\n",
  "RGuo5jzpxnf1gs1QLSKTYx++edmtPrV0wO9lkNpoUIc=": "\"use strict\";\n\n/*\n\n    TextField\n    \n    A view for a single line of text. \n    For multi-line text, use TextArea.\n\n    On input, sends didEdit up parent view chain.\n    This typically goes to a BMFieldTile.onDidEdit(changedView) which sends this.scheduleSyncToNode().\n\n    \n    Behavior:\n    (CURRENTLY DISABLED) On Return/Enter key, it passes focus to the nextResponder/parent. \n\n    Notes:\n\n*/\n\n(class TextField extends StyledDomView {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"lastMergeValue\", null); // for merge support\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"isMergeable\", false); // for merge support\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"htmlStreamReader\", null); // for merge support\n            slot.setSlotType(\"HtmlStreamReader\");\n        }\n        \n        {\n            const slot = this.newSlot(\"selectedColor\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"unselectedColor\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"doesClearOnReturn\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"doesHoldFocusOnReturn\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"doesTrim\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        /*\n            const slot = this.newSlot(\"didTextInputNote\", null)\n            const slot = this.newSlot(\"didTextEditNote\", null)\n        */\n\n        {\n            const slot = this.newSlot(\"doesInput\", false) // if true, enter key does not add return character but does report enter key to delegate\n            slot.setOwnsSetter(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"canHitEnter\", false); // if true, enter key is muted and opacity is reduced\n            slot.setOwnsSetter(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"allowsHtml\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"allowsSetStringWhileFocused\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        // has to start false for proper state setup\n        {\n            const slot = this.newSlot(\"usesDoubleTapToEdit\", false) ;\n            slot.setSlotType(\"Boolean\");\n        }\n\n        // need to separate from contentEditable since we want to override when usesDoubleTapToEdit is true.\n        {\n            const slot = this.newSlot(\"isEditable\", false);\n            slot.setOwnsSetter(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"editableBorder\", \"1px solid rgba(255, 255, 255, 0.2)\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"uneditableBorder\", \"none\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"showsBorderWhenEditable\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"mutationObserver\", null);\n            slot.setSlotType(\"MutationObserver\");\n        }\n        {\n            const slot = this.newSlot(\"isMultiline\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"onBlurSelection\", null);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"placeholderText\", null);\n            slot.setSlotType(\"String\");\n        }\n\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"flex\")\n        this.setJustifyContent(\"flex-start\")\n        this.setAlignItems(\"flex-start\")\n        this.turnOffUserSelect()\n        this.setWhiteSpace(\"pre-wrap\")\n        this.setWordWrap(\"normal\")\n        this.setOverflow(\"hidden\")\n        this.setOverflowWrap(\"normal\")\n        this.setTextOverflow(\"ellipsis\")\n        this.setWordBreak(\"keep-all\")\n        this.setSpellCheck(false)\n        this.setMinWidth(10)\n        this.setPaddingLeft(\"0.5em\")\n        this.setPaddingRight(\"0.5em\")\n        this.setPaddingTop(\"0.3em\")\n        this.setPaddingBottom(\"0.3em\")\n        this.setLineHeight(\"1.15em\")\n        //this.setMinHeight(\"2.07em\")\n        this.setMinHeight(\"1em\");\n        this.setCssProperty(\"outline\", \"none\");\n\t\t\n        this.setIsRegisteredForFocus(true) // need this to call unpauseGestures when editing ends\n\n        //this.setUnfocusOnEnterKey(true)\n        //this.setIsRegisteredForKeyboard(true) // gets set by setContentEditable()\n        //this.formatValue()\n\n        //this.setDidTextInputNote(this.newNoteNamed(\"didTextInput\"))\n        //this.setDidTextEditNote(this.newNoteNamed(\"didTextEdit\"))\n\n        this.setIsDebugging(false)\n        //this.lockedStyleAttributeSet().add(\"backgroundColor\")\n        this.selectListener().setIsListening(true);\n        return this\n    }\n\n    setupElement () {\n        super.setupElement()\n        //this.scheduleRegisterForFocus() // TODO: make this lazy\n        return this\n    }\n\n    // --- sub-element mutation observer ---\n\n    startMutationObserver () {\n        debugger;\n        if (!this.mutationObserver()) {\n            const config = { \n                subtree: true,\n                childList: true, \n                attributes: true, \n                attributeOldValue: true, \n                //characterDataOldValue: true,\n                characterData: true\n            };\n\n            const obs = new MutationObserver((mutationList, observer) => this.onDomMutation(mutationList, observer));\n            obs.observe(this.element(), config);\n            this.setMutationObserver(obs)\n        }\n        return this\n    }\n\n    stopMutationObserver () {\n        const obs = this.mutationObserver()\n        if (obs) {\n            obs.disconnect()\n            this.setMutationObserver(null)\n        }\n        return this\n    }\n\n    onDomMutation (mutationList, observer) {\n     //   console.log(\"onDomMutation --------------> \", mutationList)\n\n        for(const mutation of mutationList) {\n            if (mutation.type === 'characterData') {\n                this.onCharacterDataMutation(mutation)\n            }\n            /*\n            if (mutation.type === 'childList') {\n                console.log('A child node has been added or removed.');\n            }\n            else if (mutation.type === 'attributes') {\n                console.log('The ' + mutation.attributeName + ' attribute was modified.');\n            }\n            */\n        }\n    }\n\n    onCharacterDataMutation (mutation) {\n        console.log(\"onCharacterDataMutation --------------> \", mutation)\n    }\n\n    setContentEditable (aBool) {\n        super.setContentEditable(aBool)\n\n        /*\n        if (aBool) {\n            this.startMutationObserver()\n        } else {\n            this.stopMutationObserver()\n        }\n        */\n\n        //this.debugLog(\".setContentEditable(\" + aBool + \") = \", this.contentEditable())\n        //this.setIsRegisteredForClicks(this.contentEditable())  // is this needed after move to tap?\n\n        return this\n    }\n\n    // ---\n\n    // editing control\n\n    /*\n    setIsEditable (aBool) {\n        if (this._isEditable !== aBool) {\n            this._isEditable = aBool\n            this.syncEditingControl()\n        }\n        return this\n    }\n\n    \n    isEditable () {\n        return this._isEditable\n    }\n    */\n    \n    didUpdateSlotDoesInput () {\n        this.syncEditingControl()\n    }\n\n    didUpdateSlotCanHitEnter () {\n        this.syncEditingControl()\n    }\n    \n    didUpdateSlotIsEditable () {\n        this.syncEditingControl()\n    }\n\n    setUsesDoubleTapToEdit (aBool) {\n        if (this._usesDoubleTapToEdit !== aBool) {\n            this._usesDoubleTapToEdit = aBool\n            this.syncEditingControl()\n        }\n        return this\n    }\n\n    syncBorder () {\n        let b = this.uneditableBorder()\n\n        if (this.isEditable()) {\n            if (this.showsBorderWhenEditable()) {\n                b = this.editableBorder()\n            }\n        }\n        this.setBorder(b)\n        return this\n    }\n\n    syncPlaceholderText () {\n        const pt = this.placeholderText();\n        if (pt && pt.length > 0) {\n            //debugger;\n            this.element().setAttribute('data-placeholder', pt);\n            assert(this.element().getAttribute('data-placeholder') === pt);\n        } else {\n            this.element().removeAttribute('data-placeholder');\n        }\n        return this;\n    }\n\n    syncEditingControl () {\n        this.syncBorder();\n        this.syncPlaceholderText();\n\n        if (this.isEditable()) {\n            if (this.usesDoubleTapToEdit()) {\n                //debugger;\n                this.addDefaultDoubleTapGesture()\n                this.setContentEditable(false)\n            } else {\n                this.setContentEditable(true)\n            }\n        } else {\n            if (this.usesDoubleTapToEdit()) {\n                this.removeDefaultDoubleTapGesture()\n            }\n            this.setContentEditable(false)\n        }\n\n        if (this.doesInput() && !this.canHitEnter()) {\n            this.setOpacity(0.5);\n            this.setFontStyle(\"italic\");\n        } else {\n            this.setOpacity(1);\n            this.setFontStyle(\"normal\");\n            //this.rgba().setAlpha(1);\n            //this.setColor(\"rgba(0, 0, 0, 0.5)\");\n        }\n\n        return this\n    }\n\n\n    onDoubleTapCancelled (aGesture) {\n        //console.log(this.value() + \" onDoubleTapCancelled\")\n    }\n\n    onDoubleTapComplete (aGesture) {\n        //debugger;\n        //console.log(this.value() + \" onDoubleTapComplete\")\n        // make content editable and select text\n        //this.debugLog(\".onDoubleTapComplete()\")\n        if (this.contentEditable()) {\n            return this\n        }\n\n        \n        this.setContentEditable(true)\n        this.focus()\n        this.selectAll()\n        this.pauseGestures()\n\n        //this.setBorder(\"1px dashed white\")\n        return this\n    }\n\n    pauseGestures () {\n        GestureManager.shared().pause() // so things like text selection don't trigger gestures\n    }\n\n    unpauseGestures () {\n        GestureManager.shared().unpause() // so things like text selection don't trigger gestures\n    }\n\n    // --- onFocusIn / onFocusOut ---\n\n    onFocusIn (event) {\n        // sent before focus and bubbles up the parent chain\n\n        super.onFocusIn()\n        //console.log(this.typeId() + \" '\" + this.string() + \"' onFocusIn\")\n        if (this.contentEditable()) {\n            this.pauseGestures()\n        }\n    }\n\n    onFocusOut (event) {\n        // sent before blur\n        //console.log(\"'\" + this.textContent().substring(0, 10) + \"...'.onFocusOut()\")\n        //const isFocused = this.isActiveElementAndEditable();\n        this.storeSelectionRange();\n\n        super.onFocusOut()\n        //console.log(this.typeId() + \" '\" + this.string() + \"' onFocusOut\")\n        this.unpauseGestures() // do we need to check for (!this.contentEditable())?\n    }\n\n    // --- onFocus / onBlur ---\n\n    onFocus (event) {\n       // console.log(\"'\" + this.textContent().substring(0, 20) + \"...'.onFocus()\")\n        if (this.onBlurSelection()) {\n            this.restoreSelectionRange();\n        } else {\n            //console.log(\"--- NO blur selection ---\")\n        }\n    }\n\n    blur () {\n        //debugger\n        //console.log(this.value() + \" blur\")\n        return super.blur()\n    }\n\n    onBlur (event) {\n        super.onBlur()\n        if (this.usesDoubleTapToEdit()) {\n            this.setContentEditable(false)\n            this.setBorder(\"none\")\n            this.turnOffUserSelect()\n        }\n        this.unpauseGestures()\n    }\n\n    // --------------------------------\n\n    setPxFontSize (aNumber) {\n        super.setPxFontSize(aNumber)\n        this.setMinAndMaxHeight(aNumber + 2) // make sure TextfField can fit font size\n        this.didEdit()\n        return this\n    }\n\t\n    returnStrings () {\n        return [\"<div><br></div>\", \"<br><br>\"]\n    }\n\t\n    containsReturns () {\n        const value = this.value() // correct?\n        return returnStrings.canDetect(returnString => value.contains(returnString))\t\t\n    }\n\t\n    // ------------------\n\n    setInnerHtml (s) {\n        return super.setInnerHtml(s)\n    }\n\n    setInnerText (s) {\n        return super.setInnerText(s)\n    }\n\n    setValue (newValue) {\n        newValue = this.cleanseNewValue(newValue);\n\n        if (this.isMergeable()) {\n            this.setValueWithMerge(newValue);\n        } else {\n            this.setString(newValue);\n        }\n\n        /*\n        if (this.innerHtml() !== newValue) {\n            debugger;\n        }\n        */\n        return this;\n    }\n\n    /*\n    setValue (newValue) {\n        const oldValue = this.string();\n        if (newValue !== oldValue) {\n            return this.setString(newValue);\n        }\n    }\n    */\n\n    setValueWithMerge (newValue) {\n        //const oldValue = this.element().innerHTML;\n        let oldValue = this.lastMergeValue();\n        const needsMerge = (oldValue === null) || (newValue !== oldValue); // to cover case of lastMergeValue never being set, but element has content\n        if (oldValue === null) {\n            oldValue = \"\";\n        }\n        if (needsMerge) {\n            //const mergeableChange = (oldValue.length !== 0) && (newValue.length > oldValue.length);\n            const mergeableChange = (newValue.length > oldValue.length);\n            //const shouldMerge = mergeableChange && newValue.beginsWith(oldValue);\n            const shouldMerge = newValue.beginsWith(oldValue);\n            if (shouldMerge) {\n                /*\n                console.log(\"---- begin HTML merge ----\");\n                console.log(\"oldValue: [\" + oldValue + \"]\");\n                console.log(\"newValue: [\" + newValue + \"]\");\n                */\n\n                const reader = HtmlStreamReader.clone(); // TODO: cache this for efficiency, release whenever shouldMerge is false\n                reader.beginHtmlStream();\n                reader.onStreamHtml(newValue);\n                reader.endHtmlStream();\n                this.element().mergeFrom(reader.rootElement());\n                //console.log(\"merged: [\" + this.element().innerHTML + \"]\");\n                //console.log(\"---- end HTML merge ----\");\n            } else {\n                 this.setString(newValue);\n            }\n            this.setLastMergeValue(newValue);\n        }\n        return this;\n    }\n\n    value () {\n        // this.element().text ?\n        return this.string()\n    }\n\n    // allowsHtml\n\n    setNewValue (v) { // private method\n        //console.log(\"setNewValue(\" + v.substring(0, 10) + \"...)\");\n        if (this.allowsHtml()) {\n            this.setInnerHtml(v)\n        } else {\n            super.setString(v)\n        }\n        this.setLastMergeValue(v);\n        return this\n    }\n\n    cleanseNewValue (newValue) {\n        if (Type.isNullOrUndefined(newValue)) {\n            newValue = \"\"\n        }\n\n        if (!Type.isString(newValue)) {\n            newValue = newValue.toString()\n        }\n\n        return newValue;\n    }\n    \n    setString (newValue) {\n        newValue = this.cleanseNewValue(newValue);\n\n        const oldValue = this.string()\n        //let oldValue = this.visibleValue()\n        if (oldValue !== newValue) {\n\n            if (this.isFocused()) {\n                //if (this.allowsSetStringWhileFocused()) {\n                    //this.blur();\n                    this.setNewValue(newValue);\n                    //this.focus();\n                //} \n                //throw new Error(\"attempt to call TextField.setString while it's focused\")\n            } else {\n                //this.isFocused()\n                this.setNewValue(newValue)\n            }\n            \n            /*\n            console.log(\" setString(\")\n            console.log(\"    old: '\" + oldValue + \"'\")\n            console.log(\"    new: '\" + newValue + \"'\")\n            console.log(\"---\")\n            */            \n        }\n        return this\n    }\n\n    // ------------------\n\n    adjustFontSizeWithKeyboard () {\n        const kb = BMKeyboard.shared()\n        const controlDown   = kb.controlKey().isDown()\n        const equalSignDown = kb.equalsSignKey().isDown()\n        const minusDown     = kb.minusKey().isDown()\n\n        // adjust font size (testing this out)\n        if (controlDown) {\n            const fontSize = this.computedFontSize()\n\n            if (equalSignDown) {\n                this.setPxFontSize(fontSize + 1)\n            } else if (minusDown) {\n                if (fontSize > 1) { \n                    this.setPxFontSize(fontSize - 1)\n                }\n            }\n        }\n        return this\n    }\n\n    onAlternateEnterKeyUp (event) {\n        console.log(this.typeId() + \" onAlternateEnterKeyDown\")\n        //this.insertEnterAtCursor()\n        //this.afterEnter()\n    }\n\n    insertEnterAtCursor (event) {\n        if (this.isFocused()) {\n            //this.insertTextAtCursor(\"\\n\")\n            this.insertTextAtCursorSimple(\"\\n\")\n            this.placeCaretAtEnd()\n        }   \n    }\n\n    isSingleLine () {\n        return !this.isMultiline();\n    }\n\n    shouldMuteEvent (event) {\n        const returnKeyCode = 13; // return key\n\n        if (event.keyCode === returnKeyCode) {\n            // block return key down if it's a single line text field (or if in input mode aka send onInput note on enter key up)\n            // this still allows return up key event\n            if (this.isSingleLine() || this.doesInput()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    onKeyDown (event) {\n        // sent before the content is changed\n        let result = super.onKeyDown(event)\n        //const keyName = BMKeyboard.shared().keyForEvent(event)\n        //console.log(this.debugTypeId() + \" onKeyDown event.keyCode = \", event.keyCode)\n\n        if (this.shouldMuteEvent(event)) {\n            event.preventDefault()\n        }\n\n        return true\n    }\n\n    onInput (event) {\n        // sent after the content is changed\n        const returnKeyCode = 13; \n\n        if (!this.shouldMuteEvent(event)) {\n            this.didEdit(); // we muted the return key down event so content is not changed\n            // this is to avoid sending didEdit after didInput\n        }\n\n        //event.preventDefault();\n        // return result\n\n        //console.log(this.debugTypeId() + \" onKeyUp event.keyCode = \", event.keyCode)\n        //this.debugLog(\" onKeyUp value: [\" + this.value() + \"]\")\n\n        if (this.doesInput()) {\n            event.preventDefault();\n            //this.insertEnterAtCursor()\n            return true; // prevent default\n        }\n        return false;\n    }\n    \n    onKeyUp (event) {\n        super.onKeyUp(event);\n        return false;\n    }\n    \n    \n    onEnterKeyDown (event) {    \n        // insert 2 returns as cursor won't go to the second line with 1\n        // document.execCommand('insertHTML', false, \"\\n\\n\");\n        // prevent the default behaviour of return key pressed\n        return false;\n    }\n\n    onEnterKeyUp (event) {\n        if (!this.isContentEditable()) {\n            return \n        }\n        \n\t    //this.debugLog(\".onEnterKeyUp()\")\n\t    //this.didEdit()\n\n        this.formatValue()\n        this.afterEnter()\n\n        if (this.doesInput()) {\n            //this.insertEnterAtCursor()\n            return false\n        }\n    }\n\n    // Alt Enter\n\n    onAlternateEnterKeyDown (event) {\n        if (this.doesInput() && this.isMultiline()) {\n            this.insertTextAtCursorAndConsolidate(\"\\n\")\n            //this.formatValue()\n        }\n    }\n\n    onEscapeKeyDown (event) {\n        this.releaseFirstResponder()\n        event.stopPropagation()\n        return false\n    }\n\n    afterEnter (event) {\n\n        if (this.doesInput()) {\n            if (this.canHitEnter()) {\n                this.tellParentViews(\"didInput\", this) \n            } else {\n                SimpleSynth.clone().playButtonCancelled();\n                return;\n            }\n        }\n\n        //this.tellParentViews(\"didInput\", this) \n            \n        if (!this.doesHoldFocusOnReturn()) {\n            this.releaseFirstResponder()\n        }\n        \n        if (this.doesClearOnReturn()) {\n            this.setTextContent(\"\")\n            //this.setInnerHtml(\"\")\n            //this.focusAfterDelay(.125) // hack to get focus back after chat view scrolling - TODO: fix this\n        }\n\n        /*\n        if (this.didTextInputNote()) {\n            this.didTextInputNote().post()\n        }\n        */\n        \n        if (event) {\n            event.stopPropagation()\n        }\n\n        return false\n    }\n\t\n    formatValue () {\n        this.setTextContent(this.textContent()) // removes formatting?\n        /*\n\t    const oldValue = this.innerHtml()\n\t    let newValue = this.innerText() // removes returns\n        \n        if (this.doesTrim()) {\n            newValue = newValue.trim()\n        } \n\n        if (true) {\n            //newValue.replaceAll(\"\\n\", \"<br>\")\n        }\n        \n        if (newValue !== oldValue) {\n            this.debugLog(\"formatValue newValue !== oldValue\")\n            this.debugLog(\" newValue: [\" + newValue + \"]\")\n            this.setInnerHtml(newValue)\n            this.didEdit()\n        }\n        */\n\t    //console.trace(this.type() + \" formatValue '\" + oldValue + \"' -> '\" + this.innerHtml() + \"'\")\n        //this.debugLog(\" after formatValue: '\" + this.innerHtml() + \"'\")\n        return this\n    }\n    \n    /*\n    setInput (s) {\n        const n = this.node()\n        if (n) {\n            const m = n.nodeInputFieldMethod()\n            if (m) {\n                n[m].apply(n, [s])\n            }\n        }\n        return this\n    }\n    */\n\n    setThemeClassName (aName) {\n        if (this.themeClassName() === \"FieldKey\") {\n            debugger;\n        }\n\n        super.setThemeClassName(aName)\n        if (aName === \"FieldKey\") {\n            assert(this.themeClassName() === \"FieldKey\")\n        }\n         return this\n    }\n\n    applyStyles () {\n        /*\n        if (this.themeClassName() === \"FieldKey\") {\n            debugger;\n        }\n        */\n        super.applyStyles()\n        return this\n    }\n\n    activate () {\n        if (this.usesDoubleTapToEdit()) {\n            this.onDoubleTapComplete()\n        } else {\n            this.focus()\n        }\n        return this\n    }\n    \n    onClick (event) {\n        // needed to prevent click-to-edit event from selecting the background row\n        //this.debugLog(\".onClick()\")\n\n        if (this.contentEditable()) {\n            this.sendActionToTarget()\n            event.stopPropagation()\n            return false\n        }\n\n        return super.onClick(event)\n    }\n    \n    setBorder (v) {\n        /*\n        if (this.value() === \"a\") {\n            console.log(\"break\")\n        }\n        */\n        return super.setBorder(v)\n    }\n\n    setBackgroundColor (aColor) {\n        super.setBackgroundColor(aColor)\n        return this\n    }\n\n    // --- speech to text input -----------------------------------------------------------------------\n\n    onAlternate_l_KeyDown (event) {\n        if (this.hasFocus()) {\n            if (!event.repeat) {\n                this.startSpeechToText()\n            }\n            event.stopPropagation();\n            event.preventDefault();\n            //return true\n        }\n    }\n\n    onAlternate_l_KeyUp(event) {\n        if (this.hasFocus()) {\n            this.stopSpeechToText()\n            event.stopPropagation();\n        } else {\n            debugger;\n        }\n    }\n\n    startSpeechToText () {\n        console.log(\"=== start speech to text ===\")\n        if (this._speechSession) {\n            this._speechSession.stop()\n            this._speechSession = null\n        }\n\n        // TODO: add visual indicator?\n        if (!this._speechSession) {\n            if (getGlobalThis()[\"SpeechToTextSession\"]) {\n                this._speechSession = SpeechToTextSession.clone().setDelegate(this)\n                //debugger\n                this._speechSession.start()\n            } else {\n                console.warn(\"no SpeechToTextSession class available\")\n            }\n        }\n    }\n\n    onSpeechInterimResult (speechSession) {\n        //const s = speechSession.intermFullTranscript()\n        const s = speechSession.fullTranscript()\n        //console.log(\"onSpeechInterimResult intermFullTranscript: '\" + s + \"'\")\n        //this.insertTextAtCursorSimple(s)\n    }\n\n    onSpeechEnd (speechSession) {\n        const s = speechSession.fullTranscript()\n        console.log(\"onSpeechEnd full: '\" + s + \"'\")\n        this.insertTextAtCursorSimple(s)\n        this._speechSession = null\n    }\n\n    stopSpeechToText () {\n        console.log(\"==== stop speech to text ====\") \n        // TODO: add visual indicator?\n        const speech = this._speechSession\n        if (speech) {\n            speech.stop()\n        }\n    }\n\n    // --- arrow key defaults disabled while editing ---\n\n    onUpArrowKeyDown (event) { // why down and not up?\n        if (this.isFocused()) { \n            return false\n        }\n        \n        return super.onUpArrowKeyDown(event)\n    }\n\t\n    onDownArrowKeyDown (event) { // why down and not up?\n        if (this.isFocused()) { \n            return false\n        }\n\n        return super.onDownArrowKeyDown(event)\n    }\n\t\n    onLeftArrowKeyUp (event) {\n        if (this.isFocused()) { \n            return false          \n        }\n        \n        return super.onLeftArrowKeyUp(event)\n    }\n\t\n    onRightArrowKeyUp (event) {\n        if (this.isFocused()) { \n            return false\n        }\n        \n        return super.onRightArrowKeyUp(event)\n    }\n\n    // --- select ---\n\n    onSelectStart (event) {\n        console.log(\"'\" + this.element().textContent.substring(0, 10) + \"'.onSelectStart()\")\n    }\n\n}.initThisClass());\n\n\n\n// --- experimental DOM merge support ----\n// TODO: move to ideal if useful\n\n/*\n    nodeTypes:\n\n{\n  \"1\": \"ELEMENT_NODE\",\n  \"2\": \"ATTRIBUTE_NODE\",\n  \"3\": \"TEXT_NODE\",\n  \"4\": \"CDATA_SECTION_NODE\",\n  \"5\": \"ENTITY_REFERENCE_NODE\",\n  \"6\": \"ENTITY_NODE\",\n  \"7\": \"PROCESSING_INSTRUCTION_NODE\",\n  \"8\": \"COMMENT_NODE\",\n  \"9\": \"DOCUMENT_NODE\",\n  \"10\": \"DOCUMENT_TYPE_NODE\",\n  \"11\": \"DOCUMENT_FRAGMENT_NODE\",\n  \"12\": \"NOTATION_NODE\"\n}\n\n*/\n\nassert(HTMLElement.prototype.clone === undefined);\n\nHTMLElement.prototype.clone = function() {\n    const newNode = document.createElement(this.tagName);\n    Array.from(this.attributes).forEach(attr => {\n        newNode.setAttribute(attr.name, attr.value);\n    });\n    newNode.innerHTML = this.innerHTML;\n    return newNode\n};\n\nHTMLElement.prototype.mergeFrom = function(remoteElement) {\n    if (this.innerHTML === remoteElement.innerHTML) {\n        return;\n    }\n\n    if (!(remoteElement instanceof HTMLElement)) {\n        throw new Error('remoteElement must be an instance of HTMLElement');\n    }\n\n    //console.log(\"         this.innerHTML: \" + this.innerHTML);\n    //console.log(\"remoteElement.innerHTML: \" + remoteElement.innerHTML);\n\n    const localChildNodes = Array.from(this.childNodes);\n    const remoteChildNodes = Array.from(remoteElement.childNodes);\n\n    // walk through the source\n    if (localChildNodes.length <= remoteChildNodes.length) {\n         // this can happen if last string ended on an incomplete tag e.g. \"...<\"\n         // let it add it as a text node and then we'll replace it with the complete tag on the next merge?\n    }\n\n    for (let i = 0; i < remoteChildNodes.length; i++) {\n        //debugger;\n\n        const remoteChildNode = remoteChildNodes[i];\n        \n        if (i < localChildNodes.length) {\n            let localChildNode = localChildNodes[i];\n\n            // special case for cut off tags\n            if (i === localChildNodes.length -1 && localChildNode.nodeType === Node.TEXT_NODE && remoteChildNode.nodeType !== Node.TEXT_NODE) {\n                // this can happen if last string ended on an incomplete tag e.g. \"...<\" but the tag is now complete\n                this.removeChild(localChildNode);\n                assert(remoteChildNode.nodeType === Node.ELEMENT_NODE);\n                localChildNode = remoteChildNode.clone();\n                this.appendChild(localChildNode);\n            }\n\n            assert(localChildNode.nodeType === remoteChildNode.nodeType);\n\n            // handle children already present\n            switch (localChildNode.nodeType) {\n                case Node.ELEMENT_NODE:\n                    assert(localChildNode.tagName === remoteChildNode.tagName);\n                    assert(localChildNode.className === remoteChildNode.className);\n                    localChildNode.mergeFrom(remoteChildNode);\n                    break;\n                case Node.TEXT_NODE:\n                    localChildNode.textContent = remoteChildNode.textContent;\n                    break;\n                default:\n                    throw new Error(\"unhandled node type \" + localChildNode.nodeType);\n            }\n\n        } else {\n            // handle new children\n            switch (remoteChildNode.nodeType) {\n                case Node.ELEMENT_NODE:\n                    this.appendChild(remoteChildNode.clone());\n                    break;\n                case Node.TEXT_NODE:\n                    const newTextNode = document.createTextNode(remoteChildNode.textContent);\n                    this.appendChild(newTextNode);\n                    break;\n                default:\n                    throw new Error(\"unhandled node type \" + localChildNode.nodeType);\n            }\n        }\n    }\n};\n\nHTMLElement.prototype.findElementWithTextContent = function(textContent, className) {\n    const children = Array.from(this.childNodes);\n\n    for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n\n        if (className && !child.classList.contains(className)) {\n            continue;\n        }\n\n        if (child.textContent === textContent) {\n            return child;\n        }\n\n        if (child.textContent.trim() === textContent) {\n            console.warn(\"WARNING: findElementWithTextContent non exact match for [\" + textContent.clipWithEllipsis(15) + \"]\");\n            return child;\n        }\n\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            const match = child.findElementWithTextContent(textContent, className);\n            if (match) {\n                return match;\n            }\n        }\n    }\n\n    return null;\n}\n\n//Element.prototype.getAllSubelements = function() { // Element includes HTML and SVG elements\n\n// --- find matching class names ---\n\nHTMLElement.prototype.getAllSubelementsWithClass = function(className) {\n    return this.getAllSubelementsWithAnyOfClass([className]);\n};\n\nHTMLElement.prototype.getAllSubelementsWithAnyOfClass = function(classNames) {\n    let allSubelements = [];\n    function recurse(element) {\n      Array.from(element.children).forEach(child => {\n        // Check if the child element contains any of the class names provided\n        if (classNames.some(className => child.classList.contains(className))) {\n          allSubelements.push(child);\n        }\n        recurse(child);\n      });\n    }\n    recurse(this);\n    return allSubelements;\n};\n\n// --- find matching tag names ---\n\nHTMLElement.prototype.elementsOfTag = function(tagName) {\n    assert(Type.isString(tagName));\n    return this.elementsOfTags([tagName]);\n}\n\nHTMLElement.prototype.elementsOfTags = function(tagNames) {\n    assert(Type.isArray(tagNames));\n    const lowerCaseTagNames = tagNames.map(tagName => tagName.toLowerCase());\n\n    let allSubelements = [];\n\n    function recurse(element) {\n      Array.from(element.children).forEach(child => {\n        // Check if the child element's tag name is in the provided list \n        if (lowerCaseTagNames.includes(child.tagName.toLowerCase())) { \n          allSubelements.push(child);\n        }\n        recurse(child);\n      });\n    }\n\n    recurse(this);\n    return allSubelements;\n};\n\n/*\n\n// for testing\n\ndocument.addEventListener('blur', function(event) {\n    const focusedElement = event.target;\n    console.log(\"'\" + focusedElement.textContent.substring(0, 10) + \"...' BLUR\");\n  }, true);\n  \ndocument.addEventListener('focus', function(event) {\n    const focusedElement = event.target;\n    console.log(\"'\" + focusedElement.textContent.substring(0, 10) + \"...' FOCUS\");\n  }, true);\n  */\n",
  "yTEJhjd6zlssm1MQKIdWhzrAshhHCOqiXOw/b/TR0Y4=": "\"use strict\";\n\n/*\n    BMDataUrl\n\n    exmaples of setting up a dataTransfer for a drag out of browser event:\n\n        event.dataTransfer.setData(\"DownloadURL\", \"application/json:hello.json:data:application/json;base64,\" + btoa(\"[1,2,3]\"));\n        event.dataTransfer.setData(\"DownloadURL\", \"text/plain:hello.txt:data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D\");\n*/\n\n(class BMDataUrl extends ProtoClass {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"dataUrl\", null); // for drop\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"transferMimeType\", \"DownloadURL\"); // for drag\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"fileName\", \"file.txt\"); // for drag\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"mimeType\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"decodedData\", \"\"); // non-base64 version\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    mimeTypeDescription () {\n        const mimeType = this.mimeType()\n        if (mimeType) {\n            const name = this.mimeTypeToFileSuffixDict()[mimeType]\n            if (name) {\n                return name\n            }\n            return mimeType\n        }\n        return null\n    }\n\n    isXml () {\n        return this.mimeType() === \"application/xml\"\n    }\n\n    isJson () {\n        return this.mimeType() === \"application/json\"\n    }\n\n    isText () {\n        return this.mimeType() === \"text/plain\"\n    }\n\n    isHtml () {\n        return this.mimeType() === \"text/html\"\n    }\n\n    mimeTypeToFileSuffixDict () {\n        return {\n            \"application/json\" : \"json\",\n            \"application/xml\" : \"xml\",\n            \"text/javascript\" : \"js\",\n            \"text/plain\" : \"txt\", \n            \"text/html\" : \"html\", \n            //\"text/uri-list\" \n        }\n    }\n\n    /*\n    validMimeTypeSet () {\n        return new Set([\n            \"application/json\",\n            \"text/javascript\",\n            \"text/plain\", \n            \"text/html\", \n            \"text/uri-list\" \n        ])\n    }\n    */\n\n   dataUrlString () {\n        // e.g.: \"application/json:hello.json:data:application/json;base64,\" + btoa(\"[1,2,3]\"));\n        const header = this.mimeType() + \":\" + this.fileName() + \":data:\" + this.mimeType() + \";base64,\"  \n        const content = btoa(this.decodedData())\n        const s = header + content\n        return s\n    }\n\n    setDataUrlString (dataUrl) {\n        const type = dataUrl.before(\":\")\n        assert(type === \"data\")\n        const afterData = dataUrl.after(\"data:\")\n        const mimeType = afterData.before(\";\")\n        const encodedData = afterData.after(\"base64,\")\n        const decodedData = encodedData.base64Decoded()\n        \n        this.setDataUrl(dataUrl)\n        this.setMimeType(mimeType)\n        this.setDecodedData(decodedData)\n        return this\n    }\n\n    /*\n    attachToEvent (event) {\n        event.dataTransfer.setData(this.transferMimeType(), this.dataUrlString())\n    }\n    */\n\n}.initThisClass());\n",
  "uWytvWanpPBg68d45n59CSY7IRfpaZduXcLgmlKVouw=": "\"use strict\";\n\n/**\n * \n * A subclass of SortedArray which maintains a reference to the owner of the subnodes,\n * and is set to persist its items. This class is used by BMNodes to maintain their subnodes.\n * \n * @class SubnodesArray\n * @extends SortedArray\n */\n\n(class SubnodesArray extends SortedArray {\n    /**\n     * Initializes prototype slots for the SubnodesArray.\n     */\n    initPrototypeSlots () {\n        Object.defineSlot(this, \"_owner\", null);\n    }\n\n    /**\n     * Gets the owner of this SubnodesArray.\n     * @returns {Object|null} The owner object or null if not set.\n     */\n    owner () {\n        return this._owner;\n    }\n\n    /**\n     * Sets the owner of this SubnodesArray.\n     * @param {Object} obj - The object to set as the owner.\n     * @returns {SubnodesArray} The SubnodesArray instance.\n     */\n    setOwner (obj) {\n        this._owner = obj;\n        return this;\n    }\n\n    /**\n     * Creates a new SubnodesArray from an existing array.\n     * Ensures that any method hooks are called when populating the new array.\n     * @param {Array} oldArray - The array to create a SubnodesArray from.\n     * @returns {SubnodesArray} A new SubnodesArray instance containing the elements from oldArray.\n     */\n    static from (oldArray) {\n        const newArray = this.clone();\n        oldArray.forEach(v => newArray.push(v)); // make sure any method hooks are called\n        return newArray;\n    }\n\n    /**\n     * @returns {boolean} Always returns true, indicating that SubnodesArray should be stored.\n     */\n    shouldStore () {\n        return true;\n    }\n\n}.initThisClass());",
  "fJbUbJGw2BX3s0ENLgqmrMD4rBFMAUZ4aWNmV4/YcFs=": "\"use strict\";\n\n/*\n\n    BMNode\n \n    The base class of model objects that supports the protocol \n    used to sync with views (subclasses of NodeView).\n\n    State and behavior here are focused on managing subnodes.\n\n    The BMStorableNode subclass is used to sync the model to\n    the persistence system.\n\n\n        Notifications (intended for views):\n\n            - didUpdateNode // lets views know they need to scheduleSyncFromNode\n            - shouldFocusSubnode // request that the UI focus on the sender\n\n        Update messages sent to self:\n            - didUpdateSlotParentNode(oldValue, newValue)\n            \n            - didChangeSubnodeList // hook to resort if needed and call didReorderParentSubnodes\n            - prepareForFirstAccess // sent to self on first access to subnodes\n            - prepareToAccess // sent to sent whenever a subnode is accessed\n\n        Update messages sent to parent:\n            - didUpdateNode // let parent know a subnode has changed\n\n        Update messages sent to subnodes:\n            - didReorderParentSubnodes // sent on subnode order change\n\n        Protocol helpers:\n            - watchOnceForNote(aNote) // typically used to watch for appDidInit\n\n*/\n\n(class BMNode extends ProtoClass {\n    \n    static availableAsNodePrimitive () {\n        return true;\n    }\n\n    static primitiveNodeClasses () {\n        const classes = BMNode.allSubclasses();\n        return classes.filter(aClass => aClass.availableAsNodePrimitive());\n    }\n\n    // --- for CreatorNode Prototypes ---\n\n    static visibleClassName () {\n        let name = this.type();\n        name = name.sansPrefix(\"BM\");\n        name = name.sansSuffix(\"Field\");\n        name = name.sansSuffix(\"Node\");\n        return name;\n    }\n\n    static availableAsNodePrimitive () {\n        return false;\n    }\n\n    static nodeCreate () {\n        // we implemnet this on BMNode class and prototype so \n        // it works for both instance and class creator prototypes\n        return this.clone();\n    }\n\n    static nodeCreateName () {\n        return this.visibleClassName();\n    }\n\n    // --- mime types ---\n\n    static canOpenMimeType (mimeTypeString) {\n        return false;\n    }\n\n    static openMimeChunk (dataChunk) {\n        return null;\n    }\n\n    // ----\n\n    initPrototypeSlots () {\n \n        /*\n        {\n            const slot = this.newSlot(\"nodeType\", null);\n            slot.setCanInspect(true);\n            slot.setLabel(\"type\");\n            slot.setInspectorPath(\"Node\");\n            slot.setSlotType(\"String\");\n            slot.setCanEditInspection(false);\n        }\n        */\n\n        // parent node, subnodes\n\n        {\n            const slot = this.newSlot(\"parentNode\", null);\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"BMNode\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanReorderSubnodes\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"subnodes\", null);\n            slot.setInitProto(SubnodesArray);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"SubnodesArray\");\n        }\n\n        {\n            // this allows us to effectively override the subnode's Slot's shouldStore property\n            // if null, it uses the subnode's Slot object's value\n            const slot = this.newSlot(\"shouldStoreSubnodes\", null);\n            slot.setDuplicateOp(\"duplicate\"); //.setShouldStore(true)\n            slot.setSlotType(\"Boolean\");\n            slot.setAllowsNullValue(true);\n        }\n\n        {\n            const slot = this.newSlot(\"subnodeClasses\", []); //.setInitProto([]) // ui will present creator node if more than one option\n            slot.setAllowsNullValue(false);\n            slot.setSlotType(\"Array\");\n        }\n\n        // notification notes\n\n        {\n            const slot = this.newSlot(\"didUpdateNodeNote\", null); // private\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"BMNotification\");\n        }\n\n        {\n            const slot = this.newSlot(\"shouldFocusSubnodeNote\", null); // private\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"BMNotification\");\n        }\n\n        {\n            const slot = this.newSlot(\"shouldFocusAndExpandSubnodeNote\", null); // private\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"BMNotification\");\n        }\n\n        // view related, but computed on node\n\n        {\n            const slot = this.newSlot(\"nodeVisibleClassName\", null);\n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n            slot.setDuplicateOp(\"copyValue\");\n        }\n\n        {\n            const slot = this.newSlot(\"canDelete\", false);\n            slot.setSlotType(\"Boolean\");\n            slot.setDuplicateOp(\"copyValue\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanAddSubnode\", false);\n            slot.setSlotType(\"Boolean\");\n            slot.setDuplicateOp(\"copyValue\");\n        }\n\n        {\n            const slot = this.newSlot(\"isVisible\", true);\n            slot.setSlotType(\"Boolean\");\n            slot.setSyncsToView(true);\n        }\n    }\n\n    initPrototype () {\n\n    }\n\n    init () {\n        super.init();\n        this.setDidUpdateNodeNote(this.newNoteNamed(\"onUpdatedNode\"));\n        this.setShouldFocusSubnodeNote(this.newNoteNamed(\"shouldFocusSubnode\"));\n        this.setShouldFocusAndExpandSubnodeNote(this.newNoteNamed(\"shouldFocusAndExpandSubnode\"));\n        this.watchSubnodes();\n\n        this.setSubnodeClasses(this.thisPrototype().subnodeClasses().shallowCopy());\n        return this\n    }\n\n    setSubnodes (subnodes) {\n        if (this._subnodes === null) {\n            this._subnodes = subnodes;\n        } else {\n            this._subnodes.copyFrom(subnodes);\n        }\n        return this;\n    }\n\n    registerForAppDidInit () {\n        // need this in case app has already done init,\n        // or if appDidInit notification itself inited objects\n        // who register for appDidInit\n        // TODO: generalize this for all notifications somehow\n        // maybe register for note with object directly\n        \n        if (App.hasShared() && App.shared().hasDoneAppInit()) {\n            this.appDidInit(); // may be async\n        } else {\n            this.watchOnceForNote(\"appDidInit\");\n        }\n    }\n\n    shouldStoreSlotSubnodes () {\n        // called by subnodes slot when persisting instance\n        return this.shouldStoreSubnodes();\n    }\n\n    nodeType () {\n        return this.type();\n    }\n\n    /*\n    prepareToRetire () {\n        super.prepareToRetire() // will remove notification observations\n        this._subnodes.removeMutationObserver(this)\n    }\n    */\n\n    nodeCreate () {\n        // we implemnet this on BMNode class and prototype so \n        // it works for both instance and class creator prototypes\n        return this.duplicate();\n    }\n    \n    nodeCreateName () {\n        return this.title();\n    }\n\n    duplicate () {\n        const dup = super.duplicate();\n        if (!this.shouldStore() || this.shouldStoreSubnodes()) {\n            dup.copySubnodes(this.subnodes().map(sn => sn.duplicate()));\n        }\n        return dup;\n    }\n\n    pid () { // TODO: unify with puuid?\n        return this.puuid();\n    }\n\n    // -----------------------\n    \n    nodeVisibleClassName () {\n        if (this._nodeVisibleClassName) {\n            return this._nodeVisibleClassName;\n        }\n\t\t\n        return this.type().sansPrefix(\"BM\");\n    }\n\n    // --- subnodes ----------------------------------------\n    \n    setParentNode (aNode) {\n        assert(aNode !== this); // sanity check\n\n        if (aNode !== this._parentNode) { \n            if (this._parentNode && aNode) {\n                console.warn(this.debugTypeId() + \" setParentNode(\" + aNode.debugTypeId() + \")  already has parent \" + this._parentNode.debugTypeId());\n                console.warn(\"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\");\n            }\n            \n            const oldNode = this._parentNode;\n            this._parentNode = aNode;\n            this.didUpdateSlotParentNode(oldNode, aNode);\n        }\n        return this;\n    }\n\n    didUpdateSlotParentNode (oldValue, newValue) {\n        // for subclasses to override\n    }\n\n    rootNode () {\n        const pn = this.parentNode();\n        if (pn) {\n            return pn.rootNode();\n        }\n        return this;\n    }\n\n    // subnodes\n\n    subnodeCount () {\n        return this._subnodes.length;\n    }\n\n    hasSubnodes () {\n        return this.subnodeCount() > 0;\n    }\n\n    justAddSubnode (aSubnode) {\n        assert(!this.hasSubnode(aSubnode));\n        return this.justAddSubnodeAt(aSubnode, this.subnodeCount());\n    }\n\t\n    justAddSubnodeAt (aSubnode, anIndex) {\n        assert(aSubnode);\n        assert(!this.hasSubnode(aSubnode));\n        this.subnodes().atInsert(anIndex, aSubnode);\n        aSubnode.setParentNode(this);\n        return aSubnode;\n    }\n    \n    assertValidSubnodeType (aSubnode) {\n        assert(aSubnode.thisClass().isKindOf(BMNode), \"Attempt to add subnode of type '\" + aSubnode.type() + \"' which does not inherit from BMNode (as subnodes are required to do)\");\n    }\n\n    addSubnodeAt (aSubnode, anIndex) {\n        assert(!this.hasSubnode(aSubnode));\n        this.assertValidSubnodeType(aSubnode);\n\n        assert(anIndex >= 0);\n        this.justAddSubnodeAt(aSubnode, anIndex);\n        //this.didChangeSubnodeList(); // happens automatically from hooked array\n        return aSubnode;\n    }\n\n    subnodeBefore (aSubnode) {\n        const index = this.indexOfSubnode(aSubnode);\n        assert(index !== -1);\n        if (index > 0) {\n            return this.subnodes().at(index - 1);\n        }\n        return null;\n    }\n\n    replaceSubnodeWith (aSubnode, newSubnode) {\n        assert(!this.hasSubnode(newSubnode));\n\n        const index = this.indexOfSubnode(aSubnode);\n        assert(index !== -1);\n        this.removeSubnode(aSubnode);\n        this.addSubnodeAt(newSubnode, index);\n        return newSubnode;\n    }\n\n    replaceSubnodeWithSubnodes (aSubnode, newSubnodes) {\n        let index = this.indexOfSubnode(aSubnode);\n        assert(index !== -1);\n        this.removeSubnode(aSubnode);\n\n        newSubnodes.forEach(sn => {\n            this.addSubnodeAt(sn, index);\n            index ++;\n        })\n        return this;\n    }\n\n    moveSubnodesToIndex (movedSubnodes, anIndex) {\n        this.subnodes().moveItemsToIndex(movedSubnodes, anIndex)\n        return this\n    }\n\n    addSubnode (aSubnode) {\n        assert(!this.hasSubnode(aSubnode));\n        return this.addSubnodeAt(aSubnode, this.subnodeCount());\n    }\n\n    addLinkSubnode (aNode) {\n        /*\n        if (aNode.parentNode()) {\n            console.warn(\"adding a link subnode to a node with no parent (yet)\")\n        }\n        */\n        const link = BMLinkNode.clone().setLinkedNode(aNode);\n        this.addSubnode(link);\n        return link;\n    }\n\n    addSubnodes (subnodes) {\n        subnodes.forEach(subnode => this.addSubnode(subnode));\n        return this;\n    }\n\n    addSubnodesIfAbsent (subnodes) {\n        subnodes.forEach(subnode => this.addSubnodeIfAbsent(subnode));\n        return this;\n    }\n    \n    addSubnodeIfAbsent (aSubnode) {\n        if (!this.hasSubnode(aSubnode)) {\n            this.addSubnode(aSubnode);\n            return true;\n        }\n        return false;\n    }\n\n    subnodeProto () {\n        return this.subnodeClasses().first();\n    }\n\n    setSubnodeProto (aProto) {\n        this.subnodeClasses().removeAll();\n        this.subnodeClasses().appendIfAbsent(aProto);\n        return this;\n    }\n\n    acceptedSubnodeTypes () {\n        const types = [];\n        this.subnodeClasses().forEach(c => types.push(c.type()));\n        return types;\n    }\n\n    acceptsAddingSubnode (aSubnode) {\n        if (aSubnode === this) {\n            return false;\n        }\n\n        /*\n        if (this.hasSubnode(aSubnode)) {\n            return false;\n        }\n        */\n        //const type = aSunode.type();\n        const ancestors = aSubnode.thisClass().ancestorClassesTypesIncludingSelf();\n        return this.acceptedSubnodeTypes().canDetect(type => ancestors.contains(type));\n    }\n\n    forEachSubnodeRecursively (fn) {\n        this.subnodes().forEach(sn => {\n            fn(sn);\n            sn.forEachSubnodeRecursively(fn);\n        })\n    }\n\n    selectSubnodesRecursively (fn) {\n        const results = [];\n        this.forEachSubnodeRecursively(subnode => {\n            if (fn(subnode)) {\n                results.push(subnode);\n            }\n        })\n        return results;\n    }\n\n    // --------\n\n    addSubnodeIfAbsent (aNode) {\n        if (!this.hasSubnode(aNode)) {\n            this.addSubnode(aNode);\n        }\n        return this;\n    }\n\n    removeSubnodeIfPresent (aNode) {\n        if (this.hasSubnode(aNode)) {\n            this.removeSubnode(aNode);\n        }\n        return this;\n    }\n\n    // --------\n\t\n    isEqual (aNode) {\n\t    return this === aNode;\n    }\n\n    hash () {\n        // don't assume hash() always returns the puuid as\n        // subclasses can override to measure equality in their own way\n        return this.puuid();\n    }\n\n    createSubnodesIndex () {\n        this.subnodes().setIndexClosure( v => v.hash());\n        return this\n    }\n\t\n    hasSubnode (aSubnode) {\n        const subnodes = this.subnodes();\n        if (subnodes.length > 100) {\n            this.createSubnodesIndex();\n            return subnodes.indexHasItem(aSubnode);\n        }\n        //return subnodes.detect(subnode => subnode === aSubnode);\n        return subnodes.detect(subnode => subnode.isEqual(aSubnode));\n    }\n    \n    justRemoveSubnode (aSubnode) { // private method \n        this.subnodes().remove(aSubnode);\n        \n        if (aSubnode.parentNode() === this) {\n            aSubnode.setParentNode(null);\n        }\n        \n        return aSubnode;\n    }\n    \n    removeSubnode (aSubnode) {\n        this.justRemoveSubnode(aSubnode);\n        //this.didChangeSubnodeList(); // handled by hooked array\n        return aSubnode;\n    }\n\n    removeSubnodes (subnodeList) {\n        subnodeList.forEach(sn => this.removeSubnode(sn));\n        return this;\n    }\n    \n    removeAllSubnodes () {\n\t    if (this.subnodeCount()) {\n    \t\tthis.subnodes().slice().forEach((subnode) => {\n    \t\t\tthis.justRemoveSubnode(subnode);\n    \t\t})\n    \t\t\n            //this.didChangeSubnodeList() handled by hooked array but this could be more efficient\n        }\n        return this;\n    }\n\n    didReorderParentSubnodes () {\n    }\n\n    onDidReorderSubnodes () {\n        this.subnodes().forEach(subnode => subnode.didReorderParentSubnodes());\n    }\n\n    didChangeSubnodeList () {\n        //this.subnodes().forEach(subnode => assert(subnode.parentNode() === this)); // TODO: remove after debugging\n        this.scheduleMethod(\"onDidReorderSubnodes\");\n        //this.subnodes().forEach(subnode => subnode.didReorderParentSubnodes());\n        if (this.hasDoneInit()) {\n            this.didUpdateNode();\n        }\n        return this;\n    }\n\n    copySubnodes (newSubnodes) {\n        this.subnodes().copyFrom(newSubnodes);\n        return this;\n    }\n\n    nodeReorderSudnodesTo (newSubnodes) {\n        this.copySubnodes(newSubnodes);\n        return this;\n    }\n\n    orderFirst () {\n        this.parentNode().orderSubnodeFirst(this);\n        return this;\n    }\n\n    orderLast () {\n        this.parentNode().orderSubnodeLast(this);\n        return this;\n    }\n\n    orderSubnodeFirst (aSubnode) {\n        assert(aSubnode);\n        assert(this.hasSubnode(aSubnode));\n        const subnodes = this.subnodes().shallowCopy();\n        subnodes.remove(aSubnode);\n        subnodes.atInsert(0, aSubnode);\n        this.nodeReorderSudnodesTo(subnodes);\n        return this;\n    }\n\n    orderSubnodeLast (aSubnode) {\n        assert(this.hasSubnode(aSubnode));\n        const subnodes = this.subnodes().shallowCopy();\n        subnodes.remove(aSubnode);\n        subnodes.push(aSubnode);\n        this.nodeReorderSudnodesTo(subnodes);\n        return this;\n    }\n    \n    // --- update / sync system ----------------------------\n    \n    didUpdateNodeIfInitialized () {\n        if (this.hasDoneInit()) {\n            this.didUpdateNode();\n        }\n    }\n\n    didUpdateNode () {\n        if (!this.hasDoneInit()) {\n            return false;\n        }\n\n        const note = this.didUpdateNodeNote();\n\n        if (note) {\n            if (this.type() === \"HwLocations\") {\n                if (!BMNotificationCenter.shared().hasNotification(note)) {\n                    console.log(this.typeId() + \" '\" + this.title() + \"' POST didUpdateNode - subnodesCount: \" + this.subnodesCount());\n                    debugger;\n                }\n            }\n            note.post();\n        }\n        \n        // TODO: make this more efficient, as we don't always need it\n        \n        if (this.parentNode()) {\n            assert(this.parentNode() !== this);\n            this.parentNode().didUpdateNodeIfInitialized();\n        }\n\n        return true;\n    }\n\n    hasDuplicateSubnodes () {\n        return this.subnodes().hasDuplicates();\n    }\n\n    indexOfSubnode (aSubnode) {\n        return this.subnodes().indexOf(aSubnode);\n    }\n\n    subnodeIndexInParent () {\n        const p = this.parentNode();\n        if (p) {\n            return p.indexOfSubnode(this);\n        }\n        return 0;\n    }\n\n    nodeDepth () {\n        const p = this.parentNode();\n        if (p) {\n            return p.nodeDepth() + 1;\n        }\n        return 0;\n    }\n\n    // ---------------------------------------\n\n    prepareToAccess () {\n        // this should be called whenever subnodes need to be accessed? See willGetSlotSubnodes\n        if (!this._didPrepareForFirstAccess) {\n            this._didPrepareForFirstAccess = true;\n            this.prepareForFirstAccess();\n        }\n    }\n\n    prepareForFirstAccess () {\n        // subclasses can override \n    }\n\n    /*\n    willGetSlotSubnodes () {\n        this.prepareToAccess(); // infinite loop?\n    }\n    */\n    \n    // --- parent chain notifications ---\n    \n    tellParentNodes (msg, aNode) {\n        const f = this[msg];\n        if (f && f.apply(this, [aNode])) {\n            return;\n        }\n\n        const p = this.parentNode();\n        if (p) {\n            p.tellParentNodes(msg, aNode);\n        }\n    }\n\n    parentChainNodes (chain = []) {\n        chain.unshift(this);\n        const p = this.parentNode();\n        if (p) {\n            p.parentChainNodes(chain);\n        }\n        return chain;\n    }\n\n    parentChainNodeTo (node, chain = []) {\n        if (this !== node) {\n            chain.unshift(this);\n            const p = this.parentNode();\n            if (p) {\n                p.parentChainNodeTo(node, chain);\n            }\n        }\n        return chain;\n    }\n\n    firstParentChainNodeOfClass (aClass) {\n        //return this.firstParentChainNodeDetect(node => node.thisClass().isSubclassOf(aClass));\n\n        if (this.thisClass().isSubclassOf(aClass)) {\n            return this;\n        }\n\n        if (this.parentNode()) {\n            return this.parentNode().firstParentChainNodeOfClass(aClass);\n        }\n\n        return null;\n    }\n\n    firstParentChainNodeThatRespondsTo (methodName) {\n        return this.firstParentChainNodeDetect(node => node.respondsTo(methodName));\n    }\n\n    firstParentChainNodeDetect (func) {\n        // return this.parentChainNodes().detect(func);\n        if (func(this)) {\n            return this;\n        }\n\n        if (this.parentNode()) {\n            return this.parentNode().firstParentChainNodeDetect(func);\n        }\n\n        return null;\n    }\n    \n    // --- log ------------------------\n    \n    log (msg) {\n        //const s = this.nodePathString() + \" --  \" + msg\n        if (this.isDebugging()) {\n        \tconsole.log(\"[\" +  this.nodePathString() + \"] \" + msg);\n        }\n    }\n\n    // --- post notifications ----------------------------------------\n\n    postShouldFocusSubnode (aSubnode) {\n        assert(aSubnode);\n        this.shouldFocusSubnodeNote().setInfo(aSubnode).post();\n        return this;\n    }\n\n    postShouldFocusAndExpandSubnode (aSubnode) {\n        //debugger\n        assert(aSubnode);\n        this.shouldFocusAndExpandSubnodeNote().setInfo(aSubnode).post();\n        return this;\n    }\n\n    // -- adding subnodes by instantiating subnode class ----\n    \n    justAddAt (anIndex) {\n        const classes = this.subnodeClasses().shallowCopy();\n\n        let newSubnode = null;\n        if (classes.length === 0) {\n            newSubnode = null;\n        } else if (classes.length === 1) {\n            newSubnode = classes.first().clone();\n        } else {\n            newSubnode = BMCreatorNode.clone();\n            newSubnode.addSubnodesForObjects(classes);\n        }\n\n        if (newSubnode) {\n            this.addSubnodeAt(newSubnode, anIndex);\n        }\n        return newSubnode;\n    }\n\n    justAdd (anIndex) {  \n        return this.justAddAt(this.subnodeCount());\n    }\n\n    addAt (anIndex) {\n        const newSubnode = this.justAddAt(anIndex);\n        if (newSubnode) {\n            this.didUpdateNodeIfInitialized();\n            this.postShouldFocusAndExpandSubnode(newSubnode);\n        }\n        return newSubnode;\n    }\n\n    add (noArg) {  \n        assert(noArg === undefined);\n        return this.addAt(this.subnodeCount());\n    }\n\n    removeFromParentNode () {\n        const pn = this.parentNode();\n        if (pn) {\n            pn.removeSubnode(this);\n        } else {\n            throw new Error(\"missing parentNode\");\n        }\n        return this;\n    }\n\t\n    delete () {\n        this.removeFromParentNode();\n        return this;\n    }\n\n    // --- utility -----------------------------\n    \n    parentNodeOfType (className) {\n        if (this.type() === className) {\n            return this;\n        }\n        \n        if (this.parentNode()) {\n            return this.parentNode().parentNodeOfType(className);\n        }\n        \n        return null;\n    }\n\n    parentNodes () {\n        const node = this.parentNode();\n        const results = [];\n\t\t\n        while (node) {\n            results.push(node);\n            node = this.parentNode();\n        }\n        return results;\n    }\n\t\n    parentNodeTypes () {\n        return this.parentNodes().map(node => node.type());\n    }\n    \n    // --- subnode lookup -----------------------------\n    \n    subnodesSans (aSubnode) {\n\t    return this.subnodes().select(subnode => subnode !== aSubnode);\n    }\n\t\n    firstSubnodeOfType (obj) {\n        // obj could be clas, prototype, or instance\n        return this.subnodes().detect(subnode => subnode.type() === obj.type());\n    }\n\n    setupSubnodeOfType (aClass) {\n        let subnode = this.firstSubnodeOfType(aClass);\n        if (!subnode) {\n            subnode = aClass.clone();\n            this.addSubnode(subnode);\n        }\n        return subnode;\n    }\n        \n    sendRespondingSubnodes (aMethodName, argumentList) {\n        this.subnodes().forEach((subnode) => { \n            if (subnode[aMethodName]) {\n                subnode[aMethodName].apply(subnode, argumentList);\n            }\n        })\n        return this;\n    }\n    \n    // --- subnodes -----------------------------\n    \n    subnodesCount () {\n        return this.subnodes().length;\n    }\n\n    onDidMutateObject (anObject) {\n        if (anObject === this._subnodes) {\n            //assert(!this.subnodes().hasDuplicates())\n            this.didChangeSubnodeList();\n        }\n    }\n\n    watchSubnodes () {\n        this._subnodes.addMutationObserver(this);\n        return this\n    }\n\n    hasNullSubnodes () {\n        return this.subnodes().indexOf(null) !== -1;\n    }\n\n    didUpdateSlotSubnodes (oldValue, newValue) {\n        if (oldValue) {\n            oldValue.removeMutationObserver(this);\n        }\n\n        if (Type.isNullOrUndefined(newValue)) {\n            console.warn(\"attempt to set subnodes array to null or undefined - possible corruption of object pool storage <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\");\n            //debugger;\n            newValue = [];\n        }\n\n        if (newValue.type() !== \"SubnodesArray\") {\n            //debugger;\n            this._subnodes = SubnodesArray.from(newValue);\n            newValue.removeDuplicates();\n            newValue = this._subnodes;\n            assert(newValue.type() === \"SubnodesArray\");\n        } else {\n            /*\n            if (this.hasNullSubnodes()) {\n                console.warn(this.debugTypeId() + \" hasNullSubnodes - removing nulls and continuing:\", this.subnodes())\n                this.subnodes().removeOccurancesOf(null)\n                //debugger\n            }\n            */\n\n            if(this.hasDuplicateSubnodes()) {\n                console.warn(this.debugTypeId() + \" hasDuplicateSubnodes - removing duplicates and continuing\")\n                debugger\n                newValue.removeDuplicates()\n            }\n        }\n\n        assert(newValue.owner() === null)\n        newValue.setOwner(this)\n\n        this.watchSubnodes()\n        if (this._subnodes.contains(null)) { // what would cause this?\n            //debugger;\n            console.warn(\"found null in subnodes array - removing\")\n            this._subnodes.filterInPlace(sn => !(sn === null) )\n        }\n        \n        this._subnodes.forEach(sn => sn.setParentNode(this)) // TODO: isn't this done elsewhere?\n        this.didChangeSubnodeList() // not handled automatically\n        return this\n    }\n    \n    assertSubnodesHaveParentNodes () {\n        const missing = this.subnodes().detect(subnode => !subnode.parentNode())\n        if (missing) {\n            throw new Error(\"missing parent node on subnode \" + missing.type())\n        }\n        return this\n    }\n\n    // --- subnode sorting ---\n\t\n    setSubnodeSortFunc (f) {\n        this.subnodes().setSortFunc(f)\n\t    return this\n    }\n\t\n    doesSortSubnodes () {\n\t    return this.subnodes().doesSort()\n    }\n    \n    // --- subnode indexing ---\n\t\n    lazyIndexedSubnodes () {\n        if (!this.subnodes().indexClosure()) {\n            this.subnodes().setIndexClosure( sn => sn.hash() )\n        }\n\t    return this.subnodes()\n    }\n\t\n    subnodeWithHash (h) {\n        return this.lazyIndexedSubnodes().itemForIndexKey(h)\n    }\n\t\n    removeSubnodeWithHash (h) {\n\t    const subnode = this.subnodeWithHash(h)\n\t    if (subnode) {\n\t        this.removeSubnode(subnode)\n\t    }\n\t    return this\n    }\n\t\n    hasSubnodeWithHash (h) {\n\t    return this.lazyIndexedSubnodes().hasIndexKey(h)\n    }\n\t\n    // visibility\n\t\n    nodeBecameVisible () {\n\t    return this\n    }\n\n    // -- view selection request events ---\n\n    onRequestSelectionOfDecendantNode () {\n        return false // allow propogation up the parentNode line\n    }\n\n    onRequestSelectionOfNode () {\n        this.tellParentNodes(\"onRequestSelectionOfDecendantNode\", this)\n        return this\n    }\n\n    onTapOfNode () {\n        this.tellParentNodes(\"onTapOfDecendantNode\", this)\n        return this\n    }\n\n    debugTypeId () {\n        return this.typeId() + \" '\" + this.title() + \"'\"\n    }\n\n    // ----\n\n    /*\n    validValuesForSlotName (slotName) {\n        // if there's a method for this particular slot use it, \n        // otherwise fail back on the validValues declared in the Slot\n\n        const getterName = \"validValuesForSlot\" + slotName.capitalized()\n        const m = this[getterName]\n        if (m) {\n            const validValues = m.call(this)\n            if (validValues !== undefined) {\n                return validValues\n            }\n        } \n        \n        const slot = this.thisPrototype().slotNamed(slotName)\n        assert(slot)\n        return slot.validValues()\n    }\n    */\n\n    /*\n    moveSubnodeToNode (aSubnode, aNode) {\n        this.removeSubnode(aSubnode)\n        aNode.addSubnode(aSubnode)\n        return this\n    }\n\n    moveSubnodesToNode (aNode) {\n        this.subnodes().shallowCopy().forEach(sn => {\n            this.moveSubnodeToNode(sn, aNode)\n        })\n    }\n    */\n\n    collapseUnbranchingNodes () {\n        this.subnodes().forEach(sn => sn.collapseUnbranchingNodes());\n        this.subnodes().shallowCopy().forEach(sn => {\n            const noSiblings = this.subnodes().length == 1 && sn.subnodes().length > 0;\n            const oneChild = sn.subnodes().length == 1;\n\n            const sns = sn.subnodes().shallowCopy()\n            sns.forEach(node => node.removeFromParentNode())\n\n            if (noSiblings || oneChild) {\n                this.replaceSubnodeWithSubnodes(sn, sns)\n            }\n        })\n        return this\n    }\n\n    leafSubnodes (results = []) {\n         this.subnodes().forEach(sn => sn.leafSubnodesIncludingSelf(results));\n         return results\n    }\n\n    leafSubnodesIncludingSelf (results = []) {\n        if (!this.hasSubnodes()) {\n            results.push(this)\n        } else {\n            this.subnodes().forEach(sn => sn.leafSubnodesIncludingSelf(results));\n        }\n        return results\n    }\n\n    // --- options helper ---- TODO: move elsewhere\n\n    addOptionNodeForDict (item) {\n        const hasSubnodes = item.options && item.options.length\n        const nodeClass = hasSubnodes ? BMFolderNode : BMOptionNode;\n        const newNode = nodeClass.clone().setTitle(item.label)\n        \n        if (!hasSubnodes) {\n            newNode.setValue(item.value ? item.value : item.label)\n            newNode.justSetIsPicked(item.isPicked === true)\n            newNode.setNodeCanEditTitle(false)\n        }\n\n        if (item.subtitle) {\n            newNode.setSubtitle(item.subtitle)\n        }\n\n        this.addSubnode(newNode)\n\n        if (hasSubnodes) {\n            newNode.addOptionNodesForArray(item.options)\n        }\n\n        return newNode\n    }\n\n    addOptionNodesForArray (itemDicts) {\n        if (itemDicts) {\n            itemDicts.forEach(subitemDict => {\n                this.addOptionNodeForDict(subitemDict)\n            })\n        }\n        return this   \n    }\n\n    // --- jsonArchive ---\n\n    setJsonArchive (json) {\n        // NOTE: use slot.setShouldJsonArchive(true) to set a slot to be json archived\n        \n        //console.log(this.typeId() + \".setJsonArchive(\" + JSON.stableStringify(json, 2, 2) + \")\");\n\n        const keys = Object.keys(json).select(key => key !== \"type\");\n        const jsonArchiveSlots = this.thisPrototype().slotsWithAnnotation(\"shouldJsonArchive\", true);\n        //assert(keys.length === jsonArchiveSlots.length); // or should we assume a diff if missing?\n        \n        jsonArchiveSlots.forEach(slot => {\n            const k = slot.getterName();\n            const v = json[k];\n            if (json.hasOwnProperty(k)) {\n                slot.onInstanceSetValue(this, v);\n            } else {\n                console.warn(\"no dict key '\" + k + \"' for archive slot \" + k);\n            }\n        })\n\n        /*\n        keys.forEach(key => {\n            if (key !== \"type\") {\n            const slot = this.thisPrototype().slotNamed(key);\n            assert(slot);\n            const value = json[key];\n            slot.onInstanceSetValue(this, value);\n            }\n        })\n        */\n\n        return this\n    }\n\n\n    jsonArchive () {\n        const jsonArchiveSlots = this.thisPrototype().slotsWithAnnotation(\"shouldJsonArchive\", true) \n        const dict = {\n            type: this.type()\n        }\n\n        jsonArchiveSlots.forEach(slot => {\n            const k = slot.getterName()\n            const v = slot.onInstanceGetValue(this)\n            dict[k] = v;\n        })\n\n        //console.log(this.typeId() + \".jsonArchive() = \" + JSON.stableStringify(dict, 2, 2));\n\n        return dict\n    }\n    \n    static fromJsonArchive (json) {\n        const className = json.type;\n        assert(className); // sanity check\n        \n        const aClass = getGlobalThis()[className];\n        assert(aClass.isKindOf(this)); // sanity check\n\n        const instance = aClass.clone().setJsonArchive(json)\n        return instance\n    }\n\n    // --- JSON schema properties ---\n\n    static jsonSchemaString () {\n        const schema = this.asRootJsonSchema();\n        const s = JSON.stableStringify(schema, 2, 2);\n        return s;\n    }\n\n    static jsonSchemaTitle () {\n        return this.type();\n    }\n\n    static jsonSchemaSlots () {\n        const jsonArchiveSlots = this.prototype.slotsWithAnnotation(\"isInJsonSchema\", true);\n        return jsonArchiveSlots;\n    }\n\n    static jsonSchemaProperties (refSet) {\n        assert(refSet);\n        assert(this.asJsonSchema); // sanity check - we'll need this \n        refSet.add(this);\n\n        const slots = this.jsonSchemaSlots();\n\n        if (slots.length === 0) {\n            return undefined;\n        }\n\n        const properties = {};\n\n        slots.forEach(slot => {\n            properties[slot.getterName()] = slot.asJsonSchema(refSet);\n        });\n\n        return properties;\n    }\n\n    static jsonSchemaRequired () {\n        const slots = this.jsonSchemaSlots();\n\n        if (slots.length === 0) {\n            return undefined;\n        }\n\n        const required = [];\n        \n        slots.forEach(slot => {\n            //if (!slot.allowsNullValue()) {\n            if (slot.isRequired()) {\n                required.push(slot.getterName());\n            }\n        })\n\n        return required;\n    }\n\n    // --- json schema ---\n\n    static asRootJsonSchemaString (definitionsOnly = false) {\n        const json = this.asRootJsonSchema(definitionsOnly);\n        const s = JSON.stableStringify(json, 4, 4);\n        return s;\n    }\n\n    static asRootJsonSchema (definitionsOnly = false) {\n        // NOTE: this uses a format of all definitions at the top level\n\n        const refSet = new Set();\n        /*\n        // useful for debugging classes put in the refSet\n        refSet._add = refSet.add;\n        refSet.add = function (aClass) {\n            if (!aClass.jsonSchemaDescription || aClass.jsonSchemaDescription() === null) {\n                debugger;\n            }\n            if (!this.has(aClass)) {\n                this._add(aClass);\n                console.log(\"refSet.add(\" + aClass.type() + \") size \", this.size);\n            }\n        }\n        */\n\n        const json = {\n            \"$id\": this.type(),\n            \"$schema\": \"http://json-schema.org/draft-07/schema#\"\n        };\n        \n        if (definitionsOnly) {\n            this.asJsonSchema(refSet); // we only do this to set the refSet to include all classes with this object references\n            assert(this.asJsonSchema); // sanity check - we'll need this \n            refSet.add(this); // now we add ourselve and we're ready to just share all the definitions\n        } else {\n            Object.assign(json, this.asJsonSchema(refSet)); // so schema is at top of dict\n            refSet.delete(this); // don't include ourself in the definitions, as we're the root schema\n        }        \n\n        if (refSet.size) {\n            json.definitions = this.jsonSchemaDefinitionsForRefSet(refSet);\n            console.log(\"Object.keys(json.definitions).length = \", Object.keys(json.definitions).length);\n        }\n\n        return json;\n    }\n\n    static jsonSchemaDefinitionsForRefSet (refSet) {\n        assert(refSet);\n        const definitions = {};\n\n        // iterate to grab all the definitions - simple but a bit inefficient. Not used in tight loops, so no problem.\n        let done = false;\n        const classNameToSchemaMap = new Map(); \n        while (!done) {\n            done = true;\n            Array.from(refSet).forEach(aClass => {\n                const className = aClass.type();\n                if (!classNameToSchemaMap.has(className)) {\n                    classNameToSchemaMap.set(className, aClass.asJsonSchema(refSet));\n                    done = false;\n                }\n            });\n        }\n\n        // let's define them in alphabetical order to (possibly) make looking at the JSON easier (AI needs to look at this)\n        const orderedClassNames = classNameToSchemaMap.keysArray().sort();\n        orderedClassNames.forEach((className) => {\n            const jsonSchema = classNameToSchemaMap.get(className);\n            definitions[className] = jsonSchema;\n        });\n\n        /*\n        // as we write out the definitions, we'll get encounter more refs, \n        // so we need to queue them to be added too\n\n        const definedClasses = new Set();\n        let undefinedClasses = new Set(refSet);\n\n        while (undefinedClasses.size) {\n            const newRefSet = new Set();\n            undefinedClasses.forEach(aClass => {\n                const schemaDef = aClass.asJsonSchema(newRefSet);\n                assert(!Type.isNullOrUndefined(schemaDef), \"missing schemaDef for \" + aClass.type());\n                definitions[aClass.type()] = schemaDef;\n                definedClasses.add(aClass);\n            });\n            undefinedClasses = newRefSet.difference(definedClasses); // returns set with items in newRefSet but not in definedClasses\n        }\n        const definedClassNames = Array.from(definedClasses).map(c => c.type());\n        console.log(\"definedClasses: [\" + definedClassNames.join(\", \") + \"]\");\n        console.log(\"definitions: [\" + Object.keys(definitions).join(\", \") + \"]\");\n        */\n        return definitions;\n    }\n\n    static asJsonSchema (refSet) {\n        assert(refSet);\n        const schema = {\n            type: \"object\",\n            description: this.jsonSchemaDescription(),\n            properties: this.jsonSchemaProperties(refSet),\n            required: this.jsonSchemaRequired()\n        };\n\n        const title = this.jsonSchemaTitle();\n        if (title != this.type()) {\n            schema.title = title;\n        }\n\n        assert(schema.description, \"missing json schema description for \" + this.type());\n        return schema;\n    }\n\n    static jsonSchemaRef (refSet) {\n        assert(refSet);\n        return this.jsonSchemaRefForTypeName(this.type(), refSet);\n    }\n\n    static jsonSchemaRefForTypeName (typeName, refSet) {\n        assert(Type.isSet(refSet));\n        assert(this.asJsonSchema); // sanity check - we'll need this \n        assert(this.jsonSchemaDescription(), \"missing jsonSchemaDescription for \" + this.type());\n        refSet.add(this); // all classes in this set will be added to the \"definitions\" section of the root schema\n        return \"#/definitions/\" + typeName;\n    }\n\n    static instanceFromJson (json) {\n        const properties = json.properties;\n        assert(properties, \"missing properties in json\");\n\n        const className = properties.className;\n        assert(className, \"missing className in json\");\n\n        const aClass = getGlobalThis()[className];\n        assert(aClass, \"missing class for className '\" + className + \"'\");\n        const instance = aClass.fromJsonSchema(json);\n\n        return instance;\n    }\n\n    fromJsonSchema (json) {\n        const slots = this.slotsWithAnnotation(\"isInJsonSchema\", true);\n\n        const requiredSlots = slots.filter(slot => slot.isRequired());\n        const requiredSlotNamesSet = new Set(requiredSlots.map(slot => slot.getterName()));\n\n        Object.keys(json).forEach(key => {\n            const slot = slots.getSlot(key);\n            if (slot) {\n                assert(slot.isInJsonSchema(), \"attempt to set slot not in json schema\");\n\n                if (slot.name() === \"subnodes\") { // special case subnodes for now?\n                    //console.log(\"fromJsonSchema setting subnodes\");\n                    const subnodes = json[key];\n                    this.removeAllSubnodes();\n                    subnodes.forEach(subnodeJson => {\n                        const subnode = BMNode.instanceFromJson(subnodeJson);\n                        const hasValidSubnodeClass = this.subnodeClasses().length === 0 || this.subnodeClasses().includes(subnode.thisClass());\n                        if (hasValidSubnodeClass) {\n                            this.addSubnode(subnode);\n                        } else {\n                            console.warn(\"fromJsonSchema subnode class '\" + subnode.type() + \"' not in subnodeClasses \" + JSON.stableStringify(this.subnodeClasses().map(c => c.type())));\n                            debugger;\n                        }\n                    });\n                } else {\n                    const value = json[key];\n                    slot.onInstanceSetValueWithJsonSchemaTypeCheck(this, value);\n                }\n            } else {\n                console.warn(\"fromJsonSchema missing slot for key '\" + key + \"'\");\n                debugger;\n            }\n            requiredSlotNamesSet.delete(key);\n        });\n\n        if (requiredSlotNamesSet.size > 0) {\n            // verify all required slots were set\n            console.warn(\"fromJsonSchema missing required slots: \" + Array.from(requiredSlotNamesSet).join(\", \"));\n            debugger;\n        }\n\n        return this;\n    }\n\n    // ---- shutdown ----\n\n    nodeShutdown (visited = new Set()) {\n        // need to check for loops\n        if (visited.has(this)) {\n            return\n        }\n        visited.add(this);\n\n        this.performIfResponding(\"shutdown\", visited); \n        this.ownedSlotValues().forEach(sv => sv.performIfResponding(\"nodeShutdown\", visited));\n        this.subnodes().forEach(sn => {\n          sn.performIfResponding(\"nodeShutdown\", visited);\n        });\n      }\n\n      slotsWhoseValuesAreOwned () {\n        return this.thisPrototype().slots().filter(slot => slot.ownsValue());\n      }\n\n      ownedSlotValues () {\n        return this.slotsWhoseValuesAreOwned().map(slot => slot.onInstanceGetValue(this));\n      }\n    \n      /*\n      recursivelySendToOwnedNodes (methodName) {\n        // for things like shutdown methods, we want to send them to all owned nodes \n        // both to subnodes and slot values owned by each node\n    \n        // note: we probably want to send these from the bottom up\n        this.subnodes().forEach(sn => {\n          this.sendMessageToOwnedSlotValues(methodName);\n          sn.performIfResponding(methodName);\n        });\n        this.performIfResponding(methodName);\n      }\n      */\n\n}.initThisClass());\n\n\n\n\n",
  "WZGCys5/sskNxqPlU2JeAG5WWsqJJEp4hQN0XtMQEBo=": "\"use strict\";\n\n/*\n\n    TitledNode\n \n    BMNode -> TitledNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Class for handling a node's:\n\n        title\n        subtitle\n        summary\n        icon/thumbnail (move to viewable?)\n\n*/\n\n(class TitledNode extends BMNode {\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"title\", null);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"subtitle\", null);\n            slot.setAllowsNullValue(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setLabel(\"value\");\n            slot.setSlotType(\"String\");\n            slot.setInspectorPath(\"Node/Subtitle\");\n            slot.setShouldStoreSlot(true);\n        }\n\n        {\n            const slot = this.newSlot(\"note\", null);\n            slot.setAllowsNullValue(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"BMNotification\");\n        }\n\n        {\n            const slot = this.newSlot(\"noteIconName\", null);\n            slot.setAllowsNullValue(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setLabel(\"icon\");\n            slot.setSlotType(\"String\");\n            slot.setValidValuesClosure((instance) => BMIconResources.shared().iconNames());\n            slot.setInspectorPath(\"Node/Note\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditTitle\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditSubtitle\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setLabel(\"editable\");\n            slot.setSlotType(\"Boolean\");\n            slot.setInspectorPath(\"Node/Subtitle\");\n            slot.setShouldStoreSlot(true);\n        }\n\n        {\n            const slot = this.newSlot(\"subtitleIsSubnodeCount\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"noteIsSubnodeCount\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    // subtitle and note\n    \n    subtitle () {\n        if (this.subtitleIsSubnodeCount() && this.subnodesCount()) {\n            return this.subnodesCount()\n        }\n        \n        return this._subtitle\n    }\n\n    noteSubnodesCount () {\n        return this.subnodesCount();\n    }\n    \n    note () {\n        //console.log(this.title() + \" noteIsSubnodeCount: \" + this.noteIsSubnodeCount())\n        if (this.noteIsSubnodeCount()) {\n            const count = this.noteSubnodesCount()\n            if (count) {\n                return count\n            }\n\n            return \"\"\n        }\n        \n        return this._note\n    }\n\n    nodeHeaderTitle () {\n        return this.title()\n    }\n\n    // --- title based paths ---\n    \n    nodePath () {\n        if (this.parentNode()) {\n            const parts = this.parentNode().nodePath()\n            parts.push(this)\n            return parts\n        }\n        return [this]\n    }\n\n    nodePathArrayForPathComponents (pathComponents, results = []) {\n        results.push(this)\n\n        const link = this.nodeTileLink()\n        if (link && link !== this) {\n            return link.nodePathArrayForPathComponents(pathComponents) \n        }\n\n        const pathComponent = pathComponents.first()\n        if (pathComponent) {\n            const nextNode = this.firstSubnodeWithTitle(pathComponent)\n            if (nextNode) {\n                return nextNode.nodePathArrayForPathComponents(pathComponents.rest())\n            }\n        }\n        return results\n    }\n    \n    nodePathString () {\n        return this.nodePath().map(node => node.title()).join(\"/\")\n    }\n    \n    nodeAtSubpathString (pathString) {\n        return this.nodeAtSubpath(pathString.split(\"/\"));        \n    }\n    \n    nodeAtSubpath (subpathArray) {\n        if (subpathArray.length) {\n            const t = subpathArray.first()\n\n            let subnode = null\n            if (Type.isArray(t)) {\n                // supports a path component that is an ordered list of subnodes titles \n                subnode = this.firstSubnodeWithTitles(t)\n            } else {\n                subnode = this.firstSubnodeWithTitle(t)\n            }\n\n            if (subnode) {\n                return subnode.nodeAtSubpath(subpathArray.rest())\n            }\n            return null\n        }        \n        return this\n    }\n\n    // --- lookups and ops on subnodes via title/subtitle -------------------------------\n\n\n    removeFirstSubnodeWithTitle (aString) {\n        const sn = this.firstSubnodeWithTitle(aString)\n        if (sn) {\n            sn.delete()\n        }\n        return this\n    }\n\n    firstSubnodeWithTitle (aString) {\n        return this.subnodes().detect(subnode => subnode.title() === aString)\n    }\n\n    firstSubnodeWithTitles (titlesArray) {\n        for (let i = 0; i < titlesArray.length; i++) {\n            const title = titlesArray[i]\n            const subnode = this.firstSubnodeWithTitle(title)\n            if (subnode) {\n                return subnode\n            }\n        }\n        return null\n    }\n\n    firstSubnodeWithSubtitle (aString) {\n        return this.subnodes().detect(subnode => subnode.subtitle() === aString)\n    }\n\n    rootNode () {\n        //debugger;\n        const store = this.defaultStore()\n        const root = store.rootObject()\n        //root.setTitle(\"root\")\n        return root\n    }\n\n    /*\n    rootSubnodeWithTitleForProto (aString, aProto) {\n        return this.rootNode().subnodeWithTitleIfAbsentInsertProto(aString, aProto)\n    }\n    */\n   \n    subnodeWithTitleIfAbsentInsertProto (aString, aProto) {\n        const subnode = this.firstSubnodeWithTitle(aString)\n\n        if (subnode) {\n            if (subnode.type() !== aProto.type()) {\n                // replace the subnode with matching title, \n                // if it's not of the requested class\n\n                const newSubnode = aProto.clone()\n                try {\n                    //newSubnode.copyFrom(subnode, true)\n                    newSubnode.copyFromAndIgnoreMissingSlots(subnode)\n                } catch (error) {\n                    if (error instanceof MissingSlotError) {\n                        debugger;\n                    } else {\n                        error.rethrow();\n                    }\n                }\n                // TODO: Do we need to replace all references in pool and reload?\n                this.replaceSubnodeWith(subnode, newSubnode)\n                this.removeOtherSubnodesWithSameTitle(newSubnode)\n                return newSubnode\n            }\n\n            this.removeOtherSubnodesWithSameTitle(subnode)\n            return subnode\n        }\n\n        return this.subnodeWithTitleIfAbsentInsertClosure(aString, () => aProto.clone())\n    }\n\n    addSubnodeAndSetSlotForClass (aName, aClass) {\n        // like subnodeWithTitleIfAbsentInsertProto but we also set the matching slot value to the subnode \n        // (eg, subnode with title \"Resources\", sets \"resources\" slot)\n        const subnode = this.subnodeWithTitleIfAbsentInsertProto(aName, aClass)\n        this.removeOtherSubnodesWithSameTitle(subnode)\n        const slot = this.thisPrototype().slotNamed(aName.toLowerCase())\n        assert(slot)\n        if (slot) {\n            slot.onInstanceSetValue(this, subnode) \n        }\n        return subnode\n    }\n\n    removeSubnodesWithTitle (aString) {\n        this.subnodes().select(sn => sn.title() === aString).forEach(sn => sn.delete())\n        return this\n    }\n\n    /*\n    removeOtherSubnodeInstances (aSubnode) {\n        assert(this.hasSubnode(aSubnode))\n        this.subnodes().shallowCopy().forEach((sn) => {\n            if (sn !== aSubnode) {\n                if (sn.thisClass() === aSubnode.thisClass()) {\n                    this.removeSubnode(sn)\n                }\n            }\n        })\n        return this\n    }\n    */\n\n    removeOtherSubnodesWithSameTitle (aSubnode) {\n        assert(this.hasSubnode(aSubnode))\n        this.subnodes().shallowCopy().forEach((sn) => {\n            if (sn !== aSubnode) {\n                if (sn.title() === aSubnode.title()) {\n                    this.removeSubnode(sn)\n                }\n            }\n        })\n        return this\n    }\n\n    subnodeWithTitleIfAbsentInsertClosure (aString, aClosure) {\n        let subnode = this.firstSubnodeWithTitle(aString)\n\n        if (!subnode && aClosure) {\n            subnode = aClosure()\n            subnode.setTitle(aString)\n\n            this.addSubnode(subnode)\n        }\n\n        return subnode\n    }\n\n    // --- sorting helper ---\n\n    makeSortSubnodesByTitle () {\n        this.setSubnodeSortFunc(function (a, b) {\n            const cleanedTitle = function (t) {\n                return Type.isNullOrUndefined(t) ? \"\" : t;\n            }\n\n            let at = cleanedTitle(a.title());\n            let bt = cleanedTitle(b.title());\n            return at.localeCompare(bt);\n        })\n        return this\n    }\n\n    // --- node view badge ---\n\n    nodeViewShouldBadge () {\n        return false\n    }\n\n    nodeViewBadgeTitle () {\n        return null\n    }\n\n    // --- summary ---\n\n    summary () {\n        return this.title() + \" \" + this.subtitle()\n    }\n\n    \n}.initThisClass());\n\n\n\n\n",
  "a/bw1KhP6TYsXdGZ1AT9kMmbHyrg8UrbMD+u/h6z7Nw=": "\"use strict\";\n\n/*\n\n    InspectableNode\n \n    BMNode -> TitledNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Handles creating inspector nodes and related fields.\n    Slot has some logic for this too.\n\n*/\n\n(class InspectableNode extends TitledNode {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"nodeCanInspect\", true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeInspector\", null);\n            slot.setDuplicateOp(\"nop\");\n            slot.setSlotType(\"BMNode\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    // --- node inspector ---\n\n    nodeInspector () {\n        if (!this._nodeInspector) {\n            this._nodeInspector = BaseNode.clone()\n            this.initNodeInspector()\n        }\n        return this._nodeInspector\n    }\n\n    initNodeInspector () {  // TODO: merge with setupInspectorFromSlots?\n        this.setupInspectorFromSlots()\n        return this\n    }\n\n    setupInspectorFromSlots () {\n        const slotsMap = this.thisPrototype().allSlotsMap();\n        const slotNames = slotsMap.keysArray();\n        \n        this.nodeInspector().setTitle(this.title() + \" inspector\");\n\n        {\n            // move \"type\" slot to first item\n            const s = \"nodeType\";\n            if (slotNames.includes(s)) {\n                slotNames.remove(s);\n                slotNames.unshift(s);\n            }\n        }\n        \n        slotNames.forEachV(slotName => {\n            const slot = slotsMap.get(slotName);\n            if (slot.canInspect()) {\n                const field = slot.newInspectorField();\n                let pathNodes = null;\n\n                if (field) {\n                    field.setTarget(this);\n                    field.setCanDelete(false);\n                    pathNodes = this.nodeInspector().createNodePath(slot.inspectorPath());\n                    pathNodes.last().addSubnode(field);\n                } else {\n                    const node = slot.onInstanceGetValue(this);\n                    if (node === null || (Type.isObject(node) && node.thisClass().isKindOf(BMNode))) {\n                        const linkNode = BMLinkNode.clone().setLinkedNode(node);\n                        linkNode.setCanDelete(false) ;\n                        pathNodes = this.nodeInspector().createNodePath(slot.inspectorPath());\n                        pathNodes.last().addSubnode(linkNode);\n                    } else {\n                        throw new Error(this.type() + \".\" + slot.name() + \" must have it's slotType set to be inspected\");\n                    }\n                }\n\n                pathNodes.forEach(pathNode => { \n                    pathNode.setCanDelete(false) ;\n                })\n            }\n        })\n        return this\n    }    \n\n    // --- helpful for setting up inspector paths ---\n\n    createNodePath (aPath, pathSubnodeType = \"BMFolderNode\") {\n        const pathNodes = [this];\n\n        if (aPath) {\n            const components = aPath.split(\"/\");\n            let node = this;\n\n            components.forEach(component => {\n                node = node.subnodeWithTitleIfAbsentInsertClosure(component, () => {\n                    //debugger\n                    const nodeClass = Object.getClassNamed(pathSubnodeType);\n                    const newNode = nodeClass.clone();\n                    newNode.setNodeCanReorderSubnodes(false); // should this be here?\n                    newNode.setTitle(component);\n                    newNode.setSubtitle(null);\n                    newNode.setNodeCanAddSubnode(false);\n                    return newNode;\n                })\n                pathNodes.push(node);\n            })\n        }\n\n        return pathNodes;\n    }\n\n    // --- fields ---\n    \n    /*\n    addLinkFieldForNode (aNode) {\n        const field = BMLinkField.clone().setName(aNode.title()).setValue(aNode)\n        return this.addStoredField(field)\n    }\n    */\n    \n    addField (aField) {\n        throw new Error(\"addField shouldn't be called - use BMFieldSetNode\")\n        return this.addSubnode(aField)\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    // nodeTileLinkMethods\n    // used by UI tile views to choose the node ref to use for the next column\n    // if returns null, the tile won't open another column\n    // \n    // The two typical use cases are :\n    //\n    // 1) A pointer tile which links to some other node.\n    //\n    // 2) A means to toggle between viewing the row's node or\n    //    skipping to one of its subnodes. This allows a node\n    //    to have inspector separated from \"subnode\" browsing.\n    //    Example: a Server object might have the subnodes:\n    //    [ StringFieldNode (for server name),  \n    //      ActionNode (to connect/disconnect),\n    //      ServerClientsNode (holds list of connected server clients)\n    //\n\n    thisNode () {\n        return this\n    }\n\n    nodeTileLinkMethods () {\n        return [\"thisNode\"]\n    }\n\n    defaultNodeTileLinkMethod () {\n\n    }\n\n    // --- adding fields as subnodes ---\n\n    addSubnodeFieldsForSlots (slots) {\n        slots.forEach(slot => {\n            this.addSubnodeFieldForSlot(slot);\n        })\n    }\n\n    addSubnodeFieldForSlot (slot) {\n        const name = slot.name();\n        const field = slot.newInspectorField();\n        if (!field) {\n            const className = slot.fieldInspectorClassName();\n            throw new Error(\"no field class '\" + className + \"' found for slot '\" + slot.name() + \"' on type '\" + this.type() + \"'\");\n        }\n\n        if (field.setFieldSlotName) {\n            field.setFieldSlotName(slot.name()); //is this used?\n            debugger;\n        }\n\n        field.setShouldStore(false);\n        field.setShouldStoreSubnodes(false);\n\n        field.setTarget(this);\n        field.setNodeCanEditTitle(false);\n        field.setValueIsEditable(slot.canEditInspection());\n        field.setNodeCanReorderSubnodes(false);\n        field.setSummaryFormat(slot.summaryFormat());\n        field.setHasNewlineAfterSummary(true);\n        field.setNodeCanAddSubnode(false);\n        field.setCanDelete(false);\n        field.setIsVisible(slot.isSubnodeFieldVisible());\n        \n        /*\n        if (name === \"isAvailable\") {\n            debugger;\n        }\n        */\n       \n        const pathNodes = this.createInspectorNodePath(slot.inspectorPath());\n\n        /*\n        const node = pathNodes.last()\n        if (node !== this) {\n            node.setNodeSubtitleIsChildrenSummary(true)\n        }\n        */\n\n        field.setKeyIsVisible(slot.keyIsVisible() !== false);\n\n        if (pathNodes.length > 1) {\n            pathNodes.last().setNodeFillsRemainingWidth(slot.nodeFillsRemainingWidth());\n            //field.setNodeFillsRemainingWidth(slot.nodeFillsRemainingWidth());\n        }\n        pathNodes.last().addSubnode(field);\n        return this\n    }\n\n    createInspectorNodePath (aPath) {\n        const pathNodes = this.createNodePath(aPath);\n        pathNodes.forEach(node => {\n            if (node !== this) {\n                node.setNodeSubtitleIsChildrenSummary(true);\n                node.setHasNewlineAfterSummary(true)\n                if (node !== pathNodes.last()) {\n                    node.setHasNewLineSeparator(true);\n                }\n            }\n        });\n        return pathNodes;\n    }\n\n}.initThisClass());\n\n\n\n\n",
  "3fejE8wRvEpL/AdNH6T/RgHio1Vnoq22rID9A0rgM4g=": "\"use strict\";\n\n/*\n\n    ViewableNode\n \n    BMNode -> TitledNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    Class for handling a node's connection to the user interface.\n    Views can reference nodes, but nodes should not reference views. \n    Views can query nodes for info or tell them to take actions, but otherwise \n    nodes should only communicate with views via notfications.\n\n*/\n\n(class ViewableNode extends InspectableNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"nodeViewClassName\", null);\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"String\");\n        }\n        \n    \n        {\n            const addSlot = (name, path, label, values) => {\n                const slot = this.newSlot(name, \"\")\n                slot.setInspectorPath(path)\n                slot.setLabel(label)\n                slot.setShouldStoreSlot(true)\n                slot.setDuplicateOp(\"copyValue\")\n                slot.setSlotType(\"String\")\n                slot.setValidValues(values)\n                slot.setCanInspect(true)\n                slot.setInspectorPath(\"Node/Viewable\")\n\n                return slot\n            }\n            addSlot(\"nodeTileClassName\", \"\", \"Tile View Class\", null).setValidValuesClosure((instance) => { \n                //return BMThemeResources.shared().activeTheme().themeClassNames()\n                return Tile.allSubclasses().map(aClass => aClass.type())\n            })\n\n            //BMThemeResources.shared().activeTheme().newThemeClassOptions()\n        }\n        \n\n        /*\n        {\n            const slot = this.newSlot(\"nodeTileClassName\", null)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setLabel(\"Tile Class Name\")\n            slot.setSlotType(\"String\")\n            slot.setShouldStoreSlot(true)\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"nodeThumbnailUrl\", null);\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeIsVertical\", true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setLabel(\"is vertical\");\n            slot.setSlotType(\"Boolean\");\n            slot.setInspectorPath(\"Node/Viewable/Children Layout\");\n            slot.setShouldStoreSlot(true);\n        }\n\n        {\n            const slot = this.newSlot(\"nodeChildrenAlignment\", \"flex-start\");\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setLabel(\"alignment\");\n            slot.setSlotType(\"String\");\n            slot.setValidValues([\"flex-start\", \"center\", \"flex-end\", \"space-between\", \"space-around\"]);\n            slot.setInspectorPath(\"Node/Viewable/Children Layout\");\n            slot.setShouldStoreSlot(true);\n        }\n\n        {\n            const slot = this.newSlot(\"nodeTileIsSelectable\", true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeTilesStartAtBottom\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeNavBorderHint\", true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeMinTileHeight\", 0);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setInspectorPath(\"Node/Viewable/Style\");\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeMinTileWidth\", 0);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setInspectorPath(\"Node/Viewable/Style\");\n            slot.setSlotType(\"Number\");\n        }\n\n        // html\n\n        {\n            const slot = this.newSlot(\"acceptsFileDrop\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        // input hook\n\n        {\n            const slot = this.newSlot(\"nodeInputFieldMethod\", null);\n            slot.setAllowsNullValue(true);\n            slot.setSlotType(\"String\");\n        }\n\n        // column settings - TODO: auto adjust to fit?\n\n        /*\n        {\n            const slot = this.newSlot(\"nodeMinWidth\", 200).setDuplicateOp(\"copyValue\") // no longer used - we calc sizes of tiles instead\n        }\n        */\n        \n        {\n            const slot = this.newSlot(\"nodeFillsRemainingWidth\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"fills remaining\");\n            slot.setCanEditInspection(false);\n            slot.setCanInspect(false);\n            slot.setInspectorPath(\"Node/Viewable/Children Layout\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeFillsWindow\", false);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"fills window\");\n            slot.setCanEditInspection(true);\n            slot.setCanInspect(true);\n            slot.setShouldStoreSlot(true);\n            slot.setInspectorPath(\"Node/Viewable/Children Layout\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditTileHeight\", false);\n            slot.setDuplicateOp(\"copyValue\"); // TODO: change to NavHeight\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"nodeCanEditColumnWidth\", false);\n            slot.setDuplicateOp(\"copyValue\"); // TODO: change to NavWidth\n            slot.setSlotType(\"Boolean\");\n        }\n\n    }\n\n    initPrototype () {    \n    }\n\n\n    finalInit () {\n        super.finalInit()\n        if (this.nodeChildrenAlignment() === \"Start\") {\n            this.setNodeChildrenAlignment(\"flex-start\")\n        }\n    }\n\n    nodeOrientation () {\n        return this.nodeIsVertical() ? \"right\" : \"down\" \n    }\n\n     // --- nodeViewClass and nodeTileClass ---\n    \n     nodeViewClass () {\n        const name = this.nodeViewClassName()\n        if (name) {\n            const proto = Object.getClassNamed(name)\n            if (proto) {\n                return proto\n            }\n            console.warn(\"no class found for nodeViewClassName:'\" + name + \"'\")\n            debugger \n        }\n        \n\t  \treturn this.firstAncestorClassWithPostfix(\"View\") \n    }\n\n    // --- nodeTileClass ---\n\n    nodeTileClass () {  \n        // This is used (instead of nodeViewClass) by TilesView to \n        // get it's subnode's views. Other views (typically) use nodeViewClass.\n        const name = this.nodeTileClassName()\n\n        if (name) {\n            const proto = Object.getClassNamed(name)\n            if (proto) {\n                return proto\n            }\n            console.warn(\"no class found for nodeTileClassName:'\" + name + \"'\");\n        }\n\n\t  \treturn this.firstAncestorClassWithPostfix(\"Tile\");\n    }\n\n    onBrowserDropChunk (dataChunk) {\n        const mimeType = dataChunk.mimeType();\n        const canOpenNodes = BMNode.allSubclasses().select((aClass) => aClass.canOpenMimeType(mimeType));\n        const okTypes = this.acceptedSubnodeTypes();\n        const canUseNodes = canOpenNodes; /// canOpenNodes.select(nodeType => okTypes.contains(nodeType))\n\n        if (canUseNodes.length) {\n\n            if (canUseNodes.length === 1) {\n                const match = canUseNodes.first();\n                const newNode = match.openMimeChunk(dataChunk);\n                this.addSubnode(newNode);\n\n                //if (this.acceptsAddingSubnode(match)) {\n                //    this.addSubnode(match);\n                //}\n                \n            } else {\n                // TODO: add CreatorNode with those types and\n                // hook to instantiate from mime data\n            }\n        }\n    }\n\n    // --- update / sync system ----------------------------\n    \n    didUpdateSlot (aSlot, oldValue, newValue) {\n        super.didUpdateSlot(aSlot, oldValue, newValue);\n\n        if (aSlot.syncsToView()) { \n            this.scheduleSyncToView(aSlot.name());\n        }\n    }\n\n    scheduleSyncToView (slotName) {\n        this.didUpdateNodeIfInitialized(this, slotName);\n        return this;\n    }\n\n\n    // --- shelf ---\n\t\n    /*\n    shelfSubnodes () {\n        return [];\n    }\n\n    shelfIconName () {\n\t    return null;\n    }\n\t\n    shelfIconUrl () {\n\t    return null;\n    }\n    */\n    \n    prepareToSyncToView () {\n        this.prepareToAccess();\n    }\n\t\n    // visibility\n\t\n    nodeBecameVisible () {\n\t    return this;\n    }\n\n    // -- selection requests ---\n\n    onRequestSelectionOfDecendantNode () {\n        return false; // allow propogation up the parentNode line\n    }\n\n    onRequestSelectionOfNode () {\n        this.tellParentNodes(\"onRequestSelectionOfDecendantNode\", this);\n        return this;\n    }\n\n    onTapOfNode () {\n        this.tellParentNodes(\"onTapOfDecendantNode\", this);\n        return this;\n    }\n\n}.initThisClass());\n\n\n\n\n",
  "iYAZQ1UEUpvx5IrapXYzo0vNtHsROnO0OPkblrDvzIo=": "\"use strict\";\n\n/*\n\n    StyledNode\n \n    BMNode -> TitledNode -> InspectableNode -> ViewableNode -> StyledNode -> BaseNode -> StorableNode\n\n    For state and behavior specific to styling of views.\n\n*/\n\n(class StyledNode extends ViewableNode {\n    \n    initPrototypeSlots () {\n        // view style overrides\n        {\n            //const slot = this.newSlot(\"themeClassName\", \"DefaultThemeClass\")\n            const slot = this.newSlot(\"themeClassName\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"Theme Class\")\n            slot.setInspectorPath(\"Node/Styled\")\n            slot.setSyncsToView(true)\n            slot.setValidValuesClosure((instance) => { \n                return BMThemeResources.shared().activeTheme().themeClassNames()\n            })   \n            //slot.setInspectorPath(\"Style\")\n        }\n    }\n\n    initPrototype () {\n    }\n\n}.initThisClass());\n\n\n\n\n",
  "MSMhjC6uIA++17idzh8l9WIqRHgIjz/vybguXgA4OpA=": "\"use strict\";\n\n/*\n\n    BaseNode\n \n    Something for everone to extend. Under neath, we break up the node into \n    various classes of sub state and behavior.\n\n*/\n\n(class BaseNode extends StyledNode {\n    \n\n}.initThisClass());\n\n\n\n\n",
  "vH3uZJFZiYtEPzFiJug60EQ0FyAyk+89a43YQxBSIis=": "\"use strict\";\n\n\n(class ProtoClass_store extends ProtoClass {\n\n    recordForStore (aStore) { // should only be called by Store\n        const aRecord = {\n            type: this.type(), \n            entries: [], \n        }\n\n        this.allSlotsMap().forEachKV((slotName, slot) => {\n        //this.forEachSlotKV((slotName, slot) => {\n\n            //if (slot.shouldStoreSlot()) {\n            if (slot.shouldStoreSlotOnInstance(this)) {\n                const v = slot.onInstanceGetValue(this)\n                if (Type.isPromise(v)) {\n                    throw new Error(this.type() + \" '\" + slotName + \"' slot is set to shouldStore, but contains a Promise value which cannot be stored\")\n                }\n                //assert(!Type.isUndefined(v))\n                aRecord.entries.push([slotName, aStore.refValue(v)])\n            }\n        });\n\n        return aRecord\n    }\n\n    lazyPids (puuids = new Set()) {\n        // when doing Store.collect() will need to check for lazy slot pids on active objects\n        this.allSlotsMap().forEachV(slot => {\n            // only need to do this on unloaded store refs in instances\n            const storeRef = slot.onInstanceGetValueRef(this)\n            if (storeRef) {\n                puuids.add(storeRef.pid())\n            }\n        })\n        return puuids\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        aRecord.entries.forEach((entry) => {\n            const k = entry[0]\n            const v = entry[1]\n\n            const slot = this.thisPrototype().slotNamed(k)\n            // TODO: replace with slot.onInstanceSetValueFromEntry(this, entry, aStore)\n\n            if (slot) {\n                    if (!slot.hasSetterOnInstance(this)) {\n                    // looks like the schema has changed \n                    // TODO: add something the schedule a didMutate?\n                    console.warn(\"no setter for slot '\"+ slot.name() + \"'?\")\n                    debugger;\n                } else {\n                    /*if (slot.isLazy()) {\n                        const pid = v[\"*\"]\n                        assert(pid)\n                        const storeRef = StoreRef.clone().setPid(pid).setStore(aStore)\n                        //console.log(this.typeId() + \".\" + slot.name() + \" [\" + this.title() + \"] - setting up storeRef \")\n                        slot.onInstanceSetValueRef(this, storeRef)\n                    } else */\n                    {\n                        const unrefValue = aStore.unrefValue(v)\n                        slot.onInstanceSetValue(this, unrefValue)\n                    }\n                }\n            } else {\n                console.warn(\"loadFromRecord(aRecord), aRecord has slot '\" + k + \"' but '\" + this.type() + \"' does not. Did schema change?\");\n                //debugger;\n                this.scheduleMethod(\"didMutate\", 1000) // to force it to save - use high priorty number to cause it to be done after mutations on loading objects are being ignored e.g. before scheduled didInitLoadingPids is complete \n                //debugger;\n            }\n        })\n\n        return this\n    }\n\n    /*\n    didLoadFromStore (aStore) {\n        // called by ObjectPool.didInitLoadingPids() after all objects are deserialized\n        super.didLoadFromStore(aStore)\n    }\n    */\n\n}).initThisCategory();\n",
  "A3LQseiZhT96+6X1YCLICx5ikT5Iqyx/vMYcvpvOGGg=": "\"use strict\";\n\n(class BMNode_store extends BMNode {\n        \n    /*\n\n        Placeholder for store related methods. \n        This state/behavor is currently in BMStorableNode.\n\n    */\n\n}).initThisCategory();\n",
  "nBZTvP8VAi8+zYkVQXBlunjCE90QZc/UI+0Z5CotkOs=": "\"use strict\";\n\n/**\n * @module node.storage.base\n * @class Array_store\n * @extends Array\n * @description A custom Array class with additional methods for storage and serialization.\n */\n(class Array_store extends Array {\n\n    /**\n     * @static\n     * @param {Object} aRecordObj - The record object containing the array values.\n     * @returns {number} The length of the array in the record object.\n     */\n    static lengthOfRecord (aRecordObj) {\n        return aRecordObj.values.length\n    }\n\n    /**\n     * @param {Object} aStore - The store object to use for reference handling.\n     * @returns {Object} A record object representing the array for storage.\n     * @description Prepares the array for storage by creating a record object.\n     */\n    recordForStore (aStore) { // should only be called by Store\n        const dict = {\n            type: Type.typeName(this), \n            values: this.map(v => aStore.refValue(v))\n        }\n\n        return dict\n    }\n\n    /**\n     * @param {Object} aRecord - The record object to load from.\n     * @param {Object} aStore - The store object to use for reference handling.\n     * @returns {Array_store} The current instance after loading the values.\n     * @description Loads the array from a record object.\n     */\n    loadFromRecord (aRecord, aStore) {\n        const loadedValues = aRecord.values.map(v => aStore.unrefValue(v))\n        if (this.unhooked_push) {\n            loadedValues.forEach( v => this.unhooked_push(v) )\n        } else {\n            loadedValues.forEach( v => this.push(v) )\n        }\n        return this\n    }\n\n    /**\n     * @param {Set} [puuids=new Set()] - A Set to store the collected PIDs.\n     * @returns {Set} A Set of PIDs (Persistent Unique Identifiers) for JSON storage.\n     * @description Collects PIDs for all non-null elements in the array.\n     */\n    refsPidsForJsonStore (puuids = new Set()) {\n        this.forEach(v => { \n            if (!Type.isNull(v)) { \n                v.refsPidsForJsonStore(puuids)\n            } \n        })\n        return puuids\n    }\n\n}).initThisCategory();\n",
  "SHju706CrnhrZP10JJBmv5NgH4Ov84NUBhQTzn1CsDA=": "\"use strict\";\n\n/**\n * Extends the ArrayBuffer class with storage-related functionality.\n * @module ideal\n * @class ArrayBuffer_store\n * @extends ArrayBuffer\n */\n(class ArrayBuffer_store extends ArrayBuffer {\n\n    /**\n     * Creates an instance of ArrayBuffer_store from a record in the store.\n     * @param {Object} aRecord - The record containing the ArrayBuffer data.\n     * @param {Object} aStore - The store object.\n     * @returns {ArrayBuffer_store} A new instance of ArrayBuffer_store.\n     */\n    static instanceFromRecordInStore (aRecord, aStore) { // should only be called by Store\n        //assert(aRecord.type === \"ArrayBuffer\")\n        const bytes = aRecord.bytes\n        const obj = new ArrayBuffer(bytes.length)\n        return obj\n    }\n\n    /**\n     * Loads data from a record into this ArrayBuffer_store instance.\n     * @param {Object} aRecord - The record containing the ArrayBuffer data.\n     * @param {Object} aStore - The store object.\n     * @returns {ArrayBuffer_store} This instance after loading the data.\n     */\n    loadFromRecord (aRecord, aStore) {\n        assert(aRecord.bytes.length === this.length)\n        const bytes = aRecord.bytes\n        for (let i = 0; i < bytes.length; i++) {\n            this[i] = bytes[i]\n        }\n        return this\n    }\n\n    /**\n     * Converts the ArrayBuffer_store to an array of bytes.\n     * @returns {number[]} An array of byte values.\n     */\n    bytes () {\n        const bytes = []\n        for (let i = 0; i < this.byteLength; i++) {\n            bytes.push(this[i])\n        }\n        return bytes\n    }\n\n    /**\n     * Creates a record representation of this ArrayBuffer_store for storage.\n     * @param {Object} aStore - The store object.\n     * @returns {Object} A record object representing this ArrayBuffer_store.\n     */\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: \"ArrayBuffer\", //Type.typeName(this), \n            bytes: this.bytes(),\n        }\n    }\n\n    /**\n     * Returns a Set of persistent unique identifiers (PUIDs) for this ArrayBuffer_store.\n     * @param {Set<string>} [puuids=new Set()] - A Set to store the PUIDs.\n     * @returns {Set<string>} The Set of PUIDs.\n     */\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n    \n}).initThisCategory();\n\n\n\n",
  "2KI3i638mqVqqxhTjDkPiCbL4T39zwTzKmSUUU84Tqw=": "\"use strict\";\n\n/*\n    \n    Notes:\n\n    It seems there's no way to synchronously serialize a Blob \n    - so we implement a \"asyncRecordForStore\" method \n    - which the Store will use to make a kvPromise \n    - and add it to it's AtomicMap's queuedSets \n    - which get processed in the promiseCommit before applying the changes to the db.\n\n    Further Notes:\n\n    - using asyncRecordForStore requires the AtomicMap to queue the promises\n      waiting on the sets whose values are waiting on these blobs to be serialized.\n      Since completion of the writes to the AtomicMap and the write transaction to the db\n      has to wait on these promises, we can end up with a situation where writes (and potentially reads) \n      from the next transaction occur before the last is complete.\n      \n    So, it seems like not writing the blob to the slot until it has already cached a dataUrl for itself \n    might be the simplest option. That would allow us to implement a normal Blob.recordForStore().\n\n*/\n\n\n(class Blob_store extends Blob {\n\n    static instanceFromRecordInStore (aRecord, aStore) { // should only be called by Store\n        //assert(aRecord.type === \"Blob\")\n        const obj = this.fromBase64(aRecord.dataUrl)\n        return obj\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        const dataUrl = aRecord.dataUrl\n        return Blob.fromBase64(dataUrl)\n    }\n\n    /*\n    async asyncRecordForStore (aStore) { // should only be called by Store\n        const dataUrl = await this.toBase64()\n        return {\n            type: \"Blob\", //Type.typeName(this), // should we use typeName to handle subclasses?\n            dataUrl: dataUrl\n        }\n    }\n    */\n\n    async asyncPrepareToStoreSynchronously () {\n        this._dataUrl = await this.toBase64()\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        assert(this._dataUrl)\n        return {\n            type: \"Blob\", //Type.typeName(this), // should we use typeName to handle subclasses?\n            dataUrl: this._dataUrl\n        }\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n    // --- serializers ---\n\n    async toBase64 () {\n        return this.asyncToDataUrl();\n    }\n\n    // --- deserializer ---\n    \n    static fromBase64 (dataURL) {\n        const parts = dataURL.split(',');\n        const mimeType = parts[0].slice(5, -7);\n        const byteCharacters = atob(parts[1]);\n        const byteNumbers = new Array(byteCharacters.length);\n        for (let i = 0; i < byteCharacters.length; i++) {\n            byteNumbers[i] = byteCharacters.charCodeAt(i);\n        }\n        const byteArray = new Uint8Array(byteNumbers);\n        return new Blob([byteArray], { type: mimeType });\n    }\n    \n}).initThisCategory();\n\n\n\n",
  "wFfjR4Sbch69mgtsXbrV+klzjPStuhsxinCrpXWUAJw=": "\"use strict\";\n\n\n(class Date_store extends Date {\n\n    loadFromRecord (aRecord, aStore) {\n        this.setTime(aRecord.time)\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: this.type(), \n            time: this.getTime() // toJSON is a standard library Date method\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n",
  "hcZglDEXsAn2qwJT3DHWPf1/4vAZPbVG0tvUIo72qqs=": "\"use strict\";\n\n\n(class Error_store extends Error {\n\n    loadFromRecord (aRecord, aStore) {\n        this.name = aRecord.name;\n        this.message = aRecord.message;\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: this.type(), \n            name: this.name,\n            message: this.message\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n",
  "UIys9Ns+c7Dm6Kfcw7vD1ezcz8VmtnbbD3UQROO09QI=": "\"use strict\";\n\n\n(class Map_store extends Map {\n\n    loadFromRecord (aRecord, aStore) {\n        aRecord.entries.forEach((entry) => {\n            const key = entry[0]\n            const value = aStore.unrefValue(entry[1])\n            this.atPut(key, value)\n        })\n\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        let iterator = this.entries();\n        let entry = iterator.next().value\n        const entries = []\n        while (entry) {\n            const key = entry[0]\n            const value = entry[1]\n            entries.push([key, aStore.refValue(value)])\n            entry = iterator.next().value\n        }\n\n        return {\n            type: this.type(), \n            entries: entries\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        this.forEach(v => { \n            if (!Type.isNull(v)) { \n                v.refsPidsForJsonStore(puuids)\n            } \n        })\n        return puuids\n    }\n\n}).initThisCategory();\n\n\n\n",
  "3YJiLdZ61gZQKijqvy29HztDOY3AkwWPu1lzSCiOeok=": "\"use strict\";\n\n\n(class Set_store extends Set {\n\n    loadFromRecord (aRecord, aStore) {\n        const values = aRecord.values.map(v => aStore.unrefValue(v))\n        values.forEach(v => this.add(v))\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        return {\n            type: Type.typeName(this), \n            values: this.valuesArray().map(v => aStore.refValue(v))\n        }\n    }\n\n    shouldStore () {\n        return true\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        this.forEach(v => { \n            if (!Type.isNull(v)) { \n                v.refsPidsForJsonStore(puuids)\n            } \n        })\n        return puuids\n    }\n\n}).initThisCategory();\n\n\n\n\n",
  "xOArjE5VsxoAyVqKspPlGRmRNxX+RGNXZZjJ/DhEnGo=": "\"use strict\";\n\n\n/*\nconst typedArrayClass = Int8Array.__proto__;\n\nObject.defineSlots(typedArrayClass.prototype, {\n    _isDeserializing: false\n});\n*/\n\n(class Object_store extends Object {\n\n    static instanceFromRecordInStore (aRecord, aStore) { // should only be called by Store\n        if(!this.shouldStore()) {\n            console.warn(this.type() + \" instanceFromRecordInStore() attempting to load a record for an object (of type '\" +this.type() + \") with shouldStore set to false - returning null\");\n            return null;\n        }\n\n        //debugger;\n        const instance = this.preClone ? this.preClone() : new this();\n        instance.init();\n        // caller needs to call finalInit and afterInit\n        return instance;\n    }\n\n    loadFromRecord (aRecord, aStore) {\n        aRecord.entries.forEach((entry) => {\n            const k = entry[0]\n            const v = entry[1]\n            this[k] = aStore.unrefValue(v)\n        })\n        return this\n    }\n\n    recordForStore (aStore) { // should only be called by Store\n        // NOTES: this is (typically) only for dictionaries, not for objects.\n        // generic storage of (non ProtoClass subclass) objects is not supported.\n        \n        assert(this.shouldStore());\n\n        // Any ProtoClass subclass will not call this method as it will use the ProtoClass_store.recordForStore method.\n        // We just need to handle dictionaries here i.e.JSON dictionaries.\n        // which *might* overide the type property.\n\n        // QUESTION: why would shouldStore be true for a dictionary?\n\n        let type = \"Object\";\n\n        if (Type.isFunction(this.type)) {\n            type = this.type();\n        }\n\n        const entries = [];\n\n        Object.keys(this).forEach((k) => {\n            const v = this[k]\n            entries.push([k, aStore.refValue(v)])\n        });\n\n        // need to special case objects as they can also be used as JSON dictionaries.\n        // if we have a dictionary, we need to store it as a dictionary, not as an object.\n        \n        return {\n            type: type, \n            entries: entries, \n        }\n    }\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        if (this.hasOwnProperty(\"*\")) {\n            puuids.add(this[\"*\"])\n        } else {\n            throw new Error(\"dictionaries are reserved for pointers, but we found a non-pointer\")\n        }\n        return puuids\n    }\n    \n    defaultStore () {\n        const store = PersistentObjectPool.sharedPool();\n        return store;\n    }\n\n    // ---\n\n    didLoadFromStore () { \n        // See Object_init notes for docs on when/how to use this properly.\n        // Here for subclasses to override.\n        return this\n    }\n\n    // --- shouldStore ---\n \n    setShouldStore (aBool) {\n        if (aBool != this._shouldStore) {\n            //this.willMutate(\"shouldStore\")\n            assert(this !== getGlobalThis());\n            Object.defineSlot(this, \"_shouldStore\", aBool)\n            //this.didMutate(\"shouldStore\")\n        }\n        return this\n    }\n \n    shouldStore () {\n        return this._shouldStore;\n        //return Object.getOwnProperty(this._shouldStore)\n    }\n    \n}).initThisCategory();\n",
  "sFwdt9+4Geh3hc4TVx5562HO4KbitBjWlJ3a/GcRg18=": "\"use strict\";\n\n/*\nType.typedArrayTypeNames().forEach((name) => {\n    const aClass = Object.getClassNamed(name)\n\n    if (Type.isUndefined(aClass)) {\n        console.warn(\"TypeArray-store error: missing type \" + name)\n        return\n    }\n\n    Object.defineSlots(aClass, {\n        instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store\n            const obj = new this.thisClass()(aRecord.length)\n            //obj.loadFromRecord(aRecord, aStore)\n            return obj\n        },\n    })\n\n    Object.defineSlots(aClass.prototype, {\n\n        loadFromRecord: function(aRecord, aStore) {\n            const values = aRecord.values\n            for (let i = 0; i < values.length; i++) {\n                this[i] = values[i]\n            }\n            return this\n        },\n\n        valuesArray: function() {\n            return Array.fromIterator(this.values())\n        },\n\n        recordForStore: function(aStore) { // should only be called by Store\n            return {\n                type: this.type(), \n                values: this.valuesArray() \n            }\n        },\n\n        refsPidsForJsonStore: function(puuids = new Set()) {\n            // no references in a TypedArray\n            return puuids\n        },\n    })\n\n})\n*/\n\nconst typedArrayClass = Int8Array.__proto__ // just using int array to get to abstract parent TypeArray class, as we can't use TypeArray name directly\n\nObject.defineSlots(typedArrayClass, {\n    instanceFromRecordInStore: function(aRecord, aStore) { // should only be called by Store\n        const obj = new this.thisClass()(aRecord.length)\n        return obj\n    },\n})\n\nObject.defineSlots(typedArrayClass.prototype, {\n\n    loadFromRecord: function(aRecord, aStore) {\n        const values = aRecord.values\n        for (let i = 0; i < values.length; i++) {\n            this[i] = values[i]\n        }\n        return this\n    },\n\n    valuesArray: function() {\n        return Array.fromIterator(this.values())\n    },\n\n    recordForStore: function(aStore) { // should only be called by Store\n        return {\n            type: this.type(), \n            values: this.valuesArray() \n        }\n    },\n\n    refsPidsForJsonStore: function(puuids = new Set()) {\n        // no references in a TypedArray\n        return puuids\n    },\n})\n",
  "kIknma36/5ymKETQtT9pDYPtE+6nN3w7i3gOdcIcLok=": "\"use strict\";\n\n(class String_store extends String {\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n\n",
  "r/Ki2TaRj9WzljePmlL/gtxGuoVuQLcIpNrFUrMAIsA=": "\"use strict\";\n\n(class Boolean_store extends Boolean {\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n\n",
  "jJpd0nRHyZ3ZDCAe7TJgoAJgNW0uTLYYjjNsPg6ykE0=": "\"use strict\";\n\n(class Number_store extends Number {\n\n    refsPidsForJsonStore (puuids = new Set()) {\n        return puuids\n    }\n\n}).initThisCategory();\n\n",
  "pbTMNR97iuIxnKQ6VJxIsjL6Frp1+KCmLAcarErr278=": "\"use strict\";\n\n/*\n\n    ObjectPool\n\n        For persisting a object tree to a JSON formatted representation and back.\n        Usefull for both persistence and exporting object out the the app/browser and onto desktop or other browsers.\n\n        This is a parent class for PersistentObjectPool, which just swaps out the recordDict AtomicMap, \n        with a PersistentAtomicMap.\n\n        An object pool can also be created by pointing at an object within another pool.\n\n        JSON format of pool:\n\n            {\n                rootPid: \"rootPid\",\n                puuidToDict: {\n                    \"<objPid>\" : <Record>\n                }\n            }\n\n        Example use:\n    \n            // converting a node to json\n            const poolJson = ObjectPool.clone().setRoot(rootNode).asJson()\n            \n            // converting json to a node\n            const rootObject = ObjectPool.clone().fromJson(poolJson).root()\n\n        Notes:\n\n        Objects to be stored must implement:\n\n            // writing methods\n            puuid\n            recordForStore (aStore)\n\n            // reading methods\n            static instanceFromRecordInStore (aRecord, aStore)\n            loadFromRecord (aRecord, aStore)\n\n        These are implemented on Object, and other primitives such as Array, Set, etc.\n\n*/\n\n(class ObjectPool extends ProtoClass {\n\n    static shouldStore () {\n        return false;\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"name\", \"defaultDataStore\");\n            slot.setSlotType(\"String\");\n        }\n\n\n        {\n            const slot = this.newSlot(\"rootObject\", null);\n            slot.setSlotType(\"Object\");\n        }\n\n        {\n            const slot = this.newSlot(\"recordsMap\", null);\n            slot.setSlotType(\"AtomicMap\");\n        }\n\n        {\n            const slot = this.newSlot(\"activeObjects\", null);\n            slot.setDescription(\"objects known to the pool (previously loaded or referenced)\");\n            slot.setSlotType(\"Map\");\n        }\n\n        {\n            const slot = this.newSlot(\"dirtyObjects\", null);\n            slot.setDescription(\"subset of activeObjects containing objects with mutations that need to be stored\");\n            slot.setSlotType(\"Map\");\n        }\n\n        {\n            const slot = this.newSlot(\"loadingPids\", null);\n            slot.setDescription(\"pids of objects that are currently being loaded\");\n            slot.setSlotType(\"Set\");\n        }\n\n        {\n            const slot = this.newSlot(\"storingPids\", null);\n            slot.setDescription(\"pids of objects that are currently being stored\");\n            slot.setSlotType(\"Set\");\n        }\n\n        {\n            const slot = this.newSlot(\"lastSyncTime\", null);\n            slot.setDescription(\"Time of last sync. WARNING: vulnerable to system time changes/differences\");\n            slot.setSlotType(\"Date\");\n        }\n\n        /*\n        {\n            const slot = this.newSlot(\"isReadOnly\", false);\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"markedSet\", null);\n            slot.setDescription(\"Set of puuids used during collection to mark objects that are reachable from the root\");\n            slot.setSlotType(\"Set\");\n        }\n\n        // TODO: change name to objectPoolDidOpen?\n        {\n            const slot = this.newSlot(\"nodeStoreDidOpenNote\", null);\n            slot.setDescription(\"Notification sent after pool opens\");\n            slot.setSlotType(\"BMNotification\");\n        }\n\n        {\n            const slot = this.newSlot(\"isFinalizing\", false);\n            slot.setDescription(\"Set to true during method didInitLoadingPids() - used to ignore mutations during this period\");\n            slot.setSlotType(\"Boolean\");\n        }\n\n        // String or Error\n        {\n            const slot = this.newSlot(\"error\", null); // most recent error, if any\n            slot.setSlotType(\"Error\");\n        }\n\n        {\n            const slot = this.newSlot(\"collectablePidSet\", null); // used during collection to store keys before tx begins\n            slot.setSlotType(\"Set\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        this.setRecordsMap(ideal.AtomicMap.clone());\n        this.setActiveObjects(new Map());\n        this.setDirtyObjects(new Map());\n        this.setLoadingPids(new Set());\n        this.setLastSyncTime(null);\n        this.setMarkedSet(null);\n        this.setNodeStoreDidOpenNote(this.newNoteNamed(\"nodeStoreDidOpen\"));\n        this.setIsDebugging(false);\n        return this\n    }\n\n    setIsDebugging (b) {\n        if (b === false && this.isDebugging() === true) {\n            debugger;\n        }\n        super.setIsDebugging(b)\n        return this\n    }\n\n    clearCache () {\n        this.setActiveObjects(new Map())\n        this.setDirtyObjects(new Map())\n        this.readRoot()\n        //this.setRootObject(this.objectForPid(this.rootObject().puuid()))\n        return this\n    }\n\n    // --- open ---\n\n    /*\n    open () { // this class can also be used with synchronous AtomicMap\n        this.recordsMap().setName(this.name());\n        this.recordsMap().open();\n        debugger;\n        this.onPoolOpenSuccess();\n        return this\n    }\n    */\n\n    async promiseOpen () { \n        //debugger;\n        const map = this.recordsMap();\n        map.setName(this.name());\n        try {\n            await map.promiseOpen();\n            await this.onPoolOpenSuccess();\n        } catch (error) {\n            this.onPoolOpenFailure(error);\n        }\n    }\n\n    async onPoolOpenSuccess () {\n        //debugger\n        // here so subclasses can easily hook\n        await this.onRecordsDictOpen()\n    }\n\n    onPoolOpenFailure (error) {\n        debugger\n        // here so subclasses can easily hook\n        throw error\n    }\n\n    /*\n    postOpenNote () {\n        this.postNoteNamed(\"objectPoolDidOpen\")\n    }\n    */\n\n    show (s) {\n        const comment = s ? \" \" + s + \" \" : \"\"\n        console.log(\"---\" + comment + \"---\")\n        const max = 40\n        console.log(this.recordsMap().count() + \" records: \")\n        this.recordsMap().forEachKV((k, v) => {\n            if (v.length > max) {\n                v = v.slice(0, max) + \"...\"\n            }\n            console.log(\"   '\" + k + \"': '\" + v + \"'\")\n        })\n\n        console.log(\"------\")\n    }\n\n    async onRecordsDictOpen () {\n        //debugger\n        //this.show(\"ON OPEN\")\n        await this.promiseCollect()\n        //this.show(\"AFTER COLLECT\")\n        this.nodeStoreDidOpenNote().post()\n        return this\n    }\n\n    isOpen () {\n        return this.recordsMap().isOpen()\n    }\n\n    // --- root ---\n\n    rootKey () {\n        return \"root\"\n    }\n\n    setRootPid (pid) { \n        // private - it's assumed we aren't already in storing-dirty-objects tx\n        const map = this.recordsMap()\n        if (map.at(this.rootKey()) !== pid) {\n            map.atPut(this.rootKey(), pid)\n            console.log(\"---- SET ROOT PID \" + pid + \" ----\")\n            //debugger;\n        }\n        assert(this.hasStoredRoot())\n        return this\n    }\n\n    rootPid () {\n        return this.recordsMap().at(this.rootKey())\n    }\n\n    hasStoredRoot () {\n        return this.recordsMap().hasKey(this.rootKey())\n    }\n\n    rootOrIfAbsentFromClosure (aClosure) {\n        //debugger;\n        if (this.hasStoredRoot()) {\n            this.readRoot()\n        } else {\n         //   debugger\n            const newRoot = aClosure()\n            assert(newRoot)\n            this.setRootObject(newRoot)\n        }\n        return this.rootObject()\n    }\n\n    readRoot () {\n        //console.log(\" this.hasStoredRoot() = \" + this.hasStoredRoot())\n        if (this.hasStoredRoot()) {\n            const root = this.objectForPid(this.rootPid()) // this call will actually internally set this._rootObject as we may need it while loading the root's refs\n            assert(!Type.isNullOrUndefined(root))\n            //this._rootObject = root\n            //this.setRootObject(root) // this is for setting up new root\n            return this.rootObject()\n        }\n        throw new Error(\"missing root object\")\n    }\n\n    knowsObject (obj) { // private\n        const puuid = obj.puuid()\n        const foundIt = this.recordsMap().hasKey(puuid) ||\n            this.activeObjects().has(puuid) ||\n            this.dirtyObjects().has(puuid) // dirty objects check redundant with activeObjects?\n        return foundIt\n    }\n\n    assertOpen () {\n        assert(this.isOpen())\n    }\n\n    /*\n    changeOldPidToNewPid (oldPid, newPid) {\n        // flush and change pids on all activeObjects \n        // and pids and pidRefs in recordsMap \n        throw new Error(\"unimplemented\")\n        return this\n    }\n    */\n    \n    setRootObject (obj) { // only used for setting up a new root object\n        this.assertOpen()\n        if (this._rootObject) {\n            // can support this if we change all stored and\n            //this.changeOldPidToNewPid(\"root\", Object.newUuid())\n            throw new Error(\"can't change root object yet, unimplemented\")\n        }\n\n        assert(!this.knowsObject(obj))\n\n        //debugger;\n        //this.setRootPid(obj.puuid()) // this is set when the dirty root object is stored\n        this._rootObject = obj\n        this.debugLog(\" adding rootObject \" + obj.debugTypeId())\n        this.addActiveObject(obj)\n        this.addDirtyObject(obj)\n        return this\n    }\n\n    // ---  ---\n\n    asJson () {\n        return this.recordsMap().asJson()\n    }\n\n    updateLastSyncTime () {\n        this.setLastSyncTime(Date.now())\n        return this\n    }\n\n    // --- active and dirty objects ---\n\n    hasActiveObject (anObject) {\n        const puuid = anObject.puuid()\n        return this.activeObjects().has(puuid)\n    }\n    \n    addActiveObject (anObject) {\n        assert(!anObject.isClass());\n\n        /*\n        if (anObject.type() === \"Error\") {\n            debugger;\n            return false;\n        }\n        */\n\n        if (anObject.type() === \"PersistentObjectPool\") {\n            console.log(\"addActiveObject() called with PersistentObjectPool\");\n            debugger;\n            return false;\n        }\n\n        if (!anObject.shouldStore()) {\n            const msg = \"attempt to addActiveObject '\" + anObject.type() + \"' but shouldStore is false\"\n            console.warn(msg)\n            anObject.shouldStore()\n            //throw new Error(msg)\n            return false\n        }\n\n        if (!anObject.isInstance()) {\n            const msg = \"can't store non instance of type '\" + anObject.type() + \"'\"\n            console.log(msg)\n            anObject.isKindOf(ProtoClass) \n            throw new Error(msg)\n        }\n\n        //debugger;\n\n        if (!this.hasActiveObject(anObject)) {\n            //const title = anObject.title ? anObject.title() : \"-\";\n            //this.debugLog(() => anObject.debugTypeId() + \".addMutationObserver(\" + this.debugTypeId() + \" '\" + title + \"')\")\n            anObject.addMutationObserver(this)\n            this.activeObjects().set(anObject.puuid(), anObject)\n            //this.addDirtyObject(anObject)\n        }\n\n        return true\n    }\n\n    close () {\n        this.removeMutationObservations()\n        this.setActiveObjects(new Map())\n        this.setDirtyObjects(new Map())\n        this.recordsMap().close()\n        return this\n    }\n\n    removeMutationObservations () {\n        this.activeObjects().forEachKV((puuid, obj) => obj.removeMutationObserver(this)) // activeObjects is super set of dirtyObjects\n        return this\n    }\n\n    hasDirtyObjects () {\n        return !this.dirtyObjects().isEmpty()\n    }\n\n    /*\n    hasDirtyObject (anObject) {\n        const puuid = anObject.puuid()\n        return this.dirtyObjects().has(puuid)\n    }\n    */\n\n    onObjectUpdatePid (anObject, oldPid, newPid) {\n        // sanity check for debugging - could remove later\n        if (this.hasActiveObject(anObject)) {\n            const msg = \"onObjectUpdatePid \" + anObject.typeId() + \" \" + oldPid + \" -> \" + newPid\n            console.log(msg)\n            throw new Error(msg)\n        }\n    }\n\n    onDidMutateObject (anObject) {\n        //if (anObject.hasDoneInit() && ) {\n        if (this.hasActiveObject(anObject) && !this.isLoadingObject(anObject)) {\n            this.addDirtyObject(anObject)\n        }\n    }\n\n    isStoringObject (anObject) {\n        const puuid = anObject.puuid()\n        if (this.storingPids()) {\n            if (this.storingPids().has(puuid)) {\n                return true\n            }\n        }\n        return false\n    }\n\n    isLoadingObject (anObject) { // private\n        if (this.loadingPids()) {\n            if (this.loadingPids().has(anObject.puuid())) {\n                return true\n            }\n        }\n        return false\n    }\n\n    addDirtyObject (anObject) { // private\n        if (!this.hasActiveObject(anObject)) {\n            console.log(\"looks like it hasn't been referenced yet\")\n            throw new Error(\"not referenced yet\")\n        }\n\n        const puuid = anObject.puuid()\n\n        if (this.isStoringObject(anObject)) {\n            return this\n        }\n\n        if (this.isLoadingObject(anObject)) {\n            return this\n        }\n\n        if (!this.dirtyObjects().has(puuid)) {\n            this.debugLog(() => \"addDirtyObject(\" + anObject.typeId() + \")\" )\n            if (this.storingPids() && this.storingPids().has(puuid)) {\n                throw new Error(\"attempt to double store? did object change after store? is there a loop?\")\n            }\n            this.dirtyObjects().set(puuid, anObject)\n            this.scheduleStore()\n        }\n\n        return this\n    }\n\n    scheduleStore () {\n        if (!this.isOpen()) {\n            console.log(this.typeId() + \" can't schedule store yet, not open\")\n            return this\n        }\n        assert(this.isOpen())\n        const scheduler = SyncScheduler.shared();\n        const methodName = \"commitStoreDirtyObjects\";\n        //console.log(this.type() + \" --- scheduleStore ---\")\n        if (!scheduler.isSyncingTargetAndMethod(this, methodName)) {\n            if (!scheduler.hasScheduledTargetAndMethod(this, methodName)) {\n                //console.warn(\"scheduleStore currentAction = \", SyncScheduler.currentAction() ? SyncScheduler.currentAction().description() : null);\n                this.debugLog(\"scheduling commitStoreDirtyObjects dirty object count:\" + this.dirtyObjects().size );\n                scheduler.scheduleTargetAndMethod(this, methodName, 1000);\n            }\n        }\n        return this\n    }\n\n    // --- storing ---\n\n    async commitStoreDirtyObjects () {\n        this.debugLog(\"commitStoreDirtyObjects dirty object count:\" + this.dirtyObjects().size);\n\n        if (this.hasDirtyObjects()) {\n            //console.log(this.type() + \" --- commitStoreDirtyObjects ---\")\n\n            //this.debugLog(\"--- commitStoreDirtyObjects begin ---\")\n            await this.recordsMap().promiseBegin()\n            const storeCount = this.storeDirtyObjects()\n            await this.recordsMap().promiseCommit()\n            this.debugLog(\"--- commitStoreDirtyObjects end --- stored \" + storeCount + \" objects\")\n            this.debugLog(\"--- commitStoreDirtyObjects total objects: \" + this.recordsMap().count())\n\n\n            //this.show(\"AFTER commitStoreDirtyObjects\")\n        }\n    }\n\n    storeDirtyObjects () { // PRIVATE\n        // store the dirty objects, if they contain references objects unknown to pool,\n        // they'll be added as active + dirty objects which will be stored on next loop. \n        // We continue until there are no dirty objects left.\n\n        let totalStoreCount = 0\n        this.setStoringPids(new Set())\n\n        while (true) { // easier to express clearly than do/while in this case\n            let thisLoopStoreCount = 0\n            const dirtyBucket = this.dirtyObjects();\n            this.setDirtyObjects(new Map());\n\n            dirtyBucket.forEachKV((puuid, obj) => {\n                //console.log(\"  storing pid \" + puuid)\n\n                if (this.storingPids().has(puuid)) {\n                    const msg = \"ERROR: attempt to double store \" + obj.typeId()\n                    console.log(msg)\n                    throw new Error(msg)\n                }\n\n                this.storingPids().add(puuid)\n                //debugger;\n                this.storeObject(obj)\n\n                thisLoopStoreCount ++\n            })\n\n            if (thisLoopStoreCount === 0) {\n                break\n            }\n\n            totalStoreCount += thisLoopStoreCount\n            //this.debugLog(() => \"totalStoreCount: \" + totalStoreCount)\n        }\n\n        this.setStoringPids(null)\n        return totalStoreCount\n    }\n\n    // --- reading ---\n\n    classNameConversionMap () {\n        const m = new Map()\n        /*\n        m.set(\"BMMenuNode\", \"BMFolderNode\")\n        */\n       return m;\n    }\n\n    classForName (className) { \n        const m = this.classNameConversionMap()\n        if (m.has(className)) {\n            return Object.getClassNamed(m.get(className))\n        } \n\n        return Object.getClassNamed(className)\n    }\n\n    objectForRecord (aRecord) { // private\n        const className = aRecord.type\n        //console.log(\"loading \" + className + \" \" + aRecord.id)\n        if (className === \"Promise\") {\n            console.warn(this.type() + \" WARNING: a Promise was stored. Returning a null. Check stack trace to see which object stored it.\")\n            debugger\n            return null\n        }\n\n        const aClass = this.classForName(className)\n\n        if (!aClass) {\n            const error = \"missing class '\" + className + \"'\"\n            console.warn(error)\n            //throw new Error(error)\n            debugger\n            return null\n        }\n        assert(!Type.isNullOrUndefined(aRecord.id))\n\n        if (Type.isUndefined(aClass.instanceFromRecordInStore)) {\n            console.warn(\"Class '\" + className + \"' missing method 'instanceFromRecordInStore' - deserializing as null\");\n            debugger;\n            return null;\n        }\n        const obj = aClass.instanceFromRecordInStore(aRecord, this);\n        if (obj === null) {\n            // maybe the class shouldStore is false?\n            return null;\n        }\n\n        assert(!this.hasActiveObject(obj))\n        obj.setPuuid(aRecord.id)\n        this.addActiveObject(obj)\n        if (obj.puuid() === this.rootPid()) {\n            this._rootObject = obj; // bit of a hack to make sure root ref is set before we load root contents\n            // might want to split this method into one to get ref and another to load contents instead\n        }\n        obj.loadFromRecord(aRecord, this)\n\n        this.loadingPids().delete(obj.puuid()) // need to do this to get object to ber marked as dirty if it's slots are updated in finalInit\n\n        if (obj.finalInit) {\n            obj.finalInit();\n        }\n        \n        if (obj.afterInit) {\n            obj.afterInit();\n        }\n        return obj\n    }\n\n    activeObjectForPid (puuid) {\n        return this.activeObjects().get(puuid);\n    }\n\n    objectForPid (puuid) { // PRIVATE (except also used by StoreRef)\n        //console.log(\"objectForPid \" + puuid)\n\n        // return active object for pid, if there is one\n        const activeObj = this.activeObjectForPid(puuid);\n        if (activeObj) {\n            return activeObj;\n        }\n\n        // schedule didInitLoadingPids to occur at end of event loop \n\n        if (!this.isFinalizing() && this.loadingPids().count() === 0) {\n            SyncScheduler.shared().scheduleTargetAndMethod(this, \"didInitLoadingPids\");\n        }\n\n        this.loadingPids().add(puuid);\n        /*\n        if (puuid === \"ISkYj2Vrxc\") {\n            debugger;\n        }\n        */\n        \n        const aRecord = this.recordForPid(puuid);\n        if (Type.isUndefined(aRecord)) {\n            console.log(\"missing record for \" + puuid);\n            return undefined;\n        }\n        if (aRecord.type === \"PersistentObjectPool\") {\n            console.log(\"skipping PersistentObjectPool record for \" + puuid);\n            return null;\n        }\n        const loadedObj = this.objectForRecord(aRecord);\n        return loadedObj;\n    }\n\n    didInitLoadingPids () {\n        assert(!this.isFinalizing()); // sanity check\n        this.setIsFinalizing(true);\n        while (!this.loadingPids().isEmpty()) { // while there are still loading pids\n            const lastSet = this.loadingPids();\n            this.setLoadingPids(new Set());\n\n            lastSet.forEach(loadedPid => { // sends didLoadFromStore to each matching object\n                const obj = this.activeObjectForPid(loadedPid);\n                if (Type.isUndefined(obj)) {\n                    const errorMsg = \"missing activeObjectForPid \" + loadedPid;\n                    console.warn(errorMsg);\n                    //throw new Error(errorMsg)\n                } else if (obj.didLoadFromStore) {\n                    obj.didLoadFromStore(); // should this be able to trigger an objectForPid() that would add to loadingPids?\n                }\n            })\n        }\n        this.setIsFinalizing(false);\n    }\n\n    //\n\n    headerKey () {\n        return \"header\"; // no other key looks like this as they all use PUUID format\n    }\n\n    allPidsSet () {\n        const keySet = this.recordsMap().keysSet();\n        keySet.delete(this.headerKey());\n        return keySet;\n    }\n\n    allPids () {\n        const keys = this.recordsMap().keysArray();\n        keys.remove(this.rootKey());\n        return keys;\n    }\n\n    activeLazyPids () { // returns a set of pids\n        const pids = new Set();\n        this.activeObjects().forEachKV((pid, obj) => {\n            if (obj.lazyPids) {\n                obj.lazyPids(pids);\n            }\n        })\n        return pids;\n    }\n\n    // --- references ---\n\n    refForPid (aPid) {\n        return { \"*\": this.pid() };\n    }\n\n    pidForRef (aRef) {\n        return aRef.getOwnProperty(\"*\");\n    }\n\n    unrefValueIfNeeded (v) {\n        return this.unrefValue(v);\n    }\n\n    unrefValue (v) {\n        if (Type.isLiteral(v)) {\n            return v;\n        }\n        const puuid = v.getOwnProperty(\"*\");\n        assert(puuid);\n        const obj = this.objectForPid(puuid);\n        return obj;\n    }\n\n    refValue (v) {\n        assert(!Type.isPromise(v));\n\n        if (Type.isLiteral(v)) {\n            return v;\n        }\n\n        assert(!v.isClass());\n\n        if (!v.shouldStore()) {\n            console.log(\"WARNING: called refValue on \" + v.type() + \" which has shouldStore=false\");\n         //   debugger;\n            return null;\n        }\n\n        if (!this.hasActiveObject(v)) {\n            this.addActiveObject(v);\n            this.addDirtyObject(v);\n        }\n        const ref = { \"*\": v.puuid() };\n        return ref;\n    }\n\n    // read a record\n\n    recordForPid (puuid) { // private\n        if (!this.recordsMap().hasKey(puuid)) {\n            return undefined;\n        }\n        const jsonString = this.recordsMap().at(puuid);\n        assert(Type.isString(jsonString));\n        const aRecord = JSON.parse(jsonString);\n        aRecord.id = puuid;\n        return aRecord;\n    }\n\n    // write an object\n\n    async kvPromiseForObject (obj) {\n        const record = await obj.asyncRecordForStore(this);\n        const jsonString = JSON.stringify(record);\n        return [obj.puuid(), jsonString];\n    }\n\n    storeObject (obj) {\n        //assert(obj.shouldStore())\n        const puuid = obj.puuid()\n        assert(!Type.isNullOrUndefined(puuid))\n\n        if (obj === this.rootObject()) {\n            this.setRootPid(puuid)\n        }\n\n        if (obj.asyncRecordForStore) {\n            // asyncRecordForStore is only implemented if there's no \n            // synchronous option for serialization e.g. serializing a Blob\n            //throw new Error(\"no support for asyncRecordForStore yet!\")\n            const kvPromise = this.kvPromiseForObject(obj)\n            this.recordsMap().asyncQueueSetKvPromise(kvPromise)\n        } else {\n            const record = obj.recordForStore(this)\n            const jsonString = JSON.stringify(record)\n            this.debugLog(() => \"store \" + puuid + \" <- \" + record.type )\n            this.recordsMap().set(puuid, jsonString)\n            //this.storeRecord(puuid, record)\n        }\n        return this\n    }\n\n    /*\n    storeRecord (puuid, record) {\n        const jsonString = JSON.stringify(record)\n        this.debugLog(() => \"store \" + puuid + \" <- \" + record.type )\n        this.recordsMap().set(puuid, jsonString)\n        return this\n    }\n    */\n\n    // -------------------------------------\n\n    flushIfNeeded () {\n        if (this.hasDirtyObjects()) {\n            this.storeDirtyObjects()\n            assert(!this.hasDirtyObjects())\n        }\n        return this\n    }\n\n    async promiseCollect () {\n        //debugger;\n        if (Type.isUndefined(this.rootPid())) {\n            console.log(\"---- NO ROOT PID FOR COLLECT - clearing! ----\");\n            await this.recordsMap().promiseBegin();\n            this.recordsMap().clear();\n            await this.recordsMap().promiseCommit();\n            return 0;\n        }\n\n        // this is an on-disk collection\n        // in-memory objects aren't considered\n        // so we make sure they're flushed to the db first \n        await this.recordsMap().promiseBegin();\n        this.flushIfNeeded(); // store any dirty objects\n\n        this.debugLog(() => \"--- begin collect --- with \" + this.recordsMap().count() + \" pids\");\n        this.setMarkedSet(new Set());\n        this.markedSet().add(this.rootKey()); // so rootKey->rootPid entry isn't swept\n        this.markPid(this.rootPid());\n        this.activeObjects().forEachK(pid => this.markPid(pid));\n        this.activeLazyPids().forEachK(pid => this.markPid(pid));\n        const deleteCount = this.sweep();\n        this.setMarkedSet(null);\n\n        this.debugLog(() => \"--- end collect --- collecting \" + deleteCount + \" pids ---\");\n       // debugger\n        await this.recordsMap().promiseCommit();\n\n        const remainingCount = this.recordsMap().count();\n        this.debugLog(() => \" ---- keys count after commit: \" + remainingCount + \" ---\");\n        return remainingCount;\n    }\n\n    markPid (pid) { // private\n        //this.debugLog(() => \"markPid(\" + pid + \")\")\n        if (!this.markedSet().has(pid)) {\n            this.markedSet().add(pid)\n            const refPids = this.refSetForPuuid(pid)\n        //    debugger\n            //this.debugLog(() => \"markPid \" + pid + \" w refs \" + JSON.stringify(refPids.asArray()))\n            refPids.forEach(refPid => this.markPid(refPid))\n            return true\n        }\n        return false\n    }\n\n    refSetForPuuid (puuid) {\n        const record = this.recordForPid(puuid)\n        const puuids = new Set()\n\n        if (record) {\n            Object.keys(record).forEach(k => this.puuidsSetFromJson(record[k], puuids))\n        }\n\n        return puuids\n    }\n\n    puuidsSetFromJson (json, puuids = new Set()) {\n        // json can only contain array's, dictionaries, and literals.\n        // We store dictionaries as an array of entries, \n        // and reserve dicts in the json for pointers with the format { \"*\": \"<puuid>\" }\n\n        //console.log(\" json: \", JSON.stringify(json, null, 2))\n\n        if (Type.isLiteral(json)) {\n            // we could call refsPidsForJsonStore but none will add any pids,\n            // and null raises exception, so we can just skip it for now\n        } else if (Type.isObject(json) && json.refsPidsForJsonStore) {\n            json.refsPidsForJsonStore(puuids)\n        } else {\n            throw new Error(\"unable to handle json type: \" + typeof(json) + \" missing refsPidsForJsonStore() method?\")\n        }\n        \n        return puuids\n    }\n\n    // ------------------------\n\n    sweep () {\n        const unmarkedPidSet = this.allPidsSet().difference(this.markedSet()) // allPids doesn't contain rootKey\n\n        // delete all unmarked records\n        let deleteCount = 0\n        const recordsMap = this.recordsMap()\n        recordsMap.keysArray().forEach(pid => {\n            if (!this.markedSet().has(pid)) {\n                //this.debugLog(\"--- sweeping --- deletePid(\" + pid + \") \" + JSON.stringify(recordsMap.at(pid)))\n                this.debugLog(() => \"--- sweeping --- deletePid(\" + pid + \") \")\n                const count = recordsMap.count()\n                recordsMap.removeKey(pid)\n                assert(recordsMap.count() === count - 1)\n                deleteCount ++\n            }\n        })\n        return deleteCount\n    }\n\n    async promiseDeleteAll () {\n        await this.promiseOpen();\n        assert(this.isOpen());\n        // assert not loading or storing?\n        const map = this.recordsMap()\n        await map.promiseBegin()\n        map.forEachK(pid => {\n            map.removeKey(pid)\n        }) // the remove applies to the changeSet\n        await map.promiseCommit()\n    }\n\n    promiseClear () {\n        return this.recordsMap().promiseClear();\n    }\n\n    // ---------------------------\n\n    rootSubnodeWithTitleForProto (aTitle, aProto) {\n        return this.rootObject().subnodeWithTitleIfAbsentInsertProto(aTitle, aProto);\n    }\n\n    count () {\n        return this.recordsMap().count();\n    }\n\n    totalBytes () {\n        return this.recordsMap().totalBytes();\n    }\n\n    // ---------------------------\n\n    /*\n    activeObjectsReferencingObject (anObject) {\n        // useful for seeing if we can unload an object\n        // BUT, to do full collect, do a mark/sweep on active objects\n        // where sweep only removes unmarked from activeObjects and records cache?\n\n        assert(this.hasActiveObject(anObject)) \n\n        const referencers = new Set()\n        const pid = anObject.puuid()\n\n        this.activeObjects().forEachKV((pid, obj) => {\n            const refPids = this.refSetForPuuid(obj.puuid())\n            if (refPids.has(pid)) {\n                referencers.add(obj)\n            }\n        })\n\n        return referencers\n    }\n    */\n\n    /*\n    static selfTestRoot () {\n        const aTypedArray = Float64Array.from([1.2, 3.4, 4.5])\n        const aSet = new Set(\"sv1\", \"sv2\")\n        const aMap = new Map([ [\"mk1\", \"mv1\"], [\"mk2\", \"mv2\"] ])\n        const aNode = BMStorableNode.clone()\n        const a = [1, 2, [3, null], { foo: \"bar\", b: true }, aSet, aMap, new Date(), aTypedArray, aNode]\n        return a\n    }\n\n    static selfTest () {\n        console.log(this.type() + \" --- self test start --- \")\n        const store = ObjectPool.clone()\n        store.open()\n\n        store.rootOrIfAbsentFromClosure(() => BMStorableNode.clone())\n        store.flushIfNeeded()\n        console.log(\"store:\", store.asJson())\n        console.log(\" --- \")\n        store.promiseCollect()\n        store.clearCache()\n        const loadedNode = store.rootObject()\n        console.log(\"loadedNode = \", loadedNode)\n        console.log(this.type() + \" --- self test end --- \")\n    }\n    */\n\n}.initThisClass());\n\n\n\n",
  "8gwjOv+lMtDR1S0YrTytL1uMtzpWhGHX+Z9O3vBfhxk=": "\"use strict\";\n\n/*\n\n    PersistentObjectPool\n\n        An ObjectPool that uses a PersistentAtomicMap\n        to store it's records.\n\n*/\n\n(class PersistentObjectPool extends ObjectPool {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n\n    static sharedPool () {\n        return this.shared();\n    }\n\n    init () {\n        super.init();\n        this.setName(\"defaultDataStore\");\n        this.setRecordsMap(PersistentAtomicMap.clone());\n        //this.setIsDebugging(false);\n        return this;\n    }\n\n    open () {\n        throw new Error(this.type() + \" synchronous open not available - use promiseOpen()\");\n    }\n\n    async promiseSelfTest () {\n        console.log(this.type() + \" --- self test start --- \");\n        const store = this.thisClass().clone();\n        await store.promiseOpen();\n        this.selfTestOnStore(store);\n    }\n\n    selfTestOnStore (store) {\n        store.rootOrIfAbsentFromClosure(() => BMStorableNode.clone())\n        //store.flushIfNeeded()\n        console.log(\"store:\", store.asJson())\n        console.log(\" --- \")\n        store.collect()\n        store.clearCache()\n        const loadedNode = store.rootObject()\n        console.log(\"loadedNode = \", loadedNode)\n        console.log(this.type() + \" --- self test end --- \")\n    }\n\n    static async promiseSelfTest () {\n        this.addTimeout(() => { \n            return PersistentObjectPool.promiseSelfTest() \n        }, 1000);\n    }\n    \n}.initThisClass());\n\n\n\n",
  "Ou6mRkgr7WVGZqQ8s6z0SaWDFHNpxFtt536d5ylkgkE=": "\"use strict\";\n\n/*\n\n    StoreRef\n\n*/\n\n\n(class StoreRef extends Object {\n\n    init () {\n        super.init()\n        Object.defineSlot(this, \"_store\", null) // move to initPrototype?\n    }\n\n    setPid (aPid) {\n        this[\"*\"] = aPid\n        return this\n    }\n\n    pid () {\n        return this.getOwnProperty(\"*\")\n    }\n\n    setStore (aStore) {\n        this._store = aStore\n        return this\n    }\n\n    store () {\n        return this._store\n    }\n\n    unref () {\n        return this.store().objectForPid(this.pid())\n    }\n\n    ref () {\n        return this.store().refForPid(this.pid())\n    }\n    \n}.initThisClass());\n\n",
  "8ylDl9W0hvZLftRgyjTCkYVNT8U6KNowBXw2a3pJqiE=": "\"use strict\";\n\n/*\n\n    BMStorableNode \n\n    Thin subclass to:\n\n    - override some slots and mark them as shouldStore\n    - hook didUpdateSlot() to didMutate so ObjectPool (if observing mutations) gets told it needs to store the change\n    \n*/\n\n(class BMStorableNode extends StyledNode {\n\n    initPrototypeSlots () {\n        this.setShouldStore(true)\n        this.setShouldScheduleDidInit(true)\n        //this.setShouldStoreSubnodes(true)\n\n        {\n            const slot = this.overrideSlot(\"canDelete\", false)\n            slot.setShouldStoreSlot(true)  // defined in BMNode, but we want to store it\n        }\n\n        {\n            const slot = this.overrideSlot(\"title\", null)\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"subtitle\", \"\")\n            slot.setShouldStoreSlot(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"nodeFillsRemainingWidth\", false)\n            slot.setShouldStoreSlot(true)\n            slot.setCanEditInspection(true)\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.overrideSlot(\"subnodes\", null)\n            //subnodesSlot.setOwnsSetter(true)\n            slot.setShouldStoreSlot(true)\n            slot.setDoesHookGetter(true)\n            //slot.setHookedGetterIsOneShot(true)\n            //slot.setIsLazy(true) // no point in using this until we have coroutines?\n            slot.setInitProto(SubnodesArray)\n\n            assert(slot.doesHookGetter())\n        }\n        \n        /*\n        {\n            const slot = this.newSlot(\"lazySubnodeCount\", null)\n            slot.setShouldStoreSlot(false)\n        }\n        */\n    }\n\n    initPrototype () {\n    }\n\n    // --- udpates ---\n\t\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        super.didUpdateSlot(aSlot, oldValue, newValue)\n\n\t    if (!this.shouldStore() || !this.isInstance()) {\n\t        return this\n\t    }\n\t    \n        if (aSlot.shouldStoreSlot()) { \n            //this.didMutate(aSlot.name())\n            this.didMutate()\n        }\n        \n        // TODO: HACK, add a switch for this feature\n        // TODO: find a way to avoid this?\n        /*\n        if (newValue !== null && this._subnodes && this._subnodes.includes(oldValue)) { \n            newValue.setParentNode(this)\n            this.subnodes().replaceOccurancesOfWith(oldValue, newValue)\n            //this.debugLog(\" this.subnodes().replaceOccurancesOfWith(\", oldValue, \",\", newValue, \")\")\n        }\n        */\n    }\n\n    /*\n    didUpdateSlotSubnodes (oldValue, newValue) {\n        super.didUpdateSlotSubnodes(oldValue, newValue)\n        this.updateLazySubnodeCount()        \n        return this\n    }\n    */\n\n    /*\n    updateLazySubnodeCount () {\n        if (this._subnodes) {\n            this.setLazySubnodeCount(this.subnodes().length)\n        }\n    }\n    */\n\n    didChangeSubnodeList () {\n        super.didChangeSubnodeList()\n        //this.updateLazySubnodeCount()\n        return this\n    }\n\n    // subnodes\n    \n    subnodeCount () {\n        if (!this._subnodes) {\n            return this.lazySubnodeCount()\n        }\n        return this._subnodes.length\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        return this\n    }\n\n}.initThisClass());\n",
  "xdXT8C9C/N9pxS7svBUEcBx8ND3XcWbIHUD8kcHyq/k=": "\"use strict\";\n\n/*\n\n    BMDataStore\n\n    A visible representation of the storage system\n    \n*/\n\n(class BMDataStore extends BaseNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"lastSyncTime\", 0);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Storage\")\n    }\n\n    subtitle () {\n        return this.defaultStore().totalBytes().byteSizeDescription()\n    }\n\n    storeHasChanged () {\n        return this.defaultStore().lastSyncTime() !== this.lastSyncTime()\n    }\n\n    prepareToSyncToView () {\n        //console.log(\"this.storeHasChanged() = \", this.storeHasChanged())\n\n        if (this.subnodeCount() === 0 || this.storeHasChanged()) {\n            this.defaultStore().collect()\n            this.setLastSyncTime(this.defaultStore().lastSyncTime())\n            this.refreshSubnodes()\n        }\n    }\n\n    store () {\n        return this.defaultStore()\n    }\n\n    refreshSubnodes () {\n        //this.debugLog(\" refreshSubnodes\")\n        this.removeAllSubnodes()\n        this.store().allPids().forEach((pid) => {\n            const aRecord = this.store().recordForPid(pid)\n            this.addRecord(aRecord)\n        })\n    }\n\n    subnodeForClassName (aClassName) {\n        let subnode = this.firstSubnodeWithTitle(aClassName)\n        if (!subnode) {\n            subnode = BaseNode.clone().setTitle(aClassName).setNoteIsSubnodeCount(true)\n            this.justAddSubnode(subnode)\n        }\n        return subnode\n    }\n\n    addRecord (aRecord) {\n        const subnode = BMDataStoreRecord.clone()\n        //subnode.setTitle(aRecord.type + \" \" + aRecord.id)\n        subnode.setTitle(aRecord.id)\n        subnode.setKey(aRecord.id)\n        subnode.setStore(this.store())\n        const size = JSON.stableStringify(aRecord).length\n        subnode.setSubtitle(size.byteSizeDescription())\n\n        const classNode = this.subnodeForClassName(aRecord.type)\n        classNode.justAddSubnode(subnode)\n\n        return this\n    }\n    \n}.initThisClass());\n",
  "P+9Iu+TvFQH3+UoQOsHmlsD+XrJsQA0paLU/P6Fbnt8=": "\"use strict\";\n\n/*\n    \n    BMSummaryNode\n    \n    A node that contains Text, stores it's:\n    - content\n    - color\n    - font\n    - padding\n    - margin\n    and has an inspector for these attributes\n    \n    support for links?\n\n*/\n\n(class BMSummaryNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"nodeSummarySuffix\", \" \");\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"String\");\n            slot.setLabel(\"suffix\");\n            slot.setInspectorPath(\"Node/Summary\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"nodeSubtitleIsChildrenSummary\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"is children summary\");\n            slot.setInspectorPath(\"Node/Summary/Subtitle\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"hasNewlineBeforeSummary\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"begins with new line\");\n            slot.setInspectorPath(\"Node/Summary\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"hasNewlineAfterSummary\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"ends with new line\");\n            slot.setInspectorPath(\"Node/Summary\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"hasNewLineSeparator\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"new line separates key/value\");\n            slot.setInspectorPath(\"Node/Summary\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"summaryFormat\", \"value\");\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"String\");\n            slot.setLabel(\"format\");\n            slot.setValidValues([\"none\", \"key\", \"value\", \"key value\", \"value key\", \"key: value\"]);\n            slot.setSyncsToView(true);\n            slot.setInspectorPath(\"Node/Summary\");\n        }\n\n        {\n            const slot = this.newSlot(\"hidePolicy\", \"none\");\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"String\");\n            slot.setLabel(\"hide policy\");\n            slot.setValidValues([\"none\", \"hide if value is true\", \"hide if value is false\"]);\n            slot.setSyncsToView(true);\n            slot.setInspectorPath(\"Node/Summary\");\n        }\n\n        {\n            const slot = this.overrideSlot(\"subtitleIsSubnodeCount\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"is subnode count\");\n            slot.setInspectorPath(\"Node/Summary/Subtitle\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.overrideSlot(\"noteIsSubnodeCount\", false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setShouldStoreSlot(true);\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"is subnode count\");\n            slot.setInspectorPath(\"Node/Summary/Note\");\n            slot.setSyncsToView(true);\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(true);\n        this.setTitle(\"title\");\n    }\n\n    init () {\n        super.init();\n    }\n\n    didUpdateSlotSummaryFormat () {\n        this.didUpdateNodeIfInitialized();\n    }\n\n    summaryKey () {\n        return this.title();\n    }\n\n    summaryValue () {\n        return this.subtitle();\n    }\n\n    subtitle () {\n        if (this.nodeSubtitleIsChildrenSummary()) {\n            const s = this.childrenSummary();\n            if (Type.isString(s)) {\n                return s.indent(2);\n            }\n            return s;\n        }\n\n        return super.subtitle();\n    }\n\n    didUpdateSlotNodeSubtitleIsChildrenSummary (oldValue, newValue) {\n        if (oldValue === true) {\n            this.setSubtitle(null);\n        }\n    }\n\n    // --- summary ---\n    \t\t\n    summary () {\n        const k = this.summaryKey();\n        let v = this.summaryValue();\n\n        const hidePolicy = this.hidePolicy();\n        if (hidePolicy !== \"none\") {\n            const isTrue = (v === true || (typeof(v) === \"string\" && v !== \"\"));\n            const isFalse = (v === false || (typeof(v) === \"string\" && v === \"\") || v === null);\n            if (isTrue && hidePolicy === \"hide if value is true\") {\n                return \"\";\n            } else if (isFalse && hidePolicy === \"hide if value is false\") {\n                return \"\";\n            }\n        }\n\n        if (Type.isNull(v)) {\n            v = \"\";\n        }\n\n        // make this optional? \n        /*\n        if (v === \"\") {\n            return \"\";\n        }\n        */\n\n        const f = this.summaryFormat();\n        let end = this.nodeSummarySuffixOut();\n        const begin = this.hasNewlineBeforeSummary() ? \"\\n\" : \"\";\n\n        if (this.hasNewlineAfterSummary()) {\n            //end = \"<br>\";\n            end = \"\\n\";\n        }\n\n        if (f === \"key\") { \n            if (!k) {\n                return \"\";\n            }\n            return begin + k + end;\n        }\n\n        if (v === \"ally\") {\n            debugger;\n        }\n    \n        if (f === \"value\") {\n            if (!v) {\n                return \"\";\n            }\n            return begin + v + end;\n        }\n\n        const kvSeparator = this.hasNewLineSeparator() ? \"\\n\" : \" \";\n\n        if (f === \"key value\") { \n            if (!k) {\n                return \"\";\n            }\n            return begin + k + kvSeparator + v + end;\n        }\n\n        if (f === \"key: value\") { \n            if (!k) {\n                return \"\";\n            }\n            return begin + k + \":\" + kvSeparator + v + end;\n        }\n\n        if (f === \"value key\") {\n            if (!v) {\n                return \"\";\n            }\n            return begin + v + kvSeparator + k + end;\n        }\n\n        return \"\";\n    }\n        \n    childrenSummary () {\n        return this.subnodes().map(subnode => subnode.summary()).filter(s => s.length).join(\"\");\n    }\n\n    nodeSummarySuffixOut () {\n        let s = this._nodeSummarySuffix;\n        \n        if (s === \"newline\") {\n            return \"<br>\";\n        } else {\n            s = s.replaceAll(\"<br>\", \"\");\n        }\n        \n        return s;\n    }\n\n    didUpdateNode () {\n        super.didUpdateNode();\n    \n        // TODO: FIX HACK, how can we generalize this without creating unnecessary update notifications?\n\n        /*\n        this.parentChainNodes().forEach(node => {\n            //node.didUpdateNode();\n            //node.scheduleMethod(\"didUpdateNode\");\n        })\n        */\n    }\n    \n}.initThisClass());\n\n",
  "lwWc1dG4neyTMBJc0WBB6e2ekRZtors9IXVN5cmuIK4=": "\"use strict\";\n\n/**\n * BMFolderNode\n * \n * A node that supports adding, reordering, and managing other nodes within the UI.\n * Extends BMSummaryNode.\n */\n\n(class BMFolderNode extends BMSummaryNode {\n    \n    /**\n     * Indicates if this node is available as a node primitive.\n     * @returns {boolean} True if available as a node primitive.\n     */\n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    /**\n     * Initializes the prototype slots for the BMFolderNode.\n     * These slots are useful for implementing menus.\n     */\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"label\", \"\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"target\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"methodName\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"info\", null);\n            slot.setSlotType(\"Object\");\n        }\n    }\n\n    /**\n     * Initializes the prototype with default settings.\n     */\n    initPrototype () {\n        this.setCanDelete(true);\n        this.setNodeCanInspect(true);\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(true);\n        this.setTitle(\"title\");\n        this.setNodeCanEditTitle(true);\n        \n        this.setNodeCanReorderSubnodes(true);\n        this.setNodeCanInspect(true);\n        //this.setNoteIconName(\"right-arrow\");\n    }\n\n    /**\n     * Initializes the BMFolderNode instance.\n     */\n    init () {\n        super.init()\n        this.setNodeCanAddSubnode(true)\n        this.setSubnodeClasses(BMNode.primitiveNodeClasses())\n    }\n\n    /**\n     * Gets the title of the node.\n     * @returns {string} The label of the node.\n     */\n    title () {\n        return this.label()\n    }\n\n    /**\n     * Sets the title of the node.\n     * @param {string} aString - The new title to set.\n     * @returns {BMFolderNode} The current instance for method chaining.\n     */\n    setTitle (aString) {\n        this.setLabel(aString)\n        return this\n    }\n\n    /**\n     * Gets the accepted subnode types.\n     * @returns {Array} An array of accepted field types from BMCreatorNode.\n     */\n    acceptedSubnodeTypes () {\n        return BMCreatorNode.fieldTypes()\n    }\n\n    /**\n     * Sends the menu action to the target.\n     */\n    sendMenuAction () {\n       const t = this.target()\n       const m = this.methodName()\n       if (t && m && t[m]) {\n           t[m].apply(t, [this])\n       }\n    }\n\n    /**\n     * Handles the tap event on the node.\n     * @param {BMNode} aNode - The node that was tapped.\n     * @returns {BMFolderNode} The current instance for method chaining.\n     */\n    onTapOfNode (aNode) {\n        super.onTapOfNode()\n        this.sendMenuAction()\n        return this\n    }\n\n    /**\n     * Callback for when the parentNode slot is updated.\n     * @param {*} oldValue - The old value of the parentNode.\n     * @param {*} newValue - The new value of the parentNode.\n     */\n    didUpdateSlotParentNode (oldValue, newValue) {\n        this.scheduleSyncToView()\n    }\n}.initThisClass());",
  "5N369bJSzzkyng/g/PtPg6PxOqj6zoCwYb0U71z1eUA=": "\"use strict\";\n\n/*\n\n    BMImageNode\n    \n*/\n\n(class BMImageNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"dataURL\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    initPrototype () {\n        this.setNodeCanEditTitle(true);\n        this.setNodeCanEditSubtitle(false);\n        this.setTitle(\"Untitled\");\n        this.setSubtitle(null);\n        this.setCanDelete(true);\n        this.setNodeCanAddSubnode(true);\n    }\n\n    \n    onDidEditNode () {\n        this.debugLog(\" onDidEditNode\")\n    }\n\n    jsonArchive () {\n        debugger;\n        return undefined;\n    }\n    \n}.initThisClass());\n",
  "tG4HR9GszphoFX4FsD5axGNVieNADOgnSd5Unjvf4lQ=": "\"use strict\";\n\n/*\n    \n    BMTextNode\n    \n    A node that contains Text, stores it's:\n        content, color, font, padding, margin\n    and has an inspector for these attributes\n    \n*/\n\n(class BMTextNode extends BMStorableNode {\n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"nodeUrlLink\", \"\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"URL\")\n            //slot.setSyncsToView(true)\n            //slot.setInspectorPath(\"Style\")\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"value\", \"...\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setSlotType(\"String\")\n            slot.setLabel(\"value\")\n            slot.setSyncsToView(true)\n            //slot.setInspectorPath(\"Style\")\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n\n        this.setTitle(\"title\")\n        this.setNodeCanEditTitle(true)\n        \n        this.setNodeCanReorderSubnodes(true)\n  \n        this.setNodeCanEditTileHeight(true)\n        this.setNodeCanEditColumnWidth(true)\n    }\n\n    acceptedSubnodeTypes () {\n        return [];\n    }\n\n}.initThisClass());\n\n",
  "c8X7QOPbUJyr++OZy71D1x/wUaOjmbNJPZS/CZQvJNU=": "\"use strict\";\n\n/*\n    \n    BMLinkNode\n    \n    A node that to represent a link to another node, which is not a subnode\n    \n*/\n\n(class BMLinkNode extends BMSummaryNode {\n    \n    static availableAsNodePrimitive () {\n        return true;\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"linkedNode\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"BMNode\");\n        }\n        \n        {\n            const slot = this.newSlot(\"willDuplicateLinkedObject\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"Will duplicate linked object\");\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n        this.setNodeCanEditTitle(true)\n\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true) \n    }\n\n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    /*\n    didUpdateSlotLinkedNode (oldValue, newValue) {\n        assert(Type.isNull(newValue) || Type.isObject(newValue));\n\n        if (Type.isObject(newValue)) {\n            const isNode = newValue.thisClass().isKindOf(BMNode);\n            assert(isNode);\n        }\n\n        debugger;\n        return this\n    }\n    */\n\n    nodeAcceptsDrop (aNode) {\n        return true\n    }\n\n    nodeDropped (aNode) {\n        this.setLinkedNode(aNode)\n    }\n\n    duplicate () {\n        const obj = super.duplicate()\n        if (this.willDuplicateLinkedObject()) {\n            const ln = this.linkedNode()\n            if (ln) {\n                obj.setLinkedNode(ln.duplicate())\n            }\n        }\n        return obj\n    }\n\n    title () {\n        const ln = this.linkedNode()\n        if (ln) {\n            return ln.title()\n        }\n        return \"Unlinked\"\n    }\n\n    /*\n    setTitle (s) {\n        const ln = this.linkedNode()\n        if (ln) {\n            return ln.setTitle(s)\n        }\n        return this   \n    }\n    */\n\n    subtitle () {\n        const ln = this.linkedNode()\n        if (ln) {\n            return ln.subtitle()\n        }\n        return \"drop tile to link\"    \n    }\n\n    /*\n    title () {\n        if (Type.isNull(super.title()) && this.linkedNode()) {\n            return this.linkedNode().title()\n        }\n\n        return super.title()\n    }\n    */\n\n    acceptedSubnodeTypes () { \n        // TODO: have browser use nodeTileLink for this protocol?\n        return []\n    }\n    \n    note () {\n        if (this.linkedNode()) {\n            return this.linkedNode().note()\n        }\n\n        return null\n    }\n\n    noteIconName () {\n        //return this.nodeTileLink() ? \"double right caret\" : null\n        return null\n    }\n\n    nodeTileLink () {\n        return this.linkedNode()\n    }\n\n    nodeCanReorderSubnodes () {\n        const ln = this.linkedNode()\n        return ln ? ln.nodeCanReorderSubnodes() : false // have this operation done in the browser?\n    }\n\n    addSubnodeAt (aSubnode, anIndex) {\n        return super.addSubnodeAt(aSubnode, anIndex)\n    }\n\n}.initThisClass());\n\n",
  "dvO1DCno8n1+Z2h/tXkE+DPeLoHn6xPihZet0rnsqVo=": "\"use strict\";\n\n/*\n\n    BMPrototypesNode\n \n \n\n*/\n\n(class BMPrototypesNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setTitle(\"Prototypes\");\n        this.setNodeCanReorderSubnodes(true);\n    }\n\n    init () {\n        super.init();\n\n        //this.setupSubnodes();\n        return this;\n    }\n\n    setupSubnodes () {\n        /*\n        let primitives = BMFolderNode.clone().setTitle(\"Primitives\")\n        primitives.setShouldStoreSubnodes(false)\n\n        this.addSubnode(primitives)\n\n        primitives.addSubnodes(this.primitiveSubnodes())\n        */\n        return this\n    }\n\n}.initThisClass());\n\n",
  "2KIgHWbzQXWIOcUnnO8TWEhX3tJX/Kw1BfR7Gu1mx8k=": "\"use strict\";\n\n/*\n\n    BMFieldSetNode\n\n    Useful for node's which are to be viewed and interacted with as forms\n    \n    child nodes are of type BMField and should only be added via addFieldNamed()\n    This method sets the target of the field to this and the method to the field name.\n                    \n    example use in subclass \n\n    in BMCustomFormNode class:\n    \n        init () {\n            super.init()\n\n            this.addFieldNamed(\"from\")\n            this.addFieldNamed(\"to\")\n            this.addFieldNamed(\"subject\")\n            this.addFieldNamed(\"body\").setNodeMinTileHeight(-1)\n\n            this.setActions([\"send\"])\n            this.setCanDelete(true)\n        }\n\n        ...\n\n*/  \n        \n(class BMFieldSetNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"status\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"isEditable\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStoreSubnodes(false)\n    }\n    \n    didUpdateField (aField) {\n        // override to implement hooks\n    }\n\t\n    // --- fields ---\n\n    addField (aField) {\n        aField.setTarget(this) \n        aField.getValueFromTarget()\n        this.addSubnode(aField)\n        return aField\n    }\n\n    addFieldNamed (name) {\t\n        const field = BMField.clone().setKey(name)\n        field.setTarget(this)\n        field.setValueMethod(name)\n        this.addStoredField(field)\n        return field\n    }\n    \n    fieldNamed (aName) {\n        return this.subnodes().detect(sn => { \n            return sn.valueMethod() === aName || sn.key() === aName\n        })\n    }\n    \n    /*\n    valueForFieldNamed (aName) {\n        return this.fieldNamed(aName).value()\n    }\n    */\n\n    // --- validation ---\n\n    validate () {\n        return this.invalidSubnodes().length === 0\n    }\n\n    invalidSubnodes () {\n        return this.subnodes().select(sn => !sn.validate())\n    }\n\n    isValid () {\n        return this.validate() // could cache this later...\n    }\n\n}.initThisClass());\n",
  "v0stfpvH0CIQXFxLccteefm67QbTL+ljy5tJhVZQNNE=": "\"use strict\";\n\n/*\n\n    BMField\n\n    A BMStorageNode that has a key, value, and valueMethod (among other properties),\n    that's useful for automatically constructing a UI to interact with properties of a parent Node.\n    \n*/\n        \n\n(class BMField extends BMSummaryNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"isEnabled\", true);\n            slot.setSyncsToView(true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n\n        // key\n        {\n            const slot = this.newSlot(\"key\", \"key\");\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"String\");\n            slot.setLabel(\"key\");\n            slot.setInspectorPath(\"Node/Field/Key\");\n        }\n\n        {\n            const slot = this.newSlot(\"keyIsVisible\", true);\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"visible\");\n            slot.setInspectorPath(\"Node/Field/Key\");\n        }\n\n        {\n            const slot = this.newSlot(\"keyIsEditable\", false);\n            slot.setCanInspect(true);\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"editable\");\n            slot.setInspectorPath(\"Node/Field/Key\");\n        }\n\n        // value\n        {\n            const slot = this.newSlot(\"value\", null);\n            slot.setCanInspect(true);\n            slot.setInspectorPath(\"Node/Field/Value\");\n            slot.setSlotType(\"Object\");\n            slot.setAllowsNullValue(true);\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            //slot.setSlotType(\"String\"); // might be boolean or number, so use overrideSlot() on field types\n        }\n\n        {\n            const slot = this.newSlot(\"valueIsVisible\", true);\n            slot.setInspectorPath(\"Node/Field/Value\");\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"visible\");\n        }\n\n        {\n            const slot = this.newSlot(\"valueIsEditable\", true);\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"editable\");\n            slot.setInspectorPath(\"Node/Field/Value\");\n        }\n\n        {\n            const slot = this.newSlot(\"valuePlaceholderText\", null);\n            slot.setCanInspect(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setInspectorPath(\"Node/Field/Value\");\n            slot.setLabel(\"placeholder text\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n        }\n\n\n        /*\n        {\n            const slot = this.newSlot(\"valueAllowsNull\", true);\n            slot.setShouldStoreSlot(true);\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setLabel(\"editable\");\n            slot.setInspectorPath(\"Node/Field/Value\");\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"valueCanHitEnter\", true);\n            slot.setSlotType(\"Boolean\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"link\", null);\n            slot.setSlotType(\"Object\");\n        }\n\n        {\n            const slot = this.newSlot(\"ownsLink\", null);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"valuePrefix\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n        }\n\n        {\n            const slot = this.newSlot(\"valuePostfix\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n        }\n\n        {\n            const slot = this.newSlot(\"valueMethod\", null);\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n            slot.setDuplicateOp(\"duplicate\");\n        }\n        \n        {\n            const slot = this.newSlot(\"noteMethod\", null);  // fetches note from a parent node method\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n        }\n        \n        {\n            const slot = this.newSlot(\"keyError\", null);\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n        }\n        \n        {\n            const slot = this.newSlot(\"valueError\", null);\n            slot.setSlotType(\"String\");\n            slot.setSyncsToView(true);\n        }\n        \n        {\n            const slot = this.newSlot(\"target\", null);\n            slot.setSlotType(\"BMNode\");\n            slot.setSyncsToView(true);\n        }\n\n        {\n            const slot = this.newSlot(\"didUpdateNodeObs\", null);\n            slot.setSlotType(\"BMObservation\");\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true);\n        this.setSummaryFormat(\"key value\");\n        this.setHasNewlineAfterSummary(true);\n    }\n\n    didLoadFromStore () { // move to finalInit?\n        super.didLoadFromStore()\n        this.validate()\n    }\n\n    static nodeCreate () {\n        const newNode = super.nodeCreate()\n\n        if (newNode.setKeyIsEditable) {\n            newNode.setKeyIsEditable(true)\n            newNode.setValueIsEditable(true)\n        }\n\n        if (newNode.setIsEditable) {\n            newNode.setIsEditable(true)\n        }\n\n        newNode.setNodeCanInspect(true)\n        newNode.setNodeCanEditTitle(true)\n        return newNode\n    }\n\n    title () {\n        return this.key()\n    }\n\n    /*\n    target () {\n        assert(!Type.isNull(this._target)) \n\n        if (this._target) {\n            return this._target\n        }\n\t\t\n        return this.parentNode() // we can't do this because we want to support free floating Fields\n    }\n    */\n\n    /*\n    setKey (newValue) {\n        this._key = newValue\n        return this\n    }\n    */\n\n    didUpdateSlotTarget (oldValue, newValue) {\n        if (oldValue) {\n            const obs = this.didUpdateNodeObs()\n            if (obs) {\n                obs.stopWatching()\n                this.setDidUpdateNodeObs(null)\n            }\n        }\n\n        if (newValue) {\n            //debugger;\n            this.setDidUpdateNodeObs(this.watchForNoteFrom(\"onUpdatedNode\", newValue));\n            //this.didUpdateNodeObs().setIsDebugging(true);\n            this.scheduleMethod(\"syncFromTarget\");\n        } \n    }\n\n    directDidUpdateNode () {\n        super.didUpdateNode()\n        return this\n    }\n\n    /*\n    didUpdateTargetNode (aNote) {\n        debugger;\n    }\n    */\n\n    onUpdatedNode (aNote) {\n        /*\n        if (this.target()) {\n            console.log(this.type() + \" for \" + this.target().type()  + \".\" + this.key() + \" onUpdatedNode(\" + aNote.sender().type() + \")\");\n        }\n\n        if (this.key() === \"Stength\") {\n            console.log(this.type() + \" onUpdatedNode (key is Stength)\");\n        }\n\n        if (this.key() === \"Bonuses\") {\n            console.log(this.type() + \" onUpdatedNode (key is Bonuses)\");\n        }\n\n        if (this.key() === \"Total\") {\n            console.log(this.type() + \" onUpdatedNode (key is Total)\");\n        }\n        */\n\n        assert(aNote);\n        // if it has a note, it was a post sent through notification center that the target node changed\n        const aNode = aNote.sender()\n        if (aNode === this.target()) {\n            // refresh\n            //debugger;\n            //console.log(this.type() + \" didUpdateNode \" + aNode.typeId())\n            this.syncFromTarget()\n        }\n    }\n\n    syncFromTarget () {\n        //this.value(); // triggers didUpdateNodeIfInitialized\n\n        // up to subclasses to implement\n        return this\n    }\n\n    didUpdateSlotValue (oldValue, newValue) {  // setValue() is called by View on edit\n        if (this.target() && this.valueMethod()) {\n            this.setValueOnTarget(newValue);\n        } else {\n            this.validate();\n        }\n\n        this.didUpdateNodeIfInitialized();\n    }\n\n    setValueOnTarget (v) { // called by View on edit\n        //console.log(\"setValue '\" + v + \"'\")\n        const target = this.target();\n        const setter = this.setterNameForSlot(this.valueMethod());\n\n        v = this.normalizeThisValue(v);\n        \n        if (target[setter]) {\n            target[setter].apply(target, [v]);\n\n            target.didUpdateNode(this.valueMethod()); // shouldn't this be done by the setter?\n            this.validate();\n        } else {\n            console.warn(this.type() + \" target \" + target.type() + \" missing slot '\" + setter + \"'\");\n            debugger;\n        }\n\t\t\n        return this;\n    }\n\t\n    normalizeThisValue (v) {\n\t    return v;\n    }\n\t\n    value () {\n        if (this.target()) {\n            const newValue = this.getValueFromTarget();\n            if (this._value !== newValue) {\n                this._value = newValue;\n                //this.didUpdateNodeIfInitialized(); // this can cause sync action loops\n            }\n        }\n        return this._value;\n    }\n\n    getValueFromTarget () {\n        const target = this.target();\n        const slotName = this.valueMethod();\n\n        //console.log(\"target = \" + target.type() + \" getter = '\" + getter + \"'\")\n        if (target[slotName]) {\n            const value = target[slotName].apply(target);\n            return value;\n        } else {\n            console.warn(this.type() + \" target \" + target.type() + \" missing slot '\" + slotName + \"'\");\n        }\n\n        return null;\n    }\n\t\n    note () {\n        const target = this.target();\n        const slotName = this.noteMethod();\n\n        if (target && slotName) {\n            if (target[slotName]) {\n                return target[slotName].apply(target);\n            } else {\n                console.warn(this.type() + \" target \" + target.type() + \" missing note getter slot '\" + slotName + \"'\");\n            }\n        }\n\n       // return null\n        return this._note\n    }\n\t\n    didUpdateView (aFieldView) {  \n        debugger;      \n        let parentNode = this.parentNode();\n        if (!parentNode) {\n            parentNode = this.target();\n        }\n\n        if (parentNode.didUpdateField) {\n            parentNode.didUpdateField(this); // what if it's down a path in an inspector?\n        }\n\n        if (this.target() && this.target().didUpdateField) {\n            this.target().didUpdateField(this); // what if it's down a path in an inspector?\n        }\n        \n        return this;\n    }\n\t\n    visibleValue () {\n        return this.value();\n    }\n\n    validate () {\n        // subclasses should override if needed\n        return true;\n    }\n\t\n    nodeTileLink () {\n        return null;\n    }\n\n    summary () {\n        if (!this.isVisible()) {\n            return \"\";\n        }\n        return super.summary();\n    }\n\n    summaryKey () {\n        return this.key();\n    }\n\n    summaryValue () {\n        return this.value();\n    }\n\n    setNodeSummaryShowsKey () {\n    }\n\n    setNodeSummaryShowsValue () {\n    }\n\n    jsonArchive () {\n        //console.log(this.typeId() + \".jsonArchive()\")\n        return super.jsonArchive();\n    }\n\n    // --- simplified JSON representation ---\n\n\n    setJson (json) {\n        this.setValue(json);\n        const didSet = (this.value() === json || (json === null && this.value() === \"\")); // sanity check\n        if (!didSet) {\n            if (this.target()) {\n                console.warn(\"Field unabled to set value using \" + this.target().typeId() + \"' '\" + this.key() + \"' setJson(\" + json + \") failed to set value\");\n            } else {\n                console.warn(\"Field '\" + this.key() + \"' setJson(\" + json + \") failed to set value\");\n            }\n            debugger;\n            this.setValue(json);\n            let v = this.value();\n            assert(v === json, \"failed to set value\");\n        }\n        assert(didSet);\n        return this;\n    }\n\n    asJson () {\n        // test used for Character sheet atm\n        // separate fron jsonArchive \n        return this.value();\n    }\n\n    /*\n    setJson (json) {\n        this.setKey(json.key);\n        this.setValue(json.value);\n        return this;\n    }\n\n    asJson () {\n        // test used for Character sheet atm\n        // separate fron jsonArchive \n        return {\n            key: this.key(),\n            value: this.value()\n        };\n    }\n    */\n\n    // ----------------\n    \n    setIsEditable (aBool) {\n        this.setValueIsEditable(false);\n        return this;\n    }\n    \n}.initThisClass());\n",
  "QcufYXQp2zIK/dAKHzhbCYfIHzNMzdts7gfEKDTRbUA=": "\"use strict\";\n\n/*\n\n    BMJsonCachedNode\n    \n\n*/\n        \n(class BMJsonCachedNode extends BMSummaryNode {\n\n    initPrototypeSlots () {\n\n        {\n            // a unique id for this json node\n            // we'll need this in order to merge json changes properly\n            const slot = this.newSlot(\"jsonId\", null);\n            slot.setIsInJsonSchema(true);\n            slot.setDescription(\"A unique id for this json node\");\n            slot.setSlotType(\"String\");\n            slot.setShouldStoreSlot(true);\n            slot.setCanInspect(true);\n            slot.setSyncsToView(true);\n            slot.setShouldJsonArchive(true);\n        }\n\n        {\n            // the json that this node represents\n            // we update this when the node is edited\n            // the node is the truth and the json is derived from it\n            const slot = this.newSlot(\"jsonCache\", null);\n            slot.setSlotType(\"JSON Object\");\n        }\n\n        {\n            // a hash of JSON.stableStrigify(jsonCache)\n            const slot = this.newSlot(\"jsonHash\", null);\n            slot.setSlotType(\"String\");\n        }\n\n    }\n\n    initPrototype () {\n\n    }\n\n    finalInit () {\n        super.finalInit();\n        this.createJsonIdIfAbsent();\n    }\n\n    // --- json id ---\n\n    createJsonIdIfAbsent () {\n        if (this.jsonId() === null) {\n            this.createJsonId();\n        }\n        return this;\n    }\n\n    \n    createJsonId () {\n        assert(this.jsonId() === null);\n        this.setJsonId(Object.newUuid());\n        return this;\n    }\n\n    // --- json cache ---\n\n    updateJsonHash () {\n        this.setJsonHash(JSON.stableStringify(this.asJson()).hashCode());\n        return this;\n    }\n\n    setJsonCache (json) {\n        this._jsonCache = json;\n        if (json === null) {\n            this.setJsonHash(null);\n        } else {\n            this.setJsonHash(JSON.stableStringify(json).hashCode());\n        }\n        return this;\n    }\n\n    removeJsonCaches () {\n        this.setJsonHash(null); \n        this.setJsonCache(null);  \n        return this;\n    }\n\n    didUpdateNode () {\n        super.didUpdateNode();\n        this.removeJsonCaches(); \n    }\n\n    doesMatchJson (json) {\n        const a = JSON.stableStringify(json); \n        if (this.jsonHash()) {\n            return this.jsonHash() === a.hashCode();\n        }\n        const b = JSON.stableStringify(this.asJson());\n        return a === b;\n    }\n\n    asJson () {\n        if (this.jsonCache() !== null) {\n            return this.jsonCache();\n        }\n        const json = this.calcJson();\n        this.setJsonCache(json);\n        return json;\n    }\n\n  // --- JSON patches ---\n\n    computeJsonPatches () {\n        // patch format sample: [{ op: \"replace\", path: \"/lastName\", value: \"Smith\" }]\n        const lastJson = this.lastJson() ? this.lastJson() : {};\n        const currentJson = this.asJson();\n        const patch = JsonPatch.compare(obj, updatedObj);\n        this.setLastJson(currentJson);\n        return patch;\n    }\n\n    applyJsonPatches (jsonPatches) {\n        assert(Type.isDeepJsonType(jsonPatches));\n        const oldJson = this.asJson().deepCopy();\n\n        // if root node is replaced, json needs to update\n        const results = JsonPatch.applyPatchWithAutoCreation(oldJson, jsonPatches); // GPT sometimes forgets to define paths, so we do this to help it\n        assert(results.newDocument, \"Character.applyJsonPatches() results.newDocument missing\");\n        \n        const newJson = results.newDocument;\n        assert(Type.isUndefined(newJson.newDocument), \"Character.applyJsonPatches() json.newDocument should not have newDocument\");\n\n        if (jsonPatches.length === 0) {\n            console.log(\"no patches to apply\");\n            debugger;\n            return this;\n        }\n\n        /*\n        // verify patch add paths exist\n        jsonPatches.forEach(patch => {\n            const path = patch.path;\n            if (patch.op === \"add\" && !this.jsonHasPath(newJson, path)) {\n                const errorMessage = this.type() + \" applyJsonPatches( ) missing patched path: \" + path;\n                console.warn(errorMessage);\n\n                // let's try it again so we can step through with the debugger\n                //debugger\n                JsonPatch.applyPatchWithAutoCreation(newJson, [patch]);\n            }\n        });\n        */\n\n        /*\n        const newJsonString = JSON.stableStringify(newJson);\n        const oldJsonString = JSON.stableStringify(this.asJson());\n        if (newJsonString === oldJsonString) {\n            console.log(\"Character.applyJsonPatches() json applied correctly\");\n            debugger;\n            return this; \n        } else {\n            const delta = jsondiffpatch.diff(json, this.asJson());\n            console.log(\"ERROR: asJson doesn't match json! Here's the delta: \", delta);\n        }\n        */\n        // apply new json\n        this.setJson(newJson);\n        assert(JSON.stableStringify(newJson) === JSON.stableStringify(this.asJson()), \"Character.applyJsonPatches() setJson() did not apply correctly\");\n        this.setLastJson(newJson);\n        return this;\n    }\n\n    jsonHasPath (obj, path) { // helper method to find if a path exists in a json object\n        const properties = path.split('/').slice(1); // Removing the leading slash\n        let currentObj = obj;\n\n        for (let i = 0; i < properties.length; i++) {\n            const prop = properties[i];\n\n            if (currentObj.hasOwnProperty(prop)) {\n                currentObj = currentObj[prop];\n            } else {\n                //debugger;\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n}.initThisClass());\n",
  "Asq2L+kYg5GIMQd+Y8Y0Fx5o2v+gCxqh/KodkTd+n1I=": "\"use strict\";\n\n/*\n\n    BMJsonNode\n    \n\n*/\n        \n(class BMJsonNode extends BMJsonCachedNode {\n    \n    static canOpenMimeType (mimeType) {\n        return mimeType === \"application/json\"\n    }\n\n    static openMimeChunk (dataChunk) {\n        const data = dataChunk.decodedData()\n        //console.log(\"data = '\" + data + \"'\")\n        let json = null\n\n        try {\n            json = JSON.parse(data)\n            //console.log(\"drop json = \" + JSON.stableStringify(json, 2, 2) + \"\")\n        } catch (error) {\n            // return an error node instead?\n        }\n\n        const aNode = this.nodeForJson(json)\n        return aNode\n    }\n\n    jsonClasses () {\n        return [\n            BMJsonArrayNode, \n            BMBooleanField, \n            BMJsonNullField, \n            BMNumberField, \n            BMJsonDictionaryNode, \n            BMStringField\n        ];\n    }\n\n    static jsonToProtoNameDict () {\n        return {\n            \"Array\"   : \"BMJsonArrayNode\",\n            \"Boolean\" : \"BMBooleanField\",\n            \"Null\"    : \"BMJsonNullField\",\n            \"Number\"  : \"BMNumberField\",\n            \"Object\"  : \"BMJsonDictionaryNode\",\n            \"String\"  : \"BMStringField\",\n        }\n    }\n    \n    static nodeForJson(json) {\n        const t = Type.typeName(json)\n        const protoName = this.jsonToProtoNameDict()[t]  \n        if (protoName) {\n            const proto = Object.getClassNamed(protoName)\n            if (proto) {\n                const instance = proto.clone().setJson(json)\n                return instance\n            }\n        }\n\n        return null\n    }\n\n    initPrototypeSlots () {\n    }\n\n    // -----------------------------------------\n\n    initPrototype () {\n        //this.setSubnodeClasses(this.jsonClasses());\n        this.setNodeCanEditTitle(true);\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(true);\n        this.setNodeCanReorderSubnodes(true);\n        this.setCanDelete(true);\n        this.setNoteIconName(\"right-arrow\");\n        this.setTitle(\"JSON\");\n        this.setNodeCanAddSubnode(true);\n    }\n\n    finalInit () {\n        super.finalInit();\n        if (this.subnodeClasses().length === 0) {\n            this.setSubnodeClasses(this.jsonClasses());\n        }\n    }\n\n\n    \n}.initThisClass());\n",
  "TM158FddgzUox+9qkVCb43Ac0m/5PkhGAkgNi8FabKc=": "\"use strict\";\n\n/*\n\n    BMJsonArrayNode\n    \n\n*/\n        \n(class BMJsonArrayNode extends BMJsonNode {\n    \n    static canOpenMimeType (mimeType) {\n        return false;\n    }\n\n    static availableAsNodePrimitive () {\n        return true;\n    }\n\n    static jsonDefaultValue () {\n        return [];\n    }\n\n    static asJsonSchema (refSet) {\n        assert(Type.isSet(refSet));\n        const schema = {\n            type: \"array\",\n            title: this.jsonSchemaTitle(),\n            description: this.jsonSchemaDescription(),\n            default: this.jsonDefaultValue(),\n            items: this.prototype.jsonSchemaForSubnodes(refSet) // prototype method\n        };\n\n        return schema;\n    }\n\n    jsonSchemaForSubnodes (refSet) { // NOTE: method on prototype, not class\n        assert(refSet);\n        const items = {};\n        const refs = this.subnodeClasses().map(subnodeClass => {\n            return { \n                \"$ref\": subnodeClass.jsonSchemaRef(refSet)\n            };\n        });\n        if (refs.length > 0) {\n            items.anyOf = refs;\n        } else {\n            throw new Error(\"BMJsonArrayNode.jsonSchemaForSubnodes() no subnode classes. Make sure setSubnodeClasses() is called in initPrototype.\");\n        }\n        return items;\n    }\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n\n    setupSubnodesSlotWithItemType (aClass) {\n        const slot = this.overrideSlot(\"subnodes\");\n        slot.setIsInJsonSchema(true);\n        slot.setShouldJsonArchive(true);\n        slot.setJsonSchemaItemsType(\"CharacterClass\");\n        this.setSubnodeClasses([CharacterClass]);\n    }\n\n    subtitle () {\n        if (this.thisClass().type() === \"BMJsonArrayNode\") {\n            return \"Array\"; // so we know it's an array when using the UI to assembly JSON\n        }\n\n        return super.subtitle();\n    }\n\n    // --------------\n\n    replaceSubnodeWith (oldNode, newNode) {\n        newNode = this.prepareSubnode(newNode);\n        return super.replaceSubnodeWith(oldNode, newNode);\n    }\n\n    addSubnodeAt (aSubnode, anIndex) {\n        return super.addSubnodeAt(this.prepareSubnode(aSubnode), anIndex);\n    }\n\n    prepareSubnode (aSubnode) {\n        aSubnode.setCanDelete(true);\n\n        if (aSubnode.keyIsVisible) {\n            aSubnode.setKey(\"\");\n            aSubnode.setKeyIsVisible(false);\n            aSubnode.setKeyIsEditable(false);\n            const editableValueTypes = [\"BMStringField\", \"BMNumberField\", \"BMBooleanField\"];\n            if (editableValueTypes.contains(aSubnode.type())) {\n                aSubnode.setValueIsEditable(true);\n            }\n         }\n\n        //aSubnode.setTitle(null);\n        aSubnode.setNodeCanEditTitle(false);\n        return aSubnode;\n    }\n\n    // -------\n\n    jsonArchive () {\n        return this.subnodes().map(sn => sn.jsonArchive());\n    }\n\n    newSubnodeForJson (json) {\n        let aNode = null;\n        if (this.subnodeClasses().length === 1) {\n            const aClass = this.subnodeClasses().first();\n            aNode = aClass.clone().setJson(json);\n        } else {\n            aNode = BMJsonNode.nodeForJson(json);\n        }\n        return aNode;\n    }\n\n    setJson (json) {\n        // in order to merge json properly, we need to look at the jsonIds and match them up\n\n        if (this.doesMatchJson(json)) {\n            return this;\n        }\n\n        /*\n        const hashSubnodeMap = new Map();\n        this.subnodes().forEach(sn => {\n            hashSubnodeMap.set(sn.jsonHash(), sn);\n        });\n        */\n\n        const jsonIdToSubnodeMap = new Map();\n        this.subnodes().forEach(sn => { // TODO: check for duplicat ids\n            jsonIdToSubnodeMap.set(sn.jsonId(), sn);\n        });\n\n        const hasOldSubnodes = this.subnodes().length > 0;\n\n        const newSubnodes = [];\n\n        const seenJsonIds = new Set();\n\n\n        json.forEach((v) => {\n            //assert(v.jsonId);\n            const jsonId = v.jsonId;\n\n            if (seenJsonIds.has(jsonId)) {\n                console.warn(\"BMJsonArrayNode.setJson() attempt to add duplicate jsonId: \", jsonId);\n                return;\n            } else {\n                seenJsonIds.add(jsonId);\n            }\n\n            if (hasOldSubnodes && !jsonId) {\n                console.warn(\"BMJsonArrayNode.setJson() missing jsonId: \", v);\n            }\n\n            const existingNode = jsonIdToSubnodeMap.get(jsonId);\n\n            if (existingNode) {\n                // use the existing node\n                existingNode.setJson(v);\n                newSubnodes.push(existingNode);\n            } else {\n                // create a new node\n                const aNode = this.newSubnodeForJson(v);\n                newSubnodes.push(aNode);\n                console.log(\"BMJsonArrayNode.setJson() creating new node \" + aNode.type() + \" for jsonId: \" + jsonId + \" (\" + aNode.jsonId() + \")\");\n                //debugger;\n            }\n        });\n\n        if (true) {\n            this.subnodes().clear();\n            this.subnodes().appendItems(newSubnodes);\n        } else {\n            this.setSubnodes(newSubnodes);\n        }\n\n        //this.setJsonCache(json); // not safe as we might have removed duplicates\n        //this.didUpdateNode();\n        return this;\n    }\n\n    calcJson () {\n        return this.subnodes().map(sn => sn.asJson());\n    }\n\n    getBMDataUrl () {\n        //const json = this.node().copyArchiveDict();\n        const json = this.jsonArchive();\n        const d = BMDataUrl.clone();\n        d.setMimeType(\"application/json\");\n        d.setFileName(this.title() + \".json\");\n        d.setDecodedData(JSON.stableStringify(json, null, 4));\n        return d;\n    }\n\n}.initThisClass());\n",
  "vapYZ4CkwnsuCMpZtqfxbuMx4vYBtzG2nKG0tR8HvIU=": "\"use strict\";\n\n/*\n\n    BMJsonDictionaryNode\n    \n\n*/\n        \n(class BMJsonDictionaryNode extends BMJsonNode {\n    \n    static canOpenMimeType (mimeType) {\n        return false;\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"shouldMerge\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n        this.setNodeCanEditTitle(true);\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(true);\n        this.setNodeCanReorderSubnodes(true);\n        this.setCanDelete(true);\n        this.setNoteIconName(\"right-arrow\");\n        //this.setSubtitle(\"Dictionary\");\n        this.setSummaryFormat(\"key value\");\n        this.setHasNewLineSeparator(true);\n        this.setHasNewlineAfterSummary(true);\n        //this.setNodeSummarySuffix(\"newline\");\n    }\n\n    // ------------------------------\n\n    jsonArchive () {\n        // use asJson() if you want to get the json\n        // jsonAcrchive is for the storable or communication version\n        throw new Error(\"unimplemented\");\n    }\n\n    // ------------------------------\n\n    setJson (json) {\n        if (this.doesMatchJson(json)) {\n            return this;\n        }\n\n        assert(Type.isDictionary(json));\n\n        const currentKeys = new Set(this.subnodes().map(sn => sn.title()));\n        const newKeys = new Set(Reflect.ownKeys(json));\n        const keysToRemove = Set.difference(currentKeys, newKeys);\n\n        // remove any keys that are no longer in the json\n        keysToRemove.forEach((k) => {\n            this.removeSubnode(this.firstSubnodeWithTitle(k));\n        });\n\n        // merge remaining keys\n        json.ownForEachKV((k, v) => {\n            const sn = this.firstSubnodeWithTitle(k); // do this if we want to merge\n            if (this.shouldMerge() && sn) {\n                sn.setJson(v);\n            } else {\n                console.log(\"BMJsonArrayNode.setJson() creating new node for hash: \", hash);\n                const aNode = this.thisClass().nodeForJson(v);\n                aNode.setTitle(k);\n                if (aNode.setKey) {\n                    aNode.setKey(k);\n                }\n                this.addSubnode(aNode);\n            }\n        });\n\n        this.setJsonCache(json);\n\n        return this;\n    }\n\n    calcJson () {\n        const dict = {};\n        this.subnodes().forEach((sn) => {\n            const key = sn.key ? sn.key() : sn.title();\n            if (sn.asJson) {\n                // so we skip CreatorNode\n                const value = sn.asJson();\n                dict[key] = value;\n            }\n        });\n        return dict;\n    }\n\n    // ----------\n\n    addSubnodeAt (newNode, anIndex) {\n        newNode = this.prepareSubnode(newNode);\n        return super.addSubnodeAt(this.prepareSubnode(newNode), anIndex);\n    }\n\n    replaceSubnodeWith (oldNode, newNode) {\n        newNode = this.prepareSubnode(newNode);\n        return super.replaceSubnodeWith(oldNode, newNode);\n    }\n\n    prepareSubnode (aSubnode) {\n        this.assertValidSubnodeType(aSubnode);\n        aSubnode.setCanDelete(true);\n\n        if (aSubnode.keyIsVisible) {\n            aSubnode.setKeyIsVisible(true);\n            aSubnode.setKeyIsEditable(true);\n        }\n\n        aSubnode.setNodeCanEditTitle(true);\n        return aSubnode;\n    }\n\n    // ------------\n\n    getBMDataUrl () {\n        const json = this.jsonArchive();\n        const bdd = BMDataUrl.clone();\n        bdd.setMimeType(\"application/json\");\n        bdd.setFileName(this.title() + \".json\");\n        bdd.setDecodedData(JSON.stableStringify(json, null, 4));\n        return bdd;\n    }\n\n  // --- editable ---\n  \n  setIsEditable (aBool) {\n    this.subnodes().forEach(sn => {\n      if (sn.setIsEditable) {\n        sn.setIsEditable(aBool);\n        if (!aBool) {\n            if (sn.setNodeCanAddSubnode) {\n                sn.setNodeCanAddSubnode(false);\n            }\n        }\n        //console.log(sn.title() + \" setIsEditable(\" + aBool + \")\");\n      }\n    });\n    return this;\n  }\n    \n}.initThisClass());\n",
  "iJolXGc5QHADpJeNoKcA7SByCJLFJ9dkRZ1mZX8Q/H0=": "\"use strict\";\n\n/*\n\n    BMJsonNullField\n    \n\n*/\n        \n(class BMJsonNullField extends BMField {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n        //this.setNoteIconName(\"right-arrow\")\n\n        this.setKeyIsVisible(false)\n        this.setValue(\"NULL\")\n        //this.setValueIsEditable(false)\n        //this.overrideSlot(\"valueIsEditable\", false).setInitValue(false)\n    }\n\n    jsonArchive () {\n        return null\n    }\n\n    setJson (json) {\n        return this\n    }\n\n    setValueIsEditable (aBool) {\n        /*\n        if (aBool) {\n            console.log(this.type() + \" setValueIsEditable true\")\n        }\n        */\n        return super.setValueIsEditable(false)\n    }\n    \n}.initThisClass());\n",
  "hnWrU+xfm+c4cbNpX2R0gatPrlA3drEJFdKO5tSB2Qg=": "\"use strict\";\n\n/*\n\n    BMCreatorNode\n    \n    A stand-in node that let's the user select field to replace it with.\n\n*/\n        \n(class BMCreatorNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.overrideSlot(\"subnodes\");\n            slot.setShouldStoreSlot(false);\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"typeChoices\", []);\n            slot.setInitProto(Array);\n            slot.setSlotType(\"Array\");\n        }\n    }\n  \n    initPrototype () {\n        this.setNodeCanEditTitle(false);\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(false);\n        this.setNodeCanReorderSubnodes(false);\n        this.setCanDelete(true);\n        this.setNoteIconName(\"right-arrow\");\n        this.setTitle(\"Chose type\");\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess();\n        this.setupSubnodes();\n    }\n\n    static fieldTypes () {\n        return [\n            \"BMActionField\", \n            \"BMBooleanField\", \n            \"BMDateNode\",\n            \"BMImageWellField\", \n            \"BMJsonDictionaryNode\",\n            \"BMJsonArrayNode\",\n            \"BMFolderNode\", \n            \"BMNumberField\", \n            \"BMOptionsNode\",\n            \"BMStringField\",\n            \"BMTextAreaField\",\n            //\"BMChatField\",\n            //\"BMTextNode\",\n            \"BMTimeNode\",\n            \"BMLinkNode\",\n            \"BMUrlField\",\n        ];\n    }\n\n    protoObjects () {\n        return []\n        /*\n        const app = this.rootNode()\n        const protosNode = app.firstSubnodeWithTitle(\"Prototypes\")\n        const protos = protosNode.subnodes()\n        return protos\n        */\n    }\n\n    setupSubnodes () {\n        if (this.subnodes().length == 0) {\n            this.addSubnodesForObjects(BMNode.primitiveNodeClasses())\n            //this.addSubnodesForObjects(this.protoObjects())\n        }\n        return this\n    }\n    \n    addSubnodesForObjects (objects) {\n        const newSubnodes = objects.map((aClass) => {\n            const newNode = BMFolderNode.clone()\n            newNode.setTitle(aClass.nodeCreateName())\n            newNode.setNodeCanEditTitle(false)\n            newNode.setNodeCanEditSubtitle(false)\n            newNode.setNoteIconName(null)\n            newNode.setTarget(this).setMethodName(\"didChoose\").setInfo(aClass)\n            newNode.setCanDelete(false)\n            return newNode\n        })\n        this.addSubnodes(newSubnodes)\n    }\n\n   didChoose (actionNode) {\n        const obj = actionNode.info()\n        const newNode = obj.nodeCreate()\n        newNode.setCanDelete(true)\n        this.replaceSelfWithNode(newNode)\n        return this\n   }\n\n    replaceSelfWithNode (newNode) {\n        const parentNode = this.parentNode()\n        assert(parentNode)\n        parentNode.replaceSubnodeWith(this, newNode)\n        parentNode.postShouldFocusAndExpandSubnode(newNode) \n    }\n\n    nodeSummary () {\n        return \"\"\n    }\n    \n}.initThisClass());\n",
  "nkaVNdgHJrYrW7FE7FHjjnHI7E/d1MLkCFCePkw+ie4=": "\"use strict\";\n\n/*\n\n    BMActionField\n    \n    An abstraction of a UI visible action that can be performed on an object.\n    the value is the action method name, the target is the field owner.\n\n*/\n\n(class BMActionField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.overrideSlot(\"title\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setCanInspect(true);\n            slot.setSlotType(\"String\");\n            slot.setLabel(\"Title\");\n        }\n\n        {\n            const slot = this.newSlot(\"methodName\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"info\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"JSON Object\");\n        }\n    }\n\n    initPrototype () {\n        // inherits isEnabled and isEditable slots from Field\n        this.setShouldStore(true)\n        this.setNodeTileIsSelectable(true)\n        this.setNodeCanInspect(true)\n        this.setKeyIsVisible(false)\n        this.setValueIsVisible(false)\n    }\n\n    setTitle (s) {\n        super.setTitle(s)\n        return this\n    }\n    \n    summary () {\n        return \"\"\n    }\n\n    target () {\n        const t = this._target;\n        return t ? t : this.parentNode()\n    }\n\n    canDoAction () {\n        const t = this.target()\n        const m = this.methodName()\n        return t && t[m]\n    }\n\n    doAction () {\n        if (this.canDoAction()) {\n            const func = this.target()[this.methodName()]\n            \n            if (Type.isFunction(func)) {\n                func.call(this.target(), this)\n            } else {\n                //this.setValueError(\"no method with this name\")\n                console.warn(\"no method with this name\")\n            }\n        } else {\n            this.debugLog(\" can't perform action \", this.methodName(), \" on \", this.target())\n        }\n\t    \n\t    return this\n    }\n\n    syncFromTarget () {\n        super.syncFromTarget()\n    \n        const t = this.target()\n        if (t) {\n            const infoMethodName = this.methodName() + \"ActionInfo\"\n            const method = t[infoMethodName];\n            if (method) {\n                const infoDict = method.apply(t, [])\n                this.setActionInfo(infoDict)\n            }\n        }\n    }\n\n    prepareToAccess () {\n        //debugger\n        super.prepareToAccess()\n        this.syncFromTarget()\n        return this\n    }\n    \n    setActionInfo (infoDict) {\n        //if (JSON.stableStringify(infoDict) != JSON.stableStringify(this.actionInfo())) {\n\n        {\n            const v = infoDict.isEnabled;\n            if (v !== undefined) {\n                if (!Type.isBoolean(v)) {\n                    const methodName = this.methodName() + \"ActionInfo\";\n                    console.warn(this.target().typeId() + \".\" + methodName + \"() returned invalid value of '\" + v + \"' for isEnabled. Boolean value is required.\")\n                }\n                assert(Type.isBoolean(v));\n                this.setIsEnabled(v);\n            }\n        }\n\n        {\n            const v = infoDict.title\n            if (v !== undefined) {\n                assert(Type.isString(v) || Type.isNull(v));\n                this.setTitle(v);\n            }\n        }\n\n        {\n            const v = infoDict.subtitle\n            if (v !== undefined) {\n                assert(Type.isString(v) || Type.isNull(v));\n                this.setSubtitle(v);\n            }\n        }\n\n        {\n            const v = infoDict.isVisible \n            if (v !== undefined) {\n                assert(Type.isBoolean(v));\n                this.setIsVisible(v)\n            }\n        }\n\n        // this.didUpdateNodeIfInitialized();\n        // }\n\n        return this\n    }\n\n    actionInfo () {\n        return {\n            isEnabled: this.isEnabled(),\n            title: this.title(),\n            subtitle: subthis.title(),\n            isVisible: this.isVisible()\n        }\n    }\n\n}.initThisClass());\n",
  "i2JR6IAToB94upuzSH4CF/vLNMWrdpwFjmX9Mioah9M=": "\"use strict\";\n      \n/*\n\n    BMBooleanField\n\n    \n*/\n\n(class BMBooleanField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.overrideSlot(\"value\", null);\n            slot.setSlotType(\"Boolean\");\n            slot.setInitValue(false);\n        }\n\n        {\n            const slot = this.newSlot(\"unsetVisibleValue\", \"unset\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    initPrototype () {\n        this.setKeyIsEditable(false);\n        this.setValueIsEditable(false);\n    }\n\n    valueIsBool () {\n        const b = this.value();\n        return Type.isBoolean(b);\n    }\n\t\n    validate () {\n        const isValid = this.valueIsBool();\n\t\t\n        if (!isValid) {\n            const targetName = this.target() ? this.target().debugTypeId() : \"<no target>\";\n            const s = \"Field '\" + this.key() + \"' on target '\" + targetName + \"' needs to be a boolean (true or false) not a \" + Type.typeName(this.value());\n            console.warn(s);\n            debugger;\n            this.setValue(false);\n            this.setValueError(s);\n        } else {\n            this.setValueError(null);\n        } \n\t\t\n        return isValid;\n    }\n\t\n    normalizeThisValue (v) {\n\t    if (v === true || v === \"t\" || v === \"true\" | v === 1) { \n            return true; \n        }\n\t    return false;\n    }\n\t\n    didUpdateNode () {\n        assert(this.hasDoneInit());\n        //if (this.hasDoneInit()) { \n            this.validate();\n        //}\n        return super.didUpdateNode();\n    }\n\n    jsonArchive () {\n        return this.value() ? true : false;\n    }\n\n    setJson (json) {\n        assert(Type.isBoolean(json));\n        this.setValue(json);\n        return this;\n    }\n\n}.initThisClass());\n",
  "SmESa6YY+DJ575183BUoiOF/ayU6b1dDiIc/MIluwaQ=": "\"use strict\";\n\n/*\n\n    BMColorField\n    \n*/\n\n(class BMColorField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"red\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n\n        {\n            const slot = this.newSlot(\"green\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n\n        {\n            const slot = this.newSlot(\"blue\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n\n        {\n            const slot = this.newSlot(\"alpha\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setCanInspect(true)\n            slot.setSlotType(\"Number\")\n        }\n    }\n\n    initPrototype () {\n        this.setNodeCanEditTitle(true);\n        this.setNodeCanEditSubtitle(false);\n        this.setTitle(\"color\");\n        this.setSubtitle(null);\n        this.setCanDelete(true);\n        this.setNodeCanInspect(true);\n        this.setNodeCanAddSubnode(true);\n    }\n\n    asCssColor () {\n        return CssColor.clone().set(this.red(), this.green(), this.blue(), this.alpha())\n    }\n\n    fromCssColor (aCssColor) {\n        return this\n    }\n    \n}.initThisClass());\n",
  "tLpgqGwC7jGhH6rxOhkyuntVwbkSqXHTMCilzXjuDes=": "\"use strict\";\n\n/*\n\n    BMIdentityField\n\n*/\n\n(class BMIdentityField extends BMField {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setKeyIsEditable(false);\n        this.setValueIsEditable(false);\n    }\n\n    validate () {\n        if (!bitcore.PublicKey.isValid(this.value())) {\n            this.setValueError(\"invalid address\")\n        } else {\n            this.setValueError(null)\n        }\n    }\n\t\n    setValue (inValue) { // called by View on edit\n        if (Type.isNull(inValue)) {\n            console.log(\"WARNING: \" + this.type() + \" setValue(null)\")\n            return this\n        }\n\t    //console.log(\"inValue = '\" + inValue + \"'\")\n\t    let newValue = inValue.strip()\n\t    \n        const parts = newValue.split(\" \").concat(newValue.split(\"\\n\")).concat(newValue.split(\",\"))\n\t    //console.log(\"parts = '\", parts)\n        const validPart = parts.detect(part => { return bitcore.PublicKey.isValid(part) })\n\n        if (validPart) {\n            newValue = validPart\n        }\n\n        if (inValue !== newValue) {\n            this.scheduleSyncToView() \n        }\n        \n        //console.log(\"newValue = '\" + newValue + \"'\")\n        super.setValue(newValue)\n\t\t\n        return this\n    }\n\n}.initThisClass());\n",
  "e2Vjje7GHNBzBr1Io4mrsoFtZk+QS4+hmil0+kpEnEM=": "\"use strict\";\n\n/*\n\n    BMImageWellField\n\n*/\n        \n(class BMImageWellField extends BMField {\n\n    static availableAsNodePrimitive () {\n        return true\n    }\n    \n    static supportedMimeTypes () {\n        return new Set([\"image/jpeg\", \"image/gif\", \"image/png\"])\n    }\n\n    static canOpenMimeType (mimeType) {\n        return this.supportedMimeTypes().has(mimeType)\n    }\n\n    static openMimeChunk (dataChunk) {\n        const newNode = this.clone()\n        newNode.setValue(dataChunk.dataUrl())\n        //newNode.setValue(dataChunk.decodedData())\n        newNode.setKeyIsEditable(true)\n        newNode.setValueIsEditable(true)\n        newNode.setCanDelete(true)\n        return newNode\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"onlyShowsKeyWhenEmpty\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"isEditable\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.overrideSlot(\"nodeMinTileHeight\");\n            slot.setShouldStoreSlot(true);\n        }\n    }\n\n    initPrototype () {\n        this.setKey(\"Image title\");\n        this.setKeyIsEditable(false);\n        this.setValueIsEditable(false);\n        this.setNodeCanEditTileHeight(true);\n    }\n\n    summaryValue () {\n        return \"\"\n    }\n   \n}.initThisClass());\n",
  "OYGNtp70yEO4fMVAHQjuaqFYSKMYUTUrp8FlPbLg3pg=": "\"use strict\";\n\n/*\n\n    BMNumberField\n\n    A named number field that validates that the \n    value is a number and shows an appropraite error message.\n\n*/\n        \n(class BMNumberField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"unsetVisibleValue\", \"unset\");\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"isInteger\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Boolean\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Is integer\")\n            slot.setInspectorPath(\"NumberField\")\n            //slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"hasLimits\", false)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Boolean\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Has limits\")\n            slot.setInspectorPath(\"NumberField\")\n            //slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"minValue\", 0)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Number\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Min Value\")\n            slot.setInspectorPath(\"NumberField\")\n            //slot.setSyncsToView(true)\n        }\n\n        {\n            const slot = this.newSlot(\"maxValue\", 1)\n            slot.setDuplicateOp(\"copyValue\")\n            slot.setSlotType(\"Number\")\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setCanEditInspection(true)\n            slot.setLabel(\"Max value\")\n            slot.setInspectorPath(\"NumberField\")\n            //slot.setSyncsToView(true)\n        }\n    }\n\n    initPrototype () {\n    }\n\n    // --- \n    // TODO: \n    // - add a Slot.validatorMethod or methodHook so this can be done dynamically?\n\n    didUpdateSlotIsInteger () {\n        this.validate()\n    }\n\n    didUpdateSlotHasLimits () {\n        this.validate()\n    }\n\n    didUpdateSlotMinValue () {\n        this.validate()\n    }\n\n    didUpdateSlotMaxValue () {\n        this.validate()\n    }\n\n    // ----\n\n    init () {\n        super.init()\n        this.setKey(\"Number title\")\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(true)\n        this.setValue(0)\n    }\n\n    setValue (v) {\n        if (!Type.isNumber(v)) {\n            if (Type.isNull() && this.valueAllowsNull()) {\n                // ok\n            } else {\n                // attempt to coerce to a number\n                v = Number(v);\n                assert(!Type.isNaN(v), \"value must be a number\");\n                super.setValue(v);\n            }\n        } else {\n            super.setValue(v);\n        }\n        return this\n    }\n\n    valueIsNumeric () {\n        const n = this.value();\n        return !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\t\n    validate () {\n        const v = Number(this.value())\n        const errors = []\n        \n        if (!this.valueIsNumeric()) {\n            errors.push(\"This needs to be a number.\")\n        }\n\n        if (this.hasLimits()) {\n            if (v < this.minValue()) {\n                errors.push(\"Must be >= \" + this.minValue() + \".\")\n            }\n            if (v > this.maxValue()) {\n                errors.push(\"Must be <= \" + this.maxValue() + \".\")\n            }\n        }\n\n        if (this.isInteger()) {\n            if (!Number.isInteger(v)) {\n                errors.push(\"Must be an integer.\")\n            }\n        }\n\n        if (errors.length) {\n            this.setValueError(errors.join(\"\\n\"))\n        } else {\n            this.setValueError(null)\n        }\n        \n        const isValid = this.valueError() === null\n        return isValid\n    }\n    \n}.initThisClass());\n",
  "5/xDWqS/H25PtHa4tSOwodJiYSvKIFlMnvcJlpqD4DM=": "\"use strict\";\n\n/*\n\n    BMPointerField\n\n    A field that's a pointer to another node.\n    (sometimes the other node is used as a list of items, but not always)\n\n*/\n        \n(class BMPointerField extends BMField {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n        this.setKeyIsVisible(true)\n        this.setValueIsVisible(true)\n        this.setNodeTileIsSelectable(true)\n    }\n\n    /*\n    setValue (v) {\n        console.warn(\"WARNING: BMPointerField setValue '\" + v + \"'\")\n        return this\n    }\n    */\n\n    proxyGetter(methodName, defaultReturnValue = \"\") {\n        const v = this.value()\n        return v ? v[methodName].apply(v) : defaultReturnValue\n    }\n\n    title () {\n        const title = this.proxyGetter(\"title\")\n        return title\n    }\n\t\n    subtitle () {\n        return this.proxyGetter(\"subtitle\")\n    }\n\t\n    note () {\n        return this.proxyGetter(\"note\")\n    }\n\t\n    nodeTileLink () {\n        return this.value()\n    }\n\n    jsonArchive () {\n        if (this.value() && this.value().jsonArchive) {\n            return this.value().jsonArchive()\n        }\n        return undefined;\n    }\n\n}.initThisClass());\n",
  "RJHaO0Im2ACznN5r/HQj188F7y29yUZgU6vmP/Oxvg0=": "\"use strict\";\n\n/*\n\n    BMJsonField\n\n\n*/\n        \n(class BMJsonField extends BMField {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"nodeTileLink\", null);\n            slot.setSlotType(\"BMJsonNode\");\n        }\n    }\n\n    initPrototype () {\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n        this.setKeyIsVisible(true)\n        this.setValueIsVisible(true)\n        this.setNodeTileIsSelectable(true)\n    }\n\n    setValue (v) {\n        console.warn(\"WARNING: BMJsonField setValue '\" + v + \"'\")\n        const node = BMJsonNode.nodeForJson(v)\n        this.setNodeTileLink(node)\n        return this\n    }\n\n    value () {\n        const node = this.nodeTileLink()\n        if (node) {\n            return node.jsonArchive()\n        }\n        return undefined\n    }\n\n    proxyGetter(methodName, defaultReturnValue = \"\") {\n        const v = this.value()\n        return v ? v[methodName].apply(v) : defaultReturnValue\n    }\n\n    title () {\n        return this.proxyGetter(\"title\")\n    }\n\t\n    subtitle () {\n        return this.proxyGetter(\"subtitle\")\n    }\n\t\n    note () {\n        return this.proxyGetter(\"note\")\n    }\n\n}.initThisClass());\n",
  "AtZod6WIM2cthnIF6NjtMYMqRjJW+4/GbA5f2g8vlZU=": "\"use strict\";\n\n/*\n\n    BMArrayField\n\n\n*/\n        \n(class BMArrayField extends BMJsonField {\n  \n}.initThisClass());\n",
  "ntaj5ZFkDyfH4GFazw65XNul6c6Ca2sqjbXxO3QX7Jg=": "\"use strict\";\n\n/*\n\n    BMStampField\n\n*/\n\n(class BMStampField extends BMField {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        //this.setKeyIsVisible(false)\n        //this.setKey(\"drop images here\")\n        this.setKeyIsEditable(false)\n        this.setValueIsEditable(false)\n    }\n    \n}.initThisClass());\n",
  "H8qz+QTBZh4fh1y6V8GAadYVpHIIQR2iHR1+c4woUak=": "\"use strict\";\n\n/*\n\n    BMStringField\n\n*/\n        \n(class BMStringField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"unsetVisibleValue\", \"\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    initPrototype () {\n        this.setKey(\"String title\");\n\n        this.setKeyIsVisible(true);\n        this.setKeyIsEditable(true);\n\n        this.setValueIsVisible(true);\n        this.setValueIsEditable(true);\n    }\n\n    syncFromNode () {\n        return super.syncFromNode()\n    }\n    \n}.initThisClass());\n",
  "fOCB5J3iVV+cJHPflfFjBmjn1kc1pTeOWXUEONbcq70=": "\"use strict\";\n\n/*\n\n    BMTextAreaField\n    \n*/\n\n(class BMTextAreaField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true;\n    }\n\n    static canOpenMimeType (mimeType) {\n        return mimeType.startsWith(\"text/plain\");\n    }\n\n    static openMimeChunk (dataChunk) {\n        const newNode = this.clone();\n        newNode.setValue(dataChunk.decodedData());\n        newNode.setKeyIsEditable(true);\n        newNode.setValueIsEditable(true);\n        newNode.setCanDelete(true);\n        return newNode;\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isMono\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n        this.setKeyIsVisible(false);\n    }\n\n    appendToValue (text) {\n        this.setValue(this.value() + text);\n        return this\n    }\n\n    syncFromTarget () {\n        super.syncFromTarget();\n        return this\n    }\n    \n}.initThisClass());\n",
  "3qwU49YBmCIor6sJzpQqvNqBE3zkV4KeRWerbhfl0Wk=": "\"use strict\";\n\n/*\n\n    BMUrlField\n    \n*/\n\n(class BMUrlField extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    static canOpenMimeType (mimeType) {\n        return mimeType.startsWith(\"text/uri-list\")\n    }\n\n    static openMimeChunk (dataChunk) {\n        const newNode = this.clone()\n        const uris = dataChunk.decodedData().split(\"\\n\")\n        const uri = uris.first()\n\n        try {\n            const url = new URL(uri)\n            newNode.setKey(url.hostname)\n            const path = url.pathname\n            const p = path.fileName()\n            if (p) {\n                newNode.setKey(p)\n            }\n        } catch (error) {\n            newNode.setKey(\"?\")\n        }\n\n        newNode.setValue(uri)\n        newNode.setValueIsVisible(false)\n\n        return newNode\n    }\n\n    initPrototypeSlots () {\n        // scheme : // userinfo @host : port / path ? query # fragment\n        this.newStringSlotNamed(\"href\", \"\");\n        this.newStringSlotNamed(\"protocol\", \"http\");\n        this.newStringSlotNamed(\"username\", \"\");\n        this.newStringSlotNamed(\"password\", \"\");\n        this.newStringSlotNamed(\"hostname\", \"hostname\");\n        this.newStringSlotNamed(\"port\", \"\");\n        this.newStringSlotNamed(\"pathname\", \"\");\n        this.newStringSlotNamed(\"search\", \"\");\n        this.newStringSlotNamed(\"hash\", \"\");\n\n        {\n            const slot = this.newSlot(\"isUpdatingHref\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    newStringSlotNamed (slotName, defaultValue) {\n        //debugger\n        const slot = this.newSlot(slotName, defaultValue)\n        //slot.setShouldStoreSlot(true)\n        slot.setOwnsSetter(true)\n        slot.setDoesHookSetter(true)\n        slot.setDuplicateOp(\"copyValue\")\n        slot.setCanInspect(true)\n        slot.setSlotType(\"String\")\n        slot.setLabel(slotName.capitalized())\n        slot.setInspectorPath(\"URL\")\n\n        if (slotName !== \"href\") {\n            //slot.setCanEditInspection(false)\n        }\n        return slot\n    }\n\n    init () {\n        super.init()\n\n        this.setKey(\"Link\")\n        this.setKeyIsVisible(true)\n        this.setKeyIsEditable(true)\n\n        this.setValueIsEditable(true)\n        this.setValueIsVisible(true)\n\n        this.setCanDelete(true)\n\n        this.setNodeCanInspect(true)\n    }\n\n    nodeInspector () {\n        return super.nodeInspector()\n    }\n\n    urlFromValue () {\n        const s = this.value()\n        if (s.trim() === \"\") {\n            return null\n        }\n        \n        try {\n            const url = new URL(s)\n            return url\n        } catch (e) {\n            //this.setError(e.message)\n        }\n        return null\n    }\n\n    didUpdateSlotValue () {\n        this.parseValue()\n    }\n\n    didUpdateSlotHref () {\n        this.setIsUpdatingHref(true)\n        this.setValue(this.href())\n        this.parseValue()\n        this.setIsUpdatingHref(false)\n    }\n\n    // slots\n\n    scheduleUnparse () {\n        if (this.hasDoneInit()) {\n            //this.scheduleSelfFor(\"unparseValue\")\n            this.unparseValue()\n        }\n    }\n    \n    didUpdateSlotProtocol () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotUsername () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotPassword () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotHostName () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotPort () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotPathname () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotSearch () {\n        this.scheduleUnparse()\n    }\n\n    didUpdateSlotHash () {\n        this.scheduleUnparse()\n    }\n    \n    // parse / unparse\n\n    parseValue () {\n        // set slots using the value\n        const url = this.urlFromValue()\n        if (!url) {\n            return this\n        }\n        \n        this.directSetProtocol(url.protocol)\n        this.directSetUsername(url.username)\n        this.directSetPassword(url.password)\n        this.directSetHostname(url.hostname)\n        this.directSetPort(url.port)\n        this.directSetPathname(url.pathname)\n        this.directSetSearch(url.search)\n        this.directSetHash(url.hash)\n        this.directSetHref(url.href)\n        \n        return this\n    }\n\n    urlFromComponents () {\n        const url = new URL(\"http://test.com\")\n        url.protocol = this.protocol()\n        url.username = this.username()\n        url.password = this.password()\n        url.hostname = this.hostname()\n        url.port = this.port()\n        url.pathname = this.pathname()\n        url.search = this.search()\n        url.hash = this.hash()\n        return url \n    }\n\n    unparseValue () {\n        // set the value using the slots\n        const url = this.urlFromComponents()\n        this.directSetHref(url.href)\n        //this.directSetValue(url.href)\n        return this\n    }\n\n    nodeUrlLink () {\n        return this.value()\n    }\n\n    validate () {\n        const isValid = this.valueIsValidUrl()\n\t\t\n        if (!isValid) {\n            this.setValueError(\"Invalid URL\")\n        } else {\n            this.setValueError(null)\n        } \n\t\t\n        return isValid\n    }\n\n    valueIsValidUrl () {\n        //debugger\n        if (Type.isNullOrUndefined(this.value())) {\n            this.setValue(\"\")\n        }\n        \n        const url = this.value()\n        try {\n            const urlObject = new URL(url)\n            return true\n        } catch (error) {\n            return false\n        }\n\n        //const result = url.match(/(http(s)?:\\/\\/.)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)/g);\n        //return result !== null\n        throw new Error(\"what happened?\")\n    }\n    \n}.initThisClass());\n",
  "brDZxTZGw9GGfAabeATlHwivREPmin72ZX11wjrL/Jg=": "\"use strict\";\n\n/*\n\n    BMOptionNode\n    \n    A single option from a set of options choices.\n\n*/\n        \n(class BMOptionNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"label\", \"Option Title\");\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"value\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"isPicked\", false);\n            slot.setShouldStoreSlot(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(false);\n        this.setNodeCanReorderSubnodes(false);\n        this.setCanDelete(true);\n        this.setNodeCanEditTitle(true);\n    }\n\n    debugTypeId () {\n        return this.typeId() + \"_'\" + this.label() + \"'\";\n    }\n    \n    /*\n    init () {\n        super.init()\n    }\n    */\n\n    justSetIsPicked (aBool) {\n        assert(Type.isBoolean(aBool));\n        this._isPicked = aBool;\n        return this;\n    }\n\n    optionsNode () {\n        //debugger\n        return this.firstParentChainNodeOfClass(BMOptionsNode);\n    }\n\n    didUpdateSlotIsPicked (oldValue, newValue) {\n        const optionsNode = this.optionsNode();\n        if (optionsNode) {\n            optionsNode.didToggleOption(this);\n            this.didUpdateNodeIfInitialized();\n        } else {\n            debugger;\n            // if this is called, the stack views might not have properly synced \n            // after the OptionsNode removed it's subnodes\n            console.log(\"parent: \", this.parentNode().title());\n            console.log(\"grand parent: \", this.parentNode().parentNode().title());\n            console.log(\"great grand parent: \", this.parentNode().parentNode().parentNode().title());\n            const result = this.firstParentChainNodeOfClass(BMOptionsNode);\n            console.log(\"result: \", result.title());\n            throw new Error(\"missing BMOptionsNode\");\n        }\n    }\n\n    toggle () { \n        // The OptionNodeTile knows to call this\n        this.setIsPicked(!this.isPicked());\n        return this;\n    }\n\n    setTitle (aString) {\n        this.setLabel(aString);\n        return this;\n    }\n    \n    title () {\n        return this.label();\n    }\n\n    value () {\n        return this.title();\n    }\n\n    /*\n    subtitle () {\n        return null;\n    }\n    */\n\n    summary () {\n        return this.title();\n    }\n\n    note () {\n        return this.isPicked() ? \"✓\" : \"\";\n    }\n\n    /*\n    didUpdateSlotParentNode (oldValue, newValue) {\n        super.didUpdateSlotParentNode(oldValue, newValue);\n        if (newValue === null) {\n            debugger;\n        }\n    }\n    */\n\n}.initThisClass());\n",
  "vYl7nW+ip1MNnakTbPU7OblQtA6z5xKNJQwQ9/SaX34=": "\"use strict\";\n\n/*\n\n    BMOptionsNode \n\n        Idea:\n\n        have pickedValues() always return an array of the form:\n\n        [\n            {\n                path: [\"path string component A\", \"path string component B\", ...],\n                label: \"\", //?\n                subtitle: null, //\n                value: aValue, // and value that is valid JSON (no undefined, Maps, non-dict Objects, etc)\n            },\n            ...\n        ]\n\n        and implement pickedValue() to return first item:\n\n            pickedValue () {\n                return this.pickedValues().first()\n            }\n\n        and have pick action choose which to set on target value depend on this.allowsMultiplePicks()\n\n        Calling value() and setValue() on the target:\n        \n        - we need to support just putting in value or array (if multi-choice) of raw values,\n          as well as an option to store the pickedDicts(), so we need another Slot attribute...\n          \n\n*/\n\n//const allSetupOptions = new Set();\n\n(class BMOptionsNode extends BMField {\n    \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"syncedValidItemsJsonString\", null);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"allowsMultiplePicks\", false);\n            slot.setLabel(\"Multiple picks\");\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Boolean\");\n            slot.setShouldStoreSlot(true);\n        }\n\n        {\n            //const slot = this.newSlot(\"isSettingUp\", false) // doesn't appear to be needed\n            //slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.overrideSlot(\"key\", \"\");\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n        }\n\n        //this.newSlot(\"optionsSource\", null).setShouldStoreSlot(false).setDuplicateOp(\"copyValue\")  // this could be stored...\n        //this.newSlot(\"optionsSourceMethod\", null).setShouldStoreSlot(false).setDuplicateOp(\"copyValue\") // this could be stored...\n        {\n            const slot = this.newSlot(\"validValues\", null);\n            slot.setShouldStoreSlot(false);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"validValuesClosure\", null);\n            slot.setShouldStoreSlot(false);\n            slot.setDuplicateOp(\"copyValue\"); // this can't be stored\n            slot.setSlotType(\"Function\");\n        }\n    }\n\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n\n        this.setCanDelete(true)\n        this.setNodeCanInspect(true)\n\n        this.setKey(\"Options\")\n        this.setKeyIsVisible(true)\n        this.setNodeCanEditTitle(true)\n\n        this.setNodeCanReorderSubnodes(true)\n\n        this.setNodeCanAddSubnode(true);\n        this.setSummaryFormat(\"value\");\n        this.setNoteIconName(\"right-arrow\");\n        this.setSubnodeProto(BMOptionNode);\n\n    }\n    \n    /*\n    setValue (v) {\n        super.setValue(v)\n        return this\n    }\n    */\n    \n    title () {\n        return this.key()\n    }\n\n    debugTypeId () {\n        return this.typeId() + \"_'\" + this.key() + \"'\"\n    }\n    \n    setTitle (s) {\n        this.setKey(s)\n        return this\n    }\n\n    childrenSummary () {\n        const picked = this.value()\n\n        if (Type.isArray(picked)) {\n            if (picked.length === 0) {\n                return \"No selection\"\n            }\n            return picked\n        } else {\n            if (picked === null) {\n                return \"No selection\"\n            }\n            return [picked]\n        }\n        /*\n        const picked = this.pickedLeafSubnodes()\n        if (picked.length === 0) {\n            return \"No selection\"\n        }\n        return picked.map(subnode => subnode.summary()).join(\"\")\n        */\n    }\n\n    // --- subtitle ---\n\n    setSubtitle (aString) {\n        return this\n    }\n\n    subtitle () {\n        if (this.usesValidDict()) {\n            return this.pickedNodePathStrings().join(\"\\n\")\n        }\n        const s = super.subtitle()\n        return s\n    }\n\n        \n    // --- getting picked items ---\n\n    /*\n\n    fullPickedValues () {\n        return this.usesValidDict() ? this.pickedNodeValuePaths() : this.pickedValues()\n    }\n\n    pickedNodeValuePaths () {\n        return this.pickedNodePaths().map(nodePath => nodePath.map(node => { \n            return node.value ? node.value() : node.title() // string join won't work on non strings!\n        }))\n    }\n    */\n\n    pickedNodePathStrings () {\n        return this.pickedNodePaths().map(nodePath => nodePath.map(node => { \n            //return node.value ? node.value() : node.title() // string join won't work on non strings!\n            return node.title()\n        }).join(\" / \"))\n    }\n\n    pickedNodePaths () {\n        return this.pickedLeafSubnodes().map(leafNode => leafNode.parentChainNodeTo(this))\n    }\n\n    // ---\n\n    pickedValues () {\n        return this.pickedLeafSubnodes().map(s => s.value())\n    }\n\n    pickedValuesSet () {\n        return this.pickedValues().asSet()\n    }\n\n    usesValidDict () {\n        const vv = this.validValues()\n        return vv && vv.length && Type.isDictionary(vv[0]);\n    }\n\n    pickedLeafSubnodes () {\n        //this.setupSubnodesIfEmpty() // did we need this for loading from store?\n        return this.leafSubnodes().select(sn => sn.isPicked())\n    }\n\n    pickedItems () {\n        return this.pickedLeafSubnodes().map(sn => {\n            return {\n                label: sn.label(),\n                value: sn.value(),\n                path: sn.parentChainNodeTo(this).map(sn => sn.title())\n            }\n        })\n    }\n\n    // --- handle pick event ---\n\n    didToggleOption (anOptionNode) {\n        if (anOptionNode.isPicked() && !this.allowsMultiplePicks()) {\n            this.unpickLeafSubnodesExcept(anOptionNode)\n        }\n        \n        const v = this.formatedPickedValues()\n        this.setValue(v)\n\n        return this\n    }\n\n    formatedPickedValues () {\n        const pickedValues = this.pickedValues();\n        \n        let v = null;\n\n        if (pickedValues.length) {\n            v = this.allowsMultiplePicks() ? pickedValues : pickedValues.first();\n        }\n        return v\n    }\n\n    setValueOnTarget (v) {\n        super.setValueOnTarget(v)\n        //this.setOptionsOnTarget()\n        return this\n    }\n\n    /*\n    setOptionsOnTarget () {\n        const t = this.target()\n        if (t) {\n            const setter = this.setterNameForSlot(this.valueMethod() + \"Options\")\n            \n            if (t[setter]) {\n                t[setter].apply(t, [this.pickedItems()])\n                //t.didUpdateNodeIfInitialized()\n            } \n        }\n        return this\n    }\n    */\n\n    // --- picking and unpicking items programatically ---\n\n    unpickLeafSubnodesExcept (anOptionNode) {\n        this.leafSubnodes().forEach(sn => {\n            if (sn !== anOptionNode) { \n                sn.setIsPicked(false) \n            }\n        })\n        return this\n    }\n\n    pickLeafSubnodesMatchingValue () {\n        const v = this.value()\n        this.leafSubnodes().forEach(option => {\n            if (Type.isArray(v)) {\n                option.justSetIsPicked(v.contains(option.value()))\n            } else {\n                option.justSetIsPicked(v == option.value())\n            }\n        })\n    }\n\n    // --- syncing ---\n\n    acceptedSubnodeTypes () {\n        return [BMOptionNode.type()] // , BMFolderNode.type()]\n    }\n\n    // IMPORTANT: we want to use valid values this way so we can edit the subnodes from the UI\n    // to change the valid value set\n\n    didUpdateSlotValidValues (oldValue, newValue) {\n        if (newValue) {\n            //this.setupSubnodes()\n            //this.scheduleMethod(\"setupSubnodes\")\n        }\n    }\n\n    syncFromTarget () {\n        super.syncFromTarget()\n        this.setupSubnodes()\n        this.constrainValue()\n        //this.setOptionsOnTarget()\n        return this\n    }\n\n    constrainValue () {\n        // make sure the target's value is one of the valid options\n\n        /*\n        const v = this.value()\n        const validSet = this.validValuesFromLeafSubnodes().asSet()\n        let didChange = false\n        let newV = null\n        if (Type.isArray(v)) {\n            newV = v.filter(item => { \n                const isValid = validSet.has(item)\n                if (!isValid) {\n                    didChange = true\n                   // debugger;\n                }\n                return isValid\n            })\n        } else {\n            if (v !== null && !validSet.has(v)) {\n                newV = null\n                didChange = true\n                //debugger;\n\n            }\n        }\n        if (didChange) {\n            this.setValueOnTarget(newV)\n            this.didUpdateNodeIfInitialized()\n        }\n        */\n        return this\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        this.setupSubnodesIfEmpty()\n    }\n\n    /*\n    prepareToAccess () {\n        //debugger\n        super.prepareToAccess()\n        this.setupSubnodesIfEmpty()\n    }\n    */\n\n    /*\n    validValuesFromSource () {\n        const source = this.optionsSource()\n        const method = this.optionsSourceMethod()\n        if (source && method) {\n            const values = source[method].apply(source)\n            return values\n        }\n        \n        return []\n    }\n    */\n\n    computedValidValues () {\n        if (this.validValues()) {\n            return this.validValues()\n        } else if (this.validValuesClosure()) {\n            return this.validValuesClosure()(this.target())\n        } else {\n            /*\n            const t = this.target()\n            if (t) {\n                const slotName = this.key()\n                return this.target().validValuesForSlotName(slotName)\n            }\n            */\n        }\n        return []\n    }\n\n    validValuesFromLeafSubnodes () {\n        return this.leafSubnodes().map(sn => sn.value())\n    }\n\n    setupSubnodesIfEmpty () {\n        if (this.subnodes().length === 0) {\n            this.setupSubnodes()\n        }\n        return this\n    }\n\n    /*\n    didUpdateSlotParentNode (oldValue, newValue) {\n        super.didUpdateSlotParentNode(oldValue, newValue) \n        //debugger;\n        this.setupSubnodes() // is this needed?\n    }\n    */\n\n    targetHasPick (v) {\n        const value = this.value();\n\n        if (this.allowsMultiplePicks()) {\n            const values = Type.isArray(value) ? value : null;\n            return values.includes(v)\n        } \n        \n        return v === value;\n    }\n\n    // --- syncing ---\n\n    /*\n    setValue (v) {\n        if (Type.isDictionary(v)) {\n            debugger;\n        }\n        this._value = v;\n        return this;\n    }\n    */\n\n    itemForValue (v) {\n        if (Type.isNull(v)) {\n            return {\n                label: \"null\",\n                subtitle: null,\n                value: null,\n                options: null\n            }\n        }   \n\n        if (Type.isString(v) || Type.isNumber(v)) {\n            //const isPicked = this.targetHasPick(v)\n            return {\n                //path: null,  // returned in picked values?\n                label: v,\n                subtitle: null,\n                value: v,\n                //isPicked: isPicked, // slow - TODO: cache?\n                options: null\n            }\n        }\n        assert(Type.isDictionary(v))\n        return v\n    }\n\n    valueAsArray () {\n        const target = this.target();\n        const value = target ? this.value() : undefined;\n\n        if (value === null || value === undefined) {\n            return [];\n        } else if (this.allowsMultiplePicks()) {\n            return value;\n        } else {\n            return [value];\n        }\n    }\n\n    validValuesMatch () {\n        const validValues = this.computedValidValues()\n        const validItemsString = JSON.stableStringify(validValues);\n        const validValuesMatch = this.syncedValidItemsJsonString() === validItemsString; // could check a hash instead but maybe JS interns strings itself?\n        return validValuesMatch\n    }\n\n    picksMatch () {\n        // [\"\"]' != '[]'\n        const a = JSON.stableStringify(this.valueAsArray());\n        const b = JSON.stableStringify(this.pickedValues());\n        if (a === '[\"\"]' && b == '[]') {\n            return true // TODO: fix this hack...\n        }\n        return a === b;\n    }\n\n    needsSyncToSubnodes () {\n        if (this.target()) {\n            const validValuesMatch = this.validValuesMatch()\n            const picksMatch = this.picksMatch();\n            const needsSync = (!validValuesMatch || !picksMatch);\n            return needsSync\n        }\n        return false\n    }\n\n    setupSubnodes () {\n        //debugger\n        if (this.needsSyncToSubnodes() /*&& !this.isSettingUp()*/) {\n            /*\n            if (allSetupOptions.has(this)) {\n                debugger;\n            }\n            */\n            //this.setIsSettingUp(true)\n            //console.log(this.typeId() + \" \" + this.nodePathString() + \" setupSubnodes\");\n            this.removeAllSubnodes()\n            const validValues = this.computedValidValues()\n\n            validValues.forEach(v => {\n                const item = this.itemForValue(v)\n                this.addOptionNodeForDict(item)\n            })\n            //this.copySubnodes(options)\n            //this.scheduleSyncToView()\n            this.setSyncedValidItemsJsonString(JSON.stableStringify(validValues)) \n\n            this.leafSubnodes().forEach(sn => {\n                sn.setIsPicked(this.targetHasPick(sn.value()))\n            })\n\n            if (this.needsSyncToSubnodes()) {\n                console.log(\"\\nERROR: OptionsNode '\" + this.key() + \"' not synced with target after sync!\")\n                console.log(\"Let's try syncing the picked values to the target:\")\n                console.log(\"VALID VALUES:\")\n                console.log(\"  computedValidValues: \" + JSON.stableStringify(this.computedValidValues()));\n                console.log(\"  syncedValidItemsJsonString(): \" +  this.syncedValidItemsJsonString());\n                console.log(\"BEFORE:\")\n                console.log(\"  valueAsArray: \", JSON.stableStringify(this.valueAsArray()))\n                console.log(\"  pickedValues: \", JSON.stableStringify(this.pickedValues()))\n\n                //debugger;\n                this.valueAsArray()\n\n                this.setValueOnTarget(this.formatedPickedValues())\n                \n                console.log(\"AFTER:\")\n                console.log(\"  valueAsArray: \", JSON.stableStringify(this.valueAsArray()))\n                console.log(\"  pickedValues: \", JSON.stableStringify(this.pickedValues()))\n                //debugger;\n                this.valueAsArray()\n                assert(!this.needsSyncToSubnodes()) // important sanity check - maybe values aren't in pickable set?\n            }\n            //this.setIsSettingUp(false)\n            this.didUpdateNodeIfInitialized() // needed?\n            /*\n            allSetupOptions.add(this)\n            assert(allSetupOptions.has(this))\n            */\n        }\n        return this\n    }\n    \n}.initThisClass());\n",
  "3DSbX1r4KRzdot9Vpiq1KXC7hHFdMifQsgvHjYHOATU=": "\"use strict\";\n\n/*\n\n    BMDateNode\n    \n    \n\n*/\n        \n(class BMDateNode extends BMSummaryNode {\n    \n    static availableAsNodePrimitive () {\n        return true;\n    }\n    \n    initPrototypeSlots () {        \n\n        {\n            const slot = this.overrideSlot(\"subnodes\");\n            slot.setShouldStoreSlot(false);\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"year\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"month\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"day\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setDuplicateOp(\"copyValue\");\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"startYear\", 2000);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Number\");\n            slot.setLabel(\"Start year\");\n        }\n\n        {\n            const slot = this.newSlot(\"yearRange\", 20);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setCanInspect(true);\n            slot.setSlotType(\"Number\");\n            slot.setLabel(\"Year range\");\n        }\n    }\n\n    initPrototype () {\n        \n        this.setNoteIconName(\"right-arrow\")\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(false)\n        this.setNodeCanReorderSubnodes(false)\n        this.setCanDelete(true)\n\n        this.setTitle(\"Date\")\n        this.setNodeCanEditTitle(true)\n        this.setNodeCanEditSubtitle(false)\n        this.setNodeCanInspect(true)\n    }\n\n    hasDate () {\n        return !Type.isNull(this.year())\n    }\n\n    jsDate () {\n        //new Date(year, month, day, hours, minutes, seconds, milliseconds)\n        if (this.hasDate()) {\n            const d = new Date(this.year(), this.month(), this.day(), 0, 0, 0, 0, 0)\n            //console.log(\"d = \", d)\n            return d\n        }\n        return null\n    }\n\n    subtitle () {\n        if (this.hasDate()) {\n            const d = this.jsDate()\n            const s = d.monthName() + \" \" + d.dateNumberName() + \", \" + d.getFullYear()\n            const s2 = [this.year(), this.month(), this.day()].join(\"-\")\n            return s2 //+ \" - \" + s\n            return s\n        }\n\n        return \"No date selected\"\n    }\n\n    prepareToSyncToView () {\n        // called after DateNode is selected\n        if (!this.hasSubnodes()) {\n            this.setupSubnodes()\n        }\n    }\n\n    setupSubnodes () {\n        this.removeAllSubnodes()\n        \n        const startYear = this.startYear()\n        const range = this.yearRange()\n\n        const years = []\n        for (let i = startYear; i < startYear + range; i++) {\n            const year = BMYearNode.clone().setValue(i)\n            year.setCanDelete(false)\n            years.push(year)\n        }\n        this.setSubnodes(years)\n    }\n\n    onTapOfDecendantNode (aNode) {\n        if (aNode.type() === \"BMDayNode\") {\n            const dayNode = aNode\n            const monthNode = dayNode.parentNode()\n            const yearNode = monthNode.parentNode()\n            this.setDay(dayNode.value())\n            this.setMonth(monthNode.value())\n            this.setYear(yearNode.value())\n            this.scheduleSyncToView()\n            this.parentNode().postShouldFocusSubnode(this)\n        }\n        return true\n    }\n\n    endYear () {\n        return this.startYear() + this.yearRange()\n    }\n\n    yearRangeOk () {\n        return this.startYear() <= this.endYear()\n    }\n\n    didUpdateSlotStartYear () {\n        if (!this.hasDoneInit()) { // so we ignore the initial setup as a change\n            return\n        }\n\n        if (!this.yearRangeOk()) {\n            this.setEndYear(this.startYear())\n        }\n        this.setupSubnodes()\n    }\n\n    didUpdateSlotEndYear () {\n        if (!this.hasDoneInit()) {\n            return\n        }\n\n        if (!this.yearRangeOk()) {\n            this.setStartYear(this.endYear())\n        }\n        this.setupSubnodes()\n    }\n\n    jsonArchive () {\n        const d = this.jsDate()\n        return d ? d.toString() : null\n    }\n\n}.initThisClass());\n",
  "57nO5dpVhbuV2BRrHpcKEwVM1KcPgYC2onS8OVaIp1M=": "\"use strict\";\n\n/*\n\n    BMYearNode \n    \n*/\n\n(class BMYearNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"allowsMultiplePicks\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"value\", 0);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    initPrototype () {\n        this.setCanDelete(true);\n        this.setNodeCanEditTitle(true);\n\n        //this.setSubnodeProto(BMFolderNode);\n        this.setSubnodeProto(BMOptionNode);\n        this.setNodeCanReorderSubnodes(true);\n\n        //this.setNodeViewClassName(\"BMOptionsNodeView\");\n    }\n\n    title () {\n        return this.value();\n    }\n\n    hasSubnodes () {\n        return true;\n    }\n    \n    prepareToAccess () {\n        //console.log(\"this.storeHasChanged() = \", this.storeHasChanged());\n        if (this.subnodeCount() === 0) {\n            //this.refreshSubnodes();\n        }\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this;\n    }\n\n    prepareToSyncToView () {\n        // called after Node is selected\n        if (!this.subnodeCount()) {\n            for (let i = 1; i < 12 + 1; i++) {\n                const month = this.addSubnode(BMMonthNode.clone().setValue(i));\n                month.setCanDelete(false);\n            }\n        }\n    }\n    \n}.initThisClass());\n",
  "i4XLJI0vP8mmNHZLptlwVMV68F5I6lDIswx3pjiAQ58=": "\"use strict\";\n\n/*\n\n    BMMonthNode \n    \n*/\n\n(class BMMonthNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"value\", 1);\n            slot.setComment(\"month value starts with 1\");\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    initPrototype () {\n        this.setNoteIconName(\"right-arrow\")\n\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setTitle(\"a month\")\n        this.setNodeCanEditTitle(true)\n\n        //this.setSubnodeProto(BMOptionNode)\n        //this.setNodeCanReorderSubnodes(false)\n\n        //this.setNodeViewClassName(\"BMOptionsNodeView\")\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > 0 && v < 13)\n        this._value = v\n        return this\n    }\n\n    year () {\n        const year = this.parentNode().value()\n        return year\n    }\n\n    daysThisMonth () {\n        return new Date(this.year(), this.value() - 1, 0).getDate();\n    }\n\n    monthNames () {\n        return [\"January\", \"February\", \"March\", \"April\", \n            \"May\", \"June\", \"July\", \"August\", \n            \"September\", \"October\", \"November\", \"December\"];\n    }\n\n    monthName () {\n        return this.monthNames()[this.value()-1]\n    }\n\n    title () {\n        return this.monthName()\n    }\n\n    zeroPaddedMonthNumber () {\n        let v = this.value()\n        if (v < 10) { \n            v = \"0\" + v \n        }\n        return v\n    }\n\n    subtitle () {\n        //return this.zeroPaddedMonthNumber()\n        return null\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    prepareToSyncToView () {\n        // called after Node is selected\n        if (!this.subnodeCount()) {\n\n            for (let i = 1; i < this.daysThisMonth() + 1; i++) {\n                const day = BMDayNode.clone().setValue(i)\n                day.setCanDelete(false)\n                this.addSubnode(day)\n            }\n        }\n    }\n    \n}.initThisClass());\n",
  "QIf27shH7r5gzVybYQ3/oL00Y9vW1IDgU7v1eA/TtnU=": "\"use strict\";\n\n/*\n\n    BMDayNode \n    \n*/\n\n(class BMDayNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"value\", 1);\n            slot.setComment(\"day value starts with 1\");\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    initPrototype () {\n        this.setCanDelete(false);\n        this.setNodeCanInspect(false);\n        this.setTitle(\"a day\");\n        this.setNodeCanEditTitle(false);\n        this.setNodeCanReorderSubnodes(false);\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > 0 && v < 32);\n        this._value = v;\n        return this;\n    }\n\n    dayName () {\n        const v = this.value();\n        return v + v.ordinalSuffix();\n    }\n\n    title () {\n        return this.dayName();\n    }\n\n    subtitle () {\n        return null;\n    }\n    \n    note () {\n        return null;\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return null;\n    }\n    \n}.initThisClass());\n",
  "V3gvVUHsXmoS0Ha1FNSKZkWZlw/lc1yzMgNajFOhon4=": "\"use strict\";\n\n/*\n\n    BMTimeNode\n    \n    \n\n*/\n        \n(class BMTimeNode extends BMSummaryNode {\n      \n    static availableAsNodePrimitive () {\n        return true\n    }\n\n    initPrototypeSlots () {\n        this.overrideSlot(\"subnodes\").setShouldStoreSlot(false)\n\n        {\n            const slot = this.newSlot(\"hour\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"minute\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"timezone\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"formatter\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setSlotType(\"TimeFormatter\");\n            slot.setFinalInitProto(TimeFormatter);\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(false);\n        this.setNodeCanReorderSubnodes(false);\n        this.setCanDelete(true);\n\n        this.setTitle(\"Time\");\n\n        this.setNodeCanEditTitle(true);\n        this.setNodeCanEditSubtitle(false);\n        this.setNoteIconName(\"right-arrow\");\n    }\n\n    hasTime () {\n        return !Type.isNull(this.hour())\n    }\n\n    jsDate () {\n        //new Date(year, month, day, hours, minutes, seconds, milliseconds)\n        if (this.hasTime()) {\n            const d = new Date(0, 0, 0, this.hour(), this.minute(), 0, 0, 0)\n            return d\n        }\n        return null\n    }\n\n    timeString () {\n        if (!this.formatter()) { //tmp hack to deal with bug\n            this.setFormatter(TimeFormatter.clone())\n        }\n\n        return this.formatter().setDate(this.jsDate()).formattedValue()\n    }\n\n    subtitle () {\n        if (this.hasTime()) {\n            return this.timeString()\n        }\n\n        return \"No time selected\"\n    }\n\n    prepareToSyncToView () {\n        // called after clicked\n        if (!this.hasSubnodes()) {\n            this.setupHourNodes()\n        }\n    }\n\n    setupHourNodes () {\n        for (let i = 0; i < 23; i++) {\n            const hour = BMHourNode.clone().setValue(i)\n            this.addSubnode(hour)\n        }\n    }\n\n    onTapOfDecendantNode (aNode) {\n        if (aNode.type() === \"BMMinuteNode\") {\n            const minuteNode = aNode\n            const hourNode = minuteNode.parentNode()\n            this.setHour(hourNode.value())\n            this.setMinute(minuteNode.value())\n            this.scheduleSyncToView()\n            this.parentNode().postShouldFocusSubnode(this)\n        }\n        return true\n    }\n\n    jsonArchive () {\n        const d = this.jsDate()\n        return d ? d.toString() : null\n    }\n\n}.initThisClass());\n",
  "lkgiF0eZHkXFSPEImTZ1AbKlHjp8r2UJjM1p8RWAq3c=": "\"use strict\";\n\n/*\n\n    BMHourNode \n    \n*/\n\n(class BMHourNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"value\", 0);\n            slot.setComment(\"0 to 23\");\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    initPrototype () {\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setNodeCanEditTitle(false)\n        this.setNodeCanReorderSubnodes(false)\n\n        this.setNoteIconName(\"right-arrow\")\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > -1 && v < 23)\n        this._value = v\n        return this\n    }\n\n    meridiemName () {\n        if (this.value() > 11) {\n            return \"pm\"\n        }\n        return \"am\"\n    }\n\n    hourName () {\n        let v = this.value() % 12\n        if (v === 0) { v = 12 }\n        return v + \"\" + this.meridiemName()\n    }\n\n    title () {\n        return this.hourName()\n    }\n\n    subtitle () {\n        return null\n    }\n    \n    /*\n    nodeTileLink () {\n        return this\n    },    \n    */\n\n    prepareToSyncToView () {\n        // called after clicked\n        if (!this.hasSubnodes()) {\n            for (let i = 0; i < 60; i += 5) {\n                const minute = BMMinuteNode.clone().setValue(i)\n                this.addSubnode(minute)\n            }\n        }\n    }\n    \n}.initThisClass());\n",
  "CmSbNYcrAZbY4U49L06vAMCkuYWZL8Cl2yhXWiCKgBc=": "\"use strict\";\n\n/*\n\n    BMMinuteNode \n    \n*/\n\n(class BMMinuteNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"value\", 1);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    initPrototype () {\n        this.setCanDelete(false);\n        this.setNodeCanInspect(false);\n        this.setNodeCanEditTitle(false);\n        this.setNodeCanReorderSubnodes(false);\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > -1 && v < 60);\n        this._value = v;\n        return this;\n    }\n\n    minuteName () {\n        let s = this.value();\n        if (s < 10) { \n            s = \"0\" + s;\n        }\n        return s;\n    }\n\n    title () {\n        return this.minuteName();\n    }\n\n    subtitle () {\n        return null;\n    }\n    \n    note () {\n        return null;\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return null;\n    }\n    \n}.initThisClass());\n",
  "22IptqA0jdV9/yTiK7zq4t0sftnsTsxwrUoCJ84bnck=": "\"use strict\";\n\n/*\n\n    BMMeridiemNode \n    \n*/\n\n(class BMMeridiemNode extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"value\", 1);\n            slot.setSlotType(\"Number\");\n        }\n    }\n\n    /*\n    }\n\n    initPrototype () {\n        this.setNoteIconName(\"right-arrow\")\n\n        this.setCanDelete(false)\n        this.setNodeCanInspect(false)\n\n        this.setTitle(\"a month\")\n        this.setNodeCanEditTitle(true)\n\n        //this.setSubnodeProto(BMOptionNode)\n        //this.setNodeCanReorderSubnodes(false)\n\n        //this.setNodeViewClassName(\"BMOptionsNodeView\")\n    }\n\n    setValue (v) {\n        assert(Number.isInteger(v) && v > 0 && v < 13)\n        this._value = v\n        return this\n    }\n\n    year () {\n        const year = this.parentNode().value()\n        return year\n    }\n\n    daysThisMonth () {\n        return new Date(this.year(), this.value() - 1, 0).getDate();\n    }\n\n    monthNames () {\n        return [\"January\", \"February\", \"March\", \"April\", \n            \"May\", \"June\", \"July\", \"August\", \n            \"September\", \"October\", \"November\", \"December\"];\n    }\n\n    monthName () {\n        return this.monthNames()[this.value()-1]\n    }\n\n    title () {\n        return this.monthName()\n    }\n\n    zeroPaddedMonthNumber () {\n        let v = this.value()\n        if (v < 10) { \n            v = \"0\" + v \n        }\n        return v\n    }\n\n    subtitle () {\n        //return this.zeroPaddedMonthNumber()\n        return null\n    }\n    \n    nodeTileLink () {\n        // used by UI tile views to browse into next column\n        return this\n    }\n\n    prepareToSyncToView () {\n        // called after Node is selected\n        if (!this.subnodeCount()) {\n\n            for (let i = 1; i < this.daysThisMonth() + 1; i++) {\n                this.addSubnode(BMDayNode.clone().setValue(i))\n            }\n        }\n    }\n    */\n    \n}.initThisClass());\n",
  "ZwqEyrsIwiegRUceoM3qgH2OyK3FGXJWVHaf8EbK9e4=": "\"use strict\";\n\n/*\n    \n    BMDataStoreRecord\n    \n    A visible representation of a storage record.\n    \n*/\n\n(class BMDataStoreRecord extends BMFieldSetNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"key\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"store\", null);\n            slot.setSlotType(\"Object\"); // TODO: add store protocol\n        }\n    }\n\n    initPrototype () {\n        this.setCanDelete(false); // too dangerous\n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        const jsonField = BMTextAreaField.clone().setKey(\"recordString\")\n        jsonField.setValueMethod(\"recordString\").setValueIsEditable(false).setIsMono(true)\n        this.addField(jsonField)\n\n        this.referencedRecords().forEach((aRecord) => {\n            const node = BMDataStoreRecord.forRecord(aRecord)\n            this.addSubnode(node)\n        })\n    }\n\n    record () {\n        return this.store().recordForPid(this.key())\n    }\n\n    setRecordString (s) {\n        throw new Error(\"not editable\")\n    }\n\n    recordString () {\n        return JSON.stableStringify(this.record(), null, 2)\n    }\n\n    referencedRecords () {\n        return this.referencedPidSet().map( pid => this.defaultStore().recordForPid(pid) )\n    }\n\n    referencedPidSet () {\n        return this.defaultStore().refSetForPuuid(this.record().id)\n    }\n\n    /*\n    delete () {\n        super.delete()\n        this.defaultStore().justRemovePid(this.key())\n        return this\n    }\n    */\n\n    static forRecord (aRecord) {\n        const subnode = BMDataStoreRecord.clone()\n        subnode.setTitle(aRecord.type + \" \" + aRecord.id)\n        //subnode.setTitle(aRecord.id)\n        subnode.setKey(aRecord.id)\n        subnode.setStore(this.defaultStore()) //// <-------------------- avoid this?\n        const size = JSON.stableStringify(aRecord).length\n        subnode.setSubtitle(size.byteSizeDescription())\n        return subnode\n    }\n    \n}.initThisClass());\n\n",
  "7iZ2JhcVFPYsVh3UUpb9lw0kULjzyNJ8GkpR7v08Wsc=": "\n\n.ImageCloseButton {\n\tdisplay: flex;\n\tposition: absolute;\n\t\n\tcolor: rgba(128, 128, 128, 0.5);\n\talign-items: center;\n\tjustify-content: center;\n\n\ttop: 0px;\n\tright: 0px;\n\tmargin: 0px;\n\tpadding: 0px;\t\n\n\tmax-width: 30px;\n\tmin-width: 30px;\n\n\tmin-height: 30px;\n\tmax-height: 30px;\n\n\topacity: 0.3;\n\tz-index: 2;\n\tborder: none;\n\tbox-shadow: none;\n}\n\n.ImageCloseButton:hover {\n\topacity: 1;\n}\n",
  "G1KlHRDjSN76wueBUOXsrwQL5U2xFGd+Ymt6SJv3Rvw=": "\"use strict\";\n\n/*\n\n    NodeView\n\n*/\n\n(class NodeView extends StyledDomView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"node\", null); \n            //slot.setDuplicateOp(\"duplicate\");\n            slot.setSlotType(\"BMNode\")\n        }\n        {\n            const slot = this.newSlot(\"defaultSubviewProto\", null);\n            slot.setSlotType(\"Class\");\n        }\n        {\n            const slot = this.newSlot(\"overrideSubviewProto\", null);\n            slot.setSlotType(\"Class\");\n        }\n        {\n            const slot = this.newSlot(\"nodeObservation\", null);\n            slot.setSlotType(\"BMObservation\");\n        }\n        {\n            const slot = this.newSlot(\"isInspecting\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init()\n        //this.setNodeObservation(BMNotificationCenter.shared().newObservation().setName(\"didUpdateNodeNote\").setObserver(this))\n        this.setNodeObservation(BMNotificationCenter.shared().newObservation().setObserver(this)) // observe all posts from node\n        this.updateSubnodeToSubviewMap()\n        return this\n    } //.setDocs(\"init\", \"initializes the object\", \"returns this\"),\n    \n    setNode (aNode) {\n        if (this._node !== aNode) {\n            this.stopWatchingNode();\n            this._node = aNode;\n            this.startWatchingNode();\n\n            this.updateElementIdLabel();\n            this.didChangeNode();\n        }\n\t\t\n        return this;\n    }\n\n    themeClassName () {\n        if (this.node()) {\n            const name = this.node().themeClassName();\n            if (name) {\n                return name;\n            }\n        }\n        return super.themeClassName();\n    }\n\n    updateElementIdLabel () {\n        this.element().id = this.debugTypeId()\n        return this\n    }\n    \n    didChangeNode () {\n        if (this.node()) {\n            //this.syncFromNode()\n            this.scheduleSyncFromNode()\n        }\n        return this\n    }\n \n    startWatchingNode () {\n        if (this.node()) {\n            /*\n            if (this.node().type() === \"HwLocations\") {\n                console.log(this.typeId() + \" startWatchingNode \" + this.node().typeId());\n                //console.log(this.typeId() + \" startWatchingNode \" + this.node().typeId() + \" observation count = \" + BMNotificationCenter.shared().observations().length);\n            }\n            */\n            this.nodeObservation().setSender(this.node()).startWatching();\n            //this.node().onStartObserving();\n        }\n        return this;\n    }\n       \n    stopWatchingNode () {\n        if (this.node()) {\n            //console.log(\"stopWatchingNode \" + this.node() + \" observation count = \" + BMNotificationCenter.shared().observations().length);\n            this.nodeObservation().stopWatching();\n            //this.nodeObservation().setSender(null);\n            //this.node().onStopObserving();\n        }\n        return this\n    }\n    \n    willRemove () {\n        super.willRemove();\n        this.stopWatchingNode();\n        return this;\n    }\n    \n    subviewProto () {\n        debugger;\n        //console.log(\"looking for subviewProto\")\n        if (this.node()) {\n            const vc = this.node().nodeTileClass();\n            if (vc) { \n                return vc;\n            }\n        }\n        return super.subviewProto();\n    }\n\n    // --- syncing ---\n\n    subviewForNode (aNode) {\n        assert(this._subnodeToSubview);\n        return this._subnodeToSubview[aNode];\n    }\n\n    updateSubnodeToSubviewMap () {\n        // TODO: make this more efficient with add/remove hooks\n        const dict = {};\n        this.subviews().forEach(sv => {\n            if (sv.node) { \n                dict.atSlotPut(sv.node(), sv);\n            } \n        })\n        this._subnodeToSubview = dict;\n        return this;\n    }\n\n    subviewProtoForSubnode (aSubnode) {\n        let proto = this.overrideSubviewProto();\n\t\t\n        if (!proto) {\n\t\t    proto = aSubnode.nodeViewClass();\n        }\n\n        if (!proto) {\n            proto = this.defaultSubviewProto();\n        }\n\t\t\t\t\n        return proto;\n    }\n\n    newSubviewForSubnode (aSubnode) {\n        if (!aSubnode) {\n            throw new Error(\"null aSubnode\");\n        }\n\n        //console.log(this.debugTypeId() + \".newSubviewForSubnode(\" + aSubnode.debugTypeId() + \")\")\n        const proto = this.subviewProtoForSubnode(aSubnode); // this is fast\n\n        if (!proto) {\n            debugger;\n            //aSubnode.nodeViewClass() // used to step into to debug\n            throw new Error(\"no subviewProto for subnode \" + aSubnode.typeId());\n        }\n\n        const instance = proto.clone();\n\n        instance.setNode(aSubnode); // this is fast\n        return instance;\n    }\n\n    updateSubviews () {\n        // for subclasses to override\n        return this;\n    }\n\n    flattenedSubnodes (depth) {\n        if (Type.isUndefined(depth)) {\n            depth = 0;\n        }\n        const subnodes = this.node().subnodes();\n        const flattened = [];\n        subnodes.forEach(subnode => {\n            flattened.push(subnode);\n            if (depth > 0) {\n                subnode.subnodes().forEach(sub => flattened.push(sub));\n            }\n        })\n\n        return flattened;\n    }\n    \n    visibleSubnodes () {\n        const node = this.node();\n        return node.subnodes();\n    }\n\n    syncCssFromNode () {\n        const node = this.node();\n\n        if (node && node.cssVariableDict) {\n            const dict = node.cssVariableDict();\n            if (dict) {\n                this.applyCssVariableDict(dict);\n            }\n        }\n        return this;\n    }\n\n    applyCssVariableDict (dict) {\n        const el = this.element();\n        Object.keys(dict).forEach(k => {\n            const v = dict[k];\n            //el.style.setProperty('--example-variable', v);\n            el.style.setProperty(k, v);\n        })\n    }\n\n    syncFromNode () {\n        let subnodesDidChange = false;\n        // override this method if the view manages it's own subviews\n        const node = this.node();\n\n        if (!node) { \n            if (this.subviews().length > 0) {\n                this.removeAllSubviews();\n                return true;\n            }\n            return false;\n        }\n\n        //this.setIsDisplayHidden(!node.isVisible())\n        this.syncCssFromNode();\n\n        //console.log(\"> \" + this.debugTypeId() + \" syncFromNode\");\n        \n        node.prepareToSyncToView();\n        this.updateSubnodeToSubviewMap(); // not ideal - move this to update on subview add/remove\n       \n        const newSubviews = [];\n        \n        // only replace subviews if sync requires it,\n        // and reuse subviews for subnodes which are still present \n\n        if(this.visibleSubnodes().hasDuplicates()) {\n            throw new Error(\"visibleSubnodes has duplicates\");\n        }\n        \n        //debugger;\n\n        this.visibleSubnodes().forEach(subnode => {\n            let subview = undefined;\n\n            subview = this.subviewForNode(subnode) // get the current view for the node, if there is one\n\n            if (!subview) {\n                subview = this.newSubviewForSubnode(subnode)\n            }\n\n            if (Type.isNull(subview)) {\n                throw new Error(\"null subview\")\n            }\n            \n            //assert(!newSubviews.contains(subview))\n            newSubviews.push(subview)\n\n            /*\n            // this sets the display attribute which my be set elsewhere...\n\n            subview.setIsDisplayHidden(!subnode.isVisible())\n\n            if (!subnode.isVisible()) {\n                debugger;\n                console.log(\"subnode \" + subnode.title() + \" isDisplayHidden: \" + subview.isDisplayHidden())\n            }\n            */\n\n        });\n\n        /*\n        if (!node.isVisible()) {\n            debugger;\n        }\n\n        this.setIsDisplayHidden(!node.isVisible());\n        */\n\n        /*\n        const oldSubviews = this.subviews().shallowCopy()\n        const removedSubviews = newSubviews.difference(oldSubviews)\n        removedSubviews.forEach(sv => {\n            sv.prepareToRetire();\n        })\n        */\n\n        //debugger;\n        \n        if (!newSubviews.isEqual(this.subviews())) {\n            subnodesDidChange = true\n            //this.removeAllSubviews() ;\n            this.removeAllSubviews();\n            this.addSubviews(newSubviews);\n            this.updateSubnodeToSubviewMap();\n            // since node's don't hold a view reference, \n            // subviews no longer referenced in subviews list will be collected\n        }\n\n        this.subviews().forEach(subview => subview.syncFromNodeNow());\n\n        return subnodesDidChange;\n    }\n\n    flipBorderColor () {\n        const coinFlip = (Math.floor(Math.random() * 10) % 2 === 0);\n        const color = coinFlip ? \"red\" : \"blue\";\n        this.element().style.border = \"1px dashed \" + color;\n    }\n\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        super.didUpdateSlot(aSlot, oldValue, newValue);\n\n        if (aSlot.syncsToNode()) { \n            this.scheduleSyncToNode();\n        }\n    }\n    \n    syncToNode () {\n        const node = this.node();\n        if (node) {\n            //node.didUpdateNodeIfInitialized(); // is this needed? Shouldn't the slot hooks cover this?\n        }\n        return this;\n    }\n\n    onUpdatedNode (aNote) {\n        assert(aNote);\n        //this.debugLog(\" didUpdateNode \" + this.node().type());\n        this.scheduleSyncFromNode();\n    }\n    \n    scheduleSyncToNode (priority = 0) {\n        if (this.hasScheduleSyncFromNode()) {\n            this.hasScheduleSyncFromNode();\n            console.log(\"SKIPPING scheduleSyncToNode because hasScheduleSyncFromNode\");\n            this.unscheduleSyncFromNode();\n            return this;\n        }\n        \n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncToNode\", priority);\n        return this;\n    }\n    \n    hasScheduleSyncToNode () {\n        return SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, \"syncToNode\");\n    }\n\n    hasScheduleSyncFromNode () {\n        return SyncScheduler.shared().isSyncingOrScheduledTargetAndMethod(this, \"syncFromNode\");\n    }\n\n    scheduleSyncFromNode () {\n        assert(!this.hasScheduleSyncToNode());\n        SyncScheduler.shared().scheduleTargetAndMethod(this, \"syncFromNode\", 2); // let posts happen first\n        return this;\n    }\n\n    unscheduleSyncFromNode () {\n        SyncScheduler.shared().unscheduleTargetAndMethod(this, \"syncFromNode\");\n    }\n\n    syncFromNodeNow () { // unschedule syncFromNode if scheduled, and call syncFromNode now\n        this.unscheduleSyncFromNode();\n        this.syncFromNode();\n    }\n\n    // logging \n    \n    logName () {\n        return this.type();\n    }\n    \n    log (msg) {\n        const s = \"[\" + this.logName() + \"] \" + msg;\n        console.log(s);\n        return this;\n    }\n    \n    // visibility\n    \n    onVisibility () {\n\t    super.onVisibility();\n\t    //this.debugLog(\".onVisibility()\");\n\t    const node = this.node();\n\t    if (node && node.nodeBecameVisible) {\n\t        node.nodeBecameVisible();\n\t    }\n\n\t    return this;\n    }\n    \n    // value\n    \n    setValue (newValue) {\n        this.setInnerHtml(newValue);\n        return this;\n    }\n    \n    value () {\n        return this.innerHtml();\n    }\n\n    // ---\n\n    resyncAllViews () {\n        if (!this.hasScheduleSyncToNode()) {\n            this.scheduleSyncFromNode();\n        }\n        this.subviews().forEach(sv => sv.resyncAllViews());\n        //super.resyncAllViews(); // skip this as it calls updateSubviews, but we'll do that in syncFromNode\n        return this;\n    }\n\n    // --- debugging ---\n\n    nodeTitle () {\n        const node = this.node();\n        if (node) {\n            return node.title();\n        }\n        return null;\n    }\n    \n    // --- helpers ---\n\n    nodeDescription () {\n        const node = this.node();\n        if (node) {\n            return node.debugTypeId();\n        }\n        return null;\n    }\n\n    nodeId () {\n        const node = this.node();\n        const nodeId = node ? node.debugTypeId() : \"null\";\n        return nodeId;\n    }\n\n    debugTypeId () {\n        //return this.nodeDescription();\n        //return super.debugTypeId() + this.debugTypeIdSpacer() + this.nodeDescription() + \" theme:\" + this.themeClassName();\n\n        let s = \"view:'\" + this.typeId() + \"'\";\n        s += \" node:'\" + this.nodeId() + \"'\";\n        s += \" themeClass:'\" +this.themeClassName() + \"'\";\n        if (this.node()) {\n            s += \" nodeTileClassName:'\" + this.node().nodeTileClassName() + \"'\";\n        }\n\n        if (this.isVertical) {\n            s += \" isVertical:\" + this.isVertical();\n        }\n        return s;\n    }\n\n}.initThisClass());\n",
  "kpiBNLR3D9vUtejaDB0kYeCpEFqcLVR7tPf3D4Esgvs=": "\"use strict\";\n\n/*\n\n    ImageWellView\n\n    - designed to contain an ImageView\n    - can have it's own frame and decoration\n    - supports drag & drop of images \n\n*/\n\n(class ImageWellView extends NodeView {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"imageView\", null);\n            slot.setSlotType(\"ImageView\");\n        }\n        {\n            const slot = this.newSlot(\"isEditable\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setDisplay(\"flex\");\n        this.setPosition(\"relative\");\n        this.setJustifyContent(\"center\");\n        this.setAlignItems(\"center\");\n        this.setMinHeight(\"10em\");\n        this.setMinWidth(\"10em\");\n        this.setOverflowX(\"hidden\");\n        this.setOverflowY(\"hidden\");\n        this.setBorder(\"1px solid #444\");\n        this.setColor(\"white\");\n        this.setBackgroundColor(\"transparent\");\n\n        this.setIsRegisteredForBrowserDrop(true);\n        this.dragUnhighlight();\n        this.turnOffUserSelect();\n        this.autoFitParentWidth();\n        this.autoFitChildHeight();\n        this.setMinHeightPx(100);\n        this.setPadding(\"0px\");\n        return this;\n    }\n\n    syncToNode () {\n        super.syncToNode();\n        if (this.imageView()) {\n            this.node().setDataUrl(this.imageView().dataURL()); // untested\n        }\n        this.tellParentViews(\"didUpdateImageWellView\", this);\n        return this\n    }\n    \n    isEditable () {\n        // we need this to override the normal isContentEditable return value\n        return this._isEditable;\n    }\n    \n    setIsEditable (aBool) {\n        this._isEditable = aBool;\n        if (this.imageView()) {\n            this.imageView().setIsEditable(aBool);\n        }\n        return this;\n    }\n    \n    dragHighlight () {\n        this.setBackgroundColor(\"rgba(128, 128, 128, 0.5)\");\n    }\n    \n    dragUnhighlight () {\n        this.setBackgroundColor(\"transparent\");\n    }\n    \n    isFull () {\n        //console.log(\"this.imageView().dataURL()  = \", this.imageView().dataURL() );\n        return this.subviews().length > 0;\n    }\n    \n    acceptsDrop (event) {\n        return true;\n        //return this.isEditable();     \n    }\n\n    /*\n    onBrowserDrop (event) {\n        return super.onBrowserDrop(event);\n    }\n\n    onBrowserDragOver (event) {\n        const r =  super.onBrowserDragOver(event);\n        //console.log(this.debugTypeId() + \" onBrowserDragOver() -> \" + r);\n        return r;\n    }\n    */\n\n    setValue (aValue) {\n        this.setImageDataUrl(aValue)\n        return this\n    }\n\n    value () {\n        return this.imageDataUrl()\n    }\n    \n    setImageDataUrl (dataURL) {\n        assert(!Type.isArray(dataURL)) \n\n        if (this.hasImageUrl(dataURL)) {\n            return this\n        }\n        \n        this.removeAllSubviews()\n\n        const v = ImageView.clone()\n        this.setImageView(v)\n        this.addSubview(v)\n\n        if (!Type.isNullOrUndefined(dataURL) && Type.isString(dataURL)) {\n            /*\n            const v = ImageView.clone()\n            this.setImageView(v)\n            this.addSubview(v)\n            */\n\n            v.fetchDataURLFromSrc(dataURL)\n            v.autoFitChildHeight()\n            v.autoFitParentWidth()\n        }\n\n        return this\n    }\n\n    hasImageUrl (url) {\n        const v = this.imageView()\n        if (v) {\n            if (url === v.dataURL() || url === v.srcUrl()) {\n                return true\n            }\n        }\n        return false\n    }\n    \n    imageDataUrl () {\n        const v = this.imageView()\n        if (v && v.dataURL()) {\n            return v.dataURL()\n        }\n        return null\n    }\n    \n\n    // need these as method name is constructed from MIME type\n\n    onBrowserDropImageJpeg (dataChunk) {\n        this.droppedImageData(dataChunk)\n    }\n\n    onBrowserDropImageGif (dataChunk) {\n        this.droppedImageData(dataChunk)\n    }\n\n    onBrowserDropImagePng (dataChunk) {\n        this.droppedImageData(dataChunk)\n    }\n\n    // image data chunk\n\n    droppedImageData (dataChunk) {\n        this.setImageDataUrl(dataChunk.dataUrl())\n        this.scheduleSyncToNode();\n        return this        \n    }\n    \n    willRemoveSubview (aSubview) {\n        super.willRemoveSubview(aSubview)\n\n        if (aSubview === this.imageView()) {\n            this.setImageView(null)\n        }\n        return this\n    }\n    \n}.initThisClass());\n",
  "cevdWy6rOb/1bhL2tBLnpwu7vSjW1QQTUkoNpWhcd9E=": "\"use strict\";\n\n/*\n\n    ImageView\n\n*/\n\n(class ImageView extends NodeView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"imageContainer\", null);\n            slot.setSlotType(\"FlexDomView\");\n        }\n        {\n            const slot = this.newSlot(\"rawImageView\", null);\n            slot.setSlotType(\"FlexDomView\");\n        }\n        {\n            const slot = this.newSlot(\"closeButtonView\", null);\n            slot.setSlotType(\"FlexDomView\");\n        }\n        {\n            const slot = this.newSlot(\"srcUrl\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"dataURL\", null);\n            slot.setSyncsToNode(true);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"isEditable\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init();\n        this.setDisplay(\"flex\");\n        this.setPosition(\"relative\");\n        this.setJustifyContent(\"center\");\n        this.setAlignItems(\"center\");\n        this.setOverflow(\"hidden\");\n        this.setWidth(\"auto\");\n        this.setHeight(\"auto\");\n        //this.setIsRegisteredForBrowserDrop(false);\n\n        // image container\n        const ic = this.newImageViewContainer();\n        this.setImageContainer(ic);\n        this.addSubview(ic);\n\n        // close button\n        const cb = this.newCloseButtonView();\n        this.setCloseButtonView(cb);\n        this.addSubview(cb);\n\n        this.setIsEditable(false);\n        this.dragUnhighlight();\n        this.turnOffUserSelect();\n        return this;\n    }\n\n    newCloseButtonView () {\n        const v = ButtonView.clone().setElementClassName(\"ImageCloseButton\");\n        v.setDisplay(\"flex\");\n        v.setPosition(\"absolute\");\n        v.setTitleIsVisible(false);\n        v.setTopPx(0);\n        v.setRightPx(0);\n        v.setTarget(this).setAction(\"close\");\n        v.setIconName(\"close\");\n        return v;\n    }\n\n    newImageViewContainer () {\n        const v = FlexDomView.clone().setElementClassName(\"ImageViewImageContainer\");\n        v.setDisplay(\"flex\");\n        v.setPosition(\"relative\");\n        v.setJustifyContent(\"center\");\n        v.setAlignItems(\"center\");\n        v.setOverflow(\"hidden\");\n        v.setWidth(\"auto\");\n        v.setHeight(\"auto\");\n        return v;\n    }\n\n    setIsRegisteredForBrowserDrop(aBool) {\n        throw new Error(\"shouldn't be called\");\n    }\n\n    // --- editable ---\n    \n    setIsEditable (aBool) {\n        this.closeButtonView().setIsDisplayHidden(!aBool);\n        return this;\n    }\n\n    setEditable (aBool) {\n        // to avoid editable content?\n        return this;\n    }\n    \n    acceptsDrop () {\n        return false;\n    }\n\n    // --- close button ---\n\n    collapse () {\n        this.closeButtonView().setOpacity(0).setTarget(null);\n        this.setOpacity(0);\n\t\t\n        this.setWidth(\"0px\");\n\t\t\n        this.setPaddingLeftPx(0);\n        this.setPaddingRightPx(0);\n\t\t\n        this.setMarginLeft(0);\n        this.setMarginRightPx(0);\n    }\n    \n    close () {\n        const seconds = 0.3;\n\t\t\n        this.collapse();\n        \n        this.addTimeout( () => { \n            this.closeButtonView().hideDisplay();\n            const parentView = this.parentView();\n            this.removeFromParentView();\n            parentView.scheduleSyncToNode(); // is this needed?\n        }, seconds * 1000);\n    }\n\n    // --- sync ---\n\n    hasImageUrl (url) {\n        return (url === v.dataURL() || url === v.srcUrl());\n    }\n    \n    removeRawImageView () {\n        if (this.rawImageView()) {\n            this.imageContainer().removeSubview(this.rawImageView());\n            this.setRawImageView(null);\n        }\n        return this;\n    }\n    \n    fetchDataURLFromSrc (src) {\n        if (src.startsWith(\"data:\")) {\n\t        this.setFromDataURL(src);\n        } else {\n            const img = new Image();\n            img.setDelegate(this);\n            img.loadUrl(src);\n            this.setSrcUrl(src);\n        }\n\t\t\n        return this;\n    }\n    \n    didFetchDataUrl (dataURL) {\n        this.setFromDataURL(dataURL);\n        return this;\n    }\n\n    newRawImageViewForImage (image) {\n        const v = FlexDomView.clone().setElement(image).setElementClassName(\"RawImageView\");\n        v.setDisplay(\"flex\");\n        v.setPosition(\"relative\");\n        v.setJustifyContent(\"center\");\n        v.setAlignItems(\"center\");\n        v.setOverflow(\"hidden\");\n        v.makeStandardFlexView();\n        v.setWidth(\"fit-content\");\n        v.setHeight(\"auto\");\n        return v;\n    }\n\n    setFromDataURL (dataURL) {\n        //console.log(\"setFromDataURL: \", dataURL);\n        assert(!Type.isNull(dataURL));\n        assert(dataURL.startsWith(\"data:\")) ;\n\n        this.removeRawImageView();\n        this.setDataURL(dataURL);\n\n        const image = new Image();\n        image.src = dataURL;\n\n        const v = this.newRawImageViewForImage(image);\n        this.setRawImageView(v);\n        this.imageContainer().addSubview(v);\n\t\n        return this;\n    }\n    \n}.initThisClass());\n",
  "if3crRdrvgPbOq9SFaxK8pxMj9nMfa1ZaLiHX+tjFh8=": "\n/*\n.BrowserDefaultHeader {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    height: 40px;\n    width: 100%;\n    background-color: #dbdbdb;\n    text-align: right;\n    font-style: bold;\n\tz-index: 1;\n}\n*/\n\n /*  removes scrollbars on Safari and Chrome */\n.BrowserScrollView::-webkit-scrollbar { \n    display: none; \n}\n\n/* \nnotes on Scroll bars theme options\n*/\n::-webkit-scrollbar {  display: none; width: 10px; } \n/*\n::-webkit-scrollbar-button { display: none; }\n*/\n::-webkit-scrollbar-thumb { background-color: #aaa; outline: 1px solid #aaa; } \n::-webkit-scrollbar-thumb:hover { background: #b1b1b1; }\n/*\n::-webkit-scrollbar-track { background: transparent; } \n::-webkit-scrollbar-track-piece { background: transparent; }\n::-webkit-scrollbar-corner { background: transparent; }\n::-webkit-resizer { background: transparent; }\n*/\n\n\n",
  "H2ZV1KRu/g3FV4cKWhrC8Ja8EhH4qhqjUhlZ2++ghr8=": "\"use strict\";\n\n/*\n    \n    StackView\n\n    A view from which of generalized (mixed vertical and horizontal) Miller Column system can be built.\n    \n    Overview of view structure:\n\n        StackView contains:\n            |- navView, which is a NavView and contains:\n                |- scrollView, which is a StackScrollView and contains:\n                    |- tilesView, which is a TilesView contains array of: \n                        |->> Tiles(or subclass), (each of which contains a contentView, so things like slide-to-delete gestures work)\n            |- otherView, which is a FlexDomView whose content is used to display the selected ite, and can be set with setOtherViewContent()\n        \n    \n        There is also a \"direction\" attribute. If it's value is:\n        - \"right\": the navView is on the left, and otherView is on the right, causing navigation to head towards the left\n        - \"down\": the navView is on the top, and otherView is on the bottom, causing navigation to head downwards\n\n        Note: TilesViews will ask their parent StackView about their direction setting to determine the orientation layout of their subviews\n\n        The direction for child StackViews can be set individually, so for example, we could use a \"down\" direction for the \n        topmost StackView or first few levels (so there will be left to right navigation menus at the top level) \n        while children could use the \"right\" direction so navigation under the top level is left to right.\n\n        In this way, we can compose most common hierarchical navigation systems out of this single view type, \n        maximizing code reuse and flexibility. For example:\n        - developer can change layout without code changes\n        - layout could flexibly change with display size \n        - each user could potentially chose a preferred layout\n\n        This also means all the logic around expanding, collapsing, selecting, navigating the views\n        can be reused among all the possible navigation layouts.\n\n    Overview of expand/collapse behavior:\n\n        The StackView will try to collapse and expand levels of navigation to make the best use of the available display area.\n        For example, as one navigates deeper into the hierarchy such that the columns would consume the width of the display,\n        the top most views will start collpasing to allow the deepest views to be displayed. \n\n        The relevant method is:\n        StackView.updateCompactionChain()\n    \n    Drag & Drop:\n\n        When dragging & dropping, hierarchy views for nodes are cached (in nodeToStackCache) in order to make the drag & drop implementation\n        more manageable. For example, the source tilesView needs to remember where the dragged item was when returning to it.\n\n*/\n\n(class StackView extends NodeView {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"navView\", null);\n            slot.setSlotType(\"NavView\");\n        }\n        {\n            const slot = this.newSlot(\"otherView\", null);\n            slot.setSlotType(\"FlexDomView\");\n        }\n        {\n            const slot = this.newSlot(\"direction\", \"down\");\n            slot.setDoesHookSetter(true); // valid values: left, right, up, down\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"lastPathString\", null);\n            slot.setSlotType(\"String\");\n            slot.setAllowsNullValue(true);\n        }\n        {\n            const slot = this.newSlot(\"onStackViewPathChangeNote\", null);\n            slot.setSlotType(\"BMNotification\");\n        }\n        {\n            const slot = this.newSlot(\"nodeToStackCache\", null);\n            slot.setSlotType(\"Map\");\n        }\n    }\n\n    init () {\n        super.init()\n\n        this.setNodeToStackCache(null);\n        \n        this.setDisplay(\"flex\");\n        this.setPosition(\"relative\");\n        this.setWidth(\"100%\");\n        this.setHeight(\"100%\");\n        this.setMinHeight(\"100%\");\n\n        this.setFlexDirection(\"row\");\n        this.setFlexWrap(\"nowrap\");\n        this.setOverflow(\"hidden\");\n\n        this.setupNavView();\n        this.setupOtherView();\n\n        //this.setBorder(\"1px dashed white\");\n\n        this.setFlexBasis(\"fit-content\");\n        this.setFlexBasis(\"auto\");\n        this.setFlexGrow(1);\n        this.setFlexShrink(0);\n\n        // events\n        this.setIsRegisteredForWindowResize(true);\n        //this.addGestureRecognizer(LeftEdgePanGestureRecognizer.clone());\n        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone());\n        this.setOnStackViewPathChangeNote(this.newNoteNamed(\"onStackViewPathChange\"));\n\n        this.syncOrientation();\n        return this;\n    }\n\n    /*\n    didUpdateSlotParentView (oldValue, newValue) { \n        super.didUpdateSlotParentView(oldValue, newValue);\n        console.log(this.typeId() + \".didUpdateSlotParentView(\", oldValue.typeId(), \",\", newValue.typeId(), \")\");\n        return this;\n    }\n    */\n\n    setupNavView () {\n        const v = NavView.clone();\n        v.setStackView(this);\n        this.setNavView(v);\n        this.addSubview(v);\n        return this;\n    }\n\n    setupOtherView () {\n        const v = FlexDomView.clone();\n        v.setFlexGrow(1);\n        v.setFlexShrink(1);\n        v.setFlexDirection(\"column\");\n        v.setWidth(\"100%\");\n        v.setHeight(\"100%\");\n        this.setOtherView(v);\n        this.addSubview(v);\n        this.clearOtherView();\n        return this;\n    }\n\n    // --- direction ---\n\n    didUpdateSlotDirection () {\n        this.syncOrientation();\n    }\n\n    syncOrientation () {\n        const d = this.direction();\n        const nv = this.navView();\n        if (d === \"right\") {\n            this.makeOrientationRight();\n        } else if (d == \"down\") {\n            this.makeOrientationLeft();\n        } else {\n            throw new Error(\"unimplmented direction '\" + d + \"'\");\n        }\n        this.navView().syncOrientation();\n    }\n\n    makeOrientationRight () {\n        this.setFlexDirection(\"row\");\n        return this;\n    }\n\n    makeOrientationLeft () {\n        this.setFlexDirection(\"column\");\n        return this;\n    }\n\n    /*\n    verifyOrientation () {\n        const d = this.direction();\n        if (d == \"right\");\n    }\n    */\n    \n    /*\n    setFlexDirection (v) {\n        if (this.flexDirection() === \"column\" && v == \"row\") {\n            debugger; // why are we switching back to row?\n        }\n        super.setFlexDirection(v);\n        return this;\n    }\n    */\n\n    setNode (aNode) {\n        if (aNode !== this.node()) {\n            if (aNode && this.node() && this.previousStackView() && this.previousStackView().isCaching()) {\n                throw new Error(\"this might invalidate a cache\");\n            }\n            if (aNode) {\n                this._nodePathString = aNode.nodePathString();\n            }\n            super.setNode(aNode);\n        }\n        return this;\n    }\n\n    didChangeNode () {\n        super.didChangeNode();\n        this.navView().setNode(this.node());\n        return this;\n    }\n\n    syncFromNode () {\n        this.setDirection(this.node().nodeOrientation());\n\n        this.syncOrientation();\n        //this.navView().syncFromNodeNow();\n        this.syncFromNavSelection();\n\n        //this.setupColumnGroupColors();\n        //this.fitColumns();\n        return this;\n    }\n\n    onWindowResize (event) {\n        /*\n        if (this.isRootStackView()) {\n            this.safeUpdateCompactionChain();\n        }\n        */\n        // TODO: change so only top stack view registers for resize\n        this.updateCompaction();\n        return this;\n    }\n\n    setOtherViewContent (v) {\n        const ov = this.otherView();\n        ov.setFlexBasis(null);\n        ov.setFlexGrow(1);\n        ov.setFlexShrink(1);\n        \n        /*\n        if (ov.subviews().length) {\n            const names = ov.subviews().map(ov => ov.typeId());\n            //console.log(\"removing subviews: \", names);\n            debugger;\n        }\n        */\n        \n        ov.removeAllSubviews().addSubview(v);\n        return this;\n    }\n\n    clearOtherView () {\n        const ov = this.otherView();\n        ov.setFlexBasis(\"0px\");\n        ov.setFlexGrow(0);\n        ov.setFlexShrink(0);\n\n        /*\n        if (ov.subviews().length) {\n            const names = ov.subviews().map(ov => ov.typeId());\n            //console.log(\"removing subviews: \", names);\n            //debugger;\n        }\n        */\n        \n        ov.removeAllSubviews();\n        return this;\n    }\n\n    otherViewContent () {\n        return this.nextStackView();\n    }\n\n    // notifications\n    \n    tilesView () {\n        return this.navView().tilesView();\n    }\n\n    selectNodePathArray (nodePathArray) {  \n        if (nodePathArray.length === 0) { \n            //console.log(\"- only one node in pathArray and it is ours, so unselecting all subtiles and we're done!\")\n            // no selections left so unselect next\n            this.tilesView().unselectAllTiles();\n            this.syncFromNavSelection();\n            return true;\n        }\n\n        nodePathArray = nodePathArray.shallowCopy();\n        // the path should start with the node *after* this one\n        \n        //const p = nodePathArray.map(n => n.title()).join(\"/\");\n        //console.log(\"--- selectNodePathArray ---\");\n        //console.log(this.type() + \" \" + this.node().nodePathString() + \" selectNodePathArray(\" + nodePathArray.map(node => \"'\" + node.title() + \"'\").join(\", \") + \")\");\n        const node = nodePathArray.shift(); // pop the first node off (it should be us) and select the next one from our tiles, then pass remaining paths to the tile's stackview\n        //console.warn(\"- popped '\" + node.title() + \"'\");\n\n        //this.syncFromNodeNow();\n        assert(node !== this.node());\n\n        /*\n        console.log(\"1 this.tilesView().node().subnodes(): \", this.tilesView().node().subnodes());\n        this.tilesView().syncFromNodeNow(); //test\n        console.log(\"2 this.tilesView().subviews(): \", this.tilesView().subviews());\n        */\n\n        let selectedTile = this.tilesView().selectTileWithNode(node);\n\n        if (!selectedTile) {\n            // if we didn't find the tile but the node is a subnode, sync the tilesView and look again\n            if (this.tilesView().node().subnodes().contains(node)) {\n                //console.warn(\"- the tilesView node's subnodes contain the path node, but there's no matching view!\");\n               // console.log(\"- so syncFromNodeNow and see if we can find it\");\n                this.tilesView().syncFromNodeNow();\n                selectedTile = this.tilesView().selectTileWithNode(node);\n                assert(selectedTile);\n            }\n        }\n\n        if (!selectedTile) { // INVALID PATH ERROR\n            console.log(\"- invalid path - can't find tile for node: \" + node.title());\n\n            console.log(\"debug info:\");\n            console.log(\"  looking for node: \", node.debugTypeId());\n            const subnodeIds = this.tilesView().node().subnodes().map(node => node.debugTypeId());\n            console.log(\"  subnodes:\" + JSON.stableStringify(subnodeIds) );\n\n            debugger;\n            return false;\n        }\n\n        //this.syncFromNavSelection();\n        //console.log(\"- selectedTile '\" + selectedTile.node().title() + \"'\");\n\n        const childStack = this.nextStackView();\n        if (childStack) {\n            childStack.selectNodePathArray(nodePathArray);\n        }\n        return true;\n    }\n\n    selectedNodePathArray () {\n        // grab the whole chain of stack view\n        const parts = this.stackViewSubchain().shallowCopy();\n        \n        // last one might not have a node\n        while (parts.last() && Type.isNullOrUndefined(parts.last().node())) {\n            //debugger;\n            parts.removeLast();\n        }\n\n        return parts.map(sv => {\n            if (!sv.node()) {\n                debugger;\n            }\n            return sv.node();\n        })\n    }\n\n    /*\n    selectedNodePathArray () {\n        return this.stackViewSubchain().map(sv => {\n            if (!sv.node()) {\n                debugger;\n            }\n            return sv.node()\n        })\n    }\n    */\n\n    isRootStackView () {\n        return this === this.rootStackView();\n    }\n\n    topDidChangeNavSelection () {\n        // broadcast path change to listeners, like bread crumb view\n        //console.log(\"topDidChangeNavSelection\");\n        //debugger;\n        if (!this.rootStackView()) {\n            debugger;\n            return this;\n        }\n\n        const currentPathString = this.selectedPathTitlesString();\n        // TODO: change to node matching as path isn't unique and names can change\n        if (this.lastPathString() !== currentPathString) {\n            this.setLastPathString(currentPathString);\n            this.didChangePath();\n        }\n        return this;\n    }\n\n    didChangeNavSelection () {\n        this.rootStackView().topDidChangeNavSelection();\n        //this.syncFromNavSelection();\n        this.syncFromNavSelection();\n        //this.scheduleSyncFromNode();\n        return true;\n    }\n\n    // --- set path titles ----\n\n    setSelectedPathTitlesArray (titles) {\n        let title = titles.shift();\n        const pathArray = [];\n        let node = this.node();\n        while (title) {\n            node = node.firstSubnodeWithTitle(title);\n            pathArray.push(node);\n            title = titles.shift();\n        }\n        this.selectNodePathArray(pathArray);\n        return this;\n    }\n\n    setSelectedPathTitlesString (s) {\n        console.log(\"setSelectedPathTitlesString:'\" + s + \"'\");\n        const titles = s.split(\"/\");\n        this.setSelectedPathTitlesArray(titles);\n        return this;\n    }\n\n    // --- get path titles ----\n\n    selectedPathTitlesArray () {\n        const titles = this.selectedNodePathArray().map(node => {\n            return node.title();\n        })\n        titles.shift();\n        return titles;\n    }\n\n    selectedPathTitlesString () {\n        return this.selectedPathTitlesArray().join(\"/\");\n    }\n\n    // --- this view's path string ---\n\n    pathString () {\n        return this.stackViewSuperChain().reverse().map(sv => sv.node().title()).join(\"/\");\n    }\n\n    // --- selected path changes ---\n\n    didChangePath () {\n        this.onStackViewPathChangeNote().post();\n        return this;\n    }\n    \n    // ----------------\n\n    scheduleSyncFromNode () {\n     //   debugger;\n        super.scheduleSyncFromNode();\n    }\n\n    syncFromNavSelection () {\n        // update otherViewContent view to match selected tile\n\n        const tile = this.navView().tilesView().selectedTile(); // this may get called before tilesView has synced to current subnodes,\n        //console.log(\"StackView syncFromNavSelection \" + this.node().title() + \" -> \" + (tile ? tile.nodeTitle() : null));\n        //debugger;\n        // in which case, the tile may be about to be removed\n        if (tile && tile.nodeTileLink()) {\n            const oNode = tile.nodeTileLink();\n            const ovc = this.otherViewContent();\n            if (!ovc || (ovc.node() !== oNode)) {\n                const ov = this.otherViewContentForNode(oNode);\n                this.setOtherViewContent(ov);\n            }\n        } else {\n            this.clearOtherView();\n        }\n\n        this.safeUpdateCompactionChain();\n    }\n\n    // stack view chain\n\n    previousStackView () {\n        // this stackView -> otherView -> previousStackView\n        const otherView = this.parentView();\n        if (otherView) {\n            const previousStackView = otherView.parentView();\n            if (previousStackView && previousStackView.previousStackView) {\n                //if (previousStackView.isSubclassOf(StackView)) {\n                return previousStackView;\n            }\n        }\n        /*\n        if (p && p.previousStackView) {\n            return p.parentView();\n        }\n        */\n        return null;\n    }\n\n    nextStackView () {\n        return this.otherView().subviews().first();\n    }\n\n    rootStackView () {\n        let p = this;\n        while (p.previousStackView()) {\n            p = p.previousStackView();\n        }\n        return p;\n    }\n\n    // --- compaction (adjusts number of visible stack areas to fit top stack view)\n\n    safeUpdateCompactionChain () {\n        //this.bottomStackView().updateCompactionChain();\n        this.updateCompactionChain();\n    }\n\n    updateCompactionChain () {\n        this.updateCompaction();\n        this.tellParentViews(\"updateCompaction\");\n    }\n\n    updateCompaction () {\n        this.compactNavAsNeeded();\n        return this;\n    }\n\n    /*\n    firstParentWithDifferentDirection () {\n        const d = this.direction();\n        let current = this\n        while (current) {\n            const p = current.previousStackView();\n            if (p && p.direction() !== d) {\n                break;\n            }\n            current = p;\n        }\n        return current;\n    }\n    */\n\n    stackViewSuperChain () {\n        // returns list of self and StackViews above\n        const chain = [];\n        let current = this;\n        while (current) {\n            chain.push(current);\n            const p = current.previousStackView();\n            current = p;\n        }\n        return chain;\n    }\n\n    stackViewDepth () {\n        return this.stackViewSuperChain().length - 1;\n    }\n\n    bottomStackView () {\n        let current = this;\n\n        while (current) {\n            const next = current.nextStackView();\n            if (next) {\n                current = next;\n            }\n        }\n        return current;\n    }\n\n    stackViewSubchain () {\n        // returns self and all StackViews below \n        const chain = [];\n        let current = this;\n\n        while (current) {\n            chain.push(current);\n            current = current.nextStackView();\n        }\n        return chain;\n    }\n\n    navViewSubchain () {\n        return this.stackViewSubchain().map(sv => sv.navView());\n    }\n\n    sumOfNavWidths () { \n        // Returns sum of self and all preceeding vertical nav view widths.\n        // This is used for compacting\n        \n        // NOTES:\n        // - We assume no direct compaction of horizontal nav views (e.g. horizontal menus)\n        //  ** so we need to skip summing widths of horizontal nav views \n        //     as well as compacting them \n        // - Even if vertical and horizontal navs are interleaved, \n        //   we treat all vertical nav view compactions \n        //   as if they are part of the same Miller Column.\n\n        const verticalNavViews = this.navViewSubchain().filter(nv => nv.isVertical());\n        const w = verticalNavViews.sum(nv => nv.targetWidth());\n        return w;\n\n        /*\n        let w = 0;\n        const views = this.stackViewSubchain();\n        for (let i = 0; i < views.length; i++) { // use loop so we can break\n            const sv = views[i];\n\n            //if (sv.direction() !== this.direction()) {\n            //    break;\n            //}\n\n            if (sv.navView().isVertical()) {\n                w += sv.navView().targetWidth();\n            }\n        }\n        return w;\n        */\n    }\n\n    topViewWidth () {\n        const view = this.rootStackView();\n        if (view.parentView() === DocumentBody.shared()) {\n            return window.innerWidth; // assume it fills the window? what about margins, padding?\n        }\n        return view.size().width(); // clientWidth works here, but maybe all cases\n        //return this.rootStackView().calcSize().width();\n    }\n\n    compactNavAsNeeded () {\n        if (this.direction() === \"right\") {\n            //console.log(\"StackView \" + this.node().title() + \" compactNavAsNeeded\");\n\n            const maxWidth = this.topViewWidth();\n            const sum = this.sumOfNavWidths();\n\n            if (sum > maxWidth) {\n                //console.log(\"  \" + this.node().title() + \" sum \" + sum + \" > win \" + maxWidth + \" COLLAPSE\");\n                //debugger;\n                //this.topViewWidth();\n\n                this.navView().collapse();\n            } else {\n                //console.log(\"  \" + this.node().title() + \" sum \" + sum + \" < win \" + maxWidth + \" UNCOLLAPSE\");\n                this.navView().uncollapse();\n            }\n        }\n\n        return false;\n    }\n\n    // --- caching during dragging ---\n\n    // dragging events to start/end caching\n\n    onStackChildDragSourceEnter (dragView) {\n        if (!this.isCaching()) {\n            console.log(this.debugTypeId() + \" onStackChildDragSourceEnter\");\n            this.watchOnceForNoteFrom(\"onDragViewClose\", dragView);\n            //this.beginCaching();\n            this.rootStackView().beginCaching();\n        }\n    }\n\n    onDragViewClose (aNote) {\n        console.log(this.debugTypeId() + \" onDragViewClose\");\n        //this.endCaching();\n        this.rootStackView().endCaching();\n    }\n\n    // begin / end caching\n\n    isCaching () {\n        return !Type.isNull(this.nodeToStackCache());\n    }\n\n    beginCaching () {\n        // begins caching on all chained substacks\n        if(!this.isCaching()) {\n            //console.log(this.debugTypeId() + \" beginCaching -----------------\");\n            //debugger;\n            this.setNodeToStackCache(new Map());\n\n            const ov = this.otherViewContent();\n            if (ov && ov.cacheId) {\n                this.cacheView(ov);\n                ov.beginCaching();\n            }\n        }\n        return this;\n    }\n\n    endCaching () {\n        // ends caching on all chained substacks\n        if(this.isCaching()) {\n            //console.log(this.debugTypeId() + \" endCaching -----------------\");\n            //this.nodeToStackCache().valuesArray().forEach(sv => this.uncacheView(sv));\n            this.setNodeToStackCache(null);\n\n            const ov = this.otherViewContent();\n            if (ov && ov.cacheId) {\n                //this.uncacheView(ov);\n                ov.endCaching();\n            }\n        }\n        return this;\n    }\n\n    // --- node to StackView cache ---\n\n    cacheId () { // used atm in StackView cache\n        return this.node().typeId();\n    }\n\n    hasCache () {\n        return !Type.isNull(this.nodeToStackCache());\n    }\n\n    cacheView (aView) {\n        const cache = this.nodeToStackCache();\n        const k = aView.cacheId();\n        if (!cache.hasKey(k)) {\n            cache.atPut(k, aView);\n        }\n        return this\n    }\n\n    /*\n    uncacheView (stackView) {\n        const cache = this.nodeToStackCache();\n        const k = aView.cacheId();\n        if (cache.hasKey(k)) {\n            cache.removeKey(k);\n        }\n        return this;\n    }\n    */\n\n    cachedViewForNode (aNode) {\n        if (this.hasCache() && aNode) {\n            const k = aNode.typeId();\n            return this.nodeToStackCache().at(k, this);\n        }\n        return null;\n    }\n\n    otherViewContentForNode (aNode) {\n        let sv = this.cachedViewForNode(aNode);\n\n        if (!sv) {\n            // what if node is null now and set *after* this?\n            // things like a path change can alter node?\n            sv = StackView.clone().setNode(aNode);\n            if (this.isCaching()) {\n                sv.beginCaching();\n            }\n        }\n\n        return sv;\n    }\n        \n}.initThisClass());\n",
  "87xUhBQQc3/iNYUKEFikhkRLtuAxdw4GHxk5sdY3HD4=": "\"use strict\";\n\n/*\n    \n    NavView\n    \n*/\n\n(class NavView extends NodeView {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"stackView\", null);\n            slot.setSlotType(\"StackView\");\n        }\n            \n        {\n            const slot = this.newSlot(\"headerView\", null); // placed in top of NavView, set to display:none if no node.headerNode(), contains a Tile?\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"scrollView\", null); // ScrollView fits NavView size, and contains TilesView which may be larger\n            slot.setSlotType(\"ScrollView\");\n        }\n        {\n            const slot = this.newSlot(\"footerView\", null); // placed in bottom of NavView, set to display:none if no node.footerNode() \n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"tilesView\", null); // is inside scrollView\n            slot.setSlotType(\"TilesView\");\n        }\n        {\n            const slot = this.newSlot(\"isCollapsed\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"animatesCollapse\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"beforeEdgePanBorderBottom\", null); // private\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"beforeEdgePanBorderRight\", null); // private\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    targetWidth () {\n        const defaultWidth = 400;\n        if (this.node()) {\n            const minWidth = this.node().nodeMinTileWidth();\n            const maxWidth = 600;\n            let w = defaultWidth;\n            w = Math.max(defaultWidth, minWidth);\n            w = Math.min(w, maxWidth);\n            if (w) {\n                return w;\n            }\n        }\n        return defaultWidth;\n    }\n\n    targetHeight () {\n        if (this.node()) {\n            const h = this.node().nodeMinTileHeight()\n            if (h) {\n                return h\n            }\n        }\n        return 64\n    }\n\n    init () {\n        super.init()\n        //this.setDisplay(\"block\")\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setFlexDirection(\"column\")\n        this.setFlexGrow(1)\n        //this.setOpacity(0)\n        this.setOverflow(\"hidden\")\n        this.setUserSelect(\"none\")\n        //this.setTransition(\"opacity 0.5s ease-in-out\")\n        //this.setTransition(\"flex-basis 0.1s\")\n        this.setTransition(\"opacity 0.5s ease-in-out, flex-basis 0s\")\n\n        /*\n        this.setHeaderClass(ColumnGroupHeader)\n        this.setMiddleClass(BrowserScrollView)\n        this.setFooterClass(ColumnGroupFooter)\n        this.setupHeaderMiddleFooterViews()\n        this.footerView().hideDisplay()\n        */\n\n        const borderStyle = \"1px solid rgba(255, 255, 255, 0.1)\"\n        const backgroundColor = \"rgba(255, 255, 255, 0.03)\"\n\n        {\n            const v = TileContainer.clone()\n            v.setBorderBottom(borderStyle)\n            v.setBackgroundColor(backgroundColor)\n            this.setHeaderView(v)\n            this.addSubview(v)\n        }\n\n        this.setScrollView(StackScrollView.clone())\n        this.addSubview(this.scrollView())\n\n        {\n            const v = TileContainer.clone()\n            v.setBorderTop(borderStyle)\n            v.setBackgroundColor(backgroundColor)\n            this.setFooterView(v)\n            this.addSubview(v)\n        }\n\n        this.setTilesView(TilesView.clone())\n        this.scrollView().addSubview(this.tilesView())\n\n        this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) // for adjusting width\n        this.addGestureRecognizer(BottomEdgePanGestureRecognizer.clone()) // for adjusting height\n\n        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) \n        return this\n    }\n\n    isVertical () {\n        const sv = this.stackView()\n        if (!sv) {\n            return null\n        }\n        return sv.direction() === \"right\"\n    }\n\n    syncOrientation () {\n        if (this.isVertical()) {\n            this.makeOrientationRight()\n        } else {\n            this.makeOrientationDown()\n        }\n        return this\n    }\n\n    // --- border ---\n\n    borderColor () {\n        return \"rgba(255, 255, 255, 0.3)\"\n    }\n\n    hasBorder () {\n        const node = this.node()\n        if (node) {\n            const hint = node.nodeNavBorderHint()\n            if (Type.isBoolean(hint)) {\n                return hint\n            }\n        }\n        return true\n    }\n\n    borderStyle () {\n        if (this.hasBorder()) {\n            return \"0px solid \" + this.borderColor() + \" inset\"\n        }\n        return null\n    }\n\n    // ---\n\n    makeOrientationRight () {\n        // stack view is left to right, so nav items are top to bottom\n        this.setFlexDirection(\"column\")\n        //this.setFlexBasis(this.targetWidth() + \"px\")\n        this.setFlexGrow(0)\n        this.setFlexShrink(0)\n\n        // this are handled in sync to node\n        this.setMinAndMaxWidth(\"17em\") // syncFromNode can override if node requests a sizes\n        this.setMinAndMaxHeight(\"100%\")\n\n        if (this.node()) {\n            if (this.node().nodeFillsRemainingWidth() && this.isLastNavView()) {\n                //debugger;\n                //this.setMinWidth(\"fit-content\") // should only do this if it's the last node?\n                this.setMinWidth(\"17em\") // should only do this if it's the last node?\n                this.setWidth(\"-webkit-fill-available\")\n                this.setMaxWidth(\"-webkit-fill-available\") // should only do this if it's the last node?\n            }\n        }\n\n        /*\n        this.setBorderBottom(null)\n        this.setBorderRight(this.borderStyle())\n        */\n        this.setBorderRight(\"1px solid #333\")\n        this.setBorderBottom(null)\n\n        this.scrollView().setIsVertical(true)\n        //this.setBoxShadow(\"inset -10px 0 20px rgba(0, 0, 0, 0.05)\")\n\n        if (this.headerView()) {\n            const v = this.headerView()\n            v.setWidth(\"fit-content\")\n            v.setHeight(\"100%\")\n        }\n\n        if (this.footerView()) {\n            const v = this.footerView()\n            v.setWidth(\"fit-content\")\n            v.setHeight(\"100%\")\n        }\n    }\n\n    makeOrientationDown () {\n        // stack view is top to bottom, so nav items are left to right\n\n        this.setFlexDirection(\"row\")\n        //this.setFlexBasis(this.targetHeight() + \"px\")\n        this.setFlexGrow(0)\n        this.setFlexShrink(0)\n\n        this.setMinAndMaxWidth(\"100%\")\n        this.setMinAndMaxHeight(\"5em\")\n\n        if (this.node()) {\n            if (this.node().nodeFillsRemainingWidth()) {\n               // this.setMinAndMaxHeight(\"100%\")\n            }\n        }\n\n        /*\n        this.setBorderRight(null)\n        this.setBorderBottom(this.borderStyle())\n        */\n        this.setBorderRight(null)\n        this.setBorderBottom(\"1px solid #333\")\n\n        this.scrollView().setIsVertical(false)\n        //this.setBoxShadow(\"inset 0 -10px 40px #222\")\n\n\n        if (this.headerView()) {\n            const v = this.headerView()\n            v.setWidth(\"100%\")\n            v.setHeight(\"fit-content\")\n        }\n\n        if (this.footerView()) {\n            const v = this.footerView()\n            v.setWidth(\"100%\")\n            v.setHeight(\"fit-content\")\n        }\n    }\n\n    setNode (aNode) {\n        super.setNode(aNode)\n        this.tilesView().setNode(aNode)\n\n        if (aNode.headerNode) {\n            this.headerView().setNode(aNode.headerNode())\n        }\n\n        if (aNode.footerNode) {\n        //    debugger;\n            this.footerView().setNode(aNode.footerNode())\n        }\n\n        return this\n    }\n\n    isLastNavView () {\n        return Type.isNullOrUndefined(this.stackView().nextStackView())\n    }\n\n    syncFromNode () {\n        this.syncOrientation()\n        //this.tilesView().syncFromNode()\n        this.applyStyles()\n\n        if (this.isVertical()) {\n            const w = this.node().nodeMinTileWidth()\n            if (w && !Type.isNullOrUndefined(w)) {\n                //this.setMinAndMaxWidth(w)\n                this.setMinWidth(w)\n                //const maxw = this.isLastNavView() ? \"-webkit-fill-available\" : null;\n                //this.setMaxWidth(maxw)\n                this.setMinAndMaxHeight(\"100%\")\n            } \n        } else {\n            //debugger;\n            const h = this.node().nodeMinTileHeight()\n            if (h && !Type.isNullOrUndefined(h)) {\n                this.setMinAndMaxWidth(\"100%\")\n                this.setMinAndMaxHeight(h)\n            } /*else {\n                this.setMinAndMaxWidth(\"100%\")\n                this.setMinAndMaxHeight(\"5em\")\n            }*/\n        }\n\n        this.headerView().syncFromNode()\n        this.footerView().syncFromNode()\n        return this\n    }\n\n    /*\n    applyStyles () {\n        super.applyStyles()\n        \n        if (this.isVertical()) {\n            this.applyColumnStyle()\n        }\n        return this\n    }\n\n    applyColumnStyle () {\n        this.setBorder(\"\")\n        const themeClass = this.currentThemeClass()\n        if (themeClass) {\n            const columns = themeClass.firstSubnodeWithTitle(\"columns\")\n            //debugger;\n            if (columns) {\n                const colorFields = columns.subnodes().select(sn => sn.thisClass().isSubclassOf(Object.getClassNamed(\"BMStringField\")) || sn.type() === \"BMField\")\n                const count = colorFields.length\n                if (count) {\n                    let i = this.stackView().stackViewDepth()\n                    let ci = i % count\n                    const color = colorFields.at(ci).value()\n                    console.log(\"column \" + i + \" color index \" + ci + \" color \" + color)\n                    this.setBackgroundColor(color)\n                }\n            }\n        }\n    }\n    */\n\n    // --- collpase / uncollapse ---\n\n    collapse () {\n        if (!this.isCollapsed()) {\n            this.hideDisplay()\n           this.setIsCollapsed(true)\n        }\n    }\n\n    uncollapse () {\n        if (this.isCollapsed()) {\n            this.unhideDisplay()\n            this.syncOrientation()\n            this.setIsCollapsed(false)\n        }\n    }\n\n    // --- right edge gesture ---\n\n    edgeMoveBorderStyle () {\n        return \"1px rgba(255, 255, 255, 0.5) inset\"\n    }\n\n    onRightEdgePanBegin (aGesture) {\n        this.setBeforeEdgePanBorderRight(this.borderRight())\n        this.setBorderRight(this.edgeMoveBorderStyle())\n    }\n\n    onRightEdgePanMove (aGesture) {\n        const p = aGesture.currentPosition() // position in document coords\n        const f = this.frameInDocument()\n        const nw = Math.max(10, p.x() - f.x())\n        //console.log(\"nw = \", nw)\n        this.node().setNodeMinTileWidth(nw)\n        this.scheduleSyncToNode(); // is this needed as we already sent node.setNodeMinTileWidth?\n        return this\n    }\n\n    onRightEdgePanComplete (aGesture) {\n        this.onRightEdgePanMove(aGesture)\n        this.setBorderRight(this.beforeEdgePanBorderRight())\n        this.setBeforeEdgePanBorderBottom(null)\n        this.unhideTransition()\n    }\n\n    // --- bottom edge gesture ---\n\n    onBottomEdgePanBegin (aGesture) {\n        this.setBeforeEdgePanBorderBottom(this.borderBottom())\n        this.setBorderBottom(this.edgeMoveBorderStyle())\n        //this.setTransition(\"min-height 0s, max-height 0s\")\n        this.hideTransition()\n    }\n\n    onBottomEdgePanMove (aGesture) {\n        const p = aGesture.currentPosition() // position in document coords\n        const f = this.frameInDocument()\n        const newHeight = Math.max(10, p.y() - f.y())\n        //console.log(\"node \" + this.node().title() + \" newHeight = \", newHeight)\n        this.node().setNodeMinTileHeight(newHeight)\n        this.scheduleSyncToNode(); // is this needed as we already sent node.setNodeMinTileHeight()?\n        return this\n    }\n\n    onBottomEdgePanComplete (aGesture) {\n        this.onBottomEdgePanMove(aGesture)\n        this.setBorderBottom(this.beforeEdgePanBorderBottom())\n        this.setBeforeEdgePanBorderBottom(null)\n        this.unhideTransition()\n    }\n/*\n    removeAllGestureRecognizers () {\n        //debugger;\n        return super.removeAllGestureRecognizers()\n    }\n    */\n\n}.initThisClass());\n",
  "VS+xhFkEzVmPe9sVPaMwhp3sQ43yq3VR+Ys+WfO6uCw=": "\"use strict\";\n\n/*\n\n    ScrollView\n\n*/\n\n(class ScrollView extends DomView { \n    \n    initPrototypeSlots () {\n\n        /* \n        Slots for implementing sticks-to-bottom behavior\n\n        Notes:\n        \n        - isAtBottom is a computed property that checks if scroll is at bottom now\n        - wasAtBottom tracks if scroll was at bottom before content change\n\n        When user scrolls or setScrollHeight:\n        - update wasAtBottom (using isAtBottom)\n        - update lastScrollHeight (may be used elsewhere later)\n\n        When content changes:\n        - auto scroll if wasAtBottom true\n        - update lastScrollHeight to bottom (may be used elsewhere later)\n        */\n\n        {\n            const slot = this.newSlot(\"sticksToBottom\", false); // turn on/off behavior\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"wasAtBottom\", false); // on user onScroll events, marked to true if at bottom\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"lastScrollHeight\", 0);\n            slot.setSlotType(\"Number\");\n        }\n\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        this.setTopPx(null)\n        //this.makeVertical()\n        this.setMsOverflowStyle(\"none\") // removes scrollbars on IE 10+ \n        this.setOverflow(\"-moz-scrollbars-none\") // removes scrollbars on Firefox \n        this.setBackgroundColor(\"transparent\")\n        //this.setBorder(\"1px solid purple\")\n        return this\n    }\n\n    scrollContentView () {\n        return this.subviews().first()\n    }\n\n\n    // --- scroll events ---\n\n    listenForScroll () {\n        this.scrollListener().setIsListening(true) // start listing for scroll events\n        /*\n        this.element().addEventListener('scroll', (event) => { \n            this.onScroll(event) \n        });\n        */\n    }\n\n    contentView () {\n        return this.subviews().first();\n    }   \n\n    // --- sticks to bottom ---\n\n    setSticksToBottom (aBool) {\n        if (this._sticksToBottom !== aBool) {\n            this._sticksToBottom = aBool;\n            if (aBool) {\n                this.listenForScroll();\n                this.updateScrollTracking();\n                this.contentView().startContentMutationObserverIfNeeded(); // only starts if it's not already started\n            } else {\n                //this.scrollListener().setIsListening(false); // can't do this as something else might need it...\n                //this.stopContentMutationObserver(); // not safe as we don't know if this is needed elsewhere\n            }\n        }\n    }\n\n\n    onScroll (event) {\n        //debugger;\n        /*\n        const cv = this.contentView();\n        if (cv && cv.onScrollViewScroll) {\n            cv.onScrollViewScroll(this)\n        }\n        */\n        this.updateScrollTracking()\n    }\n\n    onContentViewMutations (mutations) {\n        // sent from contentView when it mutates\n        if (this.sticksToBottom()) {\n            if (this.wasAtBottom()) {\n                this.immediatelyScrollToBottom();\n                //this.contentView().scrollToBottom();\n                this.setWasAtBottom(true); // since we will be scrolling to bottom, we can set this to true now, so even if it's in progress on next mutation, it will be true\n                this.setLastScrollHeight(this.clientHeight());\n            }\n        }\n    }\n\n    // --- is at bottom calc ---\n\n    isAtBottom () {\n        const e = this.element();\n        // Check if the content is at the bottom before adding new content\n        const tolerance = this.computeScrollTolerance(); // Tolerance value to account for subpixel values and rounding errors, cache this?\n        const difference = e.scrollHeight - (e.scrollTop + e.clientHeight);\n        //this.setWasAtBottom(difference <= tolerance)\n        return difference <= tolerance;\n    }\n\n    computeScrollTolerance () {\n        return 10; // was 5\n        /*\n        const e = this.element();\n        const style = window.getComputedStyle(e);\n    \n        // Get border widths\n        const borderTop = parseFloat(style.borderTopWidth);\n        const borderBottom = parseFloat(style.borderBottomWidth);\n    \n        // Get paddings\n        const paddingTop = parseFloat(style.paddingTop);\n        const paddingBottom = parseFloat(style.paddingBottom);\n    \n        // Potential subpixel discrepancies\n        const subpixelTolerance = 1 / (window.devicePixelRatio || 1);\n    \n        // Total tolerance is the sum of all the factors\n        return borderTop + borderBottom + paddingTop + paddingBottom + subpixelTolerance;\n        */\n    }\n\n    setScrollHeight (v) {\n        super.setScrollHeight(v)\n        this.updateScrollTracking()\n        return this\n    }\n\n    // -- updates ---\n\n    updateScrollTracking () {\n        this.updateLastScrollHeight()\n        this.updateWasAtBottom()\n        return this\n    }\n\n    updateLastScrollHeight () {\n        this.setLastScrollHeight(this.scrollHeight())\n        return this\n    }\n\n    updateWasAtBottom () {\n        if (this.wasAtBottom() !== this.isAtBottom()) {\n            this.setWasAtBottom(this.isAtBottom())\n        }\n        return this\n    }\n\n}.initThisClass());\n\n\n",
  "XJkNXquwq/6buoo14SUNDYZ6jpwIn/QSJymz16gLcNk=": "\"use strict\";\n\n/*\n\n    StackScrollView\n\n*/\n\n(class StackScrollView extends ScrollView {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        /*\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        this.setTopPx(null)\n        this.setMsOverflowStyle(\"none\") // removes scrollbars on IE 10+ \n        this.setOverflow(\"-moz-scrollbars-none\") // removes scrollbars on Firefox \n        this.setBackgroundColor(\"transparent\")\n        //this.setBorder(\"1px solid purple\")\n        */\n        this.makeVertical()\n        return this\n    }\n\n    setIsVertical (aBool) {\n        if (aBool) {\n            this.makeVertical()\n        } else {\n            this.makeHorizontal()\n        }\n        return this\n    }\n\n    makeVertical () {\n        this.setWidth(\"100%\")\n        this.setFlexGrow(1);\n        this.setOverflowY(\"scroll\") // has to be scroll, not auto, for touch scroll momentum to work \n        this.setOverflowX(\"hidden\")\n        return this\n    }\n\n    makeHorizontal () {\n        this.setWidth(\"null\")\n        this.setHeight(\"100%\")\n        this.setFlexGrow(1);\n        this.setOverflowY(\"hidden\") \n        this.setOverflowX(\"scroll\") // has to be scroll, not auto, for touch scroll momentum to work \n        return this\n    }\n\n    \n}.initThisClass());\n\n\n",
  "+CxheH9dd6SGiCcmkTFmmhaxRgeXTDehVohHkBxfS04=": "\"use strict\";\n\n/*\n    \n    ScrollContentView\n    \n*/\n\n(class ScrollContentView extends NodeView {\n\n    initPrototypeSlots () {\n\n\n        // needed for ScrollView sticksToBottom feature\n        {\n            const slot = this.newSlot(\"contentMutationObserver\", null); // setup onContentMutations() event, within which we scroll to bottom if needed\n            slot.setSlotType(\"MutationObserver\");\n        }\n\n    }\n\n    // -----\n\n    prepareToRetire () {\n        super.prepareToRetire();\n        this.stopContentMutationObserver();\n        return this;\n    }\n\n    scrollView () {\n        return this.parentView()\n    }\n\n    /*\n    onRequestScrollToBottom (aNote) {\n        this.addTimeout(() => { \n            this.parentView().immediatelyScrollToBottom()\n        }, 1);\n        this.setWasAtBottom(true)\n        this.setLastScrollHeight(this.clientHeight())\n    }\n    */\n\n    // --- scroll events ---\n\n    syncFromNode () {\n        super.syncFromNode()\n        const node = this.node()\n        if (node && node.subviewsScrollSticksToBottom) {\n            this.scrollView().setSticksToBottom(node.subviewsScrollSticksToBottom())\n        }\n        return this\n    }\n\n    setNode (aNode) {\n        const didChange = this.node() !== aNode;\n        super.setNode(aNode);\n        //debugger;\n\n        if (didChange && aNode && aNode.subviewsScrollSticksToBottom && aNode.subviewsScrollSticksToBottom()) {\n            //this.setHeight(null)\n            this.setJustifyContent(\"flex-end\")\n            //this.setHeight(\"fit-content\")\n            ///this.setMinHeight(null)\n            ///this.setMaxHeight(null)\n            ///this.setMarginTop(\"auto\")\n            this.addTimeout(() => { this.scrollToBottom() }, 0);\n            \n        }\n        return this\n    }\n\n    onScrollViewScroll (event) {\n\n    }\n\n    // --- code to do auto stick-to-bottom type behavior ---\n\n\n    // --- content mutation observer ---\n\n    /*\n    didUpdateSlotElement (oldValue, newValue) {\n        super.didUpdateSlotElement(newValue)\n        if (newValue) {\n            this.startContentMutationObserverIfNeeded();\n        } else {\n            this.stopContentMutationObserver();\n        }\n    }\n    */\n\n    startContentMutationObserverIfNeeded () {\n        if (!this.contentMutationObserver()) {\n            const observer = new MutationObserver((mutations) => {\n                this.onContentMutations(mutations) // do we need to wrap this event?\n            });\n\n            this.setContentMutationObserver(observer);\n\n            const observerOptions = {\n                childList: true,\n                subtree: true\n            };\n\n            observer.observe(this.element(), observerOptions);\n        }\n        return this\n    }\n\n    stopContentMutationObserver () {\n        const obs = this.contentMutationObserver();\n        if (obs) {\n            obs.disconnect();\n            this.setContentMutationObserver(null);\n        }\n        return this;\n    }\n\n    onContentMutations (mutations) {\n        const scrollView = this.scrollView();\n        if (scrollView) {\n            scrollView.onContentViewMutations(mutations);\n        }\n        return this;\n    }\n\n}.initThisClass());\n",
  "YHM/FDl9jGej1mwIA24C97cBHvZ5a0taDEBiqFjRb8k=": "\"use strict\";\n\n/*\n    \n    TilesView\n\n    Contains array of Tile (and Tile decendant class) views.\n    Parent is a StackScrollView, whose parent is a NavView.\n    \n*/\n\n(class TilesView extends ScrollContentView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"tiles\", null);\n            slot.setSlotType(\"Array\");\n        }\n        {\n            const slot = this.newSlot(\"allowsCursorNavigation\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"tilePlaceHolder\", null);\n            slot.setSlotType(\"Tile\");\n        }\n        {\n            const slot = this.newSlot(\"hasPausedSync\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"isColumnInspecting\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        */\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        //this.setDisplay(\"block\") // if block is used, there with be gaps between rows despite 0 margins!\n        this.setDisplay(\"flex\")\n\n\n        this.setPosition(\"relative\")\n        //this.setFlexBasis(\"fit-content\")\n        //this.setFlexGrow(0)\n        //this.setFlexShrink(0)\n        this.makeOrientationRight()\n\n        this.setOverflow(\"hidden\")\n        this.setOverflowScrolling(\"auto\")\n\n        this.setMsOverflowStyle(\"none\")\n        this.setUserSelect(\"none\")\n\n        /*\n        this.setMinAndMaxWidth(\"fit-content\")\n        this.setMinAndMaxHeight(\"fit-content\")\n        */\n        //this.setBorder(\"3px solid blue\")\n\n        this.setIsDebugging(false)\n        this.setIsRegisteredForKeyboard(true)\n        this.setAcceptsFirstResponder(true)\n\n        this.setUserSelect(\"none\")\n        this.addGestureRecognizer(PinchGestureRecognizer.clone()) // for pinch open to add tile\n        this.addGestureRecognizer(TapGestureRecognizer.clone()) // for pinch open to add tile\n\n        this.setIsRegisteredForBrowserDrop(true)\n        \n        //this.setBorder(\"1px dashed red\")\n        this.setDefaultSubviewProto(TitledTile)\n        return this\n    }\n\n    // --- helpers ---\n    // subview path: StackView -> NavView -> ScrollView -> TilesView -> Tiles\n\n    navView () {\n        const sv = this.scrollView()\n        if (!sv) {\n            return null\n        }\n        return sv.parentView()\n    }\n\n    stackView () {\n        const nv = this.navView()\n        if (!nv) {\n            return null\n        }\n        return nv.parentView()\n    }\n\n    /*\n    browser () {\n        return this.stackView()\n    }\n    */\n\n    // --- title ---\n    \n    title () {\n        return this.node() ? this.node().title() : \"\"\n    }\n\n    // --- accessing tiles ---\n    \n    tiles () {\n        return this.subviews()\n    }\n\n    addTile (v) {\n        return this.addSubview(v)\n    }\n\n    removeTile (v) {\n        return this.removeSubview(v)\n    }\n\n    tilesWithNodes (nodeArray) {\n        return nodeArray.map(node => this.tileWithNode(node))\n    }\n\n    tileWithNode (aNode) {\n        return this.tiles().detect(tile => tile.node() === aNode)\n    }\n\n    indexOfTile (aTile) {\n        // we might want this to be based on flex view order instead, \n        // so best to keep it abstract\n        return this.indexOfSubview(aTile)\n    }\n\n    tileAtIndex (anIndex) {\n        return this.subviews().at(anIndex)\n    }\n\n    tileWithNode (aNode) {\n        return this.tiles().detect(tile => tile.node().nodeTileLink() === aNode)\n    }\n\n    maxTileWidth () {\n        if (this.tiles().length === 0) {\n            return 0\n        }\n        \n        const maxWidth = this.tiles().maxValue(tile => tile.desiredWidth())\t\t\t\n        return maxWidth\t\n    }\n\t\n    // --- sync ---\n\n    syncFromNode () {\n        this.syncOrientation() // implemented in Tiles_orientation.js\n        super.syncFromNode() \n\n        /*\n        if (this.node().nodeMinTileHeight()) {\n            this.setMinAndMaxHeight(this.node().nodeMinTileHeight())\n        }\n        */\n\n        /*\n        if (this.selectedTiles().length === 0) {\n            //this.didChangeNavSelection() // TODO: is this right?\n        }\n        */\n        return this\n    }\n\n\n    subviewProtoForSubnode (aSubnode) {\n        let proto = aSubnode.nodeTileClass() // we need this to get tile versions of view\n\t\t\n        if (!proto) {\n            proto = this.defaultSubviewProto()\n        }\n\t\t\t\t\n        return proto      \n    }\n\n    didChangeNode () {\n        super.didChangeNode()\n\n        if (this.node() && this.node().nodeTilesStartAtBottom()) {\n            this.setTransition(\"none\")\n            this.setAnimation(\"none\")\n            this.element().style.scrollBehavior = 'auto';\n            this.element().offsetHeight; // force reflow\n            this.addTimeout(() => { this.scrollToBottom() }, 0)\n            //this.tile().last().scrollIntoView()\n        }\n\n        return this\n    }\n\n\n    // --- duplicating tiles ---\n\n    duplicateSelectedTile () {\n        const node = this.node()\n        const tile = this.selectedTile()\n        const canAdd = node.nodeCanAddSubnode() \n        if (tile && canAdd) {\n            const canCopy = !Type.isNullOrUndefined(tile.node().copy)\n            if (canCopy) { \n                //this.debugLog(\" duplicate selected tile \" + this.selectedTile().node().title())\n                const subnode = tile.node()\n                const newSubnode = subnode.copy()\n                const index = node.indexOfSubnode(subnode)\n                node.addSubnodeAt(newSubnode, index)\n                this.scheduleSyncFromNode()\n            }\n        }\n    }\n\n    duplicateSelectedTiles () {\n        const newNodes = []\n\n        this.selectedTiles().forEach(tile => {\n            const i = this.indexOfSubview(tile)\n            const dupNode = tile.node().duplicate()\n            newNodes.push(dupNode)\n            this.node().addSubnodeAt(dupNode, i+1)\n        })\n        this.unselectAllTiles()\n        this.syncFromNodeNow()\n\n        // TODO: unselect current tiles at browser level\n        newNodes.forEach(newNode => {\n            const newTile = this.tileWithNode(newNode)\n            if (newTile) {\n                newTile.select()\n            }\n        })\n\n        return this\n    }\n\n    // --- inspecting ---\n\n    isInspecting () {\n        /*\n        if (this.isColumnInspecting()) {\n            return true\n        }\n        */\n        // see if the tile that selected this column is being inspected\n        const prev = this.previousItemSet() \n        if (prev) {\n            const tile = prev.selectedTile()\n            if (tile) {\n                return tile.isInspecting()\n            }\n        }\n        return false\n    }\n    \n    /*\n    setIsColumnInspecting (aBool) {\n        if (this._isColumnInspecting !== aBool) {\n            this._isColumnInspecting = aBool\n            this.scheduleSyncFromNode()\n        }\n        return this\n    }\n    */\n\n    // -----------------------------\n\n    columnIndex () {\n        return this.parentViewsOfClass(StackView).length\n    }\n\n    // next column\n    \n    nextColumn () {\n        const nsv = this.stackView().nextStackView()\n        if (nsv) {\n            return nsv.navView().tilesView()\n        }\n        return null\n    }\n\n    // previous column\n\t\n    previousItemSet () {\n        if (this.stackView()) {\n            const ps = this.stackView().previousStackView()\n            if (ps) {\n                return ps.navView().tilesView()\n            }\n        }\n        return null\n    }\n\n    // --- editing ---\n\n    onDoubleClick (event) {\n        //this.debugLog(\".onDoubleClick()\")\n        return true\n    }\n\n    // --- debugging ---\n\n    /*\n    setNode (aNode) {\n        if (this.node() && Type.isNull(aNode)) {\n            console.log(this.debugTypeId() + \" setNode(null)\")\n            //debugger;\n        }\n        super.setNode(aNode)\n        return this\n    }\n    */\n\n    // --- browser drop ---\n\n    onBrowserDropChunk (dataChunk) {\n        const node = this.node()\n\n        if (node && node.onBrowserDropChunk) {\n            node.onBrowserDropChunk(dataChunk)\n        }\n        this.scheduleSyncFromNode()\n    }\n\n    /*\n    scheduleSyncFromNode () {\n        console.warn(this.typeId() + \" scheduleSyncFromNode\")\n        return super.scheduleSyncFromNode()\n    }\n    */\n    \n}.initThisClass());\n",
  "LldDW4vvTWMXP6iw5UsAaucFtJ2jt2Q8bDqHAwrA6fI=": "\"use strict\";\n\n/*\n    \n    TilesView_dragViewProtocol\n    \n*/\n\n(class TilesView_dragViewProtocol extends TilesView {\n    \n    // -- messages sent by DragView to the parent/owner of the view it's dragging ---\n\n    onDragSourceBegin (dragView) {\n        this.setHasPausedSync(true)\n        //ElementDomView.pauseRetires()\n\n        //console.log(this.typeId() + \" onDragSourceBegin\")\n        // ---\n\n\n        /*\n        dragView.items().forEach(sv => {\n            sv.hideForDrag()\n        })\n        */\n\n        // ---\n        const subview = dragView.item()\n        const index = this.indexOfSubview(subview)\n        assert(index !== -1)\n\n        if (dragView.isMoveOp()) {\n            dragView.items().forEach(sv => this.removeSubview(sv))\n        } else if (dragView.isCopyOp()) {\n\n        }\n\n        //this.tiles().forEach(tile => tile.setTransition(\"all 0.3s\"))\n        this.tiles().forEach(tile => tile.setTransition(\"top 0.3s, left 0.3s\"))\n\n        this.newTilePlaceHolder(dragView)\n\n        /*\n        if (dragView.isMoveOp()) {\n            subview.hideForDrag()\n            this.moveSubviewToIndex(this.tilePlaceHolder(), index)\n        }\n        */\n\n        this.moveSubviewToIndex(this.tilePlaceHolder(), index)\n        this.stackTiles()\n        return this\n    }\n\n    onDragSourceCancelled (dragView) {\n        /*\n        dragView.items().forEach(subview => {\n            subview.unhideForDrag()\n        })\n        */\n        this.onDragSourceDropped(dragView)\n        //this.removeTilePlaceHolder()\n    }\n\n\n    onDragSourceEnter (dragView) {\n        this.onDragDestinationHover(dragView)\n        this.stackView().rootStackView().onStackChildDragSourceEnter(dragView)\n    }\n\n    onDragSourceHover (dragView) {\n        this.onDragDestinationHover(dragView)\n        this.indexOfTilePlaceHolder()\n    }\n\n    onDragSourceExit (dragView) {\n        this.onDragDestinationHover(dragView)\n    }\n\n\n    // -- DragView dropping ---\n\n    onDragSourceDropped (dragView) {\n        //console.log(this.debugTypeId() + \" --- onDragSourceDropped ---\")\n        //debugger;\n\n        const insertIndex = this.indexOfTilePlaceHolder()\n\n        let movedNodes = dragView.items().map(item => item.node())\n        if (dragView.isMoveOp()) {\n            // todo\n        } else if (dragView.isCopyOp()) {\n             movedNodes = movedNodes.map(aNode => aNode.duplicate())\n        } else {\n            throw new Error(\"unhandled drag operation\")\n        }\n        //console.log(this.debugTypeId() + \" --- unstacking ---\")\n\n        this.unstackTiles()\n        this.removeTilePlaceHolder()\n    \n        //console.log(\"---\")\n        //this.showNodes(movedNodes)\n        //this.showTiles(this.subviews())\n        const newSubnodesOrder = this.subviews().map(sv => sv.node())\n        //debugger;\n        //this.showNodes(newSubnodesOrder)\n        \n        this.node().removeSubnodes(movedNodes) // is this needed?\n        //assert(!newSubnodesOrder.containsAny(movedNodes))\n\n\n        newSubnodesOrder.atInsertItems(insertIndex, movedNodes)\n        //this.showNodes(newSubnodesOrder)\n\n        this.node().setSubnodes(newSubnodesOrder)\n\n        //console.log(\"new order: \" + this.node().subnodes().map(sn => sn.title()).join(\"-\"))\n        this.setHasPausedSync(false)\n        this.syncFromNodeNow()\n        this.selectAndFocusNodes(movedNodes)\n    }\n\n    onDragDestinationDropped (dragView) {\n        //debugger;\n        \n        const insertIndex = this.indexOfTilePlaceHolder()\n\n        let movedNodes = dragView.items().map(item => item.node())\n        if (dragView.isMoveOp()) {\n            movedNodes.forEach(aNode => aNode.removeFromParentNode())\n        } else if (dragView.isCopyOp()) {\n             movedNodes = movedNodes.map(aNode => aNode.duplicate())\n        } else {\n            throw new Error(\"unhandled drag operation\")\n        }\n\n        this.unstackTiles()\n        this.removeTilePlaceHolder()\n\n        const newSubnodesOrder = this.subviews().map(sv => sv.node())\n        assert(!newSubnodesOrder.containsAny(movedNodes))\n        newSubnodesOrder.atInsertItems(insertIndex, movedNodes)\n        this.node().setSubnodes(newSubnodesOrder)\n\n        this.setHasPausedSync(false)\n        this.syncFromNodeNow()\n        this.selectAndFocusNodes(movedNodes)\n    }\n\n    onDragSourceEnd (dragView) {\n        this.endDropMode()\n        //ElementDomView.unpauseRetires()\n    }\n\n    // -- messages sent by DragView to the potential drop view, if not the source ---\n\n    acceptsDropHover (dragView) {\n        //return true \n\n        const node = this.node()\n        if (node) {\n            const dropNode = dragView.item().node()\n\n            if (dropNode === this.node()) {\n                return false\n            }\n            \n            const acceptsNode = node.acceptsAddingSubnode(dropNode)\n            const canReorder = this.canReorderTiles()\n            //console.log(node.title() + \" acceptsNode \" + dropNode.title() + \" \" + acceptsNode)\n            //console.log(\"parentNode \" + node.parentNode().title())\n            const result = acceptsNode && canReorder\n            return result\n        }\n        return false\n    }\n\n    /// --- tile place holder ---\n\n    newTilePlaceHolder (dragView) {\n        //this.debugLog(\"newTilePlaceHolder\")\n        if (!this.tilePlaceHolder()) {\n            const ph = DomView.clone().setElementClassName(\"TilePlaceHolder\") // classname not for css rule, just a note for debugging\n            ph.setBackgroundColor(\"black\")\n\n            //ph.setTransition(\"top 0s, left 0s, max-height 1s, min-height 1s\")\n            ph.setTransition(\"top 0s, left 0s\")\n            this.addSubview(ph)\n            this.setTilePlaceHolder(ph)\n            this.syncTilePlaceHolderSize(dragView)\n        }\n        return this.tilePlaceHolder()\n    }\n\n    syncTilePlaceHolderSize (dragView) {\n        const ph = this.tilePlaceHolder()\n        //const period = 0.1\n        if (this.isVertical()) {\n            ph.setMinAndMaxWidth(this.computedWidth())\n            ph.setMinAndMaxHeight(dragView.minHeight())\n            //ph.setMinAndMaxHeight(dragView.maxHeightPx() + 1) // all tiles seem to shrink while dragging, not just place holder\n            //ph.transitions().at(\"top\").updateDuration(0)\n            //ph.transitions().at(\"left\").updateDuration(period)\n        } else {\n            ph.setMinAndMaxWidth(dragView.minWidth())\n            ph.setMinAndMaxHeight(this.computedHeight())\n            //ph.transitions().at(\"top\").updateDuration(period)\n            //ph.transitions().at(\"left\").updateDuration(0)\n        }\n\n        return this\n    }\n\n    indexOfTilePlaceHolder () {\n        const sortMethod = this.isVertical() ? \"topPx\" : \"leftPx\"\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(sortMethod) \n        const insertIndex = orderedTiles.indexOf(this.tilePlaceHolder()) \n        \n        //this.showTiles(orderedTiles)\n        //console.log(\"hover insertIndex: \", insertIndex)\n        \n        return insertIndex\n    }\n\n    // --- drag destination ---\n\n    onDragDestinationEnter (dragView) {\n        this.setHasPausedSync(true)\n\n        // insert place holder view\n        if (!this.tilePlaceHolder()) {\n            this.newTilePlaceHolder(dragView)\n            this.tilePlaceHolder().setMinAndMaxHeight(dragView.computedHeight())\n            this.onDragDestinationHover(dragView)\n        }\n    }\n\n    onDragDestinationHover (dragView) {\n        // move place holder view\n        const ph = this.tilePlaceHolder()\n        if (ph) {\n            this.syncTilePlaceHolderSize(dragView)\n            const vp = this.viewPosForWindowPos(dragView.dropPoint())\n            if (this.isVertical()) {\n                const h = dragView.computedHeight()\n                const y = vp.y() - h/2\n                ph.setTopPx(y)\n            } else {\n                const w = dragView.computedWidth()\n                const x = vp.x() - w/2\n                //console.log(\"w:\" + w + \" x:\" + vp.x())\n                ph.setLeftPx(x)\n            }\n            //console.log(\"ph.top() = \", ph.top())\n            this.stackTiles() // need to use this so we can animate the tile movements\n        }\n    }\n    \n    onDragDestinationExit (dragView) {\n        this.endDropMode()\n    }\n\n    onDragDestinationEnd (aDragView) {\n        this.endDropMode()\n    }\n\n    acceptsDropHoverComplete (aDragView) {\n        return this.acceptsDropHover(aDragView);\n    }\n\n    dropCompleteDocumentFrame () {\n        return this.tilePlaceHolder().frameInDocument()\n    }\n\n\n    removeTilePlaceHolder () {\n        this.debugLog(\"removeTilePlaceHolder\")\n\n        const ph = this.tilePlaceHolder()\n        if (ph) {\n            //console.log(\"removeTilePlaceHolder\")\n            if (this.hasSubview(ph)) {\n                this.removeSubview(ph)\n            }\n            this.setTilePlaceHolder(null)\n        }\n    }\n\n    animateRemoveTilePlaceHolderAndThen (resolve) {\n        this.debugLog(\"animateRemoveTilePlaceHolder\")\n\n        const ph = this.tilePlaceHolder()\n        if (ph) {\n            ph.setMinAndMaxHeight(0)\n            this.addTimeout(() => {\n                this.removeTilePlaceHolder()\n                if (resolve) { resolve() }\n            }, 1*1000)\n        } else {\n            if (resolve) { resolve() }\n        }\n    }\n\n    endDropMode () {\n        this.debugLog(\"endDropMode\")\n        //this.unstackTiles()\n        this.removeTilePlaceHolder()\n        this.unstackTiles()\n        this.setHasPausedSync(false)\n        this.didReorderTiles()\n\n        /*\n        this.animateRemoveTilePlaceHolderAndThen(() => {\n         this.debugLog(\"endDropMode\")\n            this.unstackTiles()\n            this.setHasPausedSync(false)\n            this.didReorderTiles()\n        })\n        */\n\n        return this\n    }\n\n    /*\n    tileIndexForViewportPoint (aPoint) {\n        if (this.tiles().length === 0) {\n            return 0\n        }\n\n        const tile = this.tiles().detect((tile) => {\n            return tile.frameInDocument().containsPoint(aPoint)\n        })\n\n        if (tile) {\n            return this.tiles().indexOf(tile)\n        }\n\n        return this.tiles().length\n    }\n    */\n\n    // Browser drop from desktop\n\n    acceptsDrop () {\n        return true\n    }\n\n\n}.initThisCategory());\n",
  "mdHo4Pnt8Fah0PCTpf0/JAuO6fa5LQ0mh3BXYGn3Xqc=": "\"use strict\";\n\n/*\n    \n    TilesView_selection\n    \n*/\n\n(class TilesView_selection extends TilesView {\n    \n    // --- column ---\n\n    unselectTilesInNextColumn () {\n        const c = this.nextColumn()\n        if (c) {\n            c.unselectAllTiles()\n        }\n        return this\n    }\n\n    /*\n    didSelectItem (itemView) {\n        console.log(this.typeId() + \" didSelectItem\")\n        this.subviews().forEach(sv => {\n            if (sv === itemView) {\n                //sv.select()\n            } else {\n                sv.unselect()\n            }\n        })\n    \n        return false\n    }\n    */\n\n    lastSelectedTile () {\n        return this.selectedTiles().maxItem(tile => tile.lastSelectionDate().getTime())\n    }\n\n    // -- update isSelected ---\n\t\n    didUpdateSlotIsSelected (oldValue, newValue) {\n        debugger;\n        super.didUpdateSlotIsSelected(oldValue, newValue)\n\n        if (this.isSelected()) {\n            const focusedView = WebBrowserWindow.shared().activeDomView()\n\n            // TODO: need a better solution to this problem\n            if (!focusedView || (focusedView && !this.hasFocusedDecendantView())) {\n                this.focus()    \n            }\n        } else {\n            this.blur()\n        }\n\t\t\n        return this\n    }\n\n    // --- tile tapping ---\n\n    selectNode (aNode) {\n        const sv = this.subviewForSubnode(aNode)\n        if (sv) {\n            this.didTapItem(sv)\n        }\n        return this\n    }\n\n    didTapItem (anItem) {\n        //debugger;\n        // if the item is already selected, this won't trigger a resync, so unselect first?\n        //anItem.unselect()\n        //debugger; \n        anItem.activate() \n        if (!anItem.hasFocusedDecendantView()) {\n            anItem.focus()\n            // anItem seems to already be focused somehow\n        }\n        this.unselectAllTilesExcept(anItem)\n        this.unselectTilesInNextColumn()\n        //this.tilesView().didChangeNavSelection()\n\n        this.didChangeNavSelection() // this may already have been sent - but only if selection bool changed\n    }\n    \n    didShiftTapItem (anItem) {\n        let lastItem = this.lastSelectedTile()\n\n        if (!lastItem) {\n            lastItem = this.tiles().first()\n        }\n\n        if (lastItem) {\n            const r1 = this.indexOfTile(anItem)\n            const r2 = this.indexOfTile(lastItem)\n            assert(r1 !== -1 && r2 !== -1)\n            const i1 = Math.min(r1, r2)\n            const i2 = Math.max(r1, r2)\n            for (let i = i1; i <= i2; i++) {\n                const item = this.tileAtIndex(i)\n                if (!item.isSelected()) {\n                    item.activate()\n                }\n            }\n        }\n\n        return this\n    }\n\n    didMetaTapItem (anItem) {\n        anItem.toggleSelection()\n    }\n\n    // --- unselecting tiles ---\n        \n    unselectAllTilesExcept (selectedTile) {\n        const tiles = this.tiles()\n\n        // unselect all other tiles\n        tiles.forEach(tile => {\n            if (tile !== selectedTile) {\n                if (tile.unselect) {\n                    tile.unselect()\n                } else {\n                    //console.warn(\"=WARNING= \" + this.typeId() + \".unselectAllTilesExcept() tile \" + tile.typeId() + \" missing unselect method\")\n                }\n            }\n        })\n        \n        return this\n    }\n\n    unselectAllTilesExceptTiles (tilesToSelect) {\n        const tiles = this.tiles()\n\n        // unselect all other tiles\n        tiles.forEach(tile => {\n            if (tilesToSelect.contains(tile)) {\n                tile.performIfResponding(\"select\") \n            } else {\n                tile.performIfResponding(\"unselect\") \n            }\n        })\n        \n        return this\n    }\n\n    // --- selection ---\n\n    /*\n    didSelectTile (aTile) {\n        this.didChangeNavSelection()\n    }\n\n    didUnselectTile (aTile) {\n        this.didChangeNavSelection()\n\n    }\n    */\n\n    hasMultipleSelections () {\n        return this.selectedTiles().length > 0\n    }\n\n    // --- selected tiles ---\n\n    selectedTiles () {\n        let tiles = this.tiles().filter(tile => tile.thisClass().isSubclassOf(Tile))\n        const selected = tiles.filter(tile => tile.isSelected())\n        return selected\n    }\n\n    selectedTile () {\n        const sr = this.selectedTiles()\n        if (sr.length === 1) {\n            return sr.first()\n        }\n        return null\n    }\n\n    // --- selected nodes ---\n\n    selectedNodes () {\n        return this.selectedTiles().map(tile => tile.node())\n    }\n\n    selectedNode () {\n        const r = this.selectedTile()\n        return r ? r.node() : null\n    }\n    \n    selectedTileIndex () { \n        // returns -1 if no tiles selected\n        return this.tiles().indexOf(this.selectedTile())\n    }\n\n    // --- selecting tiles ---\n    \n    setSelectedTileIndex (index) {\n        const oldIndex = this.selectedTileIndex()\n        //console.log(\"this.setSelectedTileIndex(\" + index + \") oldIndex=\", oldIndex)\n        if (index !== oldIndex) {\n            const tiles = this.tiles()\n            if (index >= 0 && index < tiles.length) {\n                const tile = tiles[index]\n                this.didTapItem(tile)\n            }\n        }\n        return this\n    }\n  \n    indexOfTileWithNode (aNode) {\n        return this.tiles().detectIndex(tile => tile.node() === aNode)\n    }\n\n    selectAllTiles () {\n        this.tiles().forEachPerformIfResponds(\"select\")\n        return this\n    }\n\n    unselectAllTiles () {\n        this.tiles().forEachPerformIfResponds(\"unselect\")\n        return this\n    }\n\n    selectTileWithNode (aNode) {\n        //console.log(\">>> column \" + this.node().title() + \" select tile \" + aNode.title())\n        const selectedTile = this.tileWithNode(aNode)\n\t\t\n        if (selectedTile) {\n            selectedTile.setIsSelected(true)\n\t\t\t\n            this.tiles().forEach((aTile) => {\n                if (aTile !== selectedTile) {\n                    aTile.unselect()\n                }\n            })\n        }\n\n        return selectedTile\n    }\n    \n    selectedTileTitle () {\n        const tile = this.selectedTile()\n        if (tile) { \n            return tile.title().innerHtml() \n        }\n        return null\n    }\n\n    showSelected () {\n        /*\n        TODO: add check if visible\n        if (this.selectedTile()) {\n            this.selectedTile().scrollIntoView()\n        }\n        */\n        //this.didChangeNavSelection()\n        return this\t    \n    }\n\n     // nextTile\n\n     nextTile () {\n        const si = this.selectedTileIndex()\n        if (si !== -1 && si < this.tiles().length) {\n            const nextTile = this.tiles()[si +1]\n            return nextTile\n        }\n        return null\n    }\n    \n    selectFirstTile () {\n        this.setSelectedTileIndex(0)\n        return this\n    }\n\n    firstTile () {\n        if (this.tiles().length > 0) {\n            return this.tiles()[0]\n        }\n        return null\n    }\n\n    selectNextTile () {\n        const si = this.selectedTileIndex()\n        if (si === -1) {\n            this.setSelectedTileIndex(0)\n        } else {\n            this.setSelectedTileIndex(si + 1)\n        }\n        return this\n    }\n    \n    selectPreviousTile () {\n        const si = this.selectedTileIndex()\n        if (si === -1) {\n            this.setSelectedTileIndex(0)\n        } else {\n            this.setSelectedTileIndex(si - 1)\n        }\n        return this\n    }\n\n    // --- focus / selection ---\n    \n    isInBrowser () {\n        return !Type.isNull(this.parentView())\n    }\n\n    shouldFocusAndExpandSubnode (aNote) { // focus & expand tile - can be activated by note from node\n        if (!this.isInBrowser()) {\n            return this\n        }\n\n\t    const subnode = aNote.info()\n\t    let subview = this.subviewForNode(subnode)\n\t    \n        if (!subview) {\n            this.syncFromNodeNow()\n\t        subview = this.subviewForNode(subnode)\n        } \n\n        if (subview) {\n            this.selectTileWithNode(subnode)\n            subview.scrollIntoView()\n            subview.justTap()\n            //this.didChangeNavSelection()\n\t\t    //subview.dynamicScrollIntoView()\n        } else {\n            console.warn(this.type() + \" for node \" + this.node().typeId() + \" has no matching subview for shouldSelectSubnode \" + subnode.typeId())\n\t    }\n\n\t    return this \n    }\n\n    shouldFocusSubnode (aNote) { //  focus but don't expand tile\n\t    const subnode = aNote.info()\n\n\t    let subview = this.subviewForNode(subnode)\n\t    \n        if (!subview) {\n            this.syncFromNodeNow()\n\t        subview = this.subviewForNode(subnode)\n        } \n\n        if (subview) {\n            this.selectTileWithNode(subnode)\n            subview.scrollIntoView()\n\n            // just focus the tile without expanding it\n            /*\n            if (this.previousItemSet()) {\n                this.previousItemSet().didChangeNavSelection()\n            }\n            */\n\n            this.didChangeNavSelection()\n\t\t    //subview.dynamicScrollIntoView()\n        } else {\n            console.warn(this.type() + \" for node \" + this.node().typeId() + \" has no matching subview for shouldFocusSubnode \" + subnode.typeId())\n            //console.log(\"tile nodes = \", this.tiles().map(tile => tile.node().typeId()) )\n\t    }\n\n\t    return this \n    }\n\n    didChangeNavSelection () {\n        const sv = this.stackView()\n        if (sv) {\n            sv.didChangeNavSelection()\n        }\n        return this\n    }\n\t\n    // --- scrolling ---\n\n    scrollToSubnode (aSubnode) {\n\t    //this.debugLog(\".scrollToSubnode\")\n\t    const subview = this.subviewForNode(aSubnode)\n\t    assert(subview)\n\t    this.navView().scrollView().setScrollTop(subview.offsetTop())\n\t    return this \t    \n    }\n\n    scrollToBottom () {\n        const last = this.tiles().last()\n\n        if (last) { \n            last.scrollIntoView()\n        }\n\n        return this\n    }\n\n    // --------------\n\n    /*\n    focus () {\n        super.focus()\n\t\t\n\t    if (this.selectedTileIndex() === -1) {\n            const sr = this.tiles().first()\n            if (sr) {\n                sr.setShouldShowFlash(true)\n            }\n            this.setSelectedTileIndex(0)\n        }\n\n        //this.debugLog(\" focus\")\n        return this\n    }\n    */\n    \n    selectNextColumn () {\n        const nextColumn = this.nextColumn()\n        if (nextColumn) {\n            this.blur()\n            //console.log(\"nextColumn.focus()\")\n            /*\n            const sr = nextColumn.selectedTile()\n            if (sr) {\n                sr.setShouldShowFlash(true)\n            }\n            */\n            nextColumn.focus()\n            nextColumn.selectFirstTile()\n        }\n        return this\n    }\n\n    selectPreviousColumn () {\n        //this.log(\"selectPreviousColumn this.columnIndex() = \" + this.columnIndex())\n        const prevColumn = this.previousItemSet()\n        if (prevColumn) {\n            this.blur()\n            prevColumn.focus()\n            //this.didChangeNavSelection()\n        }\n        return this\n    }\n\n    // --- select nodes ---\n\n    selectAndFocusNodes (nodes) {\n        const selectTiles = this.tilesWithNodes(nodes)\n        this.unselectAllTilesExceptTiles(selectTiles)\n        if (nodes.length === 1) {\n            const focusNode = nodes.first()\n            focusNode.parentNode().postShouldFocusAndExpandSubnode(focusNode)\n        }\n        return this\n    }\n\n    // --- key views ---\n    \n    selectNextKeyView () {\n        const nextTile = this.nextTile()\n        if (nextTile) {\n            this.selectNextTile()\n            nextTile.becomeKeyView()\n        } else {\n            const firstTile = this.firstTile()\n            if (firstTile) {\n                this.selectFirstTile()\n                firstTile.becomeKeyView()\n            }\n        }\n        return this\n    }\n\n    // --- helpers ---\n\n    selectFirstTile () {\n        if (this.subviews().length) {\n            this.setSelectedTileIndex(0)\n        }\n        return this\n    }\n\n    selectLastTile () {\n        const count = this.subviews().length\n        if (count) {\n            this.setSelectedTileIndex(count - 1)\n        }\n    }\n\n}.initThisCategory());\n",
  "xgCHx4htlsCYDA27n5Fe08Tf/kJUyT65r9Dt3O4dBPU=": "\"use strict\";\n\n/*\n    \n    TilesView_orientation\n    \n*/\n\n(class TilesView_orientation extends TilesView {\n    \n    // --- orientation ---\n\n    syncOrientation () {\n        if (this.isVertical()) {\n            this.makeOrientationRight()\n        } else {\n            this.makeOrientationDown() \n        }\n        return this\n    }\n\n    /*\n    makeOrientationRight () {  \n        //super.makeOrientationRight()\n\n        //stackview is right so nav is top to bottom\n        //this.debugLog(\"makeOrientationRight\")\n\n        this.setMinAndMaxWidth(\"100%\")\n        this.setMinAndMaxHeight(\"fit-content\")\n    }\n\n    makeOrientationDown () { \n         //super.makeOrientationDown()\n       // stackview is down so nav is left to right\n\n       this.setMinAndMaxWidth(\"fit-content\")\n       this.setMinAndMaxHeight(\"100%\")\n    }\n    */\n\n    makeOrientationRight () { \n        // stack left to right columns, so top to bottom items\n        this.setFlexDirection(\"column\") //  need to use flex to avoid gaps in rows despite 0 marins\n\n        \n        this.setMinWidth(\"100%\")\n        this.setHeight(\"fit-content\")\n        this.setMinHeight(\"100%\")\n\n        //this.setMaxHeight(\"fit-content\")\n        //this.setMinHeight(\"100%\")\n\n        //this.setMaxHeight(\"fit-content\")\n        //this.setFlexBasis(\"300px\")\n        //this.setMinAndMaxWidth(\"300px\")\n        //this.setMinAndMaxHeight(null)\n\n\n        this.debugLog(\"makeOrientationRight on \", this.node() ? this.node().title() : null)\n\n        /*\n        this.tiles().forEach(item => {\n            //item.setWidth(\"fit-content\")\n            item.setMinAndMaxWidth(\"100%\")\n            item.setMinAndMaxHeight(\"fit-content\")\n            //item.setHeight(this.desiredHeight()) // this could cause reflow, so let's avoid if we can\n            //console.log(\"    prepare for down orientation on subview \", item.node().title())\n        })\n        */\n\n        if (this.node()) {\n            const align = this.node().nodeChildrenAlignment()\n            //this.setJustifyContent(null)\n            if (this.validAlignItemsPropertyValues().contains(align)) {\n                this.setJustifyContent(align)\n                //this.setAlignItems(align)\n            } else {\n                debugger;\n                //this.node().setNodeChildrenAlignment(null) // can't do a node modifcation during a view update or sync loop will be detected\n            }\n        }\n    }\n\n    makeOrientationDown () { \n        // stackview is down, so items are left to right\n        this.setFlexDirection(\"row\")\n\n        this.setMinWidth(\"100%\")\n        this.setWidth(\"fit-content\")\n        this.setMinAndMaxHeight(\"100%\")\n\n        //this.setMinAndMaxWidth(null)\n        //this.setMinAndMaxHeight(\"50px\")   \n        //this.setFlexBasis(\"300px\")\n\n        this.debugLog(\"makeOrientationDown on \", this.node() ? this.node().title() : null)\n\n        /*\n        this.tiles().forEach(item => {\n            //item.setMinAndMaxWidth(\"100%\")\n            item.setMinAndMaxHeight(\"100%\")\n            //item.setHeight(this.desiredHeight()) // this could cause reflow, so let's avoid if we can\n            //console.log(\"    prepare for down orientation on subview \", item.node().title())\n        })\n        */\n\n        if (this.node()) {\n            const align = this.node().nodeChildrenAlignment()\n            if (this.validJustifyContentPropertyValues().contains(align)) {\n                this.setJustifyContent(align)\n            } else {\n                //this.node().setNodeChildrenAlignment(null) // can't do a node modifcation during a view update or sync loop will be detected\n            }\n            this.setAlignItems(null)\n        }\n    }\n\n    // --- get orientation ---\n\n    isVertical () {\n        const sv = this.stackView()\n        if (!sv) {\n            return null\n        }\n        return sv.direction() === \"right\"\n    }\n\n    // --- stacking general ---\n\n    stackTiles () {\n        //this.assertTilesHaveParent()\n\n        if (this.isVertical()) {\n            this.stackTilesVertically()\n        } else {\n            this.stackTilesHorizontally()\n        }\n        return this\n    }\n\n    unstackTiles () {\n        //this.assertTilesHaveParent()\n\n        if (this.isVertical()) {\n            this.unstackTilesVertically()\n        } else {\n            this.unstackTilesHorizontally()\n        }\n        return this\n    }\n\n    // --- stacking vertical ---\n\n    stackTilesVertically () {\n        // we don't need to order tiles for 1st call of stackTiles, \n        // but we do when calling stackTiles while moving a drop view around,\n        // so just always do it as top is null, and tiles are already ordered the 1st time\n\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"topPx\")\n        const displayedTiles = orderedTiles.filter(r => !r.isDisplayHidden())\n        let y = 0\n        \n\n        const offsets = displayedTiles.map(tile => tile.offsetTop())\n        //console.log(\"---\")\n\n        // NOTE: having issues getting absolute positions to match relative ones\n        // Why is getBoundingClientRect on tile always returning same top value as offsetParent.getBoundingClientRect ???\n\n        displayedTiles.forEachKV((i, tile) => {\n            //const oy = offsets[i]\n            /*\n            const dy = i === 0 ? 0 : offsets[i] - offsets[i-1]\n            const parentRect = tile.element().offsetParent.getBoundingClientRect()\n            const rect = tile.boundingClientRect()\n            let h = parentRect.top - rect.top\n            */\n\n            let h = tile.computedHeight() \n            //let h = tile.offsetHeight()\n\n            //console.log(\"h: \" + h + \" dy:\" + dy)\n            //console.log(\"y: \" + y + \" oy:\" + offsets[i])\n\n            if (tile.position() !== \"absolute\") { \n                // they are all not absolute when first dragging in\n                // and stay absolute until unstack gets called at end of drag\n                tile.makeAbsolutePositionAndSize()\n                tile.setLeftPx(0)\n                tile.setOrder(null)\n            } \n\n            /*\n            console.log(\"i:\" + i)\n            console.log(\"   computedHeight:\" + tile.computedHeight())\n            console.log(\"     offsetHeight:\" + tile.offsetHeight())\n            console.log(\"           offset:\" + oy)\n            console.log(\"                y:\" + y)\n            */\n\n            tile.setTopPx(y)\n            y += h + 2\n        })\n        //console.log(\"---\")\n\n        return this\n    }\n\n    unstackTilesVertically  () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"topPx\")\n        \n        orderedTiles.forEach(tile => assert(tile.hasElement()) ) // todo: temp test\n        orderedTiles.forEach(tile => tile.makeRelativePositionAndSize())\n\n        this.removeAllSubviews()\n        this.addSubviews(orderedTiles)\n        return this\n    }\n\n    // --- stacking horizontal ---\n\n    stackTilesHorizontally () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"leftPx\") \n        const displayedTiles = orderedTiles.filter(r => !r.isDisplayHidden())\n        let x = 0\n\n        /*\n        let names = []\n        this.tiles().forEach((tile) => { \n            if (tile.node) { \n                names.push(tile.node().title() + \" \" + tile.leftPx() + \"px\")\n            }\n        })\n        console.log(\"horizontal: \", names.join(\", \"))\n        */\n        \n        displayedTiles.forEach((tile) => {\n            let w = tile.computedWidth() \n            if (tile.position() !== \"absolute\") {\n                tile.makeAbsolutePositionAndSize()\n                tile.setTopPx(0)\n                tile.setOrder(null)\n            }\n            tile.setLeftPx(x)\n            x += w\n        })\n\n        return this\n    }\n\n    unstackTilesHorizontally () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"leftPx\")\n        orderedTiles.forEachPerform(\"makeRelativePositionAndSize\")\n        this.removeAllSubviews()\n        this.addSubviews(orderedTiles)\n        return this\n    }\n\n\n}.initThisCategory());\n",
  "Y1gUt4dZyNRdR5COza7uGcJi4NS6ePltLeiNPQ44h2Q=": "\"use strict\";\n\n/*\n    \n    TilesView_keyboard\n    \n*/\n\n(class TilesView_keyboard extends TilesView {\n    \n    // --- keyboard controls, arrow navigation ---\n\n    canNavigate () {\n        return this.allowsCursorNavigation() \n        //return this.allowsCursorNavigation() && this.isActiveElement()\n    }\n\n    // --- controls ---\n\n    /*\n    onShiftDeleteKeyUp (event) {\n        if (!this.canNavigate()) { \n            return \n        }\n\n        this.deleteSelectedTiles()\n        return false\n    }\n    */\n\n    onMetaBackspaceKeyDown (event) {\n        console.log(\"meta backspace\")\n        this.onMetaDeleteKeyDown(event)\n    }\n\n    onMetaDeleteKeyDown (event) {\n        console.log(\"meta delete\")\n        if (!this.canNavigate()) { \n            return \n        }\n\n        this.deleteSelectedTiles()\n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n    onMetaKeyDown (event) {\n        // do we need to hook this to avoid meta being stolen by app? \n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n    onMeta_d_KeyDown (event) {\n        console.log(\"duplicate selection down\")\n        this.duplicateSelectedTiles()\n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n    onMeta_n_KeyDown (event) {\n        this.debugLog(this.type() + \" for \" + this.node().title() + \" onMeta_n_KeyDown\")\n        this.addIfPossible()\n        event.stopPropagation()\n        event.preventDefault()\n    }\n\n    onShiftBackspaceKeyUp (event) {\n        this.debugLog(this.type() + \" for \" + this.node().title() + \" onShiftBackspaceKeyUp\")\n        if (this.selectedTile()) { \n            this.selectedTile().delete()\n        }\n        event.stopPropagation()\n    }\n\n    addIfPossible () {\n        const node = this.node()\n\n        if (node.nodeCanAddSubnode()) {\n            const newNode = node.add()\n            if (newNode) {\n                this.syncFromNode()\n                const newSubview = this.subviewForNode(newNode)\n                newSubview.justTap()\n            }\n        }\n    }\n\n    // --- duplicate ---\n\n    onAlternate_d_KeyUp (event) {\n        //this.debugLog(\" onMetaLeft_d_KeyUp\")\n        this.duplicateSelectedTile()\n        return false // stop propogation\n    }\n\n    // select all\n\n    onMeta_a_KeyDown (event) {\n        this.selectAllTiles()\n        event.stopPropagation()\n        event.preventDefault();\n    }\n\n\n    onControl_c_KeyUp (event) {\n        // copy?\n    }\n\n    onControl_p_KeyUp (event) {\n        // paste?\n    }\n\n    // --- shift arrow keys ---\n\n    /*\n    activateSelectedTile () {\n        const tile = this.selectedTile()\n        if (tile && tile.activate) {\n            tile.activate()\n        }\n        return this\n    }\n\n    onShiftUpArrowKeyDown (event) {\n        const result = this.onUpArrowKeyDown(event)\n        this.activateSelectedTile()\n        return result \n    }\n\n    onShiftDownArrowKeyDown (event) {\n        const result =  this.onDownArrowKeyDown(event)\n        this.activateSelectedTile()\n        return result\n    }\n    */\n\n    // --- Alternate arrow keys ---\n\n    onAlternateUpArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (this.isVertical()) {\n            this.selectFirstTile()\n        }\n        return false\n    }\n\n    onAlternateDownArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (this.isVertical()) {\n            this.selectLastTile()\n        } \n        return false\n    }\n\n    onAlternateLeftArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (!this.isVertical()) {\n            this.selectFirstTile()\n        }\n        return false\n    }\n\n    onAlternateRightArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (!this.isVertical()) {\n            this.selectLastTile()\n        } \n        return false\n    }\n\n\n    // --- normal arrow keys ---\n\n    onUpArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (this.isVertical()) {\n            this.moveDown()\n        } else {\n            this.moveLeft()\n        }\n        return false\n    }\n\t\n    onDownArrowKeyDown (event) { // why down and not up?\n        if (!this.canNavigate()) { \n            return \n        }\n\n        if (this.isVertical()) {\n            this.moveUp()\n        } else {\n            this.moveRight()\n        }\n        return false\n    }\n\t\n    onLeftArrowKeyUp (event) {\n        if (!this.canNavigate()) { \n            return this\n        }\t\n        if (this.isVertical()) {\n            this.moveLeft()\n        } else {\n            this.moveDown()\n        }\n    }\n\t\n    onRightArrowKeyUp (event) {\n        if (!this.canNavigate()) { \n            return this\n        }\t\n\n        if (this.isVertical()) {\n            this.moveRight()\n        } else {\n            this.moveUp()\n        }\n    }\n\n    // --- arrow moves ---\n\n    moveLeft () {\n        const pc = this.previousItemSet()\t\n        if (pc) {\n            if (this.selectedTile()) { \n                this.selectedTile().unselect() \n            }\n\t\t\t\n            const newSelectedTile = pc.selectedTile()\n            newSelectedTile.setShouldShowFlash(true).updateSubviews()\n            pc.didTapItem(newSelectedTile)\n        \tthis.selectPreviousColumn()\n\n            //debugger;\n            pc.didChangeNavSelection()\n        }\n        return this\n    }\n\n    moveRight () {\n        this.selectNextColumn()\n        return this\n    }\n\n    moveUp () {\n        this.selectNextTile()\n        this.showSelected()\n        return this\n    }\n\n    moveDown () {\n        this.selectPreviousTile()\n        this.showSelected()\n        return this\n    }\n\n    // --- escape ---\n\n    onEscapeKeyDown (event) {\n        //this.setIsColumnInspecting(false)\n\n        if (!this.canNavigate()) { \n            return this\n        }\t\n\n        this.moveLeft()\n        //return true\n    }\n\t\n    // --- enter key begins tile editing ---\n\t\n    onEnterKeyUp (event) {        \n        if (!this.canNavigate()) { \n            return this\n        }\n\t\n        // carefull - if Tile is registered fro keyboard,\n        // this may cause onEnterKeyUp to be sent twice\n        const tile = this.selectedTile()\n        if (tile) { \n\t\t    tile.onEnterKeyUp(event)\n        }\n\n        return false\n    }\n\n    // --- keyboard controls, add and delete actions ---\n\n    deleteTile (aTile) {\n        let sNode = aTile.node()\n        if (sNode && sNode.canDelete()) { \n\t\t\tsNode.performNodeAction(\"delete\") \n\t\t}\n        return this\n    }\n\n    deleteSelectedTiles () {\n        this.selectedTiles().forEach(r => this.deleteTile(r))\n\n        if (this.tiles().length === 0) {\n            this.selectPreviousColumn()\n        }\n    }\n\t\n    onPlusKeyUp (event) {\n        if (!this.canNavigate()) { \n            return \n        }\t\t\n\n        const sNode = this.selectedNode()\n        if (sNode && sNode.hasNodeAction(\"add\")) { \n            const newNode = sNode.performNodeAction(\"add\") \n            this.selectNextColumn()\n            if (this.nextColumn()) {\n                this.nextColumn().selectTileWithNode(newNode)\n            }\n        }\n        return false\t\t\n    }\n\t\n\n}.initThisCategory());\n",
  "p7MJr88zFEGzVJWCVQYlOv/k4HJC9JS0QJiFc9GG9xI=": "\"use strict\";\n\n/*\n    \n    TilesView_gestures\n    \n*/\n\n(class TilesView_gestures extends TilesView {\n    \n    // --- tap ---\n\n    onTapComplete (aGesture) {\n        //console.log(this.typeId() + \" \" + this.node().title() + \" .onTapComplete() shouldRequestActivation: \", aGesture.shouldRequestActivation())\n        \n        if (this.node()) {\n\n            // add a subnode if tapping on empty area\n            const p = aGesture.downPosition() // there may not be an up position on windows?\n            //this.debugLog(\".onTapComplete() \", aGesture.upEvent())\n            if (p.event().target === this.element()) {\n                const keyModifiers = BMKeyboard.shared().modifierNamesForEvent(aGesture.upEvent());\n                const isAltTap = keyModifiers.contains(\"Alternate\");\n                if (isAltTap) {\n                    // inspect parent node\n                    //this.setIsColumnInspecting(true)\n                    return this\n                } else {\n                    this.addIfPossible()\n                }\n            }\n        }\n        return true\n    }\n\n    // --- reorder ---\n\n    canReorderTiles () {\n        return this.node().nodeTileLink().nodeCanReorderSubnodes()\n    }\n\n    didReorderTiles () { \n        if (!this.node() || !this.isInBrowser()) {\n            return this\n        }\n        // TODO: make a more scaleable API\n        const subnodes = this.tiles().map(tile => tile.node())\n        this.node().nodeTileLink().nodeReorderSudnodesTo(subnodes)\n        //this.node().nodeReorderSudnodesTo(subnodes)\n        return this\n    }\n\n    // --- pinch apart to create a tile ---\n\n    tileContainingPoint (aPoint) {\n        // potentially faster:\n        //const topElement = document.elementFromPoint(aPoint.x(), aPoint.y())\n        // now see if topElement has this.element() as an ancestor\n\n        return this.tiles().detect((tile) => {\n            return tile.frameInDocument().containsPoint(aPoint)\n        })\n    }\n\n    onPinchBegin (aGesture) { // pinch apart to insert a new tile\n        // TODO: move tile specific code to Tile\n\n        //this.debugLog(\".onPinchBegin()\")\n\n        // - calc insert index\n        const p = aGesture.beginCenterPosition()\n        const tile = this.tileContainingPoint(p)\n        if (!tile) {\n            // don't allow pinch if it's bellow all the tiles\n            // use a tap gesture to create a tile there instead?\n            return this\n        }\n\n        const insertIndex = this.tiles().indexOf(tile)\n\n        //console.log(\"insertIndex: \", insertIndex)\n\n        if (this.node().hasNodeAction(\"add\")) {\n            // create new subnode at index\n            const newSubnode = this.node().addAt(insertIndex)\n\n            // reference it with _temporaryPinchSubnode so we\n            // can delete it if pinch doesn't complete with enough height\n            this._temporaryPinchSubnode = newSubnode\n\n            // sync with node to add tile view for it\n            this.syncFromNodeNow()\n\n            // find new tile and prepare it\n            const newTile = this.subviewForNode(newSubnode)\n            newTile.setMinAndMaxHeight(0)\n            newTile.contentView().setMinAndMaxHeight(64)\n            newTile.setTransition(\"all 0.3s\")\n            newTile.contentView().setTransition(\"all 0s\")\n            newTile.setBackgroundColor(\"black\")\n\n            // set new tile view height to zero and \n            const minHeight = Tile.defaultHeight()\n            const cv = newTile.contentView()\n            cv.setBackgroundColor(this.navView().backgroundColor())\n            cv.setMinAndMaxHeight(minHeight)\n            //newTile.scheduleSyncFromNode()\n            //this._temporaryPinchSubnode.didUpdateNode()\n        } else {\n            //this.debugLog(\".onPinchBegin() cancelling due to no add action\")\n\n            aGesture.cancel()\n        }        \n    }\n    \n    onPinchMove (aGesture) {\n        if (this._temporaryPinchSubnode) {\n            let s = Math.floor(aGesture.spreadY())\n            if (s < 0) {\n                s = 0\n            }\n            //this.debugLog(\".onPinchMove() s = \", s)\n            const minHeight = Tile.defaultHeight()\n            const newTile = this.subviewForNode(this._temporaryPinchSubnode)\n            //newTile.setBackgroundColor(\"black\")\n            newTile.setMinAndMaxHeight(s)\n            const t = Math.floor(s/2 - minHeight/2);\n            newTile.contentView().setTopPx(t)\n\n            const h = Tile.defaultHeight()\n\n            if (s < h) {\n                const f = s/h;\n                const rot = Math.floor((1 - f) * 90);\n                newTile.setPerspective(1000)\n                newTile.setTransformOrigin(0)\n                //newTile.contentView().setTransformOriginPercentage(0)\n                newTile.contentView().setTransform(\"rotateX(\" + rot + \"deg)\")\n                const z = -100 * f;\n                //newTile.contentView().setTransform(\"translateZ(\" + z + \"dg)\")\n            } else {\n                newTile.setPerspective(null)\n                newTile.contentView().setTransform(null)                \n            }\n        } else {\n            console.warn(this.typeId() + \".onPinchMove() missing this._temporaryPinchSubnode\")\n        }\n        // do we need to restack views?\n    }\n\n    onPinchComplete (aGesture) {\n        //this.debugLog(\".onPinchCompleted()\")\n        // if pinch is tall enough, keep new tile\n\n        if (this._temporaryPinchSubnode) {\n            const newTile = this.subviewForNode(this._temporaryPinchSubnode)\n            const minHeight = Tile.defaultHeight()\n            if (newTile.clientHeight() < minHeight) {\n                this.removeTile(newTile)\n            } else {\n                //newTile.setTransition(\"all 0.3s, height 0s\")\n                this.addTimeout(() => { \n                    newTile.contentView().setTopPx(0)\n                    newTile.setMinAndMaxHeight(minHeight) \n                }, 0)\n            }\n\n            this._temporaryPinchSubnode = null\n        }\n    }\n\n    onPinchCancelled (aGesture) {\n        //this.debugLog(\".onPinchCancelled()\")\n        if (this._temporaryPinchSubnode) {\n            this.node().removeSubnode(this._temporaryPinchSubnode)\n            this._temporaryPinchSubnode = null\n        }\n    }\n\n}.initThisCategory());\n",
  "Da8bvMUAAcHIZgRHYnxRTD4h3o5uyysUO0Ay6oiQCDc=": "\"use strict\";\n\n/*\n    \n    TilesView_helpers\n    \n*/\n\n(class TilesView_helpers extends TilesView {\n    \n    // --- reordering support ---\n\n    /*\n    absolutePositionTiles () {\n        const ys = []\n        this.tiles().forEach((tile) => {\n            const y = tile.relativePos().y()\n            ys.append(y)\n        })\n\n        let i = 0\n        this.tiles().forEach((tile) => {\n            const y = ys[i]\n            i ++\n            tile.unhideDisplay()\n            tile.setPosition(\"absolute\")\n            tile.setTopPx(y)\n            tile.setLeftPx(0)\n            tile.setRightPx(null)\n            tile.setBottomPx(null)\n            tile.setWidthPercentage(100)\n            //console.log(\"i\" + i + \" : y\" + y)\n        })\n        \n        return this\n    }\n    */\n\n\n    /*\n    orderTiles () {\n        const orderedTiles = this.tiles().shallowCopy().sortPerform(\"topPx\")\n\n        this.tiles().forEach((tile) => {\n            tile.setPosition(\"absolute\")\n            tile.unhideDisplay()\n        })\n\n        this.removeAllSubviews()\n        this.addSubviews(orderedTiles)\n        return this\n    }\n    */\n\n    // -- stacking tiles ---\n\n    /*\n    Tile methods:\n\n    makeAbsolutePositionAndSize () {\n        const f = this.frameInParentView()\n        this.setFrameInParent(f)\n        return this \n    }\n\n    makeRelativePositionAndSize () {\n        this.setPosition(\"relative\")\n\n        this.setTopPx(null)\n        this.setLeftPx(null)\n        this.setRightPx(null)\n        this.setBottomPx(null)\n\n        this.setMinAndMaxWidth(null)\n        this.setMinAndMaxHeight(null)  \n        return this \n    }\n\n    flexDirectionLength () {\n        const fd = this.parentView().flexDirection() \n        // tile is left to right\n        if (Type.isNull(fd)) {\n            fd = \"row\"\n        }\n        assert(fd)\n        const wfunc = () => { return this.computedWidth() }\n        const hfunc = () => { return this.computedHeight() }\n        const d = {\n            \"row\" : () => hfunc,\n            \"row-reverse\" : hfunc,\n            \"column\" : () => wfunc,\n            \"column-reverse\" : wfunc,\n        }\n        return d[fd]()\n    }\n\n    flexDirectionBreadth () {\n        const fd = this.parentView().flexDirection()\n        if (fd)\n        assert(fd)\n        const wfunc = () => { return this.computedWidth() }\n        const hfunc = () => { return this.computedHeight() }\n        const d = {\n            \"row\" : wfunc,\n            \"row-reverse\" : wfunc,\n            \"column\" : () => hfunc,\n            \"column-reverse\" : hfunc,\n        }\n        return d[fd]()\n    }\n    flexDirectionStartPosition\n\n    */\n\n    // --- debugging ---\n\n    showTiles (tiles) {\n        console.log(\"tiles: \", tiles.map(r => {\n            if (r.node) {\n                return r.node().title() + (r.display() !== \"block\" ? (\"-\" + r.display()) : \"\")\n            }\n            return r.type() \n        }).join(\", \"))\n        return this\n    }\n\n    showNodes (nodes) {\n        console.log(\"nodes: \", nodes.map(node => {\n            return node.title()\n        }).join(\", \"))\n        return this\n    }\n\n    // --- helpers ---\n/*\n    debugTypeId () {\n        const comment = \" '\" + (this.node() ? this.node().title() : \"untitled node\") + \"'\"\n        return super.debugTypeId() + comment\n    }\n*/\n\n    // paths\n\n    /*\n    logName () {\n        return this.browserPathString()\n    }\n    */\n\n}.initThisCategory());\n",
  "4ItmSZ/esXunNUcDYfyAE1pvsw5fk/tSxirNAw4Hoz4=": "\"use strict\";\n\n/*\n    \n    Tile\n\n    Base tile view. This is a sort of empty canvas for subclasses to put subviews in.\n    It's important that subviews are put within the contentView, as this is used\n    to support features like slide-to-delete.\n\n    Tile supports tile features such as:\n    \n        - selection\n        - applying styles to match state\n        - slide-to-delete gesture\n        - long-press + pan-to-reorder gesture\n        - dragging\n        - close/delete button on right side\n    \n    NOTES\n    \n    Tile styles lookup order:\n\n        node -> (fallback to) -> tile -> (fallback to) -> column\n\n    See lookedUpStyles method.\n\n*/\n\n(class Tile extends NodeView {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"isSelectable\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"closeButtonView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"defaultHeight\", 30);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"restCloseButtonOpacity\", 0.4);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"transitionStyle\", \"all 0s\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"selectedFlashColor\", \"#ccc\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"shouldShowFlash\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"shouldCenterCloseButton\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"contentView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n\n        {\n            const slot = this.newSlot(\"slideDeleteOffset\", 0);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"dragDeleteButtonView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"isDeleting\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"lastTapDate\", null);\n            slot.setSlotType(\"Date\");\n        }\n        {\n            const slot = this.newSlot(\"lastSelectionDate\", null);\n            slot.setSlotType(\"Date\");\n        }\n    }\n\n    applyStyles () {\n        // we default to using the current theme, but \n        // we need to give view a chance to override style\n        // also, NodeView should override this method to give node a chance to override style\n\n        const state = this.currentThemeState()\n        if (state) {\n            /*\n            if (this.thisClass() === BreadCrumbsTile) {\n                debugger;\n            }\n            */\n            state.applyBorderStylesToView(this) // apply only border styles\n            state.applyNonBorderStylesToView(this.contentView()) // apply non border styles\n        }\n        return this\n    }\n\n    /*\n    setDisplay (v) {\n        if (v === \"block\") {\n            console.log(this.typeId() + \" setDisplay \" + v)\n        }\n        return super.setDisplay(v)\n    }\n    */\n\n    init () {\n        super.init()\n\n        this.setThemeClassName(\"Tile\")\n\n        this.setDisplay(\"inline-block\")\n        this.setPosition(\"relative\") // so absolute position on close button works\n        //this.setFlexGrow(0)\n        //this.setFlexShrink(0)\n        this.makeOrientationRight()\n\n        this.setWidth(\"100%\")\n        this.setHeight(\"fit-content\")\n        this.setWhiteSpace(\"no-wrap\")\n        //this.setHeight(\"auto\")\n\n        //this.setMinHeight(\"4em\")\n        //this.setColor(\"rbga(255, 255, 255, 0.5)\")\n        this.setTransition(\"all 0s\")\n        this.setOverflow(\"hidden\")\n        this.setWhiteSpace(\"nowrap\")\n        //this.setTransitionStyle(\"all 0.0s ease, width 0s, max-width 0s, min-width 0s\")\n        \n        /*\n        this.setBorderStyle(\"solid\")\n        this.setBorderColor(\"transparent\")\n        this.setBorderLeft(\"0px\")\n        this.setBorderRight(\"0px\")\n        this.setBorderTop(\"1px\")\n        this.setBorderBottom(\"1px\")\n        this.setTextAlign(\"left\")\n        */\n\n        this.setOverflowScrolling(\"touch\")\n\n        this.turnOffUserSelect()\n        this.setAcceptsFirstResponder(false)\n        this.setupTileContentView()\n\n        if (TouchScreen.shared().isSupported() || true) { // testing \n            //\n        } else {\n            //this.addCloseButton()\n        }\n\n        this.setTransition(this.transitionStyle())\n\n        //this.animateOpen()\n        \n        this.addGestureRecognizer(LongPressGestureRecognizer.clone()) // for long press & pan reordering\n        this.addGestureRecognizer(SlideGestureRecognizer.clone()) // for slide delete\n        //this.addGestureRecognizer(TapGestureRecognizer.clone()) // for selection, and tap-longpress\n        this.addDefaultTapGesture()\n        //this.defaultTapGesture().setShouldRequestActivation(true) // test to avoid tapping button within tile and row\n\n        //this.addGestureRecognizer(RightEdgePanGestureRecognizer.clone()) // for adjusting width?\n        //this.addGestureRecognizer(BottomEdgePanGestureRecognizer.clone()) // for adjusting height?\n\n        this.setIsRegisteredForKeyboard(true)\n        this.setIsDebugging(false)\n        return this\n    }\n\n    turnOnUserSelect () {\n        debugger;\n        super.turnOnUserSelect()\n        return this\n    }\n\n    /*\n    setNode (aNode) {\n        super.setNode(aNode)\n        return this\n    }\n    */\n\n    duplicate () {\n        const dup = super.duplicate()\n        dup.setNode(this.node().duplicate())\n        return dup\n    }\n\n    // -- contentView -- \n    // a special subview within the Tile for it's content\n    // we route style methods to it\n\n    setupTileContentView () {\n        const cv = FlexDomView.clone().setElementClassName(\"TileContentView\")\n        cv.setDisplay(\"flex\")\n        cv.setHeight(\"auto\")\n        cv.setMinHeightPx(60)\n        cv.setWidthPercentage(100)\n        cv.setHeightPercentage(100) \n        cv.setPosition(\"relative\")\n        cv.setFloat(\"left\")\n        //cv.autoFitParentWidth().autoFitParentHeight() // can't do this since we need to float left for sliding\n        //cv.setTransition(\"all 0.2s ease, transform 0s, left 0s, right 0s, width 0s, min-width 0s, max-width 0s\")\n        cv.setTransition(\"all 0s\")\n        cv.setZIndex(2) // so it will be above other views like the slide delete button \n        this.setZIndex(1)\n        this.setContentView(cv)\n        this.addSubview(cv)\n        return this\n    }\n\n    desiredWidth () {\n        return this.calcWidth()\n    }\n\n    /*\n    setMinAndMaxWidth (w) {\n        super.setMinAndMaxWidth(w)\n        this.contentView().setMinAndMaxWidth(w)\n        return this\n    }\n\n    setMinAndMaxHeight (h) {\n        super.setMinAndMaxHeight(h)\n        this.contentView().setMinAndMaxHeight(h)\n        return this\n    }\n    */\n\n    addContentSubview (aView) {\n        return this.contentView().addSubview(aView)\n    }\n\n    removeContentSubview (aView) {\n        return this.contentView().removeSubview(aView)\n    }\n\n\n    // --- helpers --------\n    \n    browser () {\n        return this.column().browser()\n    }\n\n    column () {\n        const pv = this.parentView()\n        if (pv && pv.isKindOf(TilesView)) {\n            return pv\n        }\n        return null\n    }\n    \n    navView () {\n        return this.column().navView()\n    }\n\n    // ----\n\n    didUpdateSlotIsInspecting (oldValue, newValue) {\n        //super.didUpdateSlotIsSelected (oldValue, newValue)\n        this.tilesView().didChangeNavSelection()\n        //this.updateSubviews()\n    }\n\n    didUpdateSlotIsSelected (oldValue, newValue) {\n        super.didUpdateSlotIsSelected (oldValue, newValue)\n\n        \n        if (this.isSelected()) {\n            this.setLastSelectionDate(Date.clone())\n        } else {\n            //this.setShouldShowFlash(true)\n            this.setLastSelectionDate(null)\n        }\n        \n\n        this.tilesView().didChangeNavSelection()\n        //this.updateSubviews()\n    }\n    \n    // update\n     \n    updateSubviews () {   \n        if (this.closeButtonView()) {\n            const node = this.node()\n\n            if (node) {\n                this.closeButtonView().setColor(this.currentColor()) // needed?\n            }\n\t\t\t\n            if (this.canDelete()) {\n                this.closeButtonView().setOpacity(this.restCloseButtonOpacity())\n            } else {\n                this.closeButtonView().setOpacity(0)\n            }\n\n            if (node) {\n                const h = node.nodeMinTileHeight()\n                if (h) {\n                    this.setMinAndMaxHeight(h) \n                    this.contentView().autoFitParentHeight()\n                }\n            }\n        }\n\n        /*\n        // take up full height if node asks for it\n        const node = this.node()\n        if (node && node.nodeMinTileHeight()) {\n            const e = this.element()\n            if (node.nodeMinTileHeight() === -1) {\n                this.setHeight(\"auto\")                \n                this.setPaddingBottom(\"calc(100% - 20px)\")\n            } else {\n                this.setHeight(this.pxNumberToString(node.nodeMinTileHeight()))\n            }\n        }\n        */\n        \n        this.scheduleMethod(\"applyStyles\")\n        //this.applyStyles()\n\n        return this\n    }\n    \n    // -------------\n    \n    onDidEdit (aView) {\n        this.scheduleSyncToNode() \n        return true // stop propogation\n    }\n    \n    // --- sync ---\n\t\n    syncFromNode () {\n        // is this ever called?\n        //this.syncCssFromNode()\n        const node = this.node();\n        if (node) {\n            this.setIsDisplayHidden(!node.isVisible());\n        }\n        this.updateSubviews();\n        this.syncOrientation();\n        return this;\n    }\n\n    tilesView () {\n        return this.parentView()\n    }\n\n    stackView () {\n        const scrollView = this.tilesView().parentView()\n        const navView = scrollView.parentView()\n        const stackView = navView.parentView()\n        if (stackView && stackView.thisClass().isKindOf(StackView)) {\n            return stackView\n        }\n        return null\n        //return this.firstParentViewWithAncestorClass(StackView)\n    }\n\n    direction () {\n        const sv = this.stackView()\n        if (sv) {\n            const d = sv.direction()\n            return d\n        }\n\n        const pv = this.parentView()\n        if (pv && pv.direction) {\n            return pv.direction()\n        }\n\n        return \"down\"\n    }\n\n    syncOrientation () {\n        if (!this.parentView()) {\n            return this\n        }\n\n        const d = this.direction()\n\n        if (d === \"right\") {\n            this.makeOrientationRight()\n        } else if (d === \"down\") {\n            this.makeOrientationDown()\n        }\n        return this\n    }\n\n    makeOrientationRight () {  \n        // stackview is right so tiles are top to bottom\n\n        this.setDisplay(\"inline-block\")  \n\n        this.setMinAndMaxWidth(\"100%\")\n        this.setMinHeight(\"5em\")\n        this.setHeight(\"fit-content\")\n        this.setMaxHeight(null)\n\n        //this.setWidth(\"fit-content\")\n        //this.setHeight(\"fit-content\")\n        //this.setHeight(this.parentView().desiredHeight())\n        //this.setBorderBottom(\"1px solid rgba(255, 255, 255, 0.3)\")\n\n        //this.setBorderRight(\"1px solid rgba(255, 0, 0, 1)\")\n        //this.setMinAndMaxWidth(null) // new\n        //his.setMinAndMaxHeight(null)\n        //this.setBoxShadow(\"inset -10px 0 20px rgba(0, 0, 0, 0.05)\")\n\n        /*\n        if (this.contentView()) {\n            this.contentView().setMinAndMaxHeight(null)\n        }\n        */\n    }\n\n    makeOrientationDown () { \n\n        // stackview is down so tiles are left to right\n        //this.debugLog(\"makeOrientationDown\")\n\n        this.setDisplay(\"inline-block\")\n        //this.setWidth(\"fit-content\")\n        //this.setWidth(\"170px\")\n\n        this.setMinAndMaxWidth(\"17em\")\n        //this.setWidth(\"fit-content\")\n        this.setWidth(\"-webkit-fill-available\")\n\n        this.setMaxWidth(null)\n\n        this.setMinAndMaxHeight(\"100%\")\n        \n\n\n        //this.setMinAndMaxWHeight(null) // new\n        //this.setWidth(\"100%\") // want 100% if single item, like breadcrumb\n        // otherwise, the stack view should figure out the widths using one of\n        // several policy options?\n        //this.setHeight(\"fit-content\")\n        //this.setHeight(\"100%\")\n        //this.setBorderRight(\"1px solid rgba(255, 255, 255, 0.3)\")\n        //this.setBoxShadow(\"inset -10px 0 20px rgba(0, 0, 0, 0.05)\")\n\n        \n        if (this.stackView()) {\n            // apply node height hint\n            const node = this.stackView().node()\n            if (node) {\n                const h = node.nodeMinTileHeight()\n                //console.log(\"node \" + this.node().title() + \" height \" + h)\n                if (h) {\n                    this.setMinAndMaxHeight(h)\n                    //this.contentView().setMinAndMaxHeight(h)\n                }\n            }\n        }\n    }\n    \n    // close button\n    \n    addCloseButton () {\n        if (this.closeButtonView() === null) {\n            const cb = SvgIconView.clone().setIconName(\"close\")\n            cb.setStrokeColor(\"white\")\n            cb.setFillColor(\"white\")\n            this.setCloseButtonView(cb)\n            this.contentView().addSubview(cb) \n            cb.setMinAndMaxWidthAndHeight(8)\n            cb.setAction(\"delete\")\n            cb.setOpacity(0).setTransition(this.transitionStyle())\n        }\n        return this\n    }\n    \n    removeCloseButton () {\n        if (this.closeButtonView() !== null) {\n            this.contentView().removeSubview(this.closeButtonView()) \n            this.setCloseButtonView(null)\n        }\n    }\n    \n    // ---\n\n    passFirstResponderToColumn () {\n        if (this.isFirstResponder()) {\n            if (this.column()) {\n                this.column().becomeFirstResponder()\n            }\n        }\n        return this\n    }\n\n    // --- delete ---\n\n    canDelete () {\n        if (this.node()) {\n            return this.node().canDelete()\n        }\n        return false\n    }\n\n    delete () {\n        //console.log(\"delete\")\n        if (this.canDelete()) {\n            this.removeFromParentView()\n            this.node().delete()\n        }\n    }\n\n    /*\n\tanimateOpen () {\n\t\tthis.setTransition(this.transitionStyle())\n\t\tthis.setOpacity(0)\n\t\tthis.setMinAndMaxHeight(0)\n\t\tthis.addTimeout(() => {\n\t\t\tthis.setOpacity(1)\n\t\t\tthis.setMinAndMaxHeight(this.defaultHeight())\n\t\t}, 0)\t\t\n\t},\n\t*/\n  \n\n    // -------------------\n\n    /*\n    unselectNextColumnTiles () {\n        const c = this.column().nextColumn()\n        if (c) {\n            c.unselectAllTiles()\n        }\n        return this\n    }\n    */\n    \n    decendantReleasedFocus (aView) {\n        this.focus() // this doesn't seem right \n        return true\n    }\n\n    // --- selecting ---\n\t\n    willAcceptFirstResponder () {\n        super.willAcceptFirstResponder()\n\t    //this.debugLog(\".willAcceptFirstResponder()\")\n        return this\n    }\n\n    // -------------------------\n    \n    nodeTileLink () {\n        //this.debugLog(\".visibleSubnodes() isInspecting:\" + this.isInspecting())\n        /*\n        if(this.node().hasDefaultInspector && this.node().hasDefaultInspector()) {\n            return this.node().nodeDefaultInspector()\n        }\n        */\n\n        if (this.isInspecting()) {\n            return this.node().nodeInspector()\n        }\n\n        return this.node().nodeTileLink()\n    }\n\n    // --- delegate ---\n\n    sendNodeDelegate (methodName, args = [this], isStrict = false) {\n        const d = this.node();\n    \n        if (d) {\n          const f = d[methodName];\n          if (f) {\n            return f.apply(d, args);\n          }\n        } else {\n          if (isStrict) {\n            const error = this.type() + \" delegate missing method '\" + methodName + \"'\";\n            console.log(error);\n            debugger;\n            throw new Error(error);\n          }\n        }\n        return undefined;\n    }\n    \n    getFromNodeDelegate (methodName, args = [], isStrict = false) {\n        const d = this.node();\n    \n        if (d) {\n          const f = d[methodName];\n          if (f) {\n            return f.apply(d, args);\n          }\n        } else {\n          if (isStrict) {\n            const error = this.type() + \" delegate missing method '\" + methodName + \"'\";\n            console.log(error);\n            debugger;\n            throw new Error(error);\n          }\n        }\n        return undefined;\n    }\n\n}.initThisClass());\n",
  "aSI1IMXVVaxYgw2IhLdubsQ/AYLLHgtBAblu+tzXzwk=": "\"use strict\";\n\n/*\n    \n    Tile_dragging\n\n*/\n\n(class Tile_dragging extends Tile {\n    \n\n    // --- dragging source protocol ---\n\n    hideForDrag () {\n        //this.setVisibility(\"hidden\")\n        this.hideDisplay()\n    }\n\n    unhideForDrag () {\n        //this.setVisibility(\"visible\")\n        this.unhideDisplay()\n    }\n\n    /*\n    onDragItemBegin (aDragView) {\n    }\n\n    onDragItemCancelled (aDragView) {\n    }\n\n    onDragItemDropped (aDragView) {\n    }\n    */\n\n    onDragRequestRemove () {\n        //assert(this.hasParentView()) //\n        if (this.hasParentView()) {\n            this.removeFromParentView()\n        }\n        assert(!this.hasParentView()) //\n\n        this.node().removeFromParentNode()\n        assert(!this.node().parentNode())\n\n        //this.delete() // we don't want to delete it, we want to move it\n        return true\n    }\n\n    // --- dropping destination protocol implemented to handle selecting/expanding tile ---\n\n    acceptsDropHover (dragView) {\n        return this.canDropSelect() || this.acceptsDropHoverComplete(dragView)\n    }\n\n    onDragDestinationEnter (dragView) {\n        if (this.canDropSelect()) {\n            this.setupDropHoverTimeout()\n        }\n    }\n\n    onDragDestinationHover (dragView) {\n        //console.log(this.typeId() + \" onDragDestinationHover\")\n    }\n\n    onDragDestinationExit (dragView) {\n        this.cancelDropHoverTimeout()\n        //this.unselect()\n        //this.column().unselectAllTilesExcept(anItem)\n    }\n\n    // --- dropping on tile - usefull for LinkNode? ---\n\n    acceptsDropHoverComplete (dragView) {\n        const node = this.node()\n        if (node && node.nodeAcceptsDrop) {\n            return node.nodeAcceptsDrop(dragView.item().node())\n        }\n    }\n\n    onDragDestinationDropped (dragView) {\n        console.log(this.typeId() + \" onDragDestinationDropped\")\n\n        const itemNode = dragView.item().node()\n\n        const node = this.node()\n        if (itemNode && node && node.nodeDropped) {\n            return node.nodeDropped(itemNode)\n        }\n    }\n\n    dropCompleteDocumentFrame () {\n        return this.frameInDocument()\n    }\n\n    // ----\n\n    dropHoverDidTimeoutSeconds () {\n        return 0.3\n    }\n\n    canDropSelect () {\n        // only want to prevent this for non-navigation nodes\n        return true\n        //return this.node().hasSubnodes() || this.node().nodeCanReorderSubnodes()\n    }\n\n    // -----------------\n\n    dropHoverEnterTimeoutName () {\n        return \"dropHoverEnter\"\n    }\n\n    setupDropHoverTimeout () {\n        const ms = this.dropHoverDidTimeoutSeconds() * 1000\n        this.addTimeout(() => this.dropHoverDidTimeout(), ms, this.dropHoverEnterTimeoutName())\n    }\n\n    cancelDropHoverTimeout () {\n        this.clearTimeoutNamed(this.dropHoverEnterTimeoutName())\n        return this\n    }\n\n    dropHoverDidTimeout () {\n        this.justTap()\n    }\n\n    // Browser style drag\n\n    onBrowserDragStart (event) {  \n        let dKey = BMKeyboard.shared().keyForName(\"d\")\n        if (!dKey.isDown()) {\n            return false\n        }\n\n        const node = this.node()\n        if (node && node.getBMDataUrl) {\n            const bdd = node.getBMDataUrl()\n            if (bdd) {\n                event.dataTransfer.setData(bdd.transferMimeType(), bdd.dataUrlString())\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n}.initThisCategory());\n",
  "BMKxDi8Is1QnRmzNqUaZ2Hsocc8OaQLJXpqoMRNtRUk=": "\"use strict\";\n\n/*\n    \n    Tile_keyboard\n\n*/\n\n(class Tile_keyboard extends Tile {\n    \n    // --- keyboard controls ---\n\n    onEnterKeyUp () {\n        //this.debugLog(this.type() + \" for \" + this.node().title() + \" onEnterKeyUp\")\n        this.justTap()\n        return false // stop propogation\n    }\n\n    onShiftBackspaceKeyUp (event) {\n        this.debugLog(this.type() + \" for \" + this.node().title() + \" onBackspaceKeyUp\")\n        this.delete()\n        return false // stop propogation\n    }\n\n    // --- dragging key ---\n\n    onMeta_a_KeyDown (event) {\n        // only select subnodes if this tile can have them,\n        // otherwise, like the column handle this event\n        const c = this.column().nextColumn()\n        if (c) {\n            c.selectAllTiles()\n        }\n        event.stopPropagation()\n        return false \n    }\n\n    on_d_KeyDown (event) {\n        this.debugLog(\" on_d_KeyDown \", event._id)\n        this.setIsRegisteredForBrowserDrag(true)\n        return true\n    }\n\n    on_d_KeyUp (event) {\n        this.debugLog(\" on_d_KeyUp \", event._id)\n        this.setIsRegisteredForBrowserDrag(false)\n        return true\n    }\n\n    /*\n    onEscapeKeyDown (event) {\n        console.log(\" onEscapeKeyDown \", event._id)\n        this.column().onLeftArrowKeyUp()\n        return true\n    }\n    */\n\n}.initThisCategory());\n",
  "n24Aw4qOgCUuJBkvxaQ9yjsqoYj7Z3p9wzNguzXo/5I=": "\"use strict\";\n\n/*\n    \n    Tile_gestures\n\n*/\n\n(class Tile_gestures extends Tile {\n    \n    // --- tap gesture -------- \n\n    acceptsTapBegin (aGesture) {\n        return true\n    }\n\n    onTapComplete (aGesture) {\n        //console.log(this.debugTypeId() + \" onTapComplete\")\n        this.setLastTapDate(new Date())\n        const keyModifiers = BMKeyboard.shared().modifierNamesForEvent(aGesture.upEvent());\n        ///const hasThreeFingersDown = aGesture.numberOfFingersDown() === 3;\n        //const isAltTap = keyModifiers.contains(\"Alternate\");\n\n        //if (keyModifiers.length) {\n            // TODO: abstract this to DomView or GestureRecognizer?\n            const methodName = \"just\" + keyModifiers.join(\"\") + \"Tap\"\n            //this.debugLog(\" tap method \" + methodName)\n            if (this[methodName]) {\n                this[methodName].apply(this)\n                return this\n            }\n        //} \n        \n        /*\n        if (hasThreeFingersDown || isAltTap) {\n            this.justInspect()\n        } else {\n            this.setIsInspecting(false)\n            this.justTap()\n        }\n        */\n\n        return this\n    }\n\n    // -- just taps ---\n\n    justTap () {\n        this.setIsInspecting(false)\n\n        if (this.column()) {\n            this.column().didTapItem(this)\n        }\n\n        //console.log(this.debugTypeId() + \" justTap\")\n        if (this.isSelectable()) {\n            const node = this.node()\n            if (node) {\n                node.onTapOfNode()\n                node.onRequestSelectionOfNode(this)\n            }\n\n            /*\n            if (this.isFocused() && node.nodeUrlLink) {\n                // TODO: move to specialized view (something like UrlLinkTile?) \n                if (!BMKeyboard.shared().hasKeysDown()) {\n                    const url = node.nodeUrlLink()\n                    window.open(url, \"_blank\")\n                }\n            }\n            */\n        }\n    }\n\n    justShiftTap () {\n        this.setIsInspecting(false)\n        this.column().didShiftTapItem(this)\n    }\n\n    justAlternateTap () {\n        this.debugLog(\".justInspect()\")\n        if (this.node().nodeCanInspect()) { \n            this.setIsInspecting(true) // will call didUpdateSlotIsInspecting and update nav\n            this.column().didTapItem(this)\n        }\n    }\n\n    justMetaTap () {\n        this.setIsInspecting(false)\n        this.toggleSelection()\n    }\n\n    // --- tap hold ---\n    // TODO: move to GestureRecognizer or DomView?\n\n    acceptsLongPress () {\n        if (!this.column()) {\n            console.log(\"missing parent view on: \" + this.typeId())\n        }\n\n        if (this.column()) {\n            return this.column().canReorderTiles()\n        }\n        return false\n    }\n    \n    onLongPressBegin (aGesture) {\n        if (this.isRegisteredForBrowserDrag()) {\n            aGesture.cancel() // don't allow in-browser drag when we're doing a drag outside\n        }\n    }\n\n    onLongPressCancelled (aGesture) {\n    }\n\n    isTapLongPress () {\n        // ok, now we need to figure out if this is a tap-hold or tap-tap-hold\n        const maxDt = 0.7 // between tap time + long tap hold time before complete is triggered\n        let isTapTapHold = false\n        const t1 = this.lastTapDate()\n        const t2 = new Date()\n        if (t1) {\n            const dtSeconds = (t2.getTime() - t1.getTime())/1000\n            //console.log(\"dtSeconds = \" + dtSeconds)\n            \n            if (dtSeconds < maxDt) {\n                isTapTapHold = true\n            }\n        }\n        return isTapTapHold\n    }\n\n    onLongPressComplete (longPressGesture) {\n        longPressGesture.deactivate() // needed?\n\n        const isTapLongPress = this.isTapLongPress() // is tap-hold\n\n        if (!this.isSelected()) {\n            this.column().unselectAllTilesExcept(this)\n        }\n\n        this.activate()\n        const dv = DragView.clone().setItems(this.column().selectedTiles()).setSource(this.column())\n\n        if (isTapLongPress) {\n            dv.setDragOperation(\"copy\")\n        } else { // otherwise, it's just a normal long press\n            dv.setDragOperation(\"move\")\n        }\n        \n        dv.openWithEvent(longPressGesture.currentEvent())\n    }\n\n    // --- handle pan gesture ---\n\n    acceptsPan () {\n        return this._isReordering\n    }\n\n\n    // --- bottom edge pan ---\n\n    acceptsBottomEdgePan () {\n        if (this.node().nodeCanEditTileHeight) {\n            if (this.node().nodeCanEditTileHeight()) {\n                return true\n            }\n        }\n        return false\n    }\n\n    onBottomEdgePanBegin (aGesture) {\n        this._beforeEdgePanBorderBottom = this.borderBottom()\n        this.setBorderBottom(\"1px dashed red\")\n        this.setTransition(\"min-height 0s, max-height 0s\")\n    }\n\n    onBottomEdgePanMove (aGesture) {\n        const p = aGesture.currentPosition() // position in document coords\n        const f = this.frameInDocument()\n        const newHeight = p.y() - f.y()\n        const minHeight = this.node() ? this.node().nodeMinTileHeight() : 10;\n        if (newHeight < 10) {\n            newHeight = 10;\n        }\n        this.node().setNodeMinTileHeight(newHeight)\n        this.updateSubviews()\n\n        /*\n            this.node().setNodeMinTileHeight(h)\n            this.updateSubviews()\n            //this.setMinAndMaxHeight(newHeight) // what about contentView?\n            //this.contentView().autoFitParentHeight()\n        */\n\n        return this\n    }\n\n    onBottomEdgePanComplete (aGesture) {\n        this.setBorderBottom(this._beforeEdgePanBorderBottom)\n    }\n\n}.initThisCategory());\n",
  "6LzvPfv/q86oKN1jFYiV8+GlBQkwbS9oON01VmCNUdg=": "\"use strict\";\n\n/*\n    \n    Tile_slideGesture\n\n*/\n\n(class Tile_slideGesture extends Tile {\n\n\n    // -- slide gesture ---\n\n    acceptsSlide () {\n        return this.canDelete()\n    }\n\n    onSlideBegin () {\n        //this.debugLog(\".onSlideBegin()\")\n        this.setSlideDeleteOffset(this.clientWidth() * 0.5);\n        this.contentView().setTransition(\"all 0s\") \n        this.setupSlide() \n        return this\n    }\n\n    underContentViewColor () {\n        return \"black\"\n    }\n\n    setupSlide () {\n        if (!this.dragDeleteButtonView()) {\n            const h = this.clientHeight()\n\n            // need to do this because we re-route setBackgroundColor\n            this.element().style.backgroundColor = this.underContentViewColor()\n            const cb = CloseButton.clone().setOpacity(0).setTransition(\"opacity 0.1s\").setPosition(\"absolute\")\n            this.addSubview(cb)\n            //cb.setBorder(\"1px dashed white\")\n\n            const size = 10\n            cb.setMinAndMaxWidthAndHeight(size)\n            cb.verticallyAlignAbsoluteNow()\n            cb.setRightPx(size * 2)\n            cb.setZIndex(0)\n            this.setDragDeleteButtonView(cb)\n        }\n        return this\n    }\n\n    cleanupSlide () {\n        if (this.dragDeleteButtonView()) {\n            this.dragDeleteButtonView().removeFromParentView()\n            this.setDragDeleteButtonView(null)\n        }\n        this.setTouchRight(null)\n    }\n\t\n    onSlideMove (slideGesture) {\n        const d = slideGesture.distance()\n        const isReadyToDelete = d >= this._slideDeleteOffset\n\n        this.setTouchRight(d)\n\n        if (this._dragDeleteButtonView) {\n            this._dragDeleteButtonView.setOpacity(isReadyToDelete ? 1 : 0.2)\n        }\n    }\n\n    setTouchRight (v) {\n        //this.setTransform(\"translateX(\" + (v) + \"px)\");\n        //this.setLeftPx(-v)\n        //this.setRightPx(v)\n        this.contentView().setRightPx(v)\n    }\n\t\n    onSlideComplete (slideGesture) {\n        //console.log(\">>> \" + this.type() + \" onSlideComplete\")\n        const d = slideGesture.distance()\n        const isReadyToDelete  = d >= this._slideDeleteOffset\n\n        this.element().style.backgroundColor = \"transparent\"\n\n        if (isReadyToDelete) {\n            this.finishSlideAndDelete()\n        } else {\n            this.slideBack()\n        }\n    }\n\n    onSlideCancelled (aGesture) {\n        this.slideBack()\n    }\n\n    finishSlideAndDelete () {\n        this.setIsDeleting(true)\n        const dt = 0.08 // seconds\n        this.contentView().setTransition(\"right \" + dt + \"s\")\n        this.setTransition(this.transitionStyle())\n        //this.contentView().animationListener().setDelegate(this).setMethodSuffix().setIsListening(true)\n\n        this.addTimeout(() => {\n            this.setTouchRight(this.clientWidth())\n            this.addTimeout(() => {\n                this.cleanupSlide()\n                this.delete()\n            }, dt * 1000)\n        }, 0)\n    }\n\n    /*\n    onAnimationStart (event) {\n        console.log(this.debugTypeId() + \" onAnimationStart\")\n    }\n\n    onAnimationEnd (event) {\n        console.log(this.debugTypeId() + \" onAnimationEnd\")\n        this.contentView().animationListener().setIsListening(false)\n    }\n    */\n\n    slideBack () {\n        this.disableTilesViewUntilTimeout(400)\n\n        this.contentView().setTransition(\"left 0.2s ease, right 0.2s ease\")\n\n        this.addTimeout(() => {\n            this.setTouchRight(0)\n            this.contentView().setTransition(this.transitionStyle())\n        })\n\n        this.addTimeout(() => {\n            this.didCompleteSlide()\n        }, 300)\n    }\n\n    \n    disableTilesViewUntilTimeout (ms) {\n        this.navView().disablePointerEventsUntilTimeout(ms) \n        this.setPointerEvents(\"none\")\n    }\n\n    didCompleteSlide () {\n        this.cleanupSlide()\n    }\n    \n    hasCloseButton () {\n        return this.closeButtonView() && this.closeButtonView().target() != null\n    }\n\n}.initThisCategory());\n",
  "z9h8nBjqkYwTlbZbFIatdFZOFNArFXKbFO9LHuQYqso=": "\"use strict\";\n\n/*\n    \n    Tile_styling\n\n*/\n\n(class Tile_styling extends Tile {\n    \n    didUpdateSlotParentView (oldValue, newValue) {\n        super.didUpdateSlotParentView(oldValue, newValue)\n        //this.scheduleMethod(\"applyStyles\")\n        this.applyStyles()\n        return this\n    }\n\n    // --- css pass-through to contentView ---\n\n    setBackgroundColor (s) {\n        this.contentView().setBackgroundColor(s)\n        return this\n    }\n\n    setColor (s) {\n        this.contentView().setColor(s)\n        return this\n    }\n\n    setOpacity (v) {\n        this.contentView().setOpacity(v)\n        return this\n    }\n\n    // --- styles ---\n\n}.initThisCategory());\n",
  "ZOnn5XmUWZiWaSkBNtBJAGFaIPOOARnV3x7Naq5+MPw=": "\"use strict\";\n\n/*\n    \n    TitledTile\n\n    Adds a few subviews for typical tile functionality:\n\n        - titleView\n        - subtitleView\n        - noteView\n        - noteIconView\n        - thumbnailView\n\n    Most of these can easily be disabled, if not needed.\n    \n*/\n\n(class TitledTile extends Tile {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"titleView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"subtitleView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"noteView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"noteIconView\", null); // created lazily\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"thumbnailView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n    }\n\n    static titleLeftPadding () {\n        return \"30px\"\n    }\n\n    topContentArea () {\n        let lv = this.contentView().subviews().at(0)\n        return lv\n    }\n\n    bottomContentArea () {\n        let lv = this.contentView().subviews().at(1)\n        return lv\n    }\n\n    init () {\n        super.init()\n        const cv = this.contentView()\n\n        cv.setMinHeight(\"5em\")\n        cv.flexSplitIntoColumns(2)\n\n        const lv = this.topContentArea()\n\n        lv.setDisplay(\"flex\")\n        lv.setFlex(\"10\")\n        lv.setAlignItems(\"flex-start\") // alignment in direction of flex\n        lv.setJustifyContent(\"center\") // alignment perpendicutal to flex\n        lv.setFlexDirection(\"column\")\n\n        const tv = TileTitleView.clone()\n        lv.addSubview(tv)\n        this.setTitleView(tv)\n        tv.setThemeClassName(\"TileTitle\")\n        tv.setUsesDoubleTapToEdit(true)\n        //tv.setOverflow(\"visible\")\n        tv.setPaddingLeft(\"0em\")\n\n        const st = TileSubtitleView.clone()\n        lv.addSubview(st)\n        this.setSubtitleView(st)\n        st.setThemeClassName(\"TileSubtitle\")\n        st.setPaddingLeft(\"0em\")\n        st.setPaddingTop(\"0em\")\n        st.setOpacity(0.6)\n\n\n        const rv = this.bottomContentArea()\n        rv.setDisplay(\"flex\")\n        rv.setAlignItems(\"center\")\n        this.setNoteView(rv.addSubview(TileNoteView.clone()))\n        rv.setMinWidth(\"3em\")\n        rv.setJustifyContent(\"center\")\n\n        const icon = SvgIconView.clone()\n        //icon.setElementClassName(\"NoteIconView\")\n        icon.setMinAndMaxWidth(12)\n        icon.setMinAndMaxHeight(15)\n        //icon.setFillColor(\"white\")\n        icon.setStrokeColor(\"white\") // use currentColor?\n        icon.setOpacity(0.2)\n        this.setNoteIconView(rv.addSubview(icon))\n        \n        this.updateSubviews()\n        this.setIsSelectable(true)\n        return this\n    }\n\n    setupThumbnailViewIfAbsent () {\n        if (!this.thumbnailView()) {\n            const tv = DomView.clone().setElementClassName(\"TileThumbnailView\")\n            tv.setDisplay(\"block\")\n            tv.setLeftPx(10)\n            tv.setTopPx(5)\n            tv.setMinHeight(\"40px\")\n            tv.setMinWidth(\"40px\")\n            tv.setBorderRadiusPx(7)\n            tv.setBackgroundColor(\"transparent\")\n            tv.setBorder(\"0px solid #aaa\")\n\n    \t\ttv.makeBackgroundNoRepeat()\n            tv.makeBackgroundCentered()\n            //tv.makeBackgroundContain()\n            tv.setBackgroundSizeWH(50, 50)\n\n            this.setThumbnailView(tv)\n            this.addSubview(tv)\n            \n            // TODO: make this dynamic with subview for title & subtitle\n            const offset = 60\n            this.titleView().setLeftPx(offset)\n            this.subtitleView().setLeftPx(offset)\n        }\n        return this\n    }\n    \n    hasSubtitle () {\n        const node = this.node()\n\n        if (node) {\n            if (node.subtitle() !== null && node.subtitle() !== \"\") {\n                return true\n            }\n\n            if (node.nodeCanEditSubtitle()) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    updateSubviews () {\n        super.updateSubviews()\n\t\n        const node = this.node()\n\n        if (node) {\n            this.titleView().setIsEditable(node.nodeCanEditTitle())\n            this.subtitleView().setIsEditable(node.nodeCanEditSubtitle())\n            this.subtitleView().setIsDisplayHidden(!this.hasSubtitle())\n    \n            if (node) {\n                const imageUrl = node.nodeThumbnailUrl()\n                if (imageUrl) {\n                    this.setupThumbnailViewIfAbsent()\n                    this.thumbnailView().setBackgroundImageUrlPath(imageUrl)\n                }\n            } \n\n            if (node.noteIconName()) {\n                this.hideNoteView()\n                this.showNoteIconView()\n            } else {\n                this.showNoteView()\n                this.hideNoteIconView()\n            }\n        } else {\n            this.titleView().setIsEditable(false)\n            this.subtitleView().setIsEditable(false)\n            this.subtitleView().setIsDisplayHidden(true) \n        }\n\n        this.syncStylesToSubviews()\n\n        /*\n        const state = this.currentThemeState()\n        if (state) {\n            state.applyToView(this.titleView())\n            state.applyToView(this.subtitleView())\n        }\n        */\n\n        return this\n    }\n\n    syncStylesToSubviews () {\n        const b = this.isSelected()\n        this.titleView().syncStateFrom(this)\n        this.subtitleView().syncStateFrom(this)\n        this.noteView().syncStateFrom(this)\n        /*\n        this.titleView().setIsSelected(b)\n        this.subtitleView().setIsSelected(b)\n        this.noteView().setIsSelected(b)\n        */\n        return this\n    }\n\n    // noteView\n\n    showNoteView () {\n        this.noteView().unhideDisplay()   \n        this.noteView().setString(this.node().note())\n    }\n\n    hideNoteView () {\n        this.noteView().hideDisplay()     \n    }\n\n    // noteIconView\n\n    showNoteIconView () {\n        const v = this.noteIconView()\n        if (v.iconName() != this.node().noteIconName()) {\n            v.unhideDisplay()    \n            v.setIconName(this.node().noteIconName())\n            //v.setDoesMatchParentColor(true)\n\n        }\n        //const color = this.currentColor()\n        const color = this.getComputedCssProperty(\"color\")\n\n        v.setColor(color)\n        v.setFillColor(color)\n        v.setOpacity(0.95)\n        //console.log( this.node().title() + \" - \" + color)\n        //v.updateAppearance()\n    }\n\n    hideNoteIconView () {\n        this.noteIconView().hideDisplay()  \n    }\n\n    // ---\n\n    desiredWidth () {\n        /*\n        const tw = this.titleView().calcWidth()\n        const sw = this.subtitleView().calcWidth()\n        let w = Math.max(sw, tw)\n        //console.log(\"calcCssWidth of tile title '\" + this.node().title() + \"' = \" + w)\n        return w + 50\n        */\n        return this.calcWidth()\n    }\n\n    // --- edit ---\n\n    didInput () {\n        this.scheduleSyncToNode()\n    }\n\n    onDidEdit (aView) {\n        super.onDidEdit() \n    }\n\n    // --- sync ---\n\n    syncToNode () {   \n        //console.log(\"syncToNode\")\n        const node = this.node()\n        node.setTitle(this.titleView().innerText())\n        node.setSubtitle(this.subtitleView().innerText())\n        return this\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n        const node = this.node()\n        this.titleView().setString(node.title())\n        this.subtitleView().setString(node.subtitle())\n        //this.noteView().setString(this.node().note())\n        this.updateSubviews()\n\n        this.setIsDisplayHidden(!node.isVisible())\n        \n        return this\n    }\n    \n    // arrow\n    \n    makeNoteRightArrow () {\n        //debugger;\n        const nv = this.noteView()\n        \n        nv.setBackgroundImageUrlPath(this.pathForIconName(\"right-gray\"))        \n        nv.setBackgroundSizeWH(10, 10)\n        nv.setBackgroundRepeat(\"no-repeat\")\n        \n        nv.setMinAndMaxWidth(10)\n        nv.setMinAndMaxHeight(10)\n        return this\t\t\n    }\n\n    onEnterKeyUp (event) {\n        //this.debugLog(\".onEnterKeyUp()\")\n\n        if (this.titleView().isEditable()) {\n            this.titleView().activate()\n            event.stopPropagation()\n        } else if (this.subtitleView().isEditable()) {\n            this.subtitleView().activate()\n            event.stopPropagation()\n        } else {\n            super.onEnterKeyUp(event)\n        }        \n    }\n\n    /*\n    removeAllGestureRecognizers () {\n        debugger;\n        return super.removeAllGestureRecognizers()\n    }\n    */\n    \n}.initThisClass());\n",
  "AOqv3l2XsW9FM0l9g1EKSYPrYkZmra0reb5gQNR2Afk=": "\"use strict\";\n\n/*\n    \n    BMTextNodeTile\n    \n*/\n\n(class BMTextNodeTile extends Tile {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"textView\", null);\n            slot.setSlotType(\"TextField\");\n        }\n    }\n\n    init () {\n        super.init()\n\n        const cv = this.contentView()\n        cv.setMinHeight(\"1em\")\n\n        const tv = TextField.clone()\n        this.setTextView(tv)\n        this.contentView().addSubview(tv)\n\n        tv.setDisplay(\"flex\")\n        //tv.setFlex(\"10\")\n        tv.setAlignItems(\"flex-start\") // alignment in direction of flex\n        tv.setJustifyContent(\"center\") // alignment perpendicutal to flex\n        tv.setFlexDirection(\"column\")\n        tv.setWidth(\"100%\")\n        tv.setMinHeight(\"1em\")\n        tv.setIsEditable(true)\n\n        tv.setUsesDoubleTapToEdit(true)\n        tv.setOverflow(\"visible\")\n\n        this.updateSubviews()\n        this.setIsSelectable(true)\n        return this\n    }\n    \n    // ---\n\n    desiredWidth () {\n        return this.calcWidth()\n    }\n\n    // --- edit ---\n\n    didInput () {\n        this.scheduleSyncToNode();\n    }\n\n    // --- sync ---\n\n    syncToNode () {   \n        //console.log(\"syncToNode\")\n        const node = this.node()\n        node.setValue(this.textView().innerText())\n        return this\n    }\n    \n    syncFromNode () {\n        const node = this.node()\n        if (!node) {\n            return \n        }\n        \n        this.textView().setString(node.value())\n\n        this.applyStyles()\n        return this\n    }\n\n    applyStyles () {\n        console.log(this.type() + \" themeClassName \", this.node().themeClassName())\n        super.applyStyles()\n        return this\n    }\n\n}.initThisClass());\n",
  "am4P8zAR953isYzFaQQ37U0PNFXIrY93BHMwwIuNxBw=": "\"use strict\";\n\n/*\n    \n    BreadCrumbsTile\n\n    View for a typical bread crumbs path e.g.:\n\n        a / b / c / d\n\n    Supports compacting path to fit in view size (using back arrow) as needed.\n\n    Registers for onStackViewPathChange notifications (sent by top StackView) to auto update path.\n    TODO: register *only* for our own top stack view.\n    \n*/\n\n(class BreadCrumbsTile extends Tile {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"path\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"separatorString\", \"/\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"onStackViewPathChangeObs\", null);\n            slot.setSlotType(\"BMObservation\");\n        }\n        {\n            const slot = this.newSlot(\"crumbObservations\", null);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    init () {\n        super.init();\n        this.setThemeClassName(\"BreadCrumbsTile\");\n        this.setOnStackViewPathChangeObs(BMNotificationCenter.shared().newObservation().setName(\"onStackViewPathChange\").setObserver(this));\n        //this.contentView().setPaddingLeft(\"1.5em\") // TitledTile.titleLeftPadding();\n        this.setWidth(\"100%\");\n\n        //this.updateSubviews();\n        this.setIsSelectable(true);\n        this.setIsRegisteredForWindowResize(true);\n\n        this.setCrumbObservations([]);\n        return this;\n    }\n\n    makeOrientationDown () { // this is a special case where the item is full width\n        super.makeOrientationDown()\n        this.setMinAndMaxWidth(null)\n        this.setWidth(\"100%\")\n        return this\n    }\n\n    rootStackView () { // move to Tile class?\n        return this.parentView() ? this.parentView().stackView().rootStackView() : null\n    }\n\n    targetStackView () {\n        const col = this.column()\n        if (col) {\n            const nc = col.nextColumn()\n            if (nc) {\n                //debugger;\n                const sv = nc.stackView()\n                return sv\n            }\n        }\n        return null\n    }\n\n    watchRootStackView () {\n        const obs = this.onStackViewPathChangeObs()\n        if (!obs.isWatching()) {\n            const target = this.rootStackView()\n            if (target) {\n                obs.setSender(target)\n                obs.startWatching()\n            } else {\n                //debugger;\n                obs.stopWatching() // needed?\n            }\n        }\n    }\n  \n    pathNodes () {\n        if (this.targetStackView()) {\n            const nodes = this.targetStackView().selectedNodePathArray()\n            return nodes\n        }\n        return []\n    }\n\n    syncPathToStack () {\n        this.scheduleMethod(\"setupPathViews\")\n    }\n\n    setHeight (v) {\n        if (v === \"100%\") {\n            debugger;\n        }\n        return super.setHeight(v)\n    }\n\n    // --- events ---\n\n    /*\n    onMouseDown (event) {\n        const result = super.onMouseDown(event)\n        const t = this.targetStackView()\n        t.selectNodePathArray([])\n        this.setupPathViews() // needed or does the StackView send a note?\n        return result\n    }\n    */\n\n    didUpdateSlotParentView (oldValue, newValue) {  // hook this to do the initial setup\n        super.didUpdateSlotParentView(oldValue, newValue)\n        if (this.parentView()) {\n            this.watchRootStackView()\n            this.syncPathToStack()\n        }\n        return this\n    }\n\n    onStackViewPathChange (aNote) {\n        //debugger;\n        this.syncPathToStack()\n    }\n\n    onClickPathComponent (aPathComponentView) {\n        const nodePathArray = aPathComponentView.info()\n        if (nodePathArray.length === 0) {\n            debugger;\n        }\n        console.log(\"select path: \" + nodePathArray.map(n => n.title()).join(\"/\"))\n        //const ourPath = this.node().nodePath()\n        //console.log(\"our path: \" + ourPath.map(n => n.title()).join(\"/\"))\n        //debugger;\n\n        const t = this.targetStackView()\n        t.selectNodePathArray(nodePathArray)\n    //    debugger;\n        this.setupPathViews() // needed or does the StackView send a note?\n        return this\n    }\n\n    onWindowResize (event) {\n        this.updateCompaction()\n        return this\n    }\n\n    onClickBackButton (backButton) {\n        //const crumb = this.lastHiddenCrumb()\n        const crumb = this.previousCrumb()\n        if (crumb) {\n            //console.log(\"select crumb: \", crumb.title())\n            crumb.sendActionToTarget()\n        }\n    }\n\n    // crumb buttons\n\n    previousCrumb () {\n        const crumbs = this.crumbs().select(crumb => crumb.title() !== \"/\") // previous crumb\n        if (crumbs.length > 1) {\n            return crumbs[crumbs.length - 2]\n        }\n        return null\n    }\n\n    crumbs () {\n        return this.subviews().first().subviews()\n    }\n\n    hiddenCrumbs () {\n        return this.crumbs().detect(sv => sv._isCrumb && sv.isDisplayHidden())\n    }\n\n    lastHiddenCrumb () {\n        return this.hiddenCrumbs().last()\n    }\n    \n    // --- path component views --- \n\n    newUnpaddedButton () {\n        const v = ButtonView.clone()\n        //const v = BreadCrumbButton.clone()\n        v.setDisplay(\"inline-block\")\n        v.titleView().setOverflow(\"visible\")\n        v.setHeightPercentage(100)\n        v.setWidth(\"fit-content\")\n        v.setPaddingLeft(\"0em\")\n        v.setPaddingRight(\"0em\")\n        v.titleView().setPaddingLeft(\"0em\")\n        v.titleView().setPaddingRight(\"0em\")\n        //v.debugTypeId = function () { return \"crumbView\" }\n        return v\n    }\n\n    buttonForName (aName) {\n        const v = this.newUnpaddedButton()\n        v.setTitle(aName)\n        v.setTarget(this)\n        v.setAction(\"onClickPathComponent\")\n        v._isCrumb = true\n        return v\n    }\n\n    newBackButton () {\n        const v = this.newUnpaddedButton()\n        //v.setTitle(\"&lt;\")\n        v.setTitle(\"←\")\n        //v.setTitle(\"&#8592;\")\n        v.titleView().setPaddingLeft(\"0em\")\n        v.titleView().setPaddingRight(\"0.5em\")\n        v.setTarget(this)\n        v.setAction(\"onClickBackButton\")\n        return v\n    }\n\n    newSeparatorView () {\n        const v = this.newUnpaddedButton()\n        v.titleView().setPaddingLeft(\"0.5em\")\n        v.titleView().setPaddingRight(\"0.5em\")\n        v.setTitle(this.separatorString())\n        return v\n    }\n\n    crumbViewForNode (node, i, pathNodes) {\n        const name = node.title()\n        const crumb = this.buttonForName(name)\n        if (crumb.setNode) {\n            crumb.setNode(node)\n        }\n        // not efficient to get pathNodes\n        // just get the path to the crumb node itself\n        //console.log(\"pathNodes: \" + pathNodes.map(n => n.title()).join(\"/\"))\n        const crumbNodePath = pathNodes.slice(0, i+1) // we WANT our own crumbview node to be the first in this path\n        //console.log(\"crumbNodePath [\" + i + \"]: \" + crumbNodePath.map(n => n.title()).join(\"/\"))\n\n        //debugger;\n        crumb.setInfo(crumbNodePath)\n        return crumb\n    }\n\n    newPathComponentViews () {\n        const pathNodes = this.pathNodes()\n        pathNodes.shift() // remove self from list\n        const views = pathNodes.map((node, i, pathNodes) => this.crumbViewForNode(node, i, pathNodes))\n        return views\n    }\n\n    setupPathViews () {\n        const views = this.newPathComponentViews()\n        const separatedViews = views.joinWithFunc((view, index) => this.newSeparatorView())\n        separatedViews.unshift(this.newSeparatorView())\n        separatedViews.unshift(this.newBackButton())\n        this.contentView().removeAllSubviews()\n        this.contentView().addSubviews(separatedViews)\n        this.updateCompaction()\n\n        this.watchPathNodes()\n        return this\n    }\n\n    widthOfViews (views) {\n        return views.sum(v => v.calcWidth())\n    }\n\n    // --- \n\n    crumbViews () {\n        return this.contentView().subviews()\n    }\n\n    sumOfPathWidths () { // private - IMPORTANT: uses cachedSize\n        const rightMargin = 15\n        return this.crumbViews().sum(view => { \n            //const w = view.calcWidth()\n            const w = view.cachedSize().width()\n            if (Type.isNaN(w)) { \n                debugger; \n                throw new Error(\"invalid width value\")\n            }\n            return w + rightMargin\n        })\n    }\n\n    updateCompaction () {\n        const padding = 20\n        //const maxWidth =  this.calcSize().width() //this.frameInDocument().width()\n        const maxWidth = this.frameInDocument().width()\n        //console.log(\"maxWidth: \", maxWidth)\n        const views = this.crumbViews()\n        views.forEach(view => view.unhideDisplay())\n        views.forEach(view => view.cacheClientSize())\n\n        let didHide = false // to track if we need back button\n        for (let i = 1; i < views.length -1; i++) {\n            const view = views[i]\n            const sum = this.sumOfPathWidths() + padding\n            //console.log(\"sum: \", this.sumOfPathWidths())\n            const isSeparator = view.title() === \"/\"\n            if (isSeparator && views[i-1].isDisplayHidden()) {\n                view.hideDisplay()\n            }\n            if (sum > maxWidth) {\n                view.hideDisplay()\n                didHide = true\n            } else {\n                break;\n            }\n        }\n\n        if (!didHide) {\n            // if we hid anything, we need a back button\n            const backButton = views.first()\n            backButton.hideDisplay()\n        }\n    }\n\n    // ---\n\n    desiredWidth () {\n        return Number.MAX_VALUE\n    }\n\n    onUpdatedNode (aNote) {\n        this.scheduleMethod(\"setupPathViews\")\n    }\n\n    watchPathNodes () {\n        this.unwatchPathNodes()\n        this.pathNodes().forEach(node => {\n            const obs = this.watchSender(node)\n            this.crumbObservations().push(obs)\n        })\n        return this\n    }\n\n    unwatchPathNodes () {\n        this.crumbObservations().forEach(obs => {\n            obs.stopWatching()\n        })\n        this.setCrumbObservations([])\n        return this\n    }\n\n}.initThisClass());\n",
  "VWdpZ1Yh/p7vQQnW1w2b6QhK6nKbfLesXU1hU5fGv0U=": "\"use strict\";\n\n/*\n    \n    HeaderTile\n    \n*/\n\n(class HeaderTile extends TitledTile {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.setIsSelectable(true)\n        this.setThemeClassName(\"HeaderTile\")\n        return this\n    }\n\n    makeOrientationDown () {\n        super.makeOrientationDown()\n        this.setMinAndMaxWidth(null)\n        this.setWidth(\"100%\")\n        return this\n    }\n\n    applyStyles () {\n        //debugger\n        super.applyStyles()\n\n        return this\n    }\n\n\n}.initThisClass());\n",
  "+wHKHobuwxJNwRB0khxCjDxQulg9nT4CvvtDakR95+8=": "\"use strict\";\n\n/*\n    \n    TileNoteView\n    \n*/\n\n(class TileNoteView extends TextField {\n\n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        this.setFontSize(\"80%\")\n        this.setFontWeight(\"normal\")\n        this.setWhiteSpace(\"nowrap\")\n        this.setTextAlign(\"right\")\n        this.setTextOverflow(\"ellipsis\")\n        return this\n    } \n    \n    setBackgroundColor (s) {\n        super.setBackgroundColor(\"tranparent\")\n        return this\n    }\n\n    setTransition (s) {\n        //debugger;\n        return super.setTransition(s)\n    }\n\n}.initThisClass());\n",
  "+9tH5g2L2NyYcJrnMFYGZHXWaYGGNxIm1DPKetMuroM=": "\"use strict\";\n\n/*\n    \n    TileSubtitleView\n    \n*/\n\n(class TileSubtitleView extends TextField {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setMarginTop(\"3px\")\n        this.setMarginLeft(\"0px\")\n        this.setMarginBottom(\"3px\")\n        this.setFontSize(\"80%\")\n        this.setFontWeight(\"normal\")\n        this.setTextAlign(\"left\")\n        this.setOverflow(\"hidden\")\n        this.setMinWidth(\"2em\")\n        this.setWidth(\"100%\")\n        this.setWordWrap(\"break-word\")\n        this.setWhiteSpace(\"pre\")\n        return this\n    }\n\n}.initThisClass());\n\n\n",
  "K+BZRvQnLTa4rqBUWUQN8lDimIr9rJ2kvX23+lB+aJc=": "\"use strict\";\n\n/*\n    TileTitleView\n\n    A title element in a Tile. \n\n    Reasons not to just use setElementClassName() on a TextField instead:\n    - to automatically get the full class hierarchy in the div name\n    - a place to (potentially) override interaction behaviors\n\n*/\n\n(class TileTitleView extends TextField {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n\n    }\n\n    init () {\n        super.init()\n        this.setDisplay(\"block\")\n        this.setPosition(\"relative\")\n        this.setMarginTop(\"0em\")\n        this.setMarginLeft(\"0em\")\n        this.setMinWidth(\"20px\")\n        this.setWidth(\"100%\")\n        this.setPaddingTop(\"2px\")\n        this.setPaddingBottom(\"2px\")\n        this.setTextAlign(\"left\")\n        this.setWhiteSpace(\"nowrap\")\n        this.setOverflow(\"hidden\")\n        this.setWordWrap(\"normal\")\n        return this\n    }\n\n    /*\n    tile () {\n        return this.parentView().parentView()\n    }\n    */\n\n    selectNextKeyView () {\n        /*\n        this.debugLog(\".selectNextKeyView()\")\n        const tile = this.parentView().parentView();\n        const nextTile = this.row().column().selectNextTile()\n        */\n        return true\n    }\n    \n}.initThisClass());\n",
  "3NLC1goFITS5R9qjF+80dzMJD4rgK8OYTQ8CTCP5Tag=": "\n\n.BMFieldValueView br {\n    display: none;\n}\n\n.BMFieldValueView * {\n    display: inline;\n    white-space: nowrap;\n}\n\n",
  "bF90ecLGbnEJUUbMOWqh4gYDhaHSWjjILjC68l68yrk=": "\"use strict\";\n\n/*\n\n    BMFieldTile\n\n    Field views are tiles that present nodes which have key/value pairs, \n    such as those representing slots, or other named properties.\n\n    The idea is to use the field as the container, and then get\n    a custom value view to present in the value area. \n\n*/\n\n\n(class BMFieldTile extends Tile {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"allowsCursorNavigation\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"vPadding\",  \"0.1em\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"kvSection\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"keyViewContainer\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"valueViewContainer\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"errorViewContainer\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"noteViewContainer\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"keyView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"valueView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"errorView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"noteView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n        {\n            const slot = this.newSlot(\"editableColor\", \"#aaa\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"uneditableColor\", \"#888\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"errorColor\", \"red\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"valueEditableBorder\", \"1px solid rgba(255, 255, 255, 0.2)\");\n            slot.setSlotType(\"String\");\n        }\n        /*\n        {\n            const slot = this.newSlot(\"valueEditableBorder\", \"none\");\n            slot.setSlotType(\"String\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"valueUneditableBorder\", \"none\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    setupTileContentView () {\n        super.setupTileContentView();\n\n        const cv = this.contentView();\n        cv.setMinHeight(\"5em\");\n        //cv.setPaddingTop(\"0.5em\");\n        //cv.setPaddingBottom(\"0.5em\");\n        cv.setJustifyContent(\"center\"); // alignment perpendicular to flex\n        cv.setFlexDirection(\"column\");\n        return this;\n    }\n\n    init () {\n        super.init()\n        this.makeCursorDefault()\n        this.setSpellCheck(false)\n\n        this.setOpacity(1)\n        this.setPosition(\"relative\")\n        this.setHeight(\"auto\")\n        this.setMinHeight(\"5em\")\n        this.setMaxHeight(\"none\")\n        this.setHeight(\"auto\")\n        this.setOverflow(\"visible\")\n        this.setWidth(\"auto\")\n        this.setTransition(\"background-color .3s ease-out\")\n        this.setTextAlign(\"left\")\n\n        {\n            this.setKvSection(this.contentView().newFlexSubview().setElementClassName(\"KvSection\"))\n            this.kvSection().setFlexDirection(\"column\")\n\n            this.setKeyViewContainer(this.kvSection().newFlexSubview().setElementClassName(\"KeyViewContainer\"))\n            this.keyViewContainer().setAlignItems(\"flex-start\")\n            this.setupKeyView()\n\n            this.setValueViewContainer(this.kvSection().newFlexSubview().setElementClassName(\"ValueViewContainer\"))\n            this.valueViewContainer().setAlignItems(\"flex-start\")\n            this.setupValueView()\n\n            this.setNoteViewContainer(this.contentView().newFlexSubview().setElementClassName(\"NoteViewContainer\"))\n            this.setupNoteView()\n\n            this.setErrorViewContainer(this.contentView().newFlexSubview().setElementClassName(\"ErrorViewContainer\"))\n            this.setupErrorView()\n\n            /*\n            this.contentView().subviews().forEach(subview => {\n                subview.setPaddingLeft(\"1.5em\")\n                subview.setPaddingRight(\"1em\")\n            })\n            */\n        }\n\n        return this\n    }\n\n    setupKeyView () {\n        const v = TextField.clone().setElementClassName(\"BMFieldKeyView\")\n        if (!v.themeClassName()) {\n            v.setThemeClassName(\"FieldKey\")\n        }\n        v.setDisplay(\"inline-block\")\n        v.setOverflow(\"hidden\")\n        v.setTextAlign(\"left\")\n        v.setWhiteSpace(\"nowrap\")\n\n        this.setKeyView(v)\n        v.turnOffUserSelect()\n        v.setSpellCheck(false)\n        //v.setPaddingTop(this.vPadding())\n        //v.setPaddingBottom(this.vPadding())\n        v.setMarginTop(this.vPadding())\n        v.setMarginBottom(this.vPadding())\n        v.setPaddingLeft(\"0em\")\n        v.setPaddingRight(\"0em\")\n\n        this.keyViewContainer().addSubview(v)     \n        return v\n    }\n\n    setupValueView () {\n        const v = this.createValueView()\n        if (!v.themeClassName()) {\n            v.setThemeClassName(\"FieldValue\")\n        }\n        v.setUserSelect(\"text\")   // should the value view handle this?\n        v.setSpellCheck(false)   // should the value view handle this?\n        //v.setPaddingTop(this.vPadding())\n        //v.setPaddingBottom(this.vPadding())\n        v.setMarginTop(this.vPadding())\n        v.setMarginBottom(this.vPadding())\n\n        this.setValueView(v)\n        this.valueViewContainer().addSubview(v)  \n        //this.valueSectionView().addSubview(v)  \n        return v\n    }\n\n    setupNoteView () {\n        const v = DomView.clone().setElementClassName(\"BMFieldTileNoteViewView\")\n        v.setDisplay(\"block\")\n        v.setPosition(\"relative\")\n        v.setOverflow(\"hidden\")\n        v.setWidth(\"100%\")\n        v.setFontWeight(\"normal\")\n        v.setColor(\"#aaa\")\n        v.setMarginLeft(\"0em\")\n        v.setMarginRightPx(0)\n        v.setMarginTop(\"0em\")\n        v.setMarginBottom(\"0.2em\")\n        v.setUserSelect(\"text\")\n        this.setNoteView(v)\n        this.noteViewContainer().addSubview(v)\n        return v\n    }\n\n    setupErrorView () {\n        const v = DomView.clone().setElementClassName(\"BMFieldTileErrorView\")\n        v.setUserSelect(\"text\")\n        v.setSpellCheck(false)\n        //v.setInnerHtml(\"error\")\n        v.setColor(\"red\")\n        v.setPaddingBottom(\"0em\")\n        v.setWhiteSpace(\"normal\")\n        this.setErrorView(v)\n        this.errorViewContainer().addSubview(v)\n        return v \n    }\n\n    createValueView () {\n        const v = TextField.clone().setElementClassName(\"BMFieldValueView\")\n        v.setDisplay(\"flex\")\n        v.setPosition(\"relative\")\n        v.setWidth(\"100%\")\n        v.setMarginTop(\"0.1em\")\n        v.setMarginLeft(\"0em\")\n        v.setMarginRight(\"0em\")\n        v.setMarginBottom(\"0.1em\")\n        v.setTextAlign(\"left\")\n        v.setOverflow(\"hidden\")\n        v.setWhiteSpace(\"nowrap\")\n        /*\n        v.setPaddingLeft(\"7px\")\n        v.setPaddingRight(\"4px\")\n        v.setPaddingBottom(\"5px\")\n        */\n        v.setColor(\"white\")\n        v.setBackgroundColor(\"transparent\")\n        //tf.setSelectAllOnDoubleClick(true)\n        return v\n    }\n\n    // colors\n\n    currentBackgroundCssColor () {\n        const bg = this.navView().computedBackgroundColor()\n        return CssColor.clone().setCssColorString(bg)\n    }\n\n    valueBackgroundCssColor () {\n        return this.currentBackgroundCssColor().contrastComplement(0.2)\n    }\n\n    valueBackgroundColor () {\n        return this.valueBackgroundCssColor().cssColorString()\n    }\n\n    editableColor () {\n        return this.valueBackgroundCssColor().contrastComplement(0.2).cssColorString()\n    }\n\n    keyViewColor () {\n        //console.log(this.node().title() + \" \" + this.typeId() + \".isSelected() = \", this.isSelected())\n        return this.currentColor()\n        //return this.valueBackgroundCssColor().contrastComplement(0.2).cssColorString()\n    }\n\n\t\n    // visible key and value\n    \n    visibleValue () {\n        return this.node().visibleValue()\n    }\n\t\n    visibleKey () {\n        return this.node().key()\n    }\n\n    // sync \n    \n    didUpdateSlotIsSelected (oldValue, newValue) {\n        super.didUpdateSlotIsSelected(oldValue, newValue)\n        this.syncFromNodeNow() // need this to update selection color on fields?\n        return this\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n        //this.debugLog(\" syncFromNode\")\n\t\t\n        const node = this.node()\n        node.prepareToSyncToView()\n        //this.setIsDisplayHidden(!node.isVisible())\n\n        this.syncKeyFromNode()\n        this.syncValueFromNode()\n        this.syncErrorFromNode()\n        this.syncNoteFromNode()\n        return this\n    }\n\n    syncKeyFromNode () {\n        const node = this.node()\n        const keyView = this.keyView()\n\n        keyView.setString(this.visibleKey()) // setString only applies if value changed\n        keyView.setIsVisible(node.keyIsVisible())\n        keyView.setIsDisplayHidden(!node.keyIsVisible())\n        keyView.setIsEditable(node.keyIsEditable())\n        keyView.setColor(this.keyViewColor())\n    }\n\n    syncValueFromNode () {\n        const node = this.node()\n        const valueView = this.valueView()\n\n        const newValue = this.visibleValue()\n\n        valueView.setValue(newValue)\n        valueView.setIsEditable(node.valueIsEditable())\n        valueView.setIsDisplayHidden(!node.valueIsVisible())\n\n        /*\n        if (this.keyView().innerText() === \"Additional Notes\") {\n            assert(node.valuePlaceholderText() !== null, \"missing node.valuePlaceholderText()\");\n            debugger;\n        }\n        */\n\n        if (valueView.setPlaceholderText) {\n            if (node.valuePlaceholderText) {\n                valueView.setPlaceholderText(node.valuePlaceholderText());\n            } else {\n                valueView.setPlaceholderText(null);\n            }\n        }\n\n\n        /*\n        if (this.node().type() === \"ChatInputNode\" && newValue === \"\") {\n            console.log(\"BMChatInputTile syncValueFromNode(BMChatInputNode) newValue = [\" + newValue + \"]\");\n            valueView.setValue(newValue);\n        }\n        */\n\n        if (node.valueIsEditable()) {\n            //valueView.setColor(this.editableColor())\n            valueView.setColor(this.currentColor())\n            //valueView.setBorder(\"1px solid #444\")\n            //valueView.setBorder(\"1px solid rgba(255, 255, 255, 0.2)\")\n            valueView.setBorder(this.valueEditableBorder())\n            valueView.setPaddingLeft(\"0.5em\").setPaddingRight(\"0.5em\")\n        } else {\n            //console.log(\"fieldview key '\", node.key(), \"' node.valueIsEditable() = \", node.valueIsEditable(), \" setColor \", this.uneditableColor())\n            valueView.setColor(this.uneditableColor())\n            //valueView.setBorder(\"1px solid rgba(255, 255, 255, 0.05)\")\n            valueView.setBorder(this.valueUneditableBorder())\n            //valueView.setPaddingLeft(\"0em\").setPaddingRight(\"0em\")\n        }\n\n        if (valueView.setCanHitEnter) {\n            if (node.acceptsValueInput) {\n                //console.log(\"node.acceptsValueInput() = \", node.acceptsValueInput());\n                //debugger;\n                valueView.setCanHitEnter(node.acceptsValueInput());\n                //valueView.setCanHitEnter(true);\n            } else {\n                valueView.setCanHitEnter(true);\n            }\n        }\n    }\n\n    syncErrorFromNode () {\n        const node = this.node()\n        const valueView = this.valueView()\n        const errorView = this.errorView()\n\n        const color = valueView.color()\n        \n        if (node.valueError()) {\n            valueView.setColor(this.errorColor())\n            errorView.setColor(this.errorColor())\n            errorView.setInnerHtml(node.valueError())\n            errorView.fadeInHeightToDisplayBlock()\n            //valueView.setToolTip(node.valueError())\n        } else {\n            valueView.setBackgroundColor(\"transparent\")\n            valueView.setColor(color)\n\n            if (errorView.display() !== \"none\") {\n                errorView.setDisplay(\"none\")\n            }\n            //errorView.fadeOutHeightToDisplayNone()\n            \n            //valueView.setToolTip(\"\")\n        }\n    }\n\n    syncNoteFromNode () {\n        const node = this.node()\n        const noteView = this.noteView()\n        \n        if (this.visibleNote()) {\n            noteView.unhideDisplay()\n            noteView.setInnerHtml(this.visibleNote())\n        } else {\n            noteView.hideDisplay()\n            noteView.setInnerHtml(\"\")\n        }\n    }\n\n\n    // ----------------------\n\n    visibleNote () {\n        return this.node().note()\n    }\n    \n    syncToNode () {\n        const node = this.node()\n\n        if (node.keyIsEditable()) {\n        \tnode.setKey(this.keyView().value())\n        }\n\t\n        if (node.valueIsEditable()) {\n        \tnode.setValue(this.valueView().value())\n        }\n\t\t\n        super.syncToNode()\n        return this\n    }\n    \n    onDidEdit (changedView) { // sent up subview chain when an edit occurs\n        this.scheduleSyncToNode();\n        if (changedView === this.valueView()) {\n            const node = this.node()\n            if (node.onDidEditValue) {\n                node.onDidEditValue(changedView)\n            }\n        }\n        return true\n    }\n\n    onDidInput (changedView) { // sent up subview chain when an input occurs\n        if (changedView === this.valueView()) {\n            const node = this.node()\n            this.syncToNode(); //  is this done elsewhere\n            if (node.onValueInput) {\n                node.onValueInput(changedView)\n            }\n        }\n    }\n\n    syncStylesToSubviews () {\n        super.syncStylesToSubviews()\n        this.keyView().syncStateFrom(this)\n        this.valueView().syncStateFrom(this)\n        return this\n    }\n\n    updateSubviews () {\n        super.updateSubviews()\n        this.syncStylesToSubviews()\n\n        /*\n        const node = this.node()\n\n        if (node && node.nodeMinTileHeight()) {\n            if (node.nodeMinTileHeight() === -1) {\n                this.setHeight(\"auto\")\n                this.setPaddingBottom(\"calc(100% - 20px)\")\n\n            } else {\n                this.setHeight(this.pxNumberToString(node.nodeMinTileHeight()))\n            }\n        }\n        */\n        \n        return this\n    }\n\n    applyStyles () {\n        super.applyStyles()\n        //this.keyView().applyStyles()\n        //this.valueView().applyStyles()\n        return this\n    }\n    \n    onEnterKeyUp (event) {\n        //this.debugLog(\".onEnterKeyUp()\")\n        if (this.valueView().activate) {\n            this.valueView().activate()\n        }\n        return this\n    }\n\n    setBackgroundColor (c) {\n        /*\n        this.debugLog(\".setBackgroundColor \", c)\n        if (c !== \"white\") {\n            console.log(\"not white\")\n        }\n        */\n        super.setBackgroundColor(c)\n        return this\n    }\n\n    becomeKeyView () {\n        this.valueView().becomeKeyView()\n        return this\n    }\n\n    unselect () {\n        super.unselect()\n        this.valueView().blur()\n        this.keyView().blur()\n        return this\n    }\n    \n}.initThisClass());\n",
  "s8eCYX/m284ABBho1qgOJM++vM9V1DVo0d883xlpROk=": "\"use strict\";\n\n/*\n\n    BMActionFieldTile\n\n*/\n\n(class BMActionFieldTile extends Tile {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"buttonView\", null);\n            slot.setSlotType(\"ButtonView\");\n        }\n    }\n\n    init () {\n        super.init();\n\n        const cv = this.contentView();\n        cv.flexCenterContent();\n\t\t\n        const bv = ButtonView.clone().setElementClassName(\"BMActionFieldView\");\n        this.setButtonView(bv);\n\t    bv.setTarget(this).setAction(\"didClickButton\");\n\t    bv.setBorder(\"1px solid rgba(128, 128, 128, 0.5)\");\n\n        this.addContentSubview(this.buttonView());\n        //this.setMinHeightPx(64);\n        return this;\n    }\n\n    updateSubviews () {\t\n        super.updateSubviews()\n\t\t\n        const node = this.node()\n        const bv = this.buttonView()\n        bv.setTitle(node.title())\n        bv.setSubtitle(node.subtitle())\n        bv.setIsEditable(node.nodeCanEditTitle())\n\n        bv.setIsEnabled(node.isEnabled())\n\n        if (node.isEnabled()) {\n            bv.setOpacity(1)\n        } else {\n            bv.setOpacity(0.5)\t\n        }\n\n        const isVisible = this.node().isVisible();\n        assert(Type.isBoolean(isVisible));\n        //this.setIsVisible(isVisible);\n        this.setIsDisplayHidden(!isVisible);\n\n\n        if (!isVisible) {\n            assert(this.isDisplayHidden())\n        }\n        return this\n    }\n    \n    onEnterKeyUp (event) {\n        this.doAction()\n        return false\n    }\n    \n    doAction () {\n        if (this.node().isEnabled()) { // check in node field?\n            this.node().doAction()\n        }\n        return this     \n    }\n    \n    didClickButton () {\n        this.doAction()\n        return this\n    }\n\n    syncToNode () {\n        this.node().setTitle(this.buttonView().title()) \n        super.syncToNode()\n        return this\n    }\n\n    onDidEdit (changedView) {     \n        this.scheduleSyncToNode()\n        //this.node().didUpdateView(this)\n        //this.scheduleSyncFromNode() // needed for validation?\n        return true\n    }\n    \n}.initThisClass());\n",
  "DyUL1Y7vm5npjriwkwD5Qi78HDZ4LE67aem4tL7WUCg=": "\"use strict\";\n\n/*\n\n    BMBooleanFieldTile\n\n*/\n\n(class BMBooleanFieldTile extends BMFieldTile {\n    \n    /*\n    initPrototypeSlots () {\n    }\n    */\n\n    init () {\n        super.init()\n        \n        this.turnOffUserSelect()\n        this.keyView().setTransition(\"color 0.3s\")\n        this.keyView().setPaddingLeft(\"0.5em\")\n\n        this.valueView().parentView().flexCenterContent()\n        this.valueView().setPaddingBottom(\"0em\")\n\n        this.keyView().setPaddingTop(\"0em\")\n        this.keyView().setPaddingBottom(\"0.35em\")\n\n        //this.contentView().debugBorders()\n        this.kvSection().subviews().at(1).flexCenterContent()\n        //this.contentView().setFlexDirection(\"column\")\n        this.kvSection().setFlexDirection(\"row\").makeSubviewsReverseOrdered()\n        //this.kvSection().subviews().forEach(sv => sv.setAlignItems(\"center\"))\n        this.kvSection().subviews().forEach(sv => sv.flexCenterContent())\n        //this.keyView().parentView().swapSubviews(this.keyView(), this.valueView())\n\n        this.setValueEditableBorder(\"none\")\n        this.setValueUneditableBorder(\"none\")\n\n        return this\n    }\n\n    createValueView () {\n        const bv = BooleanView.clone()\n        return bv\n    }\n\t\n    booleanView () {\n        return this.valueView()\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n        this.booleanView().updateAppearance()\n        return this\n    }\n    \n}.initThisClass());\n",
  "yuhF+jSOLtcOF/TJdv3fPYa1mlnNPsDmB+9wsAusj48=": "\"use strict\";\n\n/*\n\n    BMStringFieldTile\n\n*/\n\n(class BMStringFieldTile extends BMFieldTile {\n    \n    /*\n    initPrototypeSlots () {\n            }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    createValueView () {\n        const v = TextField.clone()\n        v.setDisplay(\"block\")\n        v.setPosition(\"relative\")\n        v.setWordWrap(\"normal\")\n        v.setHeight(\"auto\")\n        v.setWidth(\"-webkit-fill-available\")\n        v.setTextAlign(\"left\")\n        v.setMargin(\"0em\")\n        v.setOverflowX(\"hidden\")\n        v.setBorderRadius(\"0.2em\")\n        return v\n    }\n    \n}.initThisClass());\n",
  "DWeFjG1DcH/oJuI0+dnrqawbBeiLH4xlTsH2gKblTd8=": "\"use strict\";\n\n/*\n\n    BMTextAreaFieldTile\n\n    \n*/\n\n(class BMTextAreaFieldTile extends BMFieldTile {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"sttButton\", null); // Button, for speech to text\n            slot.setSlotType(\"ButtonView\");\n        }\n\n        {\n            const slot = this.newSlot(\"sttSession\", null); \n            slot.setSlotType(\"SpeechToTextSession\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init();\n        this.keyView().hideDisplay();\n        this.setValueUneditableBorder(\"none\");\n        this.setValueEditableBorder(\"none\");\n\n        this.setupValueViewButton();\n        return this\n    }\n\n    createValueView () {\n        /* old css:\n        .BMTextAreaFieldValueView {\n            display: flex;\n            position: relative;\n            padding: 0;\n            margin: 0;\n            width: auto;\n            min-height: auto;\n\n            word-break: break-all;\n            unicode-bidi: embed;\n            white-space: pre-wrap;\n\n            font-weight: normal;\n            text-align: left;\n        }\n        */\n\n        const v = TextField.clone().setElementClassName(\"BMTextAreaFieldValueView\");\n        v.setDisplay(\"block\");\n        v.setPosition(\"relative\");\n        v.setWordWrap(\"normal\");\n        v.setHeight(\"auto\");\n        v.setWidth(\"-webkit-fill-available\");\n        v.setTextAlign(\"left\");\n        v.setMargin(\"0em\");\n        v.setOverflowX(\"hidden\");\n        v.setOverflowY(\"scroll\");\n        //v.setFontFamily(\"Mono\");\n        //v.setDoesHoldFocusOnReturn(true);\n        v.setDoesInput(false);\n        v.setIsMultiline(true);\n        return v;\n    }\n\n    setupValueViewButton () {\n        this.valueViewContainer().setGap(\"1em\");\n\n        //const v = ButtonView.clone().setTitle(\"STT\").setHasOutline(true);\n        const bv = ButtonView.clone().setElementClassName(\"BMActionFieldView\");\n        bv.setBorderRadius(\"0.4em\");\n        //bv.setTitle(\"x\");\n        bv.setMaxHeight(\"2.1em\");\n        bv.setHeight(\"2.1em\");\n        bv.setMinHeight(null);\n        bv.setWidth(\"2.3em\");\n\t    bv.setTarget(this).setAction(\"onClickValueButton\");\n\t    bv.setBorder(\"1px solid rgba(128, 128, 128, 0.5)\");\n        bv.setPadding(\"0px\");\n        bv.setMarginTop(\"1px\");\n        //bv.setDisplay(\"none\");\n        //bv.setIconName(\"Mic Off\");\n        bv.titleView().setIsDisplayHidden(true);\n        bv.setAttribute(\"title\", \"Speech to text input\")\n        this.setSttButton(bv);\n        this.updateSttButton();\n        //this.valueViewContainer().addSubview(bv);\n    }\n\n    /*\n    updateSubviews () {   \n        super.updateSubviews()\n        return this\n    }\n    */\n\n    /*\n\t\n    fillBottomOfColumnIfAvailable () {\n        if (this.column().tiles().last() === this) {\n            //this.debugLog(\" update height\")\n            this.setMinAndMaxHeightPercentage(100)\n            this.setFlexGrow(100)\n            this.setBorderBottom(\"0em\")\n\n            this.valueView().setHeight(\"100%\")\n        } else {\n            this.setFlexGrow(1)\n            this.setBorderBottom(\"1px solid rgba(125, 125, 125, 0.5)\")\n        }\n        return this\n    }\n    */\n\n    // --- text to speech button ---\n    \n    syncValueFromNode () {\n        super.syncValueFromNode();\n        const show = this.getFromNodeDelegate(\"hasValueButton\");\n        if (show !== undefined) {\n            this.sttButton().setParentViewIfTrue(this.valueViewContainer(), show);\n            this.updateSttButton();\n        }\n    }\n\n    isMicOn () {\n        if (!this.sttSession()) {\n            return false;\n        }\n        return this.sttSession().isRecording();\n    }\n\n    updateSttButton () {\n        const iconName = this.isMicOn() ? \"Mic On\" : \"Mic Off\";\n        this.sttButton().setIconName(iconName);\n    }\n\n    onClickValueButton () {\n        console.log(\"this.isMicOn():\", this.isMicOn());\n        if (!this.isMicOn()) {\n            this.setupSttSessionIfNeeded();\n            this.sttSession().start();\n        } else {\n            this.sttSession().stop();\n        }\n        this.updateSttButton();\n    }\n\n    setupSttSessionIfNeeded () {\n        if (!this.sttSession()) {\n          const stt = SpeechToTextSession.clone().setDelegate(this).setSessionLabel(\"ChatInputNode STT input\");\n          this.setSttSession(stt);\n        }\n    }\n\n    onSpeechInterimResult (sttSession) {\n        const text = this.sttSession().interimTranscript();\n        this.valueView().setString(text);\n        console.log(\"onSpeechInterimResult('\" + text + \"')\");\n    }\n\n    onSpeechFinal (sttSession) {\n\n    }\n\n    onSpeechInput (sttSession) {\n        const text = this.sttSession().fullTranscript();\n        console.log(\"onSpeechInput('\" + text + \"')\");\n        //debugger;\n        if (text.length > 0) {\n            const textField = this.valueView();\n            //textField.setString(text);\n            textField.setValue(text);\n            textField.afterEnter(null);\n            //textField.didInput();\n            //this.sttSession().stop();\n        }\n        assert(!sttSession.isRecording());\n        this.updateSttButton();\n    }\n\n    onSpeechEnd (sttSession) {\n        this.updateSttButton()\n    }\n\n    onSessionEnd (sttSession) {\n        this.updateSttButton()\n    }\n    \n}.initThisClass());\n",
  "+hcV2h2VbThYTE8Uct1A36hWzb3+7lY12QNrUwk6zp8=": "\"use strict\";\n\n/*\n\n    BMChatInputTile \n\n    \n*/\n\n(class BMChatInputTile extends BMTextAreaFieldTile {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init();\n        this.keyView().hideDisplay();\n        this.setValueUneditableBorder(\"none\");\n        this.setValueEditableBorder(\"none\");\n        //this.setWidth(\"-webkit-fill-available\");\n        this.setElementClassName(\"BMChatInputTile\"); // not needed\n        //this.valueView().setWhiteSpace(\"pre-wrap\");\n        return this\n    }\n\n    speakableElements () {\n        return this.valueView().element().elementsOfTags(this.node().tagsToSpeak());\n    }\n\n    speakableElementWithText (text) {\n        return this.speakableElements().detect(e => e.textContent === text || e.textContent.trim() === text);\n    }\n\n    onSpeakingText (aNote) {\n        //debugger;\n        const text = aNote.info();\n        //console.log(this.typeId() + \" onSpeakingText: [\" + text.clipWithEllipsis(15) + \"]\");\n\n        if (text.includes(\"<break time=\")) {\n            // no need to highlight breaks as they are not in the text\n            return;\n        }\n\n        const e = this.speakableElementWithText(text);\n        assert(e, \"BMChatInputTile.onSpeakingText(aNote) missing div for text [\" + text + \"]\");\n        this.unhighlightAllSentences();\n        this.highlightElement(e);\n    }\n\n    unhighlightAllSentences () {\n        this.speakableElements().forEach(el => this.unhighlightElement(el));\n        return this;\n    }\n\n    onSpokeText (aNote) {\n        //debugger;\n        const text = aNote.info();\n        //console.log(this.type() + \" onSpokeText: [\" + text.clipWithEllipsis(15) + \"]\");\n\n        if (text.includes(\"<break time=\")) {\n            // no need to highlight breaks as they are not in the text\n            return;\n        }\n\n        const e = this.speakableElementWithText(text);\n        assert(e);\n        this.unhighlightElement(e);\n    }\n\n    highlightElement (e) {\n        e.style.opacity = 1;\n        e.style.color = \"rgba(255, 255, 0, 1)\";\n        return this;\n    }\n\n    unhighlightElement (e) {\n        e.style.fontWeight = \"\";\n        e.style.opacity = \"\";\n        e.style.color = \"\";\n        return this;\n    }\n\n    /*\n    highlightText (text) {\n\n    }\n\n\n    unhighlightText (text) {\n\n    }\n    */\n\n    createValueView () {\n     //   debugger;\n\n        const v = TextField.clone().setElementClassName(\"BMChatInputTileValueView\");\n        \n        v.setIsMergeable(true); // needed to avoid recreating DOM elements when updating the value \n        v.setDisplay(\"block\")\n        v.setPosition(\"relative\")\n        v.setWordWrap(\"normal\")\n        v.setHeight(\"auto\")\n        v.setWidth(\"-webkit-fill-available\")\n        v.setTextAlign(\"left\")\n        v.setMargin(\"0em\")\n        v.setOverflowX(\"hidden\")\n        v.setOverflowY(\"scroll\")\n        v.setBackgroundColor(\"rgba(255, 255, 255, 0.05)\")\n        v.setBorder(\"1px solid rgba(255, 255, 255, 0.02)\")\n        v.setBorderRadius(\"0.4em\")\n        v.setPaddingTop(\"0.4em\")\n        v.setPaddingLeft(\"0.4em\")\n        v.setPaddingRight(\"0.4em\")\n        v.setPaddingBottom(\"0.4em\")\n\n        // ---- narration text ---\n        v.setPaddingTop(\"0.4em\");\n        v.setPaddingBottom(\"0.4em\");\n        v.setPaddingLeft(\"0.8em\");\n        v.setPaddingRight(\"0.8em\");\n\n        // ----\n\n        v.setAllowsHtml(true)\n        v.setWhiteSpace(\"normal\");\n        \n        v.setIsMultiline(true);\n        v.setDoesInput(true);\n        \n        // hack to disable theme application\n        v.setPaddingTop = () => { return this }\n        v.setPaddingLeft = () => { return this }\n        v.setPaddingRight = () => { return this }\n        v.setPaddingBottom = () => { return this }\n        \n        v.setBackgroundColor = () => { return this }\n        v.setBorder = () => {\n            //debugger;\n            return this\n        }\n        v.syncBorder = () => {\n            // avoiding changing border\n            return this\n        }\n        \n       /*\n        v.setValueEditableBorder(\"1px solid white\")\n        v.setValueUneditableBorder(\"1px solid white\")\n        */\n        //v.setFontFamily(\"Mono\")\n        v.setDoesHoldFocusOnReturn(true);\n        v.setDoesInput(true);\n        //v.setDoesClearOnReturn(true);\n        return v\n    }\n\n    onUpdatedNode (aNote) {\n        return super.onUpdatedNode(aNote)\n    }\n\n    syncFromNode () {\n        const node = this.node();\n        this.watchSender(node);\n        this.syncDotsFromNode();\n        super.syncFromNode();\n        return this;\n    }\n\n    syncDotsFromNode () {\n        const node = this.node();\n        if (node) {\n            if (node.isComplete) { // only for responding nodes\n                if (node.isComplete()) {\n                    this.hideDots();\n                } else {\n                    this.showDots();\n                }\n            }\n        }\n        return this;\n    }\n\n    // Support for animated trailing dots using CSS \"after\" style and CSS animation.\n    // It's toggled using CSS variables \"--div-after-display\" and \"--div-after-animation\".\n    // See CSS BMChatInputTileValueView class settings.\n\n    showDots () {\n        const view = this.valueView(); // this is a TextField\n        view.setCssProperty(\"--div-after-display\", \"inline-block\");\n        view.setCssProperty(\"--div-after-animation\", \"dotty steps(1,end) 1s infinite\");\n        return this;\n    }\n\n    hideDots () {\n        const view = this.valueView();\n        view.setCssProperty(\"--div-after-display\", \"none\");\n        view.setCssProperty(\"--div-after-animation\", \"none\");\n        return this;\n    }\n\n    /*\n    centerDotsHtml () {\n        return `<span class=\"dots\"><span class=\"dot dot3\">.</span><span class=\"dot dot2\">.</span><span class=\"dot dot1\">.</span><span class=\"dot dot2\">.</span><span class=\"dot dot3\">.</span>`;\n    }\n    */\n    \n}.initThisClass());\n",
  "VW9G0YkseBaT+QnduKs/3iRU6S6t1w55j1qVD3LENbg=": "\"use strict\";\n\n/*\n\n    BMImageWellFieldTile\n\n*/\n\n(class BMImageWellFieldTile extends BMFieldTile {\n    \n    canOpenMimeType (mimeType) {\n        // TODO: add checks for browser supported image types?\n        return mimeType.startsWith(\"image/\")\n    }\n\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        this.valueViewContainer().flexCenterContent()\n        this.valueViewContainer().setPaddingTop(\"0px\").setPaddingBottom(\"0px\")\n        this.valueView().setPaddingTop(\"0px\").setPaddingBottom(\"0px\")\n\n        //this.keyView().setElementClassName(\"BMImageWellKeyField\")\n        //this.valueView().setIsEditable(false)\n        this.turnOffUserSelect()\n        this.keyView().setTransition(\"color 0.3s\")\n        //this.valueViewContainer().setPadding(\"0px\")\n        return this\n    }\n\n    createValueView () {\n        const imageWellView = ImageWellView.clone()\n        //imageWellView.setWidth(\"100%\").setHeight(\"fit-content\")\n        return imageWellView\n    }\n\t\n    imageWellView () {\n        return this.valueView()\n    }\n\n    syncFromNode () {\n        super.syncFromNode()\n\n        const field = this.node()\n        this.setMaxWidth(\"100em\") // get this from node instead?\n        \n        this.applyStyles() // normally this would happen in updateSubviews\n        this.imageWellView().setImageDataUrl(field.value())\n        this.imageWellView().setIsEditable(field.valueIsEditable())\n\n        return this\n    }\n\n    syncToNode () {\n        const field = this.node()\n\t\t\t\t\n        //this.updateKeyView()\n        \n        field.setKey(this.keyView().value())\n\n        if (field.valueIsEditable()) {\n            const data = this.imageWellView().imageDataUrl()\n            //console.log(\"data = \" + (data ? data.slice(0, 40) + \"...\" : \"null\"))\n        \tfield.setValue(data)\n        }\n        \n        //super.suncToNode()\n        return this\n    }\n\n    dataUrl () {\n        return this.imageWellView().imageDataUrl()\n    }\n\n    isEmpty () {\n        return Type.isNull(this.dataUrl())\n    }\n    \n    didUpdateImageWellView (anImageWell) {\n        //this.debugLog(\".didUpdateImageWellView()\")\n        this.scheduleSyncToNode() \n        return this\n    }\n    \n}.initThisClass());\n",
  "4QJ4BQxnp5/785PmzgpxBnUb2v0gFd+7QpxSzpCYb48=": "\"use strict\";\n\n/*\n\n    BMOptionsNodeTile \n\n    View for BMOptionsNode\n\n    BMOptionsNode -> BMOptionsNodeTile\n        BMOption -> BMSingleOptionTile\n        BMMultiOption -> BMMultiOptionTile\n\n*/\n\n\n(class BMOptionsNodeTile extends TitledTile {\n    \n    /*\n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init()\n        return this\n    }\n    */\n\n    syncFromNode () {\n        super.syncFromNode()\n\n        /*\n            We need a way of enabling/dissabling the options\n            depending on whether the node value is editable.\n            We still want the subnodes to be visible, \n            we just don't want to allow the selection to chage.\n        */\n\n        /*\n        if (this.node().valueIsEditable()) {\n        } else {\n        }\n        */\n        return this\n    }\n\t\n}.initThisClass());\n",
  "0JqEEMiB9z2Hqm7CqslaxlJHwkTQL9C6E/1SKeFvJOs=": "\"use strict\";\n\n/*\n\n    BMOptionNodeTile \n\n \n*/\n\n(class BMOptionNodeTile extends TitledTile {\n    \n    /*\n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n        //this.setHasSubtitle(true)\n        return this\n    }\n    */\n\n    /*\n    activate () {\n        super.activate()\n        this.toggle()\n        return this\n    }\n    */\n\n    toggle () {\n        //debugger\n        const canToggle = this.node().optionsNode().valueIsEditable();\n        if (canToggle) {\n            this.node().toggle()\n        }\n        return this\n    }\n\n    onEnterKeyUp (event) {\n        //debugger;\n        super.onEnterKeyUp(event)\n        this.toggle()\n        event.stopPropagation()\n        return this\n    }\n    \n    onTapComplete (aGesture) {\n        //debugger;\n        super.onTapComplete(aGesture)\n        this.toggle()\n        //event.stopPropagation() // is this correct? this prevents tiles from doing selection?\n        return this\n    }\n\n    syncToNode () {\n        super.syncToNode()\n        \n        return this\n    }\n\n}.initThisClass());\n",
  "RbAMohbGEGt94koGgDZpNOHt/lBoI0y0VkG7JtrlIwA=": "\"use strict\";\n\n/*\n\n    BMPointerFieldTile\n\n*/\n\n(class BMPointerFieldTile extends TitledTile {\n    \n    initPrototypeSlots () {\n\n    }\n\n    init () {\n        super.init()\n\n        this.makeNoteRightArrow()\n\t\t\n        return this\n    }\n\n    updateSubviews () {\t\n        super.updateSubviews()\n\t\t\n        let node = this.node()\n\n        if (this.isSelected()) {\n            this.noteView().setOpacity(1)\t\n        } else {\n            this.noteView().setOpacity(0.4)\t\n        }\n\n        this.applyStyles()\n\t\t\n        return this\n    }\n    \n}.initThisClass());\n",
  "ItBcx0XW3la3uFe7zMT5wdhOxVSIxBA3lQ6PGmHAjOE=": "\"use strict\";\n\n/*\n    \n    TileContainer\n    \n*/\n\n(class TileContainer extends NodeView {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"tile\", null);\n            slot.setSlotType(\"Tile\");\n        }\n    }\n\n    init () {\n        super.init()\n        //this.setDisplay(\"block\")\n        this.setDisplay(\"flex\")\n        this.setPosition(\"relative\")\n        this.setFlexDirection(\"column\")\n        this.setFlexGrow(1)\n        //this.setOpacity(0)\n        this.setOverflow(\"hidden\")\n        this.setUserSelect(\"none\")\n        //this.setTransition(\"opacity 0.5s ease-in-out\")\n        //this.setTransition(\"flex-basis 0.1s\")\n        this.setTransition(\"opacity 0.5s ease-in-out, flex-basis 0s\")\n        //this.setMinAndMaxHeight(\"fit-content\")\n        this.makeOrientationRight()\n        this.setIsDisplayHidden(true)\n\n        return this\n    }\n\n    // --- orientation ---\n\n    isVertical () {\n        const sv = this.parentView()\n        if (!sv) {\n            return null\n        }\n        return sv.isVertical()\n    }\n\n    syncOrientation () {\n        if (this.isVertical()) {\n            this.makeOrientationRight()\n        } else {\n            this.makeOrientationDown()\n        }\n        return this\n    }\n\n    // ---\n\n    makeOrientationRight () {\n        /*\n        // stack view is left to right, so nav items are top to bottom\n        this.setFlexDirection(\"column\")\n        //this.setFlexBasis(this.targetWidth() + \"px\")\n        this.setFlexGrow(0)\n        this.setFlexShrink(0)\n\n        // this are handled in sync to node\n        this.setMinAndMaxWidth(\"17em\") // syncFromNode can override if node requests a sizes\n        this.setMinAndMaxHeight(\"100%\")\n        */\n        this.setWidth(\"-webkit-fill-available\")\n        this.setHeight(\"fit-content\")\n    }\n\n    makeOrientationDown () {\n        /*\n        // stack view is top to bottom, so nav items are left to right\n\n        this.setFlexDirection(\"row\")\n        //this.setFlexBasis(this.targetHeight() + \"px\")\n        this.setFlexGrow(0)\n        this.setFlexShrink(0)\n\n        this.setMinAndMaxWidth(\"100%\")\n        this.setMinAndMaxHeight(\"5em\")\n        */\n        this.setWidth(\"fit-content\")\n        this.setHeight(\"-webkit-fill-available\")\n    }\n\n    removeTile () {\n        const oldTile = this.tile()\n        if (oldTile) {\n            oldTile.setNode(null)\n            this.removeSubview(oldTile)\n        }\n        return this\n    }\n\n    setNode (aNode) {\n        super.setNode(aNode)\n\n        if (aNode === null) {\n            this.removeTile()\n            this.setIsDisplayHidden(true)\n        } else {\n            this.setIsDisplayHidden(false)\n            const tile = this.tile()\n            if (tile) {\n                const tileClass = this.subviewProtoForSubnode(aNode);\n                if (tile.thisClass() !== aClass) {\n                    this.setupTile()\n                }   \n            } else {\n                this.setupTile()\n            }\n        }\n        return this\n    }\n\n    setupTile () {\n        this.removeTile()\n        const tileClass = this.node().nodeTileClass() // we need this to get tile versions of view\n        assert(tileClass)\n        const newTile = tileClass.clone()\n        newTile.setNode(this.node())\n        this.setTile(newTile)\n        this.addSubview(newTile)\n        return this\n    }\n\n    syncFromNode () {\n        this.syncOrientation()\n        if (this.tile()) {\n            this.tile().syncFromNode()\n        }\n        //this.applyStyles()\n        return this\n    }\n\n}.initThisClass());\n",
  "YpXoLS6c1ZU0AydcVPOFDzyFcEImcKEllXb/DBZ17K0=": "\"use strict\";\n\n/*\n    \n    BrowserView\n\n    A StackView with the 2nd level node used as a horizontal breadcrumb path node.\n\n    To do this, we create a top wrapper node, which has one subnode which is the actual root node.\n    Somehow we will set the root node tile view to display the path selected in the UI...\n    \n\n    AppLauncher - sets up database, may read App object from database or create if db is empty?\n\n\n    Nodes: ---------------> Views:\n\n    browserNode             BrowserView\n      appRootNode             HeaderTile \n        settingsNode (OPTION hidden) \n        topContentNode          BreadCrumbsTile\n            about\n            guide\n               index\n               content\n                 intro\n                   overview\n                   perspectiv\n                   goals\n            tuturial\n            reference\n            binaries\n            source\n            twitter\n            links\n            repl\n            \n\n    Ideas:\n\n        - need way to read/write local changes (with permission) to server\n        \n    Questions:\n\n    - Should browserHeaderNode be the AppNode, so we can option click it to inspect it and map app name to header?\n    - Which node should be root node of storage pool?\n    -- does App own the pool, or does pool own the app?\n    -- should there be a RootPoolNode class that helps manage the pool or help expose management and info to the UI? \n\n    Todo:\n\n        Make moveToBase() more generic\n*/\n\n(class BrowserView extends StackView {\n    \n    initPrototypeSlots () {\n    }\n\n    init () {\n        super.init()\n        this.scheduleMethod(\"moveToBase\")\n        //this.scheduleMethod(\"pullPathFromUrlHash\")\n        return this\n    }\n\n    /*\n    pullPathFromUrlHash () {\n        const path = App.shared().mainWindow().urlHash()\n        if (path.length) {\n            this.setSelectedPathTitlesString(path)\n        }\n    }\n\n    pushUrlHashFromPath () {\n        App.shared().mainWindow().setUrlHash(this.selectedPathTitlesString())\n    }\n\n    topDidChangeNavSelection () {\n        console.log(\"topDidChangeNavSelection to '\" + this.selectedPathTitlesString() + \"'\")\n        //debugger\n        super.topDidChangeNavSelection()\n        this.scheduleMethod(\"pushUrlHashFromPath\")\n    }\n    */\n\n    browserHeaderNode () {\n        return this.node().subnodes().first()\n    }\n\n    breadCrumbsNode () {\n        return this.browserHeaderNode().subnodes().first()\n    }\n\n    moveToBase () {\n        assert(this.browserHeaderNode())\n        assert(this.breadCrumbsNode())\n        this.selectNodePathArray([this.browserHeaderNode(), this.breadCrumbsNode()])\n        return this\n    }\n\n}.initThisClass());\n",
  "lsUyXG+zxuTWRx+n9T3/rfoRXDgIZ/ePRan4n2G0X0g=": "\"use strict\";\n\n/*\n\n    BMBlob\n\n*/\n\n(class BMBlob extends BaseNode {\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"name\", null);\n            slot.setSyncsToView(true);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"valueHash\", null);\n            slot.setSyncsToView(true);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"valueSize\", null);\n            slot.setSyncsToView(true);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"lastModifiedTime\", null);\n            slot.setSyncsToView(true);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"expirationDate\", null);\n            slot.setSyncsToView(true);\n            slot.setShouldStoreSlot(true);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"Date\");\n        }\n\n        {\n            const slot = this.newSlot(\"value\", null);\n            slot.setSyncsToView(true);\n            slot.setShouldStoreSlot(false);\n            slot.setDoesHookSetter(true);\n            slot.setSlotType(\"ArrayBuffer\");\n        }\n    }\n  \n    initPrototype () {\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(false);\n        this.setCanDelete(true);\n    }\n\n    age () {\n        return new Date().getTime() - this.lastModifiedTime() \n    }\n\n    prepareForFirstAccess () {\n        super.prepareForFirstAccess()\n        this.setupValueField()\n    }\n\n    async setupValueField () {\n        const field = BMTextAreaField.clone().setKey(\"value\");\n        field.setValueMethod(\"value\");\n        field.setValueIsEditable(false);\n        field.setIsMono(true);\n        field.setTarget(this);\n        field.getValueFromTarget();\n        this.addSubnode(field);\n\n        await this.promiseReadValue();\n        this.didReadValue();\n        this.scheduleSyncToView();\n    }\n\n    didReadValue () {\n    }\n\n    title () {\n        return this.name()\n    }\n\n    subtitle () {\n        const size = this.valueSize()\n        if (size) {\n            return size.byteSizeDescription() \n        }\n        return null\n    }\n\n    // key\n\n    hash () {\n        return this.valueHash() // for subnode lookup\n    }\n\n    didUpdateSlotValue (oldValue, newValue) {\n        if (newValue) {\n            this.setValueSize(newValue.length)\n            this.setLastModifiedTime(new Date().getTime())\n            this.promiseWriteValue()\n        }\n        return this\n    }\n\n    store () {\n        return this.parentNode().store()\n    }\n\n    async promiseWriteValue () {\n        // what about number or null values?\n        const v = this.value()\n        assert(Type.isArrayBuffer(v) || Type.isString(v))\n\n        const digestBuffer = await v.promiseSha256Digest();\n        const h = digestBuffer.base64Encoded();\n        await this.promiseWriteValueWithHash(v, h);\n    }\n\n    async promiseWriteValueWithHash (v, h) {\n        this.setValueHash(h);\n        \n        if (Type.isArrayBuffer(v)) {\n            assert(v.byteLength);\n        }\n\n        assert(this.isValid());\n\n        await this.store().promiseOpen();\n\n        try {\n            await this.store().promiseAtPut(h, v);\n            console.log(\"did write hash/value pair: \" + this.description())\n        } catch (error) {\n            console.log(\"error writing hash/value pair: \" + this.description())\n            debugger\n        }\n    }\n\n    async promiseReadValue () {\n        if (this.value()) {\n            return\n        }\n\n        assert(this.isValid());\n\n        const value = await this.store().promiseAt(this.valueHash());\n        this._value = value;\n        this.didUpdateNodeIfInitialized();\n    }\n\n    isValid () {\n        if (Type.isNull(this.name())) {\n            return false\n        }\n\n        if (Type.isNull(this.valueHash())) {\n            return false\n        }\n\n        if (Type.isNull(this.valueSize())) {\n            return false\n        }\n\n        if (Type.isNull(this.lastModifiedTime()) || this.lastModifiedTime() === 0) {\n            return false\n        }\n\n        return true\n    }\n\n    description () {\n        const slotNames = [\"name\", \"valueHash\", \"valueSize\", \"lastModifiedTime\"]\n        const parts = [this.typeId()]\n        slotNames.forEach(slotName => {\n            parts.push(slotName + \":\" + this[slotName]())\n        })\n        return parts.join(\", \")\n    }\n\n    static async testHash () {\n        // This is a test to make sure browser JS and node JS hashes match.\n        //  Here's the code from nodejs:\n        // crypto.createHash('sha256').update(Buffer.from(\"abc\", \"utf8\")).digest(\"base64\");\n        const nodejsHash = 'ungWv48Bz+pBQUDeXa4iI7ADYaOWF3qctBD/YfIAFa0='\n        const enc = new TextEncoder(); // always utf-8\n        const uint8Array = enc.encode(\"abc\");\n        const arrayBuffer = uint8Array.buffer\n        const digestBuffer = await arrayBuffer.promiseSha256Digest();\n        const h = digestBuffer.base64Encoded()\n        assert(h === nodejsHash)\n        console.log(\"hashes match!\")\n        debugger;\n    }\n\n}.initThisClass());\n\n\n\n//BMBlob.testHash()",
  "1JcLq+lvP4wsCCOQsD2670McTIgHhTHWHaASIiBv0o4=": "\"use strict\";\n\n/*\n\n    BMBlobs\n\n    Async storage for larger values.\n\n    Motivation:\n    Due to indexeddb only having an async API, we have to load the app's store \n    entirely into memory in order to be able to synchronously read it. \n    This works as long as the amount of data isn't too big.\n    To help keep the store small, we put large objects, and objects which are ok to load asynchronously \n    (eg app resources like fonts, images) in blobs.\n\n    blobs -> blob subnode (name, valueHash, date, etc) \n\n    A container for existing blobs. \n    A blob is an object that refs an entry in a PersistentAsyncMap (separate from the app's store).\n    The data hash is used as a pointer to a CamRecord\n\n    store a blob:\n\n    const blob = blobs.blobWithName(k)\n    // returns existing blob if there's a match\n\n    NOTES:\n\n    The Blobs object and it's subnodes should be stored in the app's\n    store, so there will need to be a path from the app's root node to\n    the BMBlobs singleton instance. It may be tricky to get this right as\n    creating a BMBlobs before reading it out of the store would create a\n    conflicting instance.\n\n*/\n\n(class BMBlobs extends BMStorableNode {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"store\", null);\n            slot.setSlotType(\"PersistentObjectPool\");\n        }\n    }\n  \n    initPrototype () {\n        this.setTitle(\"Blobs\");\n        this.setNoteIsSubnodeCount(true);\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(true);\n        this.setNodeCanReorderSubnodes(true);\n    }\n\n    init () {\n        super.init();\n        this.setStore(PersistentAsyncMap.clone().setName(\"BlobHashStore\"));\n        return this;\n    }\n\n    promiseOpen () {\n        debugger;\n        return this.store().promiseOpen();\n    }\n\n    // --- lookup blob by name ---\n\n    blobWithName (aName) {\n        return this.subnodes().detect(sn => sn.title() === aName)\n        //return this.firstSubnodeWithTitle(aName)\n    }\n\n    hasBlobWithName (aName) {\n        return !Type.isNullOrUndefined(this.blobWithName(aName))\n    }\n\n    // --- lookup blob by hash ---\n\n    hasBlobWithValueHash (h) {\n        return !Type.isNullOrUndefined(this.blobWithValueHash(h))\n    }\n\n    blobWithValueHash (h) {\n        //debugger\n        return this.subnodes().detect(sn => sn.valueHash() === h) /// <------------------------------ TEMPORARY\n        //return this.subnodeWithHash(h)\n    }\n\n    // create blob\n    \n    createBlobWithNameAndValue (aName, aValue) {\n        //debugger\n        const oldBlob = this.blobWithName(aName);\n        if (oldBlob) {\n            oldBlob.setValue(aValue);\n            return oldBlob;\n        }\n\n        assert(!this.hasBlobWithName(aName));\n        const blob = BMBlob.clone();\n        blob.setName(aName);\n        blob.setValue(aValue); // this will trigger an async compute of valueHash and store of value\n        this.addSubnode(blob);\n        return blob;\n    }\n\n    async collectGarbage () {\n        // remove invalid Blob subnodes (thbose with null meta data)\n        this.subnodes().shallowCopy().forEach((blob) => {\n            if (!blob.isValid()) {\n                this.debugLog(\" collecting inValid blob:\", blob.description());\n                blob.delete();\n            }\n        })\n\n        // remove store entries which are not referenced by a Blob subnode valueHash\n        const subnodeHashes = this.subnodes().map(sn => sn.valueHash()).asSet();\n        const store = this.store();\n\n        //store.promiseClear()\n        const storedHashes = await store.promiseAllKeys();\n        storedHashes.forEach(async (h) => {\n            if (!subnodeHashes.has(h)) {\n                this.debugLog(\"collecting unreferenced blob hash:\", h);\n                await store.promiseRemoveKey(h);\n            }\n        })\n    }\n\n    static async selfTest () {\n        this.addTimeout(async () => {\n            const blob = BMBlobs.shared().blobForKey(\"http://test.com/\");\n            blob.setValue(\"test content\");\n            await blob.promiseWrite();\n        })\n    }\n\n}.initThisClass());\n",
  "J5uFR60ogO6kzvd9PQf2iIEcLKC8qpG1W9Gpf162Oh0=": "\"use strict\";\n\n/* \n    AudioQueue \n\n    sound protocol:\n    play()\n    addDelegate(delegate)\n    removeDelegate(delegate)\n    stop()\n\n*/\n\n(class AudioQueue extends BMSummaryNode {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"isMuted\", false);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"currentSound\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"queue\", null); // FIFO (first in first out) queue\n      slot.setSlotType(\"Array\");\n    }\n\n    this.setNodeSubtitleIsChildrenSummary(true)\n    this.setShouldStoreSubnodes(false)\n  }\n\n  /*\n  initPrototype () {\n    const slot = this.slotNamed(\"shortName\")\n    slot.setValidValues(this.validShortNames())\n  }\n  */\n\n  init () {\n    super.init();\n    this.setTitle(\"Audio Queue\");\n    this.setQueue([]);\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.setCanDelete(true);\n  }\n\n  subtitle () {\n    const lines = [];\n    const isPlaying = this.currentSound() !== null;\n    \n    if (isPlaying) {\n      lines.push(\"playing\");\n    }\n\n    if (this.queueSize()) {\n      lines.push(this.queueSize() + \" clips queued\");\n    }\n\n    if (this.isMuted()) {\n      lines.push(\"muted\");\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  queueSize () {\n    return this.queue().length;\n  }\n\n  // ---\n\n  setIsMuted (aBool) {\n    this._isMuted = aBool;\n    if (aBool) {\n      this.pause();\n    } else {\n      this.resume();\n    }\n    return this;\n  }\n\n  // -----------------------------------\n\n  queueAudioBlob (audioBlob) {\n    const sound = WASound.fromBlob(audioBlob);\n    this.queueWASound(sound);\n    return sound;\n  }\n\n  queueWASound (sound) {\n    // e.g. sound could be a WASound or YouTube MusicTrack\n    // just needs to support the protocol\n\n    // verify sound protocol\n    assert(sound.play);\n    assert(sound.stop);\n    assert(sound.addDelegate);\n    assert(sound.removeDelegate);\n\n    //console.log(this.type() + \" PUSH \" + sound.description());\n    this.queue().push(sound);\n    this.processQueue();\n    this.didUpdateNode();\n  }\n\n  processQueue () {\n    if (!this.currentSound()) {\n      const q = this.queue();\n      if (q.length) {\n        const sound = q.shift();\n        //console.log(this.type() + \" POP \" + sound.description());\n        this.playSound(sound);\n      }\n    }\n    return this;\n  }\n\n  async playSound (sound) {\n    //this.pause();\n    if (!this.isMuted()) {\n      //sound.setData(audioBlob);\n      sound.addDelegate(this);\n      this.setCurrentSound(sound);\n      sound.play(); // returns a promise\n    } else {\n      this.processQueue();\n    }\n    return this;\n  }\n\n  onSoundEnded (waSound) {\n    waSound.removeDelegate(this);\n    this.debugLog(\"finished playing\");\n    this.setCurrentSound(null);\n    this.processQueue();\n    this.didUpdateNode();\n  }\n  \n  pause () {\n    throw new Error(\"pause not supported\");\n    /*\n    this.debugLog(\"pause()\");\n\n    const audio = this.currentSound();\n    if (audio) {\n      audio.pause();\n      this.debugLog(\"paused\");\n    }\n    */\n  }\n\n  resume () {\n    this.debugLog(\"resume()\");\n\n    const audio = this.currentSound();\n    if (audio) {\n      //if (audio.paused) {\n        audio.play();\n        this.debugLog(\"resumed\");\n      //}\n    }\n  }\n\n  stopAndClearQueue () {\n    const audio = this.currentSound();\n    if (audio) {\n        audio.stop();\n        // this.onSoundEnded(audio); // needed?\n    }\n    this.setQueue([]);\n  }\n\n}.initThisClass());",
  "WgkG+cd6ScAU7WJ6w15X/13Qpl9PtAf2wAYkInNL/V8=": "\"use strict\";\n\n/*\n    App \n    \n    A shared instance that represents the application. \n\n    Handles:\n    - starting up persistence system\n    - setting up user interface, if any\n\n    For your application, create a subclass if needed.\n\n    NOTES\n\n    Originally planned to have a shared instance of App that would be the root of the object graph,\n    so we'd load the store and then call run on the App instance loaded from it.\n\n    But that felt difficult so instead we create an instance now, and ask it to load the object pool the store.\n\n*/\n\n(class App extends TitledNode {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n\n    static shared () {\n        return super.shared();\n    }\n    \n    // --- shared ---\n\n    static sharedContext () {\n        // We override sharedContext so all subclasses use the same shared value\n        // and anyone can call App.shared() to access it\n        return App;\n    }\n\n    // --- store ---\n    // we open store from app class since we might want to load app instance from store\n\n    static loadAndRunShared () {\n      //  debugger;\n        const app = this.shared();\n        app.setStore(this.defaultStore());\n        app.store().setName(this.type()); // name of the database\n        app.loadFromStore();\n        return app;\n    }\n\n    async loadFromStore () {\n        const clearFirst = false;\n\n        if (clearFirst) {\n            await this.clearStore();\n            this.scheduleMethod(\"justOpen\"); // is this needed to wait for tx to commit?\n        } else {\n            await this.justOpen();\n        }\n    }\n\n    async clearStore () {\n        console.log(\">>>>>>>>>>>>>>>> clearing db <<<<<<<<<<<<<<<\");\n        await this.store().promiseDeleteAll();\n        console.log(\">>>>>>>>>>>>>>>> cleared db  <<<<<<<<<<<<<<<\");\n    }\n\n    async asyncLogTimeToRun (block, label) {\n        const start = performance.now();\n        await block();\n        const end = performance.now();\n        const time = end - start;\n        console.log(\" --- \" + label + \" \" + Math.round(time/100)/10 + \"s --- \");\n    }\n\n    async justOpen () {\n        try {\n            await this.asyncLogTimeToRun(async () => { \n                await this.store().promiseOpen(); \n            }, \"store open\");\n\n            await this.asyncLogTimeToRun(async () => { \n                this.store().rootOrIfAbsentFromClosure(() => {\n                    return this.thisClass().rootNodeProto().clone();\n                });\n            }, \"store read\");\n\n            await this.asyncLogTimeToRun(async () => { \n\n            await this.run();\n        }, \"app run\");\n\n        } catch (error) {\n            console.warn(\"ERROR: \", error);\n            debugger;\n            //ResourceLoaderPanel.shared().setError(errorMessage)\n        }\n    }\n\n    static rootNodeProto () {\n        return BMStorableNode;\n    }\n\n    // ------\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"store\", null);\n            slot.setSlotType(\"PersistentObjectPool\");\n        }\n\n        {\n            const slot = this.newSlot(\"name\", \"App\");\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"version\", [0, 0]);\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"hasDoneAppInit\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"rootView\", null);\n            slot.setSlotType(\"DomView\");\n        }\n\n        {\n            const slot = this.newSlot(\"didInitPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n    }\n  \n    initPrototype () {\n        this.setIsDebugging(true);\n    }\n\n    init () {\n        this.setDidInitPromise(Promise.clone()); // here in case there are multiple Apps?\n    }\n\n    title () {\n        return this.name();\n    }\n    \n    // run and setup sequence in order of which methods are called\n    // 1. setup NodeStore\n\n    isBrowserCompatible () {\n        // subclasses can override to do their own checks\n        return true;\n    }\n\n    async run () {\n        /*\n        if (true || !this.isBrowserCompatible()) {\n            const message = \"Sorry, this app requires a Chrome, FireFox, or Brave browser.\";\n            bootLoadingView.setErrorMessage(message);\n            //ResourceLoaderPanel.shared().setError(message);\n            throw new Error(message);\n            return this;\n        }\n        */\n        await this.setup()\n    }\n\n    /*\n    showBrowserCompatibilityPanel () {\n        console.log(\"showing panel\")\n        const panel = PanelView.clone()\n        this.documentBodyView().addSubview(panel)\n        panel.setTitle(\"Sorry, this app only works on<br>Chrome, FireFox, and Brave browsers.\")\n        panel.orderFront()\n        panel.setZIndex(100)\n        console.log(\"showed panel\")\n    }\n    */\n\n    // 2. setup\n\n    async setup () {\n        //debugger;\n        SyncScheduler.shared().pause();\n        BMNotificationCenter.shared().pause();\n\n        //this.debugLog(\"Launching \" + this.fullVersionString());\n        //debugger;\n\n        await this.asyncLogTimeToRun(async () => { \n            await this.setupModel();\n        }, \"setupModel\");\n\n        await this.asyncLogTimeToRun(async () => { \n            await this.setupUi();\n        }, \"setupUi\");\n\n        await this.asyncLogTimeToRun(async () => { \n            await this.appDidInit();\n        }, \"appDidInit\");\n\n        SyncScheduler.shared().resume();\n        BMNotificationCenter.shared().resume();\n\n        setTimeout(() => {\n            console.log(\"All synchronous operations completed\");\n            this.afterFirstRender();\n          }, 2);\n        //debugger;\n    }\n\n    async setupModel () {\n        // for subclasses to override\n    }\n\n    async setupUi () {\n        this.setupDocTheme();\n        //this.addTimeout( () => this.showClasses(), 1)\n    }\n\n    hideRootView () {\n        if (this.rootView()) {\n            this.rootView().setIsDisplayHidden(true);\n        }\n        return this;\n    }\n\n    unhideRootView () {\n        if (this.rootView()) {\n            this.rootView().setIsDisplayHidden(false);\n        }\n        return this;\n    }\n\n    showClasses () {\n        const s = ProtoClass.subclassesDescription()\n        console.log(s)\n    }\n\n    async appDidInit () {\n        this.setHasDoneAppInit(true);\n        //debugger;\n        this.postNoteNamed(\"appDidInit\");\n\n        if (this.runTests) {\n\t\t    this.runTests();\n        }\n\n        //Documentation.shared().show()\n        //this.registerServiceWorker() // not working yet\n\n        bootLoadingView.setTitle(\"\");\n\n        document.body.style.display = \"flex\";\n        //ResourceManager.shared().markPageLoadTime();\n        //document.title = this.name() + \" (\" + ResourceManager.shared().loadTimeDescription() + \")\";\n        //debugger;\n        bootLoadingView.close();\n        this.unhideRootView();\n        this.afterAppUiDidInit();\n    }\n\n    afterAppUiDidInit () {\n        const searchParams = WebBrowserWindow.shared().pageUrl().searchParams;\n        if (searchParams.keys().length !== 0) {\n            this.handleSearchParams(searchParams);\n        }\n        this.didInitPromise().callResolveFunc(this);\n    }\n\n    handleSearchParams (searchParams) {\n        // for subclasses to implement\n        return this\n    }\n\n    afterFirstRender () {\n        //debugger;\n        ResourceManager.shared().markPageLoadTime();\n        document.title = this.name() + \" (\" + ResourceManager.shared().loadTimeDescription() + \")\";\n    }\n        \n    // -- window and document ---\n\n    mainWindow () {\n        return WebBrowserWindow.shared()\n    }\n\n    documentBodyView () {\n        return this.mainWindow().documentBody()\n    }\n\n    setName (aString) {\n        this._name = aString\n        this.setTitle(aString)\n        //this.mainWindow().setTitle(aString)\n        return this\n    }\n    \n    // --- version ---\n\n    versionsString () {\n        return this.version().join(\".\")\n    }\n\n    fullVersionString () {\n        return \"Application '\" + this.name() + \"' version \" + this.versionsString();\n    }\n\n    // --- themes - temporary, until ThemesResources is ready\n\n    setupDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setColor(\"#f4f4ec\")\n        doc.setBackgroundColor(\"rgb(25, 25, 25)\")\n        this.setupNormalDocTheme()\n        //this.setupVectorTheme()\n        //this.setupBlenderProTheme()\n    }\n\n    setupNormalDocTheme () {\n        const doc = DocumentBody.shared()\n        doc.setBackgroundColor(\"#191919\")\n        //doc.setFontFamily(\"BarlowCondensed\");\n        doc.setFontFamily(\"EB Garamond\");\n        doc.setFontWeight(\"Medium\");\n        //doc.setFontWeight(\"bold\")\n        //doc.setFontFamily(\"Helvetica Neue\")\n        //doc.setFontFamily(\"Helvetica LT W01 Condensed\")\n        //doc.setFontFamily(\"San Francisco Display\")\n        //doc.setFontFamily(\"PublicSans Light\")\n        //doc.setFontFamily(\"OpenSans Regular\")\n        doc.setFontSizeAndLineHeight(\"16px\")\n   }\n\n   /*\n    setupNormalDocTheme () {\n        //const doc = DocumentBody.shared()\n        const doc = this.documentBodyView()\n        doc.setBackgroundColor(\"#191919\")\n        doc.setFontFamily(\"Helvetica\")\n        doc.setFontSizeAndLineHeight(\"15px\")\n        doc.setLetterSpacing(\"0.05em\")\n   }\n   */\n\n}.initThisClass());\n",
  "StYldQp8EjIWYFPLb5eURv2coiOrGx2Fxyctza3+7q4=": "\"use strict\";\n\n/*\n\n    BMResource\n\n*/\n\n(class BMResource extends BaseNode {\n    \n    // --- supported mime types ---\n\n    static supportedMimeTypes () {\n        //throw new Error(\"subclasses should override this method\")\n        return new Set();\n    }\n\n    static canOpenMimeType (mimeType) {\n        return this.supportedMimeTypes().has(mimeType);\n    }\n\n    static openMimeChunk (dataChunk) {\n         throw new Error(\"subclasses should override this method\");\n        //const aNode = this.clone();\n        //setValue(dataChunk);\n        //console.log(dataChunk.mimeType() + \" data.length: \" + dataChunk.decodedData().length);\n        //return aNode;\n    }\n\n    // --- supported extension types ---\n\n    static supportedExtensions () {\n        throw new Error(\"subclasses should override this method\");\n        return [];\n    }\n\n    static canHandleExtension (extension) {\n        return this.supportedExtensions().contains(extension);\n    }\n\n    // ---\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"path\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"data\", null);\n            slot.setSlotType(\"Object\");\n        }\n\n        {\n            const slot = this.newSlot(\"error\", null);\n            slot.setSlotType(\"Error\");\n        }\n        {\n            const slot = this.newSlot(\"loadState\", \"unloaded\"); // \"unloaded\", \"loading\", \"decoding\", \"loaded\"\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"isLoaded\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"urlResource\", null);\n            slot.setSlotType(\"BMUrlResource\");\n        }\n\n        {\n            const slot = this.newSlot(\"loadDataPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n\n        {\n            const slot = this.newSlot(\"decodeDataPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n\n        {\n            const slot = this.newSlot(\"value\", null);\n            slot.setSlotType(\"Object\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    title () {\n        return this.name();\n    }\n\n    subtitle () {\n        return this.path().pathExtension();\n    }\n\n    subtitle () {\n        return this.path().pathExtension() + \", \" + this.loadState();\n    }\n\n    name () {\n        return this.path().lastPathComponent().sansExtension();\n    }\n\n    // --- promises ---\n\n    loadDataPromise () {\n        if (!this._loadDataPromise) {\n            this.setLoadDataPromise(Promise.clone());\n        }\n        return this._loadDataPromise;\n    }\n\n    decodeDataPromise () {\n        if (!this._decodeDataPromise) {\n            this.setDecodeDataPromise(Promise.clone());\n        }\n        return this._decodeDataPromise;\n    }\n\n    // --- resource file ---\n\n    /*\n    fileResource () {\n        return BMFileResources.shared().rootFolder().nodeAtSubpathString(this.path());\n    }\n\n    async asyncLoadFileResource () {        \n        this.setTitle(this.path().lastPathComponent().sansExtension());\n        \n        const fileResource = this.fileResource();\n        if (!fileResource) {\n          const error = \"no index for file resource at path '\" + this.path() + \"'\"\n          this.setError(error);\n          throw new Error(error);\n        }\n        await fileResource.promiseLoad();\n        this.onFileResourceLoaded(fileResource);\n    }\n    \n    onFileResourceLoaded (fileResource) {\n        this.setData(fileResource.data());\n        this.postNoteNamed(\"resourceLoaded\");\n        this.setLoadState(\"loaded\");\n        this.didLoad();\n        return this;\n    }\n    */\n\n    // --- load ---\n\n    loadIfNeeded () {\n        if (this.loadState() === \"unloaded\") {\n            this.load();\n        }\n        return this;\n    }\n\n    load () {\n        throw new Error(\"deprecated - use asyncLoad instead\");\n    }\n\n    async asyncLoad () {\n        try {\n            this.setLoadState(\"loading\");\n            await this.asyncLoadUrlResource();\n            this.setLoadState(\"loaded\");\n            this.postNoteNamed(\"resourceLoaded\");\n        } catch (error) {\n            this.setError(error);\n            this.postNoteNamed(\"loadError\");\n            throw error;\n        }\n\n        try {\n            this.setLoadState(\"decoding\");\n            await this.asyncDecodeData();\n            this.setLoadState(\"decoded\");\n            this.postNoteNamed(\"resourceDecoded\");\n        } catch (error) {\n            this.setError(error);\n            this.postNoteNamed(\"decodeError\");\n            throw error;\n        }\n        return this;\n    }\n\n    async asyncLoadUrlResource () {\n        const url = this.urlResource()\n        await url.promiseLoad();\n        const data = url.data();\n        assert(data.byteLength);\n        this.setData(data);\n        await this.onDidLoad();\n    }\n    \n    async onDidLoad () {\n        this.setIsLoaded(true);\n        this.postNoteNamed(\"didLoad\");\n    }\n\n    async asyncDecodeData () {\n        // for subclasses to override\n        return this;\n    }\n\n    async prechacheWhereAppropriate () {\n    }\n\n}.initThisClass());\n",
  "6qOErJ6uW9FpSoGGp4xg1Vj5bEPD5ArtLgQpCBSQ77I=": "\"use strict\";\n\n/*\n\n    BMResources\n\n    BMResources.shared().files().resourceForPath(\"./app/info/.../data.txt\") \n\n*/\n\n(class BMResources extends BMStorableNode {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n\n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"themes\", null);\n            slot.setSlotType(\"BMThemeResources\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"fonts\", null);\n            slot.setSlotType(\"BMFontResources\");\n        }\n        {\n            const slot = this.newSlot(\"sounds\", null);\n            slot.setSlotType(\"BMSoundResources\");\n        }\n        {\n            const slot = this.newSlot(\"images\", null);\n            slot.setSlotType(\"BMImageResources\");\n        }\n        {\n            const slot = this.newSlot(\"icons\", null);\n            slot.setSlotType(\"BMIconResources\");\n        }\n        {\n            const slot = this.newSlot(\"json\", null);\n            slot.setSlotType(\"BMJsonResources\");\n        }\n        {\n            const slot = this.newSlot(\"files\", null);\n            slot.setSlotType(\"BMFileResources\");\n        }\n    }\n\n    initPrototype () {\n        this.setShouldStore(false);\n        this.setTitle(\"Resources\");\n        this.setSubtitle(\"\");\n    }\n\n    init () {\n        super.init();\n        this.setupSubnodes(); // don't need to wait for appDidInit?\n        //this.watchOnceForNote(\"appDidInit\");\n    }\n\n    setupSubnodes () {\n        //const themes = this.defaultStore().rootSubnodeWithTitleForProto(\"Themes\", BMThemeResources);\n        //themes.setNodeCanReorderSubnodes(true);\n        //this.addSubnode(themes);\n        //let link = this.addLinkSubnode(themes);\n        //this.setThemes(themes);\n        //console.log(\"themes link = \", link.debugTypeId());\n\n        this.setFiles(BMFileResources.shared());\n        this.addSubnode(this.files());\n\n        this.setFonts(BMFontResources.shared());\n        this.addSubnode(this.fonts());\n\n        this.setSounds(BMSoundResources.shared());\n        this.addSubnode(this.sounds());\n\n        this.setImages(BMImageResources.shared());\n        this.addSubnode(this.images());\n\n        this.setIcons(BMIconResources.shared());\n        this.addSubnode(this.icons());\n\n        this.setJson(BMJsonResources.shared());\n        this.addSubnode(this.json());\n\n        return this;\n    }\n\n    resourceClassesForFileExtension (extension) {\n        return this.subnodes().map(sn => sn.resourceClassesForFileExtension(extension)).flat()\n    }\n\n    resourceClassForFileExtension (extension) {\n        return this.resourceClassesForFileExtension(extension).first()\n    }\n\n    resourceForPath (aPath) {\n        const rClass = this.resourceClassForFileExtension(aPath.pathExtension())\n        /*\n        if (!rClass) {\n            // do we want this behavior?\n            // What's the typical use case for this method\n            rClass = BMResourceFile; \n        }\n        */\n        if (rClass) {\n            const aResource = rClass.clone().setPath(aPath).load()\n            return aResource\n        }\n        return null\n    }\n\n    async prechacheWhereAppropriate () {\n        console.log(this.type() + \".prechacheWhereAppropriate()\");\n        await this.subnodes().promiseParallelMap(async (node) => node.prechacheWhereAppropriate());\n    }\n\n}.initThisClass());\n",
  "6YBcdGTeI0CUF+He7h+bctVZyaw0HQww6TtDH1+n04A=": "\"use strict\";\n\n/*\n\n    BMResourceGroup\n\n*/\n\n(class BMResourceGroup extends BaseNode {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"resourceClasses\", []);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    initPrototype () {\n        this.setNoteIsSubnodeCount(true);\n    }\n\n    init () {\n        super.init();\n        this.setTitle(this.type());\n        this.setResourceClasses([]);\n        this.setup();\n        this.registerForAppDidInit();\n    }\n\n    setup () {\n        // subclasses should override this to set ResourceClasses\n    }\n\n    async appDidInit () {\n        await this.setupSubnodes();\n    }\n\n    extensions () {\n        const exts = this.resourceClasses().map(rClass => rClass.supportedExtensions()).flat().unique();\n        return exts;\n    }\n\n    resourcePaths () {\n        return ResourceManager.shared().resourceFilePathsWithExtensions(this.extensions());\n    }\n\n    urlResources () {\n        return ResourceManager.shared().urlResourcesWithExtensions(this.extensions());\n    }\n\n    async setupSubnodes () {\n        await this.urlResources().promiseParallelMap(async (r) => {\n            const rClass = this.resourceClassForFileExtension(r.pathExtension());\n            const aResource = rClass.clone().setPath(r.path());\n            aResource.setUrlResource(r);\n            //console.log(\"setup node '\" + r.resourceHash() + \"' '\" + r.path() + \"'\")\n            //await aResource.asyncLoad();\n            aResource.asyncLoad(); // do this in parallel\n            this.addResource(aResource);\n        })\n\n        //this.resourcePaths().forEach(path => this.addResourceWithPath(path))\n        return this\n    }\n\n    resourceClassesForFileExtension (ext) {\n        const extension = ext.toLowerCase();\n        return this.resourceClasses().select(rClass => rClass.canHandleExtension(ext));\n    }\n\n    resourceClassForFileExtension (ext) {\n        return this.resourceClassesForFileExtension(ext).first();\n    }\n\n    resourceForPath (aPath) {\n        const rClass = this.resourceClassForFileExtension(aPath.pathExtension());\n        if (!rClass) {\n            debugger;\n            this.resourceClassForFileExtension(aPath.pathExtension());\n            return null;\n        };\n        const aResource = rClass.clone().setPath(aPath);\n        //aResource.asyncLoad(); // this is done in prechacheWhereAppropriate\n        return aResource;\n    }\n\n    /*\n    addResourceWithPath (aPath) {\n        const aResource = this.resourceForPath(aPath)\n        this.addResource(aResource)\n        return this\n    }\n    */\n\n    addResource (aResource) {\n        this.addSubnode(aResource);\n        return this;\n    }\n\n    resources () {\n        return this.subnodes();\n    }\n\n    resourceNamed (name) {\n        return this.resources().detect(r => r.name() == name);\n    }\n\n    async prechacheWhereAppropriate () {\n        await this.resources().promiseParallelMap(this.resources(), async (r) => r.prechacheWhereAppropriate());\n        //await this.resources().promiseParallelMap(this.resources(), async (r) => await r.prechacheWhereAppropriate());\n    }\n\n}.initThisClass());\n",
  "SrNKsWfTy5Fg17dZgybcT9zKHPms0KRxqdJ2Y1o3Kjg=": "/*\n\texample use:\n\n\tMimeExtensions.shared().mimeTypeForPathExtension(\".jpg\")\n\n*/\n\n\n(class MimeExtensions extends Base {\n\n\tconstructor () {\n\t\tsuper()\n\t\tthis.setup()\n\t}\n\n\tmimeTypeForPathExtension (ext) {\n\t\tif (ext[0] !== \".\") {\n\t\t\text = \".\" + ext;\n\t\t}\n\n\t\treturn this._fileExtensionToMimeTypeDict[ext]\n\t}\n\n\tpathExtensionsForMimeType (mimeType) {\n\t\tconst allExtensions = Object.keys(this._fileExtensionToMimeTypeDict)\n\t\tconst matchingExtensions = allExtensions.filter(ext => {\n\t\t\treturn mimeType === this._fileExtensionToMimeTypeDict[ext]\n\t\t})\n\t\treturn matchingExtensions.map(ext => ext.slice(1))\n\t}\n\n\tsetup () {\n\t\tthis._fileExtensionToMimeTypeDict = {\n\t\t\t\".123\": \"application/vnd.lotus-1-2-3\",\n\t\t\t\".3dml\": \"text/vnd.in3d.3dml\",\n\t\t\t\".3g2\": \"video/3gpp2\",\n\t\t\t\".3gp\": \"video/3gpp\",\n\t\t\t\".a\": \"application/octet-stream\",\n\t\t\t\".aab\": \"application/x-authorware-bin\",\n\t\t\t\".aac\": \"audio/x-aac\",\n\t\t\t\".aam\": \"application/x-authorware-map\",\n\t\t\t\".aas\": \"application/x-authorware-seg\",\n\t\t\t\".abw\": \"application/x-abiword\",\n\t\t\t\".acc\": \"application/vnd.americandynamics.acc\",\n\t\t\t\".ace\": \"application/x-ace-compressed\",\n\t\t\t\".acu\": \"application/vnd.acucobol\",\n\t\t\t\".acutc\": \"application/vnd.acucorp\",\n\t\t\t\".adp\": \"audio/adpcm\",\n\t\t\t\".aep\": \"application/vnd.audiograph\",\n\t\t\t\".afm\": \"application/x-font-type1\",\n\t\t\t\".afp\": \"application/vnd.ibm.modcap\",\n\t\t\t\".ai\": \"application/postscript\",\n\t\t\t\".aif\": \"audio/x-aiff\",\n\t\t\t\".aifc\": \"audio/x-aiff\",\n\t\t\t\".aiff\": \"audio/x-aiff\",\n\t\t\t\".air\": \"application/vnd.adobe.air-application-installer-package+zip\",\n\t\t\t\".ami\": \"application/vnd.amiga.ami\",\n\t\t\t\".apk\": \"application/vnd.android.package-archive\",\n\t\t\t\".application\": \"application/x-ms-application\",\n\t\t\t\".apr\": \"application/vnd.lotus-approach\",\n\t\t\t\".asc\": \"application/pgp-signature\",\n\t\t\t\".asf\": \"video/x-ms-asf\",\n\t\t\t\".asm\": \"text/x-asm\",\n\t\t\t\".aso\": \"application/vnd.accpac.simply.aso\",\n\t\t\t\".asx\": \"video/x-ms-asf\",\n\t\t\t\".atc\": \"application/vnd.acucorp\",\n\t\t\t\".atom\": \"application/atom+xml\",\n\t\t\t\".atomcat\": \"application/atomcat+xml\",\n\t\t\t\".atomsvc\": \"application/atomsvc+xml\",\n\t\t\t\".atx\": \"application/vnd.antix.game-component\",\n\t\t\t\".au\": \"audio/basic\",\n\t\t\t\".avi\": \"video/x-msvideo\",\n\t\t\t\".aw\": \"application/applixware\",\n\t\t\t\".azf\": \"application/vnd.airzip.filesecure.azf\",\n\t\t\t\".azs\": \"application/vnd.airzip.filesecure.azs\",\n\t\t\t\".azw\": \"application/vnd.amazon.ebook\",\n\t\t\t\".bat\": \"application/x-msdownload\",\n\t\t\t\".bcpio\": \"application/x-bcpio\",\n\t\t\t\".bdf\": \"application/x-font-bdf\",\n\t\t\t\".bdm\": \"application/vnd.syncml.dm+wbxml\",\n\t\t\t\".bh2\": \"application/vnd.fujitsu.oasysprs\",\n\t\t\t\".bin\": \"application/octet-stream\",\n\t\t\t\".bmi\": \"application/vnd.bmi\",\n\t\t\t\".bmp\": \"image/bmp\",\n\t\t\t\".book\": \"application/vnd.framemaker\",\n\t\t\t\".box\": \"application/vnd.previewsystems.box\",\n\t\t\t\".boz\": \"application/x-bzip2\",\n\t\t\t\".bpk\": \"application/octet-stream\",\n\t\t\t\".btif\": \"image/prs.btif\",\n\t\t\t\".bz\": \"application/x-bzip\",\n\t\t\t\".bz2\": \"application/x-bzip2\",\n\t\t\t\".c\": \"text/x-c\",\n\t\t\t\".c4d\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4f\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4g\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4p\": \"application/vnd.clonk.c4group\",\n\t\t\t\".c4u\": \"application/vnd.clonk.c4group\",\n\t\t\t\".cab\": \"application/vnd.ms-cab-compressed\",\n\t\t\t\".car\": \"application/vnd.curl.car\",\n\t\t\t\".cat\": \"application/vnd.ms-pki.seccat\",\n\t\t\t\".cc\": \"text/x-c\",\n\t\t\t\".cct\": \"application/x-director\",\n\t\t\t\".ccxml\": \"application/ccxml+xml\",\n\t\t\t\".cdbcmsg\": \"application/vnd.contact.cmsg\",\n\t\t\t\".cdf\": \"application/x-netcdf\",\n\t\t\t\".cdkey\": \"application/vnd.mediastation.cdkey\",\n\t\t\t\".cdx\": \"chemical/x-cdx\",\n\t\t\t\".cdxml\": \"application/vnd.chemdraw+xml\",\n\t\t\t\".cdy\": \"application/vnd.cinderella\",\n\t\t\t\".cer\": \"application/pkix-cert\",\n\t\t\t\".cgm\": \"image/cgm\",\n\t\t\t\".chat\": \"application/x-chat\",\n\t\t\t\".chm\": \"application/vnd.ms-htmlhelp\",\n\t\t\t\".chrt\": \"application/vnd.kde.kchart\",\n\t\t\t\".cif\": \"chemical/x-cif\",\n\t\t\t\".cii\": \"application/vnd.anser-web-certificate-issue-initiation\",\n\t\t\t\".cil\": \"application/vnd.ms-artgalry\",\n\t\t\t\".cla\": \"application/vnd.claymore\",\n\t\t\t\".class\": \"application/java-vm\",\n\t\t\t\".clkk\": \"application/vnd.crick.clicker.keyboard\",\n\t\t\t\".clkp\": \"application/vnd.crick.clicker.palette\",\n\t\t\t\".clkt\": \"application/vnd.crick.clicker.template\",\n\t\t\t\".clkw\": \"application/vnd.crick.clicker.wordbank\",\n\t\t\t\".clkx\": \"application/vnd.crick.clicker\",\n\t\t\t\".clp\": \"application/x-msclip\",\n\t\t\t\".cmc\": \"application/vnd.cosmocaller\",\n\t\t\t\".cmdf\": \"chemical/x-cmdf\",\n\t\t\t\".cml\": \"chemical/x-cml\",\n\t\t\t\".cmp\": \"application/vnd.yellowriver-custom-menu\",\n\t\t\t\".cmx\": \"image/x-cmx\",\n\t\t\t\".cod\": \"application/vnd.rim.cod\",\n\t\t\t\".com\": \"application/x-msdownload\",\n\t\t\t\".conf\": \"text/plain\",\n\t\t\t\".cpio\": \"application/x-cpio\",\n\t\t\t\".cpp\": \"text/x-c\",\n\t\t\t\".cpt\": \"application/mac-compactpro\",\n\t\t\t\".crd\": \"application/x-mscardfile\",\n\t\t\t\".crl\": \"application/pkix-crl\",\n\t\t\t\".crt\": \"application/x-x509-ca-cert\",\n\t\t\t\".csh\": \"application/x-csh\",\n\t\t\t\".csml\": \"chemical/x-csml\",\n\t\t\t\".csp\": \"application/vnd.commonspace\",\n\t\t\t\".css\": \"text/css\",\n\t\t\t\".cst\": \"application/x-director\",\n\t\t\t\".csv\": \"text/csv\",\n\t\t\t\".cu\": \"application/cu-seeme\",\n\t\t\t\".curl\": \"text/vnd.curl\",\n\t\t\t\".cww\": \"application/prs.cww\",\n\t\t\t\".cxt\": \"application/x-director\",\n\t\t\t\".cxx\": \"text/x-c\",\n\t\t\t\".daf\": \"application/vnd.mobius.daf\",\n\t\t\t\".dataless\": \"application/vnd.fdsn.seed\",\n\t\t\t\".davmount\": \"application/davmount+xml\",\n\t\t\t\".dcr\": \"application/x-director\",\n\t\t\t\".dcurl\": \"text/vnd.curl.dcurl\",\n\t\t\t\".dd2\": \"application/vnd.oma.dd2+xml\",\n\t\t\t\".ddd\": \"application/vnd.fujixerox.ddd\",\n\t\t\t\".deb\": \"application/x-debian-package\",\n\t\t\t\".def\": \"text/plain\",\n\t\t\t\".deploy\": \"application/octet-stream\",\n\t\t\t\".der\": \"application/x-x509-ca-cert\",\n\t\t\t\".dfac\": \"application/vnd.dreamfactory\",\n\t\t\t\".dic\": \"text/x-c\",\n\t\t\t\".diff\": \"text/plain\",\n\t\t\t\".dir\": \"application/x-director\",\n\t\t\t\".dis\": \"application/vnd.mobius.dis\",\n\t\t\t\".dist\": \"application/octet-stream\",\n\t\t\t\".distz\": \"application/octet-stream\",\n\t\t\t\".djv\": \"image/vnd.djvu\",\n\t\t\t\".djvu\": \"image/vnd.djvu\",\n\t\t\t\".dll\": \"application/x-msdownload\",\n\t\t\t\".dmg\": \"application/octet-stream\",\n\t\t\t\".dms\": \"application/octet-stream\",\n\t\t\t\".dna\": \"application/vnd.dna\",\n\t\t\t\".doc\": \"application/msword\",\n\t\t\t\".docm\": \"application/vnd.ms-word.document.macroenabled.12\",\n\t\t\t\".docx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\",\n\t\t\t\".dot\": \"application/msword\",\n\t\t\t\".dotm\": \"application/vnd.ms-word.template.macroenabled.12\",\n\t\t\t\".dotx\": \"application/vnd.openxmlformats-officedocument.wordprocessingml.template\",\n\t\t\t\".dp\": \"application/vnd.osgi.dp\",\n\t\t\t\".dpg\": \"application/vnd.dpgraph\",\n\t\t\t\".dsc\": \"text/prs.lines.tag\",\n\t\t\t\".dtb\": \"application/x-dtbook+xml\",\n\t\t\t\".dtd\": \"application/xml-dtd\",\n\t\t\t\".dts\": \"audio/vnd.dts\",\n\t\t\t\".dtshd\": \"audio/vnd.dts.hd\",\n\t\t\t\".dump\": \"application/octet-stream\",\n\t\t\t\".dvi\": \"application/x-dvi\",\n\t\t\t\".dwf\": \"model/vnd.dwf\",\n\t\t\t\".dwg\": \"image/vnd.dwg\",\n\t\t\t\".dxf\": \"image/vnd.dxf\",\n\t\t\t\".dxp\": \"application/vnd.spotfire.dxp\",\n\t\t\t\".dxr\": \"application/x-director\",\n\t\t\t\".ecelp4800\": \"audio/vnd.nuera.ecelp4800\",\n\t\t\t\".ecelp7470\": \"audio/vnd.nuera.ecelp7470\",\n\t\t\t\".ecelp9600\": \"audio/vnd.nuera.ecelp9600\",\n\t\t\t\".ecma\": \"application/ecmascript\",\n\t\t\t\".edm\": \"application/vnd.novadigm.edm\",\n\t\t\t\".edx\": \"application/vnd.novadigm.edx\",\n\t\t\t\".efif\": \"application/vnd.picsel\",\n\t\t\t\".ei6\": \"application/vnd.pg.osasli\",\n\t\t\t\".elc\": \"application/octet-stream\",\n\t\t\t\".eml\": \"message/rfc822\",\n\t\t\t\".emma\": \"application/emma+xml\",\n\t\t\t\".eol\": \"audio/vnd.digital-winds\",\n\t\t\t\".eot\": \"application/vnd.ms-fontobject\",\n\t\t\t\".eps\": \"application/postscript\",\n\t\t\t\".epub\": \"application/epub+zip\",\n\t\t\t\".es3\": \"application/vnd.eszigno3+xml\",\n\t\t\t\".esf\": \"application/vnd.epson.esf\",\n\t\t\t\".et3\": \"application/vnd.eszigno3+xml\",\n\t\t\t\".etx\": \"text/x-setext\",\n\t\t\t\".exe\": \"application/x-msdownload\",\n\t\t\t\".ext\": \"application/vnd.novadigm.ext\",\n\t\t\t\".ez\": \"application/andrew-inset\",\n\t\t\t\".ez2\": \"application/vnd.ezpix-album\",\n\t\t\t\".ez3\": \"application/vnd.ezpix-package\",\n\t\t\t\".f\": \"text/x-fortran\",\n\t\t\t\".f4v\": \"video/x-f4v\",\n\t\t\t\".f77\": \"text/x-fortran\",\n\t\t\t\".f90\": \"text/x-fortran\",\n\t\t\t\".fbs\": \"image/vnd.fastbidsheet\",\n\t\t\t\".fdf\": \"application/vnd.fdf\",\n\t\t\t\".fe_launch\": \"application/vnd.denovo.fcselayout-link\",\n\t\t\t\".fg5\": \"application/vnd.fujitsu.oasysgp\",\n\t\t\t\".fgd\": \"application/x-director\",\n\t\t\t\".fh\": \"image/x-freehand\",\n\t\t\t\".fh4\": \"image/x-freehand\",\n\t\t\t\".fh5\": \"image/x-freehand\",\n\t\t\t\".fh7\": \"image/x-freehand\",\n\t\t\t\".fhc\": \"image/x-freehand\",\n\t\t\t\".fig\": \"application/x-xfig\",\n\t\t\t\".fli\": \"video/x-fli\",\n\t\t\t\".flo\": \"application/vnd.micrografx.flo\",\n\t\t\t\".flv\": \"video/x-flv\",\n\t\t\t\".flw\": \"application/vnd.kde.kivio\",\n\t\t\t\".flx\": \"text/vnd.fmi.flexstor\",\n\t\t\t\".fly\": \"text/vnd.fly\",\n\t\t\t\".fm\": \"application/vnd.framemaker\",\n\t\t\t\".fnc\": \"application/vnd.frogans.fnc\",\n\t\t\t\".for\": \"text/x-fortran\",\n\t\t\t\".fpx\": \"image/vnd.fpx\",\n\t\t\t\".frame\": \"application/vnd.framemaker\",\n\t\t\t\".fsc\": \"application/vnd.fsc.weblaunch\",\n\t\t\t\".fst\": \"image/vnd.fst\",\n\t\t\t\".ftc\": \"application/vnd.fluxtime.clip\",\n\t\t\t\".fti\": \"application/vnd.anser-web-funds-transfer-initiation\",\n\t\t\t\".fvt\": \"video/vnd.fvt\",\n\t\t\t\".fzs\": \"application/vnd.fuzzysheet\",\n\t\t\t\".g3\": \"image/g3fax\",\n\t\t\t\".gac\": \"application/vnd.groove-account\",\n\t\t\t\".gdl\": \"model/vnd.gdl\",\n\t\t\t\".geo\": \"application/vnd.dynageo\",\n\t\t\t\".gex\": \"application/vnd.geometry-explorer\",\n\t\t\t\".ggb\": \"application/vnd.geogebra.file\",\n\t\t\t\".ggt\": \"application/vnd.geogebra.tool\",\n\t\t\t\".ghf\": \"application/vnd.groove-help\",\n\t\t\t\".gif\": \"image/gif\",\n\t\t\t\".gim\": \"application/vnd.groove-identity-message\",\n\t\t\t\".gmx\": \"application/vnd.gmx\",\n\t\t\t\".gnumeric\": \"application/x-gnumeric\",\n\t\t\t\".gph\": \"application/vnd.flographit\",\n\t\t\t\".gqf\": \"application/vnd.grafeq\",\n\t\t\t\".gqs\": \"application/vnd.grafeq\",\n\t\t\t\".gram\": \"application/srgs\",\n\t\t\t\".gre\": \"application/vnd.geometry-explorer\",\n\t\t\t\".grv\": \"application/vnd.groove-injector\",\n\t\t\t\".grxml\": \"application/srgs+xml\",\n\t\t\t\".gsf\": \"application/x-font-ghostscript\",\n\t\t\t\".gtar\": \"application/x-gtar\",\n\t\t\t\".gtm\": \"application/vnd.groove-tool-message\",\n\t\t\t\".gtw\": \"model/vnd.gtw\",\n\t\t\t\".gv\": \"text/vnd.graphviz\",\n\t\t\t\".gz\": \"application/x-gzip\",\n\t\t\t\".h\": \"text/x-c\",\n\t\t\t\".h261\": \"video/h261\",\n\t\t\t\".h263\": \"video/h263\",\n\t\t\t\".h264\": \"video/h264\",\n\t\t\t\".hbci\": \"application/vnd.hbci\",\n\t\t\t\".hdf\": \"application/x-hdf\",\n\t\t\t\".hh\": \"text/x-c\",\n\t\t\t\".hlp\": \"application/winhlp\",\n\t\t\t\".hpgl\": \"application/vnd.hp-hpgl\",\n\t\t\t\".hpid\": \"application/vnd.hp-hpid\",\n\t\t\t\".hps\": \"application/vnd.hp-hps\",\n\t\t\t\".hqx\": \"application/mac-binhex40\",\n\t\t\t\".htke\": \"application/vnd.kenameaapp\",\n\t\t\t\".htm\": \"text/html\",\n\t\t\t\".html\": \"text/html\",\n\t\t\t\".hvd\": \"application/vnd.yamaha.hv-dic\",\n\t\t\t\".hvp\": \"application/vnd.yamaha.hv-voice\",\n\t\t\t\".hvs\": \"application/vnd.yamaha.hv-script\",\n\t\t\t\".icc\": \"application/vnd.iccprofile\",\n\t\t\t\".ice\": \"x-conference/x-cooltalk\",\n\t\t\t\".icm\": \"application/vnd.iccprofile\",\n\t\t\t\".ico\": \"image/x-icon\",\n\t\t\t\".ics\": \"text/calendar\",\n\t\t\t\".ief\": \"image/ief\",\n\t\t\t\".ifb\": \"text/calendar\",\n\t\t\t\".ifm\": \"application/vnd.shana.informed.formdata\",\n\t\t\t\".iges\": \"model/iges\",\n\t\t\t\".igl\": \"application/vnd.igloader\",\n\t\t\t\".igs\": \"model/iges\",\n\t\t\t\".igx\": \"application/vnd.micrografx.igx\",\n\t\t\t\".iif\": \"application/vnd.shana.informed.interchange\",\n\t\t\t\".imp\": \"application/vnd.accpac.simply.imp\",\n\t\t\t\".ims\": \"application/vnd.ms-ims\",\n\t\t\t\".in\": \"text/plain\",\n\t\t\t\".ipk\": \"application/vnd.shana.informed.package\",\n\t\t\t\".irm\": \"application/vnd.ibm.rights-management\",\n\t\t\t\".irp\": \"application/vnd.irepository.package+xml\",\n\t\t\t\".iso\": \"application/octet-stream\",\n\t\t\t\".itp\": \"application/vnd.shana.informed.formtemplate\",\n\t\t\t\".ivp\": \"application/vnd.immervision-ivp\",\n\t\t\t\".ivu\": \"application/vnd.immervision-ivu\",\n\t\t\t\".jad\": \"text/vnd.sun.j2me.app-descriptor\",\n\t\t\t\".jam\": \"application/vnd.jam\",\n\t\t\t\".jar\": \"application/java-archive\",\n\t\t\t\".java\": \"text/x-java-source\",\n\t\t\t\".jisp\": \"application/vnd.jisp\",\n\t\t\t\".jlt\": \"application/vnd.hp-jlyt\",\n\t\t\t\".jnlp\": \"application/x-java-jnlp-file\",\n\t\t\t\".joda\": \"application/vnd.joost.joda-archive\",\n\t\t\t\".jpe\": \"image/jpeg\",\n\t\t\t\".jpeg\": \"image/jpeg\",\n\t\t\t\".jpg\": \"image/jpeg\",\n\t\t\t\".jpgm\": \"video/jpm\",\n\t\t\t\".jpgv\": \"video/jpeg\",\n\t\t\t\".jpm\": \"video/jpm\",\n\t\t\t\".js\": \"application/javascript\",\n\t\t\t\".json\": \"application/json\",\n\t\t\t\".kar\": \"audio/midi\",\n\t\t\t\".karbon\": \"application/vnd.kde.karbon\",\n\t\t\t\".kfo\": \"application/vnd.kde.kformula\",\n\t\t\t\".kia\": \"application/vnd.kidspiration\",\n\t\t\t\".kil\": \"application/x-killustrator\",\n\t\t\t\".kml\": \"application/vnd.google-earth.kml+xml\",\n\t\t\t\".kmz\": \"application/vnd.google-earth.kmz\",\n\t\t\t\".kne\": \"application/vnd.kinar\",\n\t\t\t\".knp\": \"application/vnd.kinar\",\n\t\t\t\".kon\": \"application/vnd.kde.kontour\",\n\t\t\t\".kpr\": \"application/vnd.kde.kpresenter\",\n\t\t\t\".kpt\": \"application/vnd.kde.kpresenter\",\n\t\t\t\".ksh\": \"text/plain\",\n\t\t\t\".ksp\": \"application/vnd.kde.kspread\",\n\t\t\t\".ktr\": \"application/vnd.kahootz\",\n\t\t\t\".ktz\": \"application/vnd.kahootz\",\n\t\t\t\".kwd\": \"application/vnd.kde.kword\",\n\t\t\t\".kwt\": \"application/vnd.kde.kword\",\n\t\t\t\".latex\": \"application/x-latex\",\n\t\t\t\".lbd\": \"application/vnd.llamagraphics.life-balance.desktop\",\n\t\t\t\".lbe\": \"application/vnd.llamagraphics.life-balance.exchange+xml\",\n\t\t\t\".les\": \"application/vnd.hhe.lesson-player\",\n\t\t\t\".lha\": \"application/octet-stream\",\n\t\t\t\".link66\": \"application/vnd.route66.link66+xml\",\n\t\t\t\".list\": \"text/plain\",\n\t\t\t\".list3820\": \"application/vnd.ibm.modcap\",\n\t\t\t\".listafp\": \"application/vnd.ibm.modcap\",\n\t\t\t\".log\": \"text/plain\",\n\t\t\t\".lostxml\": \"application/lost+xml\",\n\t\t\t\".lrf\": \"application/octet-stream\",\n\t\t\t\".lrm\": \"application/vnd.ms-lrm\",\n\t\t\t\".ltf\": \"application/vnd.frogans.ltf\",\n\t\t\t\".lvp\": \"audio/vnd.lucent.voice\",\n\t\t\t\".lwp\": \"application/vnd.lotus-wordpro\",\n\t\t\t\".lzh\": \"application/octet-stream\",\n\t\t\t\".m13\": \"application/x-msmediaview\",\n\t\t\t\".m14\": \"application/x-msmediaview\",\n\t\t\t\".m1v\": \"video/mpeg\",\n\t\t\t\".m2a\": \"audio/mpeg\",\n\t\t\t\".m2v\": \"video/mpeg\",\n\t\t\t\".m3a\": \"audio/mpeg\",\n\t\t\t\".m3u\": \"audio/x-mpegurl\",\n\t\t\t\".m4u\": \"video/vnd.mpegurl\",\n\t\t\t\".m4v\": \"video/x-m4v\",\n\t\t\t\".ma\": \"application/mathematica\",\n\t\t\t\".mag\": \"application/vnd.ecowin.chart\",\n\t\t\t\".maker\": \"application/vnd.framemaker\",\n\t\t\t\".man\": \"text/troff\",\n\t\t\t\".mathml\": \"application/mathml+xml\",\n\t\t\t\".mb\": \"application/mathematica\",\n\t\t\t\".mbk\": \"application/vnd.mobius.mbk\",\n\t\t\t\".mbox\": \"application/mbox\",\n\t\t\t\".mc1\": \"application/vnd.medcalcdata\",\n\t\t\t\".mcd\": \"application/vnd.mcd\",\n\t\t\t\".mcurl\": \"text/vnd.curl.mcurl\",\n\t\t\t\".mdb\": \"application/x-msaccess\",\n\t\t\t\".mdi\": \"image/vnd.ms-modi\",\n\t\t\t\".me\": \"text/troff\",\n\t\t\t\".mesh\": \"model/mesh\",\n\t\t\t\".mfm\": \"application/vnd.mfmp\",\n\t\t\t\".mgz\": \"application/vnd.proteus.magazine\",\n\t\t\t\".mht\": \"message/rfc822\",\n\t\t\t\".mhtml\": \"message/rfc822\",\n\t\t\t\".mid\": \"audio/midi\",\n\t\t\t\".midi\": \"audio/midi\",\n\t\t\t\".mif\": \"application/vnd.mif\",\n\t\t\t\".mime\": \"message/rfc822\",\n\t\t\t\".mj2\": \"video/mj2\",\n\t\t\t\".mjp2\": \"video/mj2\",\n\t\t\t\".mlp\": \"application/vnd.dolby.mlp\",\n\t\t\t\".mmd\": \"application/vnd.chipnuts.karaoke-mmd\",\n\t\t\t\".mmf\": \"application/vnd.smaf\",\n\t\t\t\".mmr\": \"image/vnd.fujixerox.edmics-mmr\",\n\t\t\t\".mny\": \"application/x-msmoney\",\n\t\t\t\".mobi\": \"application/x-mobipocket-ebook\",\n\t\t\t\".mov\": \"video/quicktime\",\n\t\t\t\".movie\": \"video/x-sgi-movie\",\n\t\t\t\".mp2\": \"audio/mpeg\",\n\t\t\t\".mp2a\": \"audio/mpeg\",\n\t\t\t\".mp3\": \"audio/mpeg\",\n\t\t\t\".mp4\": \"video/mp4\",\n\t\t\t\".mp4a\": \"audio/mp4\",\n\t\t\t\".mp4s\": \"application/mp4\",\n\t\t\t\".mp4v\": \"video/mp4\",\n\t\t\t\".mpa\": \"video/mpeg\",\n\t\t\t\".mpc\": \"application/vnd.mophun.certificate\",\n\t\t\t\".mpe\": \"video/mpeg\",\n\t\t\t\".mpeg\": \"video/mpeg\",\n\t\t\t\".mpg\": \"video/mpeg\",\n\t\t\t\".mpg4\": \"video/mp4\",\n\t\t\t\".mpga\": \"audio/mpeg\",\n\t\t\t\".mpkg\": \"application/vnd.apple.installer+xml\",\n\t\t\t\".mpm\": \"application/vnd.blueice.multipass\",\n\t\t\t\".mpn\": \"application/vnd.mophun.application\",\n\t\t\t\".mpp\": \"application/vnd.ms-project\",\n\t\t\t\".mpt\": \"application/vnd.ms-project\",\n\t\t\t\".mpy\": \"application/vnd.ibm.minipay\",\n\t\t\t\".mqy\": \"application/vnd.mobius.mqy\",\n\t\t\t\".mrc\": \"application/marc\",\n\t\t\t\".ms\": \"text/troff\",\n\t\t\t\".mscml\": \"application/mediaservercontrol+xml\",\n\t\t\t\".mseed\": \"application/vnd.fdsn.mseed\",\n\t\t\t\".mseq\": \"application/vnd.mseq\",\n\t\t\t\".msf\": \"application/vnd.epson.msf\",\n\t\t\t\".msh\": \"model/mesh\",\n\t\t\t\".msi\": \"application/x-msdownload\",\n\t\t\t\".msl\": \"application/vnd.mobius.msl\",\n\t\t\t\".msty\": \"application/vnd.muvee.style\",\n\t\t\t\".mts\": \"model/vnd.mts\",\n\t\t\t\".mus\": \"application/vnd.musician\",\n\t\t\t\".musicxml\": \"application/vnd.recordare.musicxml+xml\",\n\t\t\t\".mvb\": \"application/x-msmediaview\",\n\t\t\t\".mwf\": \"application/vnd.mfer\",\n\t\t\t\".mxf\": \"application/mxf\",\n\t\t\t\".mxl\": \"application/vnd.recordare.musicxml\",\n\t\t\t\".mxml\": \"application/xv+xml\",\n\t\t\t\".mxs\": \"application/vnd.triscape.mxs\",\n\t\t\t\".mxu\": \"video/vnd.mpegurl\",\n\t\t\t\".n-gage\": \"application/vnd.nokia.n-gage.symbian.install\",\n\t\t\t\".nb\": \"application/mathematica\",\n\t\t\t\".nc\": \"application/x-netcdf\",\n\t\t\t\".ncx\": \"application/x-dtbncx+xml\",\n\t\t\t\".ngdat\": \"application/vnd.nokia.n-gage.data\",\n\t\t\t\".nlu\": \"application/vnd.neurolanguage.nlu\",\n\t\t\t\".nml\": \"application/vnd.enliven\",\n\t\t\t\".nnd\": \"application/vnd.noblenet-directory\",\n\t\t\t\".nns\": \"application/vnd.noblenet-sealer\",\n\t\t\t\".nnw\": \"application/vnd.noblenet-web\",\n\t\t\t\".npx\": \"image/vnd.net-fpx\",\n\t\t\t\".nsf\": \"application/vnd.lotus-notes\",\n\t\t\t\".nws\": \"message/rfc822\",\n\t\t\t\".o\": \"application/octet-stream\",\n\t\t\t\".oa2\": \"application/vnd.fujitsu.oasys2\",\n\t\t\t\".oa3\": \"application/vnd.fujitsu.oasys3\",\n\t\t\t\".oas\": \"application/vnd.fujitsu.oasys\",\n\t\t\t\".obd\": \"application/x-msbinder\",\n\t\t\t\".obj\": \"application/octet-stream\",\n\t\t\t\".oda\": \"application/oda\",\n\t\t\t\".odb\": \"application/vnd.oasis.opendocument.database\",\n\t\t\t\".odc\": \"application/vnd.oasis.opendocument.chart\",\n\t\t\t\".odf\": \"application/vnd.oasis.opendocument.formula\",\n\t\t\t\".odft\": \"application/vnd.oasis.opendocument.formula-template\",\n\t\t\t\".odg\": \"application/vnd.oasis.opendocument.graphics\",\n\t\t\t\".odi\": \"application/vnd.oasis.opendocument.image\",\n\t\t\t\".odp\": \"application/vnd.oasis.opendocument.presentation\",\n\t\t\t\".ods\": \"application/vnd.oasis.opendocument.spreadsheet\",\n\t\t\t\".odt\": \"application/vnd.oasis.opendocument.text\",\n\t\t\t\".oga\": \"audio/ogg\",\n\t\t\t\".ogg\": \"audio/ogg\",\n\t\t\t\".ogv\": \"video/ogg\",\n\t\t\t\".ogx\": \"application/ogg\",\n\t\t\t\".onepkg\": \"application/onenote\",\n\t\t\t\".onetmp\": \"application/onenote\",\n\t\t\t\".onetoc\": \"application/onenote\",\n\t\t\t\".onetoc2\": \"application/onenote\",\n\t\t\t\".opf\": \"application/oebps-package+xml\",\n\t\t\t\".oprc\": \"application/vnd.palm\",\n\t\t\t\".org\": \"application/vnd.lotus-organizer\",\n\t\t\t\".osf\": \"application/vnd.yamaha.openscoreformat\",\n\t\t\t\".osfpvg\": \"application/vnd.yamaha.openscoreformat.osfpvg+xml\",\n\t\t\t\".otc\": \"application/vnd.oasis.opendocument.chart-template\",\n\t\t\t\".otf\": \"application/x-font-otf\",\n\t\t\t\".otg\": \"application/vnd.oasis.opendocument.graphics-template\",\n\t\t\t\".oth\": \"application/vnd.oasis.opendocument.text-web\",\n\t\t\t\".oti\": \"application/vnd.oasis.opendocument.image-template\",\n\t\t\t\".otm\": \"application/vnd.oasis.opendocument.text-master\",\n\t\t\t\".otp\": \"application/vnd.oasis.opendocument.presentation-template\",\n\t\t\t\".ots\": \"application/vnd.oasis.opendocument.spreadsheet-template\",\n\t\t\t\".ott\": \"application/vnd.oasis.opendocument.text-template\",\n\t\t\t\".oxt\": \"application/vnd.openofficeorg.extension\",\n\t\t\t\".p\": \"text/x-pascal\",\n\t\t\t\".p10\": \"application/pkcs10\",\n\t\t\t\".p12\": \"application/x-pkcs12\",\n\t\t\t\".p7b\": \"application/x-pkcs7-certificates\",\n\t\t\t\".p7c\": \"application/pkcs7-mime\",\n\t\t\t\".p7m\": \"application/pkcs7-mime\",\n\t\t\t\".p7r\": \"application/x-pkcs7-certreqresp\",\n\t\t\t\".p7s\": \"application/pkcs7-signature\",\n\t\t\t\".pas\": \"text/x-pascal\",\n\t\t\t\".pbd\": \"application/vnd.powerbuilder6\",\n\t\t\t\".pbm\": \"image/x-portable-bitmap\",\n\t\t\t\".pcf\": \"application/x-font-pcf\",\n\t\t\t\".pcl\": \"application/vnd.hp-pcl\",\n\t\t\t\".pclxl\": \"application/vnd.hp-pclxl\",\n\t\t\t\".pct\": \"image/x-pict\",\n\t\t\t\".pcurl\": \"application/vnd.curl.pcurl\",\n\t\t\t\".pcx\": \"image/x-pcx\",\n\t\t\t\".pdb\": \"application/vnd.palm\",\n\t\t\t\".pdf\": \"application/pdf\",\n\t\t\t\".pfa\": \"application/x-font-type1\",\n\t\t\t\".pfb\": \"application/x-font-type1\",\n\t\t\t\".pfm\": \"application/x-font-type1\",\n\t\t\t\".pfr\": \"application/font-tdpfr\",\n\t\t\t\".pfx\": \"application/x-pkcs12\",\n\t\t\t\".pgm\": \"image/x-portable-graymap\",\n\t\t\t\".pgn\": \"application/x-chess-pgn\",\n\t\t\t\".pgp\": \"application/pgp-encrypted\",\n\t\t\t\".pic\": \"image/x-pict\",\n\t\t\t\".pkg\": \"application/octet-stream\",\n\t\t\t\".pki\": \"application/pkixcmp\",\n\t\t\t\".pkipath\": \"application/pkix-pkipath\",\n\t\t\t\".pl\": \"text/plain\",\n\t\t\t\".plb\": \"application/vnd.3gpp.pic-bw-large\",\n\t\t\t\".plc\": \"application/vnd.mobius.plc\",\n\t\t\t\".plf\": \"application/vnd.pocketlearn\",\n\t\t\t\".pls\": \"application/pls+xml\",\n\t\t\t\".pml\": \"application/vnd.ctc-posml\",\n\t\t\t\".png\": \"image/png\",\n\t\t\t\".pnm\": \"image/x-portable-anymap\",\n\t\t\t\".portpkg\": \"application/vnd.macports.portpkg\",\n\t\t\t\".pot\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".potm\": \"application/vnd.ms-powerpoint.template.macroenabled.12\",\n\t\t\t\".potx\": \"application/vnd.openxmlformats-officedocument.presentationml.template\",\n\t\t\t\".ppa\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".ppam\": \"application/vnd.ms-powerpoint.addin.macroenabled.12\",\n\t\t\t\".ppd\": \"application/vnd.cups-ppd\",\n\t\t\t\".ppm\": \"image/x-portable-pixmap\",\n\t\t\t\".pps\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".ppsm\": \"application/vnd.ms-powerpoint.slideshow.macroenabled.12\",\n\t\t\t\".ppsx\": \"application/vnd.openxmlformats-officedocument.presentationml.slideshow\",\n\t\t\t\".ppt\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".pptm\": \"application/vnd.ms-powerpoint.presentation.macroenabled.12\",\n\t\t\t\".pptx\": \"application/vnd.openxmlformats-officedocument.presentationml.presentation\",\n\t\t\t\".pqa\": \"application/vnd.palm\",\n\t\t\t\".prc\": \"application/x-mobipocket-ebook\",\n\t\t\t\".pre\": \"application/vnd.lotus-freelance\",\n\t\t\t\".prf\": \"application/pics-rules\",\n\t\t\t\".ps\": \"application/postscript\",\n\t\t\t\".psb\": \"application/vnd.3gpp.pic-bw-small\",\n\t\t\t\".psd\": \"image/vnd.adobe.photoshop\",\n\t\t\t\".psf\": \"application/x-font-linux-psf\",\n\t\t\t\".ptid\": \"application/vnd.pvi.ptid1\",\n\t\t\t\".pub\": \"application/x-mspublisher\",\n\t\t\t\".pvb\": \"application/vnd.3gpp.pic-bw-var\",\n\t\t\t\".pwn\": \"application/vnd.3m.post-it-notes\",\n\t\t\t\".pwz\": \"application/vnd.ms-powerpoint\",\n\t\t\t\".py\": \"text/x-python\",\n\t\t\t\".pya\": \"audio/vnd.ms-playready.media.pya\",\n\t\t\t\".pyc\": \"application/x-python-code\",\n\t\t\t\".pyo\": \"application/x-python-code\",\n\t\t\t\".pyv\": \"video/vnd.ms-playready.media.pyv\",\n\t\t\t\".qam\": \"application/vnd.epson.quickanime\",\n\t\t\t\".qbo\": \"application/vnd.intu.qbo\",\n\t\t\t\".qfx\": \"application/vnd.intu.qfx\",\n\t\t\t\".qps\": \"application/vnd.publishare-delta-tree\",\n\t\t\t\".qt\": \"video/quicktime\",\n\t\t\t\".qwd\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qwt\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxb\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxd\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxl\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".qxt\": \"application/vnd.quark.quarkxpress\",\n\t\t\t\".ra\": \"audio/x-pn-realaudio\",\n\t\t\t\".ram\": \"audio/x-pn-realaudio\",\n\t\t\t\".rar\": \"application/x-rar-compressed\",\n\t\t\t\".ras\": \"image/x-cmu-raster\",\n\t\t\t\".rcprofile\": \"application/vnd.ipunplugged.rcprofile\",\n\t\t\t\".rdf\": \"application/rdf+xml\",\n\t\t\t\".rdz\": \"application/vnd.data-vision.rdz\",\n\t\t\t\".rep\": \"application/vnd.businessobjects\",\n\t\t\t\".res\": \"application/x-dtbresource+xml\",\n\t\t\t\".rgb\": \"image/x-rgb\",\n\t\t\t\".rif\": \"application/reginfo+xml\",\n\t\t\t\".rl\": \"application/resource-lists+xml\",\n\t\t\t\".rlc\": \"image/vnd.fujixerox.edmics-rlc\",\n\t\t\t\".rld\": \"application/resource-lists-diff+xml\",\n\t\t\t\".rm\": \"application/vnd.rn-realmedia\",\n\t\t\t\".rmi\": \"audio/midi\",\n\t\t\t\".rmp\": \"audio/x-pn-realaudio-plugin\",\n\t\t\t\".rms\": \"application/vnd.jcp.javame.midlet-rms\",\n\t\t\t\".rnc\": \"application/relax-ng-compact-syntax\",\n\t\t\t\".roff\": \"text/troff\",\n\t\t\t\".rpm\": \"application/x-rpm\",\n\t\t\t\".rpss\": \"application/vnd.nokia.radio-presets\",\n\t\t\t\".rpst\": \"application/vnd.nokia.radio-preset\",\n\t\t\t\".rq\": \"application/sparql-query\",\n\t\t\t\".rs\": \"application/rls-services+xml\",\n\t\t\t\".rsd\": \"application/rsd+xml\",\n\t\t\t\".rss\": \"application/rss+xml\",\n\t\t\t\".rtf\": \"application/rtf\",\n\t\t\t\".rtx\": \"text/richtext\",\n\t\t\t\".s\": \"text/x-asm\",\n\t\t\t\".saf\": \"application/vnd.yamaha.smaf-audio\",\n\t\t\t\".sbml\": \"application/sbml+xml\",\n\t\t\t\".sc\": \"application/vnd.ibm.secure-container\",\n\t\t\t\".scd\": \"application/x-msschedule\",\n\t\t\t\".scm\": \"application/vnd.lotus-screencam\",\n\t\t\t\".scq\": \"application/scvp-cv-request\",\n\t\t\t\".scs\": \"application/scvp-cv-response\",\n\t\t\t\".scurl\": \"text/vnd.curl.scurl\",\n\t\t\t\".sda\": \"application/vnd.stardivision.draw\",\n\t\t\t\".sdc\": \"application/vnd.stardivision.calc\",\n\t\t\t\".sdd\": \"application/vnd.stardivision.impress\",\n\t\t\t\".sdkd\": \"application/vnd.solent.sdkm+xml\",\n\t\t\t\".sdkm\": \"application/vnd.solent.sdkm+xml\",\n\t\t\t\".sdp\": \"application/sdp\",\n\t\t\t\".sdw\": \"application/vnd.stardivision.writer\",\n\t\t\t\".see\": \"application/vnd.seemail\",\n\t\t\t\".seed\": \"application/vnd.fdsn.seed\",\n\t\t\t\".sema\": \"application/vnd.sema\",\n\t\t\t\".semd\": \"application/vnd.semd\",\n\t\t\t\".semf\": \"application/vnd.semf\",\n\t\t\t\".ser\": \"application/java-serialized-object\",\n\t\t\t\".setpay\": \"application/set-payment-initiation\",\n\t\t\t\".setreg\": \"application/set-registration-initiation\",\n\t\t\t\".sfd-hdstx\": \"application/vnd.hydrostatix.sof-data\",\n\t\t\t\".sfs\": \"application/vnd.spotfire.sfs\",\n\t\t\t\".sgl\": \"application/vnd.stardivision.writer-global\",\n\t\t\t\".sgm\": \"text/sgml\",\n\t\t\t\".sgml\": \"text/sgml\",\n\t\t\t\".sh\": \"application/x-sh\",\n\t\t\t\".shar\": \"application/x-shar\",\n\t\t\t\".shf\": \"application/shf+xml\",\n\t\t\t\".si\": \"text/vnd.wap.si\",\n\t\t\t\".sic\": \"application/vnd.wap.sic\",\n\t\t\t\".sig\": \"application/pgp-signature\",\n\t\t\t\".silo\": \"model/mesh\",\n\t\t\t\".sis\": \"application/vnd.symbian.install\",\n\t\t\t\".sisx\": \"application/vnd.symbian.install\",\n\t\t\t\".sit\": \"application/x-stuffit\",\n\t\t\t\".sitx\": \"application/x-stuffitx\",\n\t\t\t\".skd\": \"application/vnd.koan\",\n\t\t\t\".skm\": \"application/vnd.koan\",\n\t\t\t\".skp\": \"application/vnd.koan\",\n\t\t\t\".skt\": \"application/vnd.koan\",\n\t\t\t\".sl\": \"text/vnd.wap.sl\",\n\t\t\t\".slc\": \"application/vnd.wap.slc\",\n\t\t\t\".sldm\": \"application/vnd.ms-powerpoint.slide.macroenabled.12\",\n\t\t\t\".sldx\": \"application/vnd.openxmlformats-officedocument.presentationml.slide\",\n\t\t\t\".slt\": \"application/vnd.epson.salt\",\n\t\t\t\".smf\": \"application/vnd.stardivision.math\",\n\t\t\t\".smi\": \"application/smil+xml\",\n\t\t\t\".smil\": \"application/smil+xml\",\n\t\t\t\".snd\": \"audio/basic\",\n\t\t\t\".snf\": \"application/x-font-snf\",\n\t\t\t\".so\": \"application/octet-stream\",\n\t\t\t\".spc\": \"application/x-pkcs7-certificates\",\n\t\t\t\".spf\": \"application/vnd.yamaha.smaf-phrase\",\n\t\t\t\".spl\": \"application/x-futuresplash\",\n\t\t\t\".spot\": \"text/vnd.in3d.spot\",\n\t\t\t\".spp\": \"application/scvp-vp-response\",\n\t\t\t\".spq\": \"application/scvp-vp-request\",\n\t\t\t\".spx\": \"audio/ogg\",\n\t\t\t\".src\": \"application/x-wais-source\",\n\t\t\t\".srx\": \"application/sparql-results+xml\",\n\t\t\t\".sse\": \"application/vnd.kodak-descriptor\",\n\t\t\t\".ssf\": \"application/vnd.epson.ssf\",\n\t\t\t\".ssml\": \"application/ssml+xml\",\n\t\t\t\".stc\": \"application/vnd.sun.xml.calc.template\",\n\t\t\t\".std\": \"application/vnd.sun.xml.draw.template\",\n\t\t\t\".stf\": \"application/vnd.wt.stf\",\n\t\t\t\".sti\": \"application/vnd.sun.xml.impress.template\",\n\t\t\t\".stk\": \"application/hyperstudio\",\n\t\t\t\".stl\": \"application/vnd.ms-pki.stl\",\n\t\t\t\".str\": \"application/vnd.pg.format\",\n\t\t\t\".stw\": \"application/vnd.sun.xml.writer.template\",\n\t\t\t\".sus\": \"application/vnd.sus-calendar\",\n\t\t\t\".susp\": \"application/vnd.sus-calendar\",\n\t\t\t\".sv4cpio\": \"application/x-sv4cpio\",\n\t\t\t\".sv4crc\": \"application/x-sv4crc\",\n\t\t\t\".svd\": \"application/vnd.svd\",\n\t\t\t\".svg\": \"image/svg+xml\",\n\t\t\t\".svgz\": \"image/svg+xml\",\n\t\t\t\".swa\": \"application/x-director\",\n\t\t\t\".swf\": \"application/x-shockwave-flash\",\n\t\t\t\".swi\": \"application/vnd.arastra.swi\",\n\t\t\t\".sxc\": \"application/vnd.sun.xml.calc\",\n\t\t\t\".sxd\": \"application/vnd.sun.xml.draw\",\n\t\t\t\".sxg\": \"application/vnd.sun.xml.writer.global\",\n\t\t\t\".sxi\": \"application/vnd.sun.xml.impress\",\n\t\t\t\".sxm\": \"application/vnd.sun.xml.math\",\n\t\t\t\".sxw\": \"application/vnd.sun.xml.writer\",\n\t\t\t\".t\": \"text/troff\",\n\t\t\t\".tao\": \"application/vnd.tao.intent-module-archive\",\n\t\t\t\".tar\": \"application/x-tar\",\n\t\t\t\".tcap\": \"application/vnd.3gpp2.tcap\",\n\t\t\t\".tcl\": \"application/x-tcl\",\n\t\t\t\".teacher\": \"application/vnd.smart.teacher\",\n\t\t\t\".tex\": \"application/x-tex\",\n\t\t\t\".texi\": \"application/x-texinfo\",\n\t\t\t\".texinfo\": \"application/x-texinfo\",\n\t\t\t\".text\": \"text/plain\",\n\t\t\t\".tfm\": \"application/x-tex-tfm\",\n\t\t\t\".tgz\": \"application/x-gzip\",\n\t\t\t\".tif\": \"image/tiff\",\n\t\t\t\".tiff\": \"image/tiff\",\n\t\t\t\".tmo\": \"application/vnd.tmobile-livetv\",\n\t\t\t\".torrent\": \"application/x-bittorrent\",\n\t\t\t\".tpl\": \"application/vnd.groove-tool-template\",\n\t\t\t\".tpt\": \"application/vnd.trid.tpt\",\n\t\t\t\".tr\": \"text/troff\",\n\t\t\t\".tra\": \"application/vnd.trueapp\",\n\t\t\t\".trm\": \"application/x-msterminal\",\n\t\t\t\".tsv\": \"text/tab-separated-values\",\n\t\t\t\".ttc\": \"application/x-font-ttf\",\n\t\t\t\".ttf\": \"application/x-font-ttf\",\n\t\t\t\".twd\": \"application/vnd.simtech-mindmapper\",\n\t\t\t\".twds\": \"application/vnd.simtech-mindmapper\",\n\t\t\t\".txd\": \"application/vnd.genomatix.tuxedo\",\n\t\t\t\".txf\": \"application/vnd.mobius.txf\",\n\t\t\t\".txt\": \"text/plain\",\n\t\t\t\".u32\": \"application/x-authorware-bin\",\n\t\t\t\".udeb\": \"application/x-debian-package\",\n\t\t\t\".ufd\": \"application/vnd.ufdl\",\n\t\t\t\".ufdl\": \"application/vnd.ufdl\",\n\t\t\t\".umj\": \"application/vnd.umajin\",\n\t\t\t\".unityweb\": \"application/vnd.unity\",\n\t\t\t\".uoml\": \"application/vnd.uoml+xml\",\n\t\t\t\".uri\": \"text/uri-list\",\n\t\t\t\".uris\": \"text/uri-list\",\n\t\t\t\".urls\": \"text/uri-list\",\n\t\t\t\".ustar\": \"application/x-ustar\",\n\t\t\t\".utz\": \"application/vnd.uiq.theme\",\n\t\t\t\".uu\": \"text/x-uuencode\",\n\t\t\t\".vcd\": \"application/x-cdlink\",\n\t\t\t\".vcf\": \"text/x-vcard\",\n\t\t\t\".vcg\": \"application/vnd.groove-vcard\",\n\t\t\t\".vcs\": \"text/x-vcalendar\",\n\t\t\t\".vcx\": \"application/vnd.vcx\",\n\t\t\t\".vis\": \"application/vnd.visionary\",\n\t\t\t\".viv\": \"video/vnd.vivo\",\n\t\t\t\".vor\": \"application/vnd.stardivision.writer\",\n\t\t\t\".vox\": \"application/x-authorware-bin\",\n\t\t\t\".vrml\": \"model/vrml\",\n\t\t\t\".vsd\": \"application/vnd.visio\",\n\t\t\t\".vsf\": \"application/vnd.vsf\",\n\t\t\t\".vss\": \"application/vnd.visio\",\n\t\t\t\".vst\": \"application/vnd.visio\",\n\t\t\t\".vsw\": \"application/vnd.visio\",\n\t\t\t\".vtu\": \"model/vnd.vtu\",\n\t\t\t\".vxml\": \"application/voicexml+xml\",\n\t\t\t\".w3d\": \"application/x-director\",\n\t\t\t\".wad\": \"application/x-doom\",\n\t\t\t\".wav\": \"audio/x-wav\",\n\t\t\t\".wax\": \"audio/x-ms-wax\",\n\t\t\t\".wbmp\": \"image/vnd.wap.wbmp\",\n\t\t\t\".wbs\": \"application/vnd.criticaltools.wbs+xml\",\n\t\t\t\".wbxml\": \"application/vnd.wap.wbxml\",\n\t\t\t\".wcm\": \"application/vnd.ms-works\",\n\t\t\t\".wdb\": \"application/vnd.ms-works\",\n\t\t\t\".wiz\": \"application/msword\",\n\t\t\t\".wks\": \"application/vnd.ms-works\",\n\t\t\t\".wm\": \"video/x-ms-wm\",\n\t\t\t\".wma\": \"audio/x-ms-wma\",\n\t\t\t\".wmd\": \"application/x-ms-wmd\",\n\t\t\t\".wmf\": \"application/x-msmetafile\",\n\t\t\t\".wml\": \"text/vnd.wap.wml\",\n\t\t\t\".wmlc\": \"application/vnd.wap.wmlc\",\n\t\t\t\".wmls\": \"text/vnd.wap.wmlscript\",\n\t\t\t\".wmlsc\": \"application/vnd.wap.wmlscriptc\",\n\t\t\t\".wmv\": \"video/x-ms-wmv\",\n\t\t\t\".wmx\": \"video/x-ms-wmx\",\n\t\t\t\".wmz\": \"application/x-ms-wmz\",\n\t\t\t\".wpd\": \"application/vnd.wordperfect\",\n\t\t\t\".wpl\": \"application/vnd.ms-wpl\",\n\t\t\t\".wps\": \"application/vnd.ms-works\",\n\t\t\t\".wqd\": \"application/vnd.wqd\",\n\t\t\t\".wri\": \"application/x-mswrite\",\n\t\t\t\".wrl\": \"model/vrml\",\n\t\t\t\".wsdl\": \"application/wsdl+xml\",\n\t\t\t\".wspolicy\": \"application/wspolicy+xml\",\n\t\t\t\".wtb\": \"application/vnd.webturbo\",\n\t\t\t\".wvx\": \"video/x-ms-wvx\",\n\t\t\t\".x32\": \"application/x-authorware-bin\",\n\t\t\t\".x3d\": \"application/vnd.hzn-3d-crossword\",\n\t\t\t\".xap\": \"application/x-silverlight-app\",\n\t\t\t\".xar\": \"application/vnd.xara\",\n\t\t\t\".xbap\": \"application/x-ms-xbap\",\n\t\t\t\".xbd\": \"application/vnd.fujixerox.docuworks.binder\",\n\t\t\t\".xbm\": \"image/x-xbitmap\",\n\t\t\t\".xdm\": \"application/vnd.syncml.dm+xml\",\n\t\t\t\".xdp\": \"application/vnd.adobe.xdp+xml\",\n\t\t\t\".xdw\": \"application/vnd.fujixerox.docuworks\",\n\t\t\t\".xenc\": \"application/xenc+xml\",\n\t\t\t\".xer\": \"application/patch-ops-error+xml\",\n\t\t\t\".xfdf\": \"application/vnd.adobe.xfdf\",\n\t\t\t\".xfdl\": \"application/vnd.xfdl\",\n\t\t\t\".xht\": \"application/xhtml+xml\",\n\t\t\t\".xhtml\": \"application/xhtml+xml\",\n\t\t\t\".xhvml\": \"application/xv+xml\",\n\t\t\t\".xif\": \"image/vnd.xiff\",\n\t\t\t\".xla\": \"application/vnd.ms-excel\",\n\t\t\t\".xlam\": \"application/vnd.ms-excel.addin.macroenabled.12\",\n\t\t\t\".xlb\": \"application/vnd.ms-excel\",\n\t\t\t\".xlc\": \"application/vnd.ms-excel\",\n\t\t\t\".xlm\": \"application/vnd.ms-excel\",\n\t\t\t\".xls\": \"application/vnd.ms-excel\",\n\t\t\t\".xlsb\": \"application/vnd.ms-excel.sheet.binary.macroenabled.12\",\n\t\t\t\".xlsm\": \"application/vnd.ms-excel.sheet.macroenabled.12\",\n\t\t\t\".xlsx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n\t\t\t\".xlt\": \"application/vnd.ms-excel\",\n\t\t\t\".xltm\": \"application/vnd.ms-excel.template.macroenabled.12\",\n\t\t\t\".xltx\": \"application/vnd.openxmlformats-officedocument.spreadsheetml.template\",\n\t\t\t\".xlw\": \"application/vnd.ms-excel\",\n\t\t\t\".xml\": \"application/xml\",\n\t\t\t\".xo\": \"application/vnd.olpc-sugar\",\n\t\t\t\".xop\": \"application/xop+xml\",\n\t\t\t\".xpdl\": \"application/xml\",\n\t\t\t\".xpi\": \"application/x-xpinstall\",\n\t\t\t\".xpm\": \"image/x-xpixmap\",\n\t\t\t\".xpr\": \"application/vnd.is-xpr\",\n\t\t\t\".xps\": \"application/vnd.ms-xpsdocument\",\n\t\t\t\".xpw\": \"application/vnd.intercon.formnet\",\n\t\t\t\".xpx\": \"application/vnd.intercon.formnet\",\n\t\t\t\".xsl\": \"application/xml\",\n\t\t\t\".xslt\": \"application/xslt+xml\",\n\t\t\t\".xsm\": \"application/vnd.syncml+xml\",\n\t\t\t\".xspf\": \"application/xspf+xml\",\n\t\t\t\".xul\": \"application/vnd.mozilla.xul+xml\",\n\t\t\t\".xvm\": \"application/xv+xml\",\n\t\t\t\".xvml\": \"application/xv+xml\",\n\t\t\t\".xwd\": \"image/x-xwindowdump\",\n\t\t\t\".xyz\": \"chemical/x-xyz\",\n\t\t\t\".zaz\": \"application/vnd.zzazz.deck+xml\",\n\t\t\t\".zip\": \"application/zip\",\n\t\t\t\".zir\": \"application/vnd.zul\",\n\t\t\t\".zirz\": \"application/vnd.zul\",\n\t\t\t\".zmm\": \"application/vnd.handheld-entertainment+xml\",\n\n\t\t\t\".woff2\": \"font/woff2\",\n\t\t\t\".woff\": \"font/woff\",\n\t\t}\n\t}\n}.initThisClass());\n",
  "2Py7cic8zxCLxra20JTpbShPGaPq/szunA15ou/VbAw=": "\"use strict\";\n\n/*\n\n    BMFileResources\n\n\n    BMFileResources.shared().setupSubnodesIfNeeded();\n\n    const fileOrFolderResource = BMFileResources.shared().rootFolder().resourceAtPath(\"path/to/resource\");\n\n    const resources = MResourceFiles.shared().rootFolder().allResourceFiles().resourcesWithName(aName);\n\n    BMFileResources.shared().rootFolder().allResourceFiles().forEach(file => {\n        ...\n    });\n*/\n\n(class BMFileResources extends BMResourceGroup {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"rootPath\", \".\");\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"hasSetupSubnodes\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n    }\n\n    initPrototype () {\n        this.setTitle(\"FileResources\");\n        this.setNoteIsSubnodeCount(true);\n    }\n\n    init () {\n        super.init()\n        //this.registerForAppDidInit() // BMResourceGroup does this\n        //this.onFinishInit()\n        return this\n    }\n\n    /*\n    setup () {\n        // subclasses need to use this to set ResourceClasses\n        this.setResourceClasses([BMResourceFile]);\n        this.setSubnodeClasses([BMResourceFile]);\n    }\n    */\n\n    async appDidInit () {\n        await this.setupSubnodesIfNeeded();\n        //this.cacheJsonFiles(); // this won't work in appDidInit as it's async and other appDidInit notifications may be sent before it's done\n    }\n\n    showPaths () {\n        const paths = this.rootFolder().allResourceFiles().map(file => file.path());\n        console.log(\"paths = \", paths.join(\"\\n\"));\n    }\n\n    /*\n    prepareForFirstAccess () {\n        debugger;\n        this.setupSubnodesIfNeeded()\n        return this\n    }\n    */\n    \n    async setupSubnodesIfNeeded () {\n        if (!this.hasSetupSubnodes()) {\n            const rootFolder = BMResourceFolder.clone().setPath(this.rootPath())\n            this.addSubnode(rootFolder)\n\n            const entries = ResourceManager.shared().entries()\n            //const allPaths = ResourceManager.shared().resourceFilePaths()\n            entries.forEach(entry => {\n                const aPath = entry.path\n                const pathArray = aPath.split(\"/\")\n                while (pathArray.first() === \".\") {\n                    pathArray.shift()\n                }\n                const file = rootFolder.addRelativeResourcePathArray(pathArray)\n                file.setResourceHash(entry.hash)\n                file.setResourceSize(entry.size)\n                if (!file) {\n                    throw new Error(\"no file added\")\n                }\n            }) // will find path to last folder and insert resource\n            this.setHasSetupSubnodes(true)\n        }\n        return this;\n    }\n\n    rootFolder () {\n        this.setupSubnodesIfNeeded();\n        //debugger\n        return this.subnodes().first();\n    }\n\n    jsonFiles () {\n        const jsonFiles = this.rootFolder().allResourceFiles().select(file => file.pathExtension() === \"json\");\n        return jsonFiles;\n    }\n\n    async prechacheWhereAppropriate () {\n        this.setupSubnodesIfNeeded();\n        await this.rootFolder().allResourceFiles().promiseParallelMap(async (file) => file.prechacheWhereAppropriate());\n        //this.subnodes().promiseSerialForEach(async (node) => node.prechacheWhereAppropriate());\n    }\n\n}.initThisClass());\n",
  "v8kRRwWaOdeK8G5Vq7wJZKuJwybPfK+S8x5VmH4uNdM=": "\"use strict\";\n\n/*\n\n    BMResourceFolder\n\n    An abstraction for an individual file folder.\n\n    BMFileResources will setup all BMResourceFolders.\n\n*/\n\n(class BMResourceFolder extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"path\", null);\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    initPrototype () {\n        this.setTitle(\"BMFileSystemFolder\");\n        this.setNoteIsSubnodeCount(true);\n    }\n\n    init () {\n        super.init()\n        //this.registerForAppDidInit()\n        return this\n    }\n\n    name () {\n        return this.path().lastPathComponent()\n    }\n\n    title () {\n        return this.name()\n    }\n\n    setupSubnodes () {\n        return this\n    }\n\n    isParentOfPath (aPath) {\n        const checkPath = this.path() + \"/\"\n        return (checkPath.indexOf(aPath) === 0)\n    }\n\n    addRelativeResourcePath (aPath) {\n        return this.addRelativeResourcePathArray(aPath.split(\"/\"))\n    }\n\n    addRelativeResourcePathArray (pathArray) {\n        pathArray = pathArray.slice()\n\n        const fullPath = this.path() + \"/\" + pathArray.join(\"/\")\n        //console.log(\"'\" + this.path() + \"' addRelativeResourcePathArray(\", pathArray, \")\")\n\n        if (pathArray.length === 1) { // it's a file\n            const fileName = pathArray.first()\n            const oldFile = this.fileWithName(fileName)\n            if (oldFile) {\n                return oldFile\n            }\n\n            return this.addSubnodeForFileName(fileName) // we assume all paths are to files, not folders\n        } else {\n\n            // must be a folder\n            const subfolderName = pathArray.first()\n            const subfolder = this.addSubnodeForFolderNameCreateIfAbsent(subfolderName)\n            pathArray.shift()\n            const file = subfolder.addRelativeResourcePathArray(pathArray)\n            return file\n        }\n    }\n\n    // subfolders\n\n    hasSubfolderNamed (aName) {\n        const subfolder = this.subfolderWithName(subfolderName)\n        return subfolder !== null\n    }\n\n    addSubnodeForFolderNameCreateIfAbsent (subfolderName) {\n        const subfolder = this.subfolderWithName(subfolderName)\n        if (subfolder) {\n            return subfolder\n        }\n        return this.addSubnodeForFolderName(subfolderName)\n    }\n\n    addSubnodeForFolderName (aName) {\n        if (aName.length === 0) {\n            throw new Error(\"empty folder name\")\n        }\n        if (aName.indexOf(\"/\") !== -1) {\n            throw new Error(\"folder name contains /\")\n        }\n        //console.log(\"'\" + this.path() + \"' addSubnodeForFolderName '\" + aName + \"'\")\n        const fullPath = this.path() + \"/\" + aName\n        const subfolder = BMResourceFolder.clone().setPath(fullPath)\n        this.addSubnode(subfolder)\n        //this.show()\n        return subfolder\n    }\n\n    show () {\n        const subnodeNames = this.subnodes().map(sn => sn.name())\n        console.log(this.type() + \" '\" + this.path() + \"': \" +  JSON.stringify(subnodeNames))\n    }\n\n    folderClassName () {\n        return \"BMResourceFolder\"\n    }\n\n    subfolders () {\n        return this.subnodes().filter(node => node.type() === this.folderClassName())\n    }\n\n    folders () {\n        return this.subfolders()\n    }\n\n    subfolderWithName (aName) {\n        return this.subfolders().detect(subnode => subnode.name() === aName)\n    }\n\n    folderAt (aName) {\n        return this.subfolderWithName(aName)\n    }\n\n    // files\n\n    addSubnodeForFileName (fileName) {\n        const file = BMResourceFile.clone().setPath(this.path() + \"/\" + fileName)\n        this.addSubnode(file)\n        return file\n    }\n\n    fileClassName () {\n        return \"BMResourceFile\"\n    }\n\n    files () {\n        return this.subnodes().filter(sn => sn.thisClass().isKindOf(BMResourceFile));\n    }\n    \n    fileNames () {\n        return this.files().map(file => file.name());\n    }\n\n    fileWithName (aName) {\n        return this.subnodes().detect(sn => sn.name() === aName)\n    }\n\n    fileAt (aName) {\n        return this.subnodes().detect(sn => sn.name() === name)\n    }\n\n    allResourceFiles () {\n        return this.leafSubnodes().filter(node => node.thisClass().isKindOf(BMResourceFile));\n    }\n\n    resourceAtPath (aPath) {\n        const pathArray = aPath.split(\"/\");\n        // remove first component \n        const first = pathArray.shift();\n        const localResource = this.fileWithName(first);\n\n        if (pathArray.length === 0) {\n            return localResource;\n        }\n\n        return localResource.resourceAtPath(pathArray.join(\"/\"));\n        //return this.allResourceFiles().detect(file => file.path() === aPath);\n    }\n\n    resourcesWithName (aName) {\n        return this.allResourceFiles().filter(file => file.name() === aName);\n    }\n\n    resourceWithName (aName) {\n        const files = this.resourcesWithName(aName)\n        assert(files.length === 1, \"expected one file with name '\" + aName + \"', got: \" + files.length);\n        return files.first();\n    }\n\n    async prechacheWhereAppropriate() {\n        console.log(this.type() + \".prechacheWhereAppropriate() \" + this.path());\n        await this.subnodes().promiseParallelMap(async (node) => node.prechacheWhereAppropriate());\n    }\n\n}.initThisClass());\n",
  "ONYCCeMIMhLy0C29iwzAEiDRXoQ9frwMBincZI3rGPE=": "\"use strict\";\n\n/*\n\n    BMFileResources\n\n*/\n\n(class BMResourceFile extends BaseNode {\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"path\", \".\"); // path from _index.json entry\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"resourceHash\", null); // hash from _index.json entry\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"resourceSize\", null); // size from _index.json entry\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"data\", null);\n            slot.setSlotType(\"Object\");\n        }\n\n        {\n            const slot = this.newSlot(\"value\", null); // the value decoded from the data. e.g. value = JSON.parse(data)\n            slot.setSlotType(\"Object\");\n        }\n\n        //this.newSlot(\"encoding\", \"utf8\")\n        //this.newSlot(\"request\", null) // this set back to null after request is successfully completed\n\n        {\n            const slot = this.newSlot(\"error\", null);\n            slot.setSlotType(\"Error\");\n        }\n\n        {\n            const slot = this.newSlot(\"promiseForLoad\", null); \n            slot.setDescription(\"holds promise used for reading from URL request or indexedDB\");\n            slot.setSlotType(\"Promise\");\n        }\n\n        // notifications\n\n        {\n            const slot = this.newSlot(\"isLoading\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        {\n             const slot = this.newSlot(\"isLoaded\", false);\n             slot.setSlotType(\"Boolean\");\n        }\n        {\n            const slot = this.newSlot(\"loadState\", null);\n            slot.setSlotType(\"String\");\n        }\n        \n        //this.newSlot(\"loadNote\", null) \n        //this.newSlot(\"loadErrorNote\", null) \n        //this.newSlot(\"usesBlobCache\", false)\n    }\n\n    initPrototype () {\n        this.setTitle(\"File\");\n        this.setNoteIsSubnodeCount(true);\n        this.setIsDebugging(true);\n    }\n\n    init () {\n        super.init();\n        this.setPromiseForLoad(Promise.clone());\n        // notifications\n        //this.setLoadNote(this.newNoteNamed(\"fileResouceLoaded\"));\n        //this.setLoadErrorNote(this.newNoteNamed(\"resourceFileLoadError\"));\n        return this;\n    }\n\n    name () {\n        return this.path().lastPathComponent();\n    }\n\n    title () {\n        return this.name();\n    }\n\n    pathExtension () {\n        return this.path().pathExtension();\n    }\n\n    setupSubnodes () {\n        //this.resourcePaths().forEach(path => this.addFontWithPath(path));\n        return this;\n    }\n\n    // move this loading code to parent BMResource?\n\n    hasData () {\n        return this.data() !== null;\n    }\n\n    urlResource () {\n        //const path = ResourceManager.bootPath() + this.path();\n        return UrlResource.with(this.path());\n    }\n\n    async promiseLoad () {\n        const url = this.urlResource();\n        url.setResourceHash(this.resourceHash());\n        const r = await url.promiseLoad(); // will use cam cache if available\n        this._data = r.data();\n        this.promiseForLoad().callResolveFunc();\n        this.setValue(await this.asyncValueFromData());\n        return this;\n    }\n\n    async dataPromise () {\n        if (!this.hasData()) {\n            await this.promiseLoad();\n        }\n        return this.data();\n    }\n\n    precacheExtensions () {\n        //return [\"js\", \"css\", \"json\", \"txt\"];\n        //return [\"json\", \"txt\"]; // just cache the data files for now\n        return [\"json\", \"txt\", \"ttf\", \"woff\", \"woff2\"];\n    }\n\n    async prechacheWhereAppropriate () {\n        //console.log(this.type() + \".prechacheWhereAppropriate() \" + this.path());\n        if (this.precacheExtensions().includes(this.pathExtension())) {\n            //console.log(\"precaching \" + this.path())\n            await this.promiseLoad();\n            //console.log(\"precached \" + this.path())\n        }\n        return this;\n    }\n\n    /*\n    getValueResourceObject () {\n        const typeName = this.typeFromPathExtension();\n        const value = getGlobal()[typeName].clone().setData(this.data());\n        this.setValue(value);\n        return this.value();\n    }\n    */\n\n    async asyncValueFromData () {\n        if (this.path() === \"./app/info/AnthropicService.json\") {\n          //  debugger;\n        }\n\n        try {\n            const ext = this.pathExtension();\n            const data = this.data();\n            if (ext === \"json\") {\n                const jsonString = data.asString();\n                return JSON.parse(jsonString);\n            } else if ([\"js\", \"css\", \"txt\"].includes(ext)) {\n                const textString = data.asString();\n                return textString;\n            }\n            return this.data();\n        } catch (error) {\n            console.error(this.type() + \".asyncValueFromData() error loading value from data for \" + this.path() + \" : \" + error.message);\n            debugger;\n            throw error;\n        }\n    }\n\n}.initThisClass());\n\n\n\n\n    /*\n\n    old blob code\n\n    // --- load data from cached blob ---\n\n    hasCachedBlob () {\n        const h = this.resourceHash();\n        const b = h && BMBlobs.shared().hasBlobWithValueHash(h);\n        //console.log(\"has cache for \" + this.path() + \":\" + b)\n        return b;\n    }\n\n    async promiseLoadCachedBlob () {        \n        assert(this.hasCachedBlob())\n        const h = this.resourceHash()\n        const blob = BMBlobs.shared().blobWithValueHash(h)   \n        this.debugLog(() => \"reading from blob cache... \" + h + \" \" + this.path())\n        try {\n            await blob.promiseReadValue();\n            this.onReadCachedBlob(blob);\n        } catch (error) {\n            this.onErrorReadingCachedBlob(blob);\n            error.rethrow();\n        }\n    }\n\n    onReadCachedBlob (blob) {\n        this.debugLog(() => \"success reading blob \" + blob.name() + \" for \" + this.path())\n        //debugger;\n        if (Type.isUndefined(blob.value())) {\n            console.log(\"found undefined reading blob \" + blob.name() + \" for \" + this.path())\n            this.promiseLoadFromUrl()\n        } else {\n            this.setData(blob.value())\n            this.postLoad()\n        }\n    }\n\n    onErrorReadingCachedBlob (blob) {\n        console.log(\"error reading blob \" + blob.name() + \" for \" + this.path())\n    }\n\n    // --- load data from url ---\n\n    loadRequestType () {\n        return \"arraybuffer\"\n        //return 'application/json'; // need to change for binary files?\n    }\n\n    promiseLoadFromUrl () {\n        //console.log(\"loading via url fetch for path: \", this.path())\n        const promise = Promise.clone();\n\n        const path = this.path()\n        const rq = new XMLHttpRequest();\n        rq.open('GET', path, true);\n        if (this.loadRequestType()) {\n            rq.responseType = this.loadRequestType();\n        }\n\n        rq.onload = (event) => { \n            this.onUrlLoad(event); \n            promise.callResolveFunc();\n        }\n\n        rq.onerror = (event) => { \n            this.onRequestError(event); \n            promise.callRejectFunc();\n        }\n\n        //rq.onload      = (event) => { this.onRequestLoad(event) }\n        //rq.onabort     = (event) => { this.onRequestAbort(event) }\n        //rq.onloadend   = (event) => { this.onRequestLoadEnd(event) }\n        //rq.onloadstart = (event) => { this.onRequestLoadStart(event) }\n\n        rq.onprogress = (event) => { \n            this.onRequestProgress(event) \n        }\n\n        rq.ontimeout = (event) => { \n            this.onRequestTimeout(event);\n            promise.callRejectFunc();\n        }\n\n        this.setRequest(rq)\n        rq.send();\n\n        return promise;\n    }\n\n    onUrlLoad () {\n        //console.log(\"onUrlLoad \" + this.path())\n        const data = this.request().response\n        this.setData(data)\n        this.postLoad()\n        this.setIsLoading(false)\n        \n        const h = this.resourceHash()\n        if (h && this.usesBlobCache()) {\n            console.log(\"writing to blob cache... \" + h + \" \" + this.path())\n\n            if (false) {\n                const buffer = this.data()\n                const str = new TextDecoder().decode(buffer);\n                console.log(\"path: '\" + this.path() + \"'\")\n                console.log(\"size: '\" + buffer.byteLength + \"'\")\n                console.log(\"hash: '\" + h + \"'\")\n                console.log(\"type: '\" + typeof(buffer) + \"'\")\n                console.log(\"slice: '\" + str.slice(0, 6) + \"'\")\n                debugger;\n            }\n\n            const blob = BMBlobs.shared().createBlobWithNameAndValue(h, this.data())\n            blob.setName(this.path())\n            blob.setValueHash(this.resourceHash())\n            blob.setValueSize(this.resourceSize())\n        }\n        return this\n    }\n\n    onRequestError (event) {\n        console.log(\"onRequestError \" + this.path())\n        this.setError(event.error)\n        this.postLoadError()\n        this.setIsLoading(false)\n        return this\n    }\n\n    postLoad () {\n        this.loadNote().post()\n        return this\n    }\n\n    postLoadError () {\n        this.loadErrorNote().post()\n        return this\n    }\n\n    onRequestAbort (event) {\n        this.setLoadState(\"aborted\")\n    }\n\n    onRequestLoadEnd (event) {\n    }\n\n    onRequestLoadStart (event) {\n        this.setLoadState(\"started\")\n    }\n\n    onRequestProgress (event) {\n        if (event.lengthComputable) {\n            const p = Math.floor(100 * (event.loaded / event.total))/100\n            this.setLoadState(p + \"% of \" + event.total.byteSizeDescription())\n        } else {\n            this.setLoadState(\"loading (\" +  event.loaded.byteSizeDescription() + \" so far)\")\n        }\n    }\n\n    onRequestTimeout (event) {\n        this.setLoadState(\"timeout\")\n    }\n\n    onRequestLoad (event) {\n        const request = event.currentTarget;\n        const downloadedBuffer = request.response;  // may be array buffer, blob, or string, depending on request type\n        this.setData(downloadedBuffer)\n        //this.onDidLoad()\n    }\n\n    onDidLoad () {\n        this.setIsLoaded(true)\n        this.postNoteNamed(\"didLoad\")\n    }\n    */",
  "/6zu8SfVFmf+D1DX8wMsiOVJntiuebWBrWt/CuwKvCo=": "\"use strict\";\n\n/*\n\n    BMFontResources\n\n    BMResources.shared().fonts().newFontOptions()\n\n*/\n\n(class BMFontResources extends BMResourceGroup {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n    \n    initPrototypeSlots () {\n        //this.newSlot(\"extensions\", [\"ttf\", \"woff\", \"woff2\"]);\n    }\n\n    initPrototype () {\n        this.setTitle(\"Fonts\")\n    }\n\n    init () {\n        super.init()\n        //this.setExtensions([\"ttf\", \"woff\", \"woff2\"])\n        return this\n    }\n\n    setup () {\n        super.setup();\n        this.setResourceClasses([BMFont]);\n        this.setSubnodeClasses([BMFontFamily]);\n    }\n\n    addResource (aResource) {\n        //debugger\n        const aPath = aResource.path()\n        const components = aPath.split(\"/\")\n\n        const fontFileName = components.pop()\n        //const fontsFolderName = components.pop()\n        const familyName = components.pop()\n        //assert(fontsFolderName === \"fonts\")\n\n        /*\n        // verify path is in expected format \n        if (components.first() === \".\") {\n            components.removeFirst()\n        }\n\n        const resources = components.removeFirst()\n        assert(resources === \"resources\")\n\n        const fonts = components.removeFirst()\n        assert(fonts === \"fonts\")\n\n        const familyName = components.removeFirst()\n        */\n\n        const family = this.fontFamilyNamed(familyName) \n        family.addFont(aResource)\n\n        return this\n    }\n\n    // --- families ---\n\n    addFamily (aFontFamily) {\n        this.addSubnode(aFontFamily)\n        return this\n    }\n\n    families () {\n        return this.subnodes()\n    }\n\n    fontFamilyNamed (aName) {\n        const family = this.families().detect(family => family.name() === aName);\n        if (family) {\n            return family;\n        }\n\n        const newFamily = BMFontFamily.clone().setName(aName)\n        this.addFamily(newFamily)\n        return newFamily\n    }\n\n    allFonts () {\n        const fonts = []\n        this.subnodes().forEach(fontFamily => {\n            fontFamily.subnodes().forEach(font => fonts.push(font))\n        })\n        return fonts\n    }\n\n    allFontNames () {\n        return this.allFonts().map(font => font.title())\n    }\n\n    newFontOptions () {\n        const options = BMOptionsNode.clone()\n        this.allFonts().forEach(font => {\n            const name = font.title()\n            const option = BMOptionNode.clone().setLabel(name).setValue(name)\n            options.addSubnode(option)\n        })\n        return options\n    }\n\n    // --- font loading status ---\n\n    hasLoadedAllFonts () {\n        return this.unloadedFonts().length === 0;\n    }\n\n    loadedFonts () {\n        return this.allFonts().select(font => font.fontFaceIsLoaded());\n    }\n\n    unloadedFonts () {\n        return this.allFonts().select(font => !font.fontFaceIsLoaded());\n    }\n\n    hasLoadedFontWithName (name) {\n        return this.loadedFonts().canDetect(font => font.name() === name);\n    }\n\n    hasLoadedAllFontsWithNames (names) {\n        // not efficient to call alot - cache in a set if that becomes a use case\n        return names.canDetect(name => !this.hasLoadedFontWithName(name)) === false; \n    }\n\n}.initThisClass());\n",
  "Hr8utp+iAPfzGMVzBf4R5OtkXDh9w/g8bv+39P8DfkE=": "\"use strict\";\n\n/*\n\n    BMFontFamily\n\n\n*/\n\n(class BMFontFamily extends BaseNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"name\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"fonts\", null);\n            slot.setSlotType(\"Array\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    title () {\n        return this.name()\n    }\n\n    /*\n    subtitle () {\n        return \"font family\"\n    }\n    */\n\n    addFont (aFont) {\n        //debugger\n        this.addSubnode(aFont)\n        return this\n    }\n\n    /*\n    addFontWithResource (aResource) {\n        const font = BMFont.clone().setResource(aResource)\n        font.load()\n        this.addSubnode(font)\n        return this\n    }\n    */\n\n}.initThisClass());\n",
  "O3rkrzmBifKyJpOsR/cAaQSDcQek2Czmm8oeg+QYXf8=": "\"use strict\";\n\n/*\n\n    BMFont\n\n    Managed by BMFontResources.\n\n*/\n\n(class BMFont extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"ttf\", \"woff\", \"woff2\"];\n    }\n\n    static fontWeightMap () {\n        const wm = new Map()\n        wm.set(\"Thin\", 100);\n        wm.set(\"Extra Light\", 200); wm.set(\"ExtraLight\", 200);\n        wm.set(\"Ultra Light\", 200); wm.set(\"UltraLight\", 200);\n        wm.set(\"Light\", 300);\n        wm.set(\"Normal\", 400);\n        wm.set(\"Medium\", 500);\n        wm.set(\"Semi Bold\", 600); wm.set(\"SemiBold\", 600);\n        wm.set(\"Demi Bold\", 600); wm.set(\"DemiBold\", 600);\n        wm.set(\"Bold\", 700);\n        wm.set(\"Extra Bold\", 800); wm.set(\"ExtraBold\", 800);\n        wm.set(\"Ultra Bold\", 800); wm.set(\"UltraBold\", 800);\n        wm.set(\"Black\", 900)\n        wm.set(\"Heavy\", 900);\n        return wm;\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"name\", null);\n            slot.setSlotType(\"String\");\n        }\n        {\n            const slot = this.newSlot(\"options\", null);\n            slot.setSlotType(\"Object\");\n        }\n        {\n            const slot = this.newSlot(\"fontFace\", null); // reference to browser FontFace object\n            slot.setSlotType(\"FontFace\");\n        }\n        {\n            const slot = this.newSlot(\"weightMap\", BMFont.fontWeightMap());\n            slot.setSlotType(\"Map\");\n        }\n    }\n\n    initPrototype () {\n        this.setIsDebugging(false)\n    }\n\n    init () {\n        super.init()\n        this.setOptions({})  // example options { style: 'normal', weight: 700 }  \n    }\n\n    title () {\n        return this.name()\n    }\n\n    name () {\n        if (this._name) {\n            return this._name\n        }\n\n        return this.path().fileName()\n    }\n\n    fontFaceIsLoaded () {\n        const face = this.fontFace();\n        return face && face.status === \"loaded\";\n    }\n\n    optionsFromName () {\n        const name = this.name();\n        const options = {};\n        this.weightMap().forEach((v, k) => {\n            if (name.indexOf(k) !== -1) {\n                options.weight = v;\n            }\n        });\n\n        if (name.indexOf(\"Italic\") !== -1) {\n            options.style = \"italic\";\n        }\n\n        return options;\n    }\n\n    // loading \n\n    async onDidLoad () { // called when resource data loaded\n        await super.onDidLoad();\n        await this.asyncLoadFontFromData();\n        //this.debugLog(\".didLoad('\" + this.name() + \"') '\" + this.path() + \"'\");\n    }\n\n    async asyncLoadFontFromData () {\n        if (this.fontFace()) {\n            return this;\n        }\n\n        //console.log(\"BMFont.asyncLoadFontFromData() \" + this.name())\n        let name = this.name();\n\n        if (Object.keys(this.options()).length === 0) {\n            this.setOptions(this.optionsFromName());\n            name = name.split(\" \").shift();\n        }\n\n        //console.log(\"BMFont load \" + this.name() + \" -> '\" + name + \"' options: \", this.options());\n\n        const face = new FontFace(name, this.data(), this.options()); \n        this.setFontFace(face);\n\n        try {\n            const loadedFace = await face.load();\n            assert(loadedFace === face);\n            document.fonts.add(loadedFace);\n            // it's safe to remove the data now\n            this.setData(null);\n            //console.log(\"added font to document: \", this.name());\n        } catch (error) {\n            this.onLoadError(error);\n            error.rethrow();\n        }\n        return this;\n    }\n\n    onLoadError (error) {\n        if (this.isDebugging()) {\n            this.debugLog(\".onLoadError() \", error)\n        }\n        return this\n    }\n\n    /*\n    cssVariableDict () {\n        const face = this.fontFace();\n        return {\n            \"font-family\": face.family,\n            \"font-style\": face.style, \n            \"font-weight\": face.weight, \n            \"font-stretch\": face.stretch, \n        }\n    }\n    */\n\n    // fontFace attributes accessors\n\n    fontFaceAttribute (name) {\n        const face = this.fontFace();\n        if (face) {\n            return face[name];\n        }\n        return null;\n    }\n\n    fontFamilyName () {\n        return this.fontFaceAttribute(\"family\");\n    }\n\n    fontStyle () {\n        return this.fontFaceAttribute(\"style\");\n    }\n\n    fontWeight () {\n        return this.fontFaceAttribute(\"weight\");\n    }\n\n    fontStretch () {\n        return this.fontFaceAttribute(\"stretch\");\n    }\n\n}.initThisClass());\n",
  "3hklSG1JC0Es8mo7SygKQA7vcDkTeixTpapn/Eq1MRM=": "\"use strict\";\n\n/*\n    \n    BMFontTile\n    \n*/\n\n(class BMFontTile extends TitledTile {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n    \n    updateSubviews () {\n        super.updateSubviews();\n\t\n        const node = this.node();\n\n        if (node) {\n            this.titleView().setFontFamily(node.fontFamilyName());\n            this.titleView().setFontStyle(node.fontStyle());\n            this.titleView().setFontWeight(node.fontWeight());\n            this.titleView().setFontStretch(node.fontStretch());\n        }\n\n        return this;\n    }\n    \n}.initThisClass());\n",
  "STFNv+a6LNmfIXU+OxaPIr7pvke1ulQGUMHZ3K+fhRQ=": "\"use strict\";\n\n/*\n\n    BMSoundResources\n\n*/\n\n(class BMSoundResources extends BMResourceGroup {\n\n    init () {\n        super.init()\n        this.setTitle(\"Sounds\")\n    }\n\n    setup () {\n        super.setup();\n        this.setResourceClasses([WASound]);\n        this.setSubnodeClasses([WASound]);\n        return this;\n    }\n\n    addSound (aSound) {\n        this.addResource(aSound)\n        return this\n    }\n\n    sounds () {\n        return this.resources()\n    }\n\n}.initThisClass());\n",
  "d0w33P1out8Xc7gEmcKP8PRgBSjdRphhve28+AwV4Vw=": "\"use strict\";\n\n/*\n\n    WASound\n\n    Note: \n    \n    AudioBufferSourceNode can't be paused and later resumed. Use AudioWorklet instead.\n\n    Usage:\n\n        const sound = WASound.clone();\n        sound.shouldPlayOnLoad(true);\n        sound.setData(data);\n        sound.play(); // returns a promise\n\n*/\n\n(class WASound extends BMResource {\n\n    static supportedExtensions () {\n        return [\"aac\", \"alac\", \"amr\", \"flac\", \"mp3\", \"mp4\", \"3gp\",  \"opus\", \"oga\", \"ogg\", \"ogv\", \"wav\"];\n    }\n\n    // ---\n\n    initPrototypeSlots () {\n\n        // converting blob to ArrayBuffer, arrayBuffer is stored in data slot\n\n        {\n            const slot = this.newSlot(\"arrayBufferPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n\n        // fetching\n\n        {\n            const slot = this.newSlot(\"fetchPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n\n        // decoding \n\n        {\n            const slot = this.newSlot(\"decodePromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n\n        {\n            const slot = this.newSlot(\"decodedBuffer\", null);\n            slot.setSlotType(\"AudioBuffer\");\n        }\n\n        // playing\n\n        {\n            const slot = this.newSlot(\"shouldPlayOnLoad\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n        \n        {\n            const slot = this.newSlot(\"shouldPlayOnAccess\", true);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"playPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n\n        {\n            const slot = this.newSlot(\"source\", null); // AudioBufferSourceNode \n            slot.setSlotType(\"AudioBufferSourceNode\");\n        }\n\n        // source attributes\n\n        {\n            const slot = this.newSlot(\"loop\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"playbackRate\", 1);\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"whenToPlay\", 0);\n            slot.setSlotType(\"Number\");\n        }\n\n        {\n            const slot = this.newSlot(\"offsetInSeconds\", 0);\n            slot.setSlotType(\"Number\");\n        }\n\n        /*\n        {\n            const slot = this.newSlot(\"durationInSeconds\", undefined);\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"isPlaying\", false);\n            slot.setSlotType(\"Boolean\");\n        }\n\n        {\n            const slot = this.newSlot(\"delegateSet\", null);\n            slot.setSlotType(\"Set\");\n        }\n\n        // optional info\n        {\n            const slot = this.newSlot(\"label\", null);\n            slot.setShouldJsonArchive(true);\n            slot.setSlotType(\"String\");\n        }\n\n        {\n            const slot = this.newSlot(\"transcript\", null);\n            slot.setShouldJsonArchive(true);\n            slot.setSlotType(\"String\");\n        }\n\n        /*\n        {\n            const slot = this.newSlot(\"loopStart\", null);\n            slot.setSlotType(\"Number\");\n        }\n        {\n            const slot = this.newSlot(\"loopEnd\", null);\n            slot.setSlotType(\"Number\");\n        }\n        */\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init();\n        //this.setFetchPromise(Promise.clone());\n        this.setDecodePromise(Promise.clone());\n        this.setArrayBufferPromise(Promise.resolve());\n        this.setDelegateSet(new Set());\n    }\n\n    /*\n    setData (data) {\n        console.log(this.typeId() + \".setData(\", data, \")\");\n        this._data = data;\n        return this;\n    }\n    */\n\n    setArrayBuffer (arrayBuffer) {\n        this.setData(arrayBuffer);\n        return this;\n    }\n\n    title () {\n        return this.name();\n    }\n\n    name () {\n        return this.path().lastPathComponent().sansExtension();\n    }\n\n    // --- blob ---\n\n    static fromBlob (audioBlob) {\n        const sound = this.clone();\n        sound.asyncLoadFromDataBlob(audioBlob); // don't await as we want to return the sound instance immediately\n        return sound;\n    }\n\n    async asyncLoadFromDataBlob (audioBlob) {\n        // start the FileReader conversion to an array buffer\n        const promise = audioBlob.asyncToArrayBuffer();\n        this.setArrayBufferPromise(promise);\n        const arrayBuffer = await promise;\n        // set the result \n        this.setData(arrayBuffer);\n        //console.log(this.typeId() + \" setData \" + arrayBuffer.byteLength);\n    }\n\n    // --- attributes ---\n\n    duration () {\n        if (this.decodedBuffer()) {\n            return this.decodedBuffer().duration; // in seconds\n        }\n        return 0;\n    }\n\n    sampleCount () { \n        if (this.decodedBuffer()) {\n            return this.decodedBuffer().length;\n        }\n        return 0;\n    }\n\n    length () { \n        throw new Error(\"use sampleCount method instead\");\n        return this.sampleCount();\n    }\n\n    numberOfChannels () { // sample count\n        if (this.decodedBuffer()) {\n            return this.decodedBuffer().numberOfChannels;\n        }\n        return 0;\n    }\n\n    // ---\n\n    audioCtx () {\n        return WAContext.shared().setupIfNeeded().audioContext();\n    }\n\n    onDidLoad () {\n        this.promiseToDecode();\n        return this;\n    }\n\n    hasDecoded () {\n        return this.decodedBuffer() !== null;\n    }\n\n    hasData () {\n        return this.data() !== null;\n    }\n\n    async promiseToDecode () {\n        if (this.hasDecoded()) {\n            return Promise.resolve();\n        }\n\n        try {\n            if (this.path()) {\n                //debugger;\n                //console.log(this.typeId() + \" path: \", this.path());\n            } else {\n                if (!this.fetchPromise()) {\n                    this.setFetchPromise(Promise.resolve());\n                }\n\n                await this.fetchPromise();\n                await this.arrayBufferPromise();\n            }\n\n            if (!this.hasData()) {\n                throw new Error(\"no data for sound\");\n            }\n\n            assert(this.data().byteLength);\n            const arrayBufferCopy = this.data().slice(0);\n            const decodedBuffer = await WAContext.shared().promiseDecodeArrayBuffer(arrayBufferCopy);\n            assert(this.data().byteLength);\n            this.onDecode(decodedBuffer);\n        } catch (error) {\n            this.onError(error);\n            error.rethrow();\n        }\n    }\n\n    onError (e) {\n        console.warn(this.type() + \" onDecodeError \", e.error, \" \" + this.path());\n        this.setError(e.error);\n    }\n\n    // --- decode ---\n\n    onDecode (decodedBuffer) {\n        assert(!Type.isNullOrUndefined(decodedBuffer));\n        this.setDecodedBuffer(decodedBuffer);\n        this.setLoadState(\"loaded\");\n        //console.log(this.type() + \" didDecode \" + this.path())\n        if (this.shouldPlayOnLoad()) {\n            this.play();\n        }\n    }\n\n    onDecodeError (e) {\n        console.warn(this.type() + \" onDecodeError \", e.error, \" \" + this.path());\n        this.setError(e.error);\n    }\n\n    // --- audio source ---\n\n    newAudioSource () { \n        // a AudioBufferSourceNode can only be used once\n        const ctx = this.audioCtx();\n        const source = ctx.createBufferSource();\n        source.buffer = this.decodedBuffer();\n        source.connect(ctx.destination);\n        this.syncToSource(source);\n        source.addEventListener(\"ended\", (event) => { \n            this.onEnded(event);\n        })\n        return source\n    }\n\n    syncToSource (source) {\n        // TODO: do this work if it's already playing?\n        source.playbackRate.value = this.playbackRate();\n        source.loop = this.loop();\n        return this;\n    }\n\n    // --- play ---\n\n    async play () {\n        await this.promiseToDecode();\n        this.setPlayPromise(Promise.clone());\n        this.setSource(this.newAudioSource()); // setups source with decoded buffer\n        this.syncToSource(this.source());\n        this.source().start(this.whenToPlay(), this.offsetInSeconds(), this.duration());\n        this.setIsPlaying(true);\n        this.onStarted();\n        return this.playPromise();\n    }\n\n    description () {\n        const parts = [this.type()];\n        if (this.label()) {\n            parts.push(this.label());\n        }\n\n        if (this.transcript()) {\n            parts.push(this.transcript().clipWithEllipsis(15));\n        }\n\n        return parts.join(\" \");\n    }\n\n    onStarted () {\n        //console.log(\"Sound.onStarted() \" + this.description());\n        this.post(\"onSoundStarted\");\n    }\n\n    onEnded () {\n        //console.log(\"Sound.onEnded() \" + this.description());\n        this.setIsPlaying(false);\n        this.setSource(null);\n        this.playPromise().callResolveFunc();\n        this.post(\"onSoundEnded\");\n    }\n\n    stop () {\n        if (this.isPlaying()) {\n            this.source().stop();\n            this.onEnded(); // needed?\n            //this.setSource(null);\n            //this.setPlayPromise(null);\n        }\n        return this;\n    }\n\n    /*\n    NOTE: AudioBufferSourceNode can't be paused and later resumed. Use AudioWorklet instead.\n    pause () \n    resume ()\n    */\n\n    prepareToAccess () {\n        super.prepareToAccess();\n        if (this.shouldPlayOnAccess()) {\n            this.play();\n        }\n    }\n\n    sourceState () {\n        // valid states: [\"suspended\", \"running\", \"closed\"]\n        return this.source() ? this.source().state : \"no source\";\n    }\n\n    post (methodName) {\n        this.postNoteNamed(methodName);\n        this.sendDelegate(methodName);\n        return this;\n    }\n\n    addDelegate (d) {\n        this.delegateSet().add(d);\n        return this;\n    }\n\n    removeDelegate (d) {\n        this.delegateSet().delete(d);\n        return this;\n    }\n\n    sendDelegate (methodName, args = [this]) {\n        const sendDelegate = (d, methodName, args) => {\n            const f = d[methodName]\n            if (f) {\n              f.apply(d, args)\n            }\n        };\n\n        /*\n        const d = this.delegate();\n        if (d) {\n          sendDelegate(d, methodName, args);\n        } else {\n          const error = this.type() + \" delegate missing method '\" + methodName + \"'\";\n          console.log(error);\n          debugger;\n          throw new Error(error);\n        }\n        */\n\n        this.delegateSet().forEach(d => { \n            sendDelegate(d, methodName, args); \n        });\n    }\n\n    // ----\n\n    async promiseDataUrl () {\n        // Step 1: Convert ArrayBuffer to Blob\n        const arrayBuffer = this.data();\n        assert(arrayBuffer);\n        //console.log(this.typeId() + \" promiseDataUrl byte count \" + arrayBuffer.byteLength);\n        assert(arrayBuffer.byteLength > 0);\n        const mimeType = 'audio/*';\n        const dataUrl = await arrayBuffer.promiseAsDataUrlWithMimeType(mimeType);\n        console.log(\"dataUrl: \", dataUrl.clipWithEllipsis(20));\n        return dataUrl;\n    }\n\n\n}.initThisClass());\n",
  "FiuKpZhiWDLZqaGswVSyxdZxH+j3/ncmvhM8FObTAsM=": "\"use strict\";\n\n/*\n\n    WAContext\n\n    A WebAudioContext wrapper. \n    This is used with WASound for decoding and playing sounds.\n\n    Notes:\n\n    Browsers don't allow sounds to be played until a user interacts (using certain events) with the page,\n    so this class registers to listen for \"onFirstUserEvent\" notification, and sets up the WebAudioContext after when it's received.\n\n*/\n\n(class WAContext extends BaseNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n        Broadcaster.shared().addListenerForName(this, \"firstUserEvent\")\n        //this.watchOnceForNote(\"onFirstUserEvent\")\n    }\n\n    static firstUserEvent (anEventListener) {\n        Broadcaster.shared().removeListenerForName(this, \"firstUserEvent\")\n        WAContext.shared().setupIfNeeded() // need user input to do this\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"audioContext\", null);\n            slot.setSlotType(\"AudioContext\");\n        }\n        {\n            const slot = this.newSlot(\"setupPromise\", null);\n            slot.setSlotType(\"Promise\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    init () {\n        super.init();\n        this.setSetupPromise(Promise.clone());\n    }\n\n    title () {\n        return \"WebAudio Context\"\n    }\n\n    subtitle () {\n        return null\n    }\n\n    isSetup () {\n        return !Type.isNull(this.audioContext())\n    }\n\n    setupIfNeeded () {\n        if (!this.isSetup()) {\n            this.setAudioContext(new window.AudioContext());\n            this.setupPromise().callResolveFunc();\n            Broadcaster.shared().broadcastNameAndArgument(\"didSetupWAContext\", this);\n            //console.warn(\"can't get audio context until user gesture e.g. tap\");\n        }\n        return this\n    }\n    \n    async promiseDecodeArrayBuffer (audioArrayBuffer) {\n        // NOTE: may mutate audioArrayBuffer!!!!!!!!!!\n        await this.setupPromise(); // should we throw an error instead? \n\n        const promise = Promise.clone();\n        //assert(audioArrayBuffer.byteLength);\n        this.audioContext().decodeAudioData(audioArrayBuffer,\n            decodedBuffer => { \n                //assert(audioArrayBuffer.byteLength);\n                promise.callResolveFunc(decodedBuffer);\n            },\n            error => { \n                promise.callRejectFunc(error);\n            }\n        );\n        return promise;\n    }\n\n    /*\n    connectSource (webAudioSource) {\n        this.setupIfNeeded();\n        webAudioSource.connect(this.audioContext().destination);\n    }\n\n    disconnectSource (webAudioSource) {\n        \n    }\n    */\n\n}.initThisClass());\n\n",
  "0LD1YPz76jHWcIJvZXvy59aLgkH7JNHY+SC/+5XDzK8=": "\"use strict\";\n\n/* \n    WAQueue \n\n    Use:\n\n    const waq = WAQueue.clone()\n    waq.pushSound(waSound1);\n    waq.pushSound(waSound2);\n\n    waSound just needs to respond to play() and post a onSoundEnded()\n\n\n*/\n\n(class WAQueue extends BMSummaryNode {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"isMuted\", false);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"currentSound\", null);\n      slot.setSlotType(\"Object\"); // TODO use protocol\n    }\n\n    {\n      const slot = this.newSlot(\"soundQueue\", null);\n      slot.setSlotType(\"Array\");\n    }\n\n    this.setNodeSubtitleIsChildrenSummary(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  initPrototype () {\n    this.setCanDelete(true);\n  }\n\n  init () {\n    super.init();\n    this.setTitle(\"Audio Queue\");\n    this.setAudioBlobQueue([]);\n\n  }\n\n  isPlaying () {\n    return this.currentSound() !== null;\n  }\n\n  subtitle () {\n    const lines = [];\n    const qSize = this.soundQueue().length;\n    \n    if (this.isPlaying()) {\n      lines.push(\"playing\");\n    }\n\n    if (qSize) {\n      lines.push(qSize + \" sounds queued\");\n    }\n\n    if (this.isMuted()) {\n      lines.push(\"muted\");\n    }\n\n    return lines.join(\"\\n\");\n  }\n\n  // ---\n\n  setIsMuted (aBool) {\n    this._isMuted = aBool;\n    if (aBool) {\n      this.pause();\n    } else {\n      this.resume();\n    }\n    return this;\n  }\n\n  // -----------------------------------\n\n  pushSound (waSound) {\n    this.soundQueue().push(waSound);\n    this.processQueue();\n    this.didUpdateNode();\n    return this;\n  }\n\n  processQueue () {\n    if (!this.currentSound()) {\n      const q = this.soundQueue();\n      if (q.length) {\n        const waSound = q.shift();\n        this.playSound(waSound);\n      }\n    }\n    return this;\n  }\n\n  playAudioBlob (waSound) {\n    this.pause();\n    if (!this.isMuted()) {\n      this.watchOnceForNoteFrom(waSound);\n      waSound.play()\n      this.setCurrentSound(waSound);\n    } else {\n      this.processQueue();\n    }\n    return this;\n  }\n\n  onSoundEnded (waSound) {\n    this.debugLog(\"finished playing\");\n    this.setCurrentSound(null);\n    this.processQueue();\n    this.didUpdateNode();\n  }\n  \n  stop () {\n    this.debugLog(\"pause()\");\n\n    const sound = this.currentSound();\n    if (sound) {\n      sound.stop();\n      this.debugLog(\"paused\");\n    }\n  }\n\n  resume () {\n    this.debugLog(\"resume()\");\n\n    const audio = this.currentSound();\n    if (audio) {\n      //if (audio.paused) {\n        audio.play();\n        this.debugLog(\"resumed\");\n      //}\n    }\n  }\n\n  stopAndClearQueue () {\n    this.soundQueue().clear();\n    this.stop();\n  }\n\n}.initThisClass());\n\n",
  "e8rnZgAi8vRMmd7kLjPNNnLxanAwRwM74JeVbM/x1lU=": "\"use strict\";\n\n/*\n\n    BMImage\n\n*/\n\n(class BMImage extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"apng\", \"avif\", \"gif\", \"jpg\", \"jpeg\", \"jfif\", \"pjpeg\", \"pjp\", \"png\", \"webp\", /* these aren't well supported -> */ \"tif\", \"tiff\", \"ico\", \"cur\", \"bmp\"]\n    }\n\n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"path\", \"\");\n            slot.setSlotType(\"String\");\n        }\n        */\n        {\n            const slot = this.newSlot(\"dataURL\", \"\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    initPrototype () {\n    }\n\n    title () {\n        return this.path().fileName()\n    }\n\n    subtitle () {\n        return this.path().pathExtension()\n    }\n\n    onDidLoad () {\n        super.onDidLoad()\n        debugger;\n        this.setDataUrl(this.data())\n        return this\n    }\n\n    /*\n    // this code should be on UI side\n\n    canvasForImage () {\n        // now just to show that passing to a canvas doesn't hold the same results\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = myImage.naturalWidth;\n        canvas.height = myImage.naturalHeight;\n        canvas.getContext(\"2d\").drawImage(myImage, 0, 0);\n    }\n    */\n\n}.initThisClass());\n\n",
  "dz4+K8raM1rwi66dzU+iT0hzjnhgMhw6TgEnAKGdEbU=": "\"use strict\";\n\n/*\n\n    BMURLImage\n\n*/\n\n(class BMURLImage extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"apng\", \"avif\", \"gif\", \"jpg\", \"jpeg\", \"jfif\", \"pjpeg\", \"pjp\", \"png\", \"webp\", /* these aren't well supported -> */ \"tif\", \"tiff\", \"ico\", \"cur\", \"bmp\"];\n    }\n\n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"dataURL\", \"\");\n            slot.setSlotType(\"String\");\n        }\n    }\n\n    initPrototype () {\n        this.setIsDebugging(false);\n    }\n\n    title () {\n        return this.path().fileName();\n    }\n\n    subtitle () {\n        return this.path().pathExtension();\n    }\n\n    load () {\n        this.loadDataURL();\n        return this;\n    }\n\n    async loadDataURL () {\n        if (this.isDebugging()) {\n            this.debugLog(\".loadDataURL() \" + this.path());\n        }\n\n        try {\n            const response = await fetch(this.path());\n            const blob = await response.blob();\n            const dataUrl = await blob.asyncToDataUrl();\n            this.setDataURL(dataUrl);\n        } catch (error) {\n            this.setError(error);\n            error.rethrow();\n        }\n\n        /*\n        const request = new XMLHttpRequest();\n        request.open(\"get\", this.path());\n        request.responseType = \"blob\";\n        request.onload = () => { this.loadedRequest(request) };\n        request.send();\n        */\n        return this;\n    }\n\n    didFetchDataUrl (dataURL) {\n        debugger;\n        this.setDataURL(dataURL);\n        return this\n    }\n\n}.initThisClass());\n\n//console.log(\"BMURLImage: \", BMURLImage)",
  "lh8Oz6HS/ehAvpV2vJ4r6p0LuQWt9PLsiEO+fccj7do=": "\"use strict\";\n\n/*\n\n    BMImageResources\n\n*/\n\n(class BMImageResources extends BMResourceGroup {\n    \n    init () {\n        super.init();\n        this.setTitle(\"Images\");\n        this.setSubnodeClasses([BMURLImage]);\n        return this\n    }\n\n    setup () {\n        super.setup();\n        this.setResourceClasses([BMURLImage]);\n        this.setSubnodeClasses([BMURLImage]);\n        return this;\n    }\n\n}.initThisClass());\n",
  "zU5CTrGdIObU56+kUOxPntX0LoiMrWYngB7QluhrIHw=": "\"use strict\";\n\n/*\n    \n    BMImageTile\n    \n*/\n\n(class BMImageTile extends TitledTile {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n    \n    updateSubviews () {\n        super.updateSubviews()\n\t\n        const node = this.node()\n\n        if (node) {\n            const name = node.title()\n            this.titleView() //.setFontFamily(name)\n        }\n\n        return this\n    }\n\n    \n}.initThisClass());\n",
  "cxuABDCXU16Nk8eUqxRRHS0R3MQptbGuN+m6Ke4kL+Y=": "\"use strict\";\n\n/*\n\n    BMThemeFolder\n\n*/\n\n(class BMThemeFolder extends BMStorableNode {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(true);\n        \n        this.setNodeCanEditTitle(true);\n        this.setTitle(\"Untitled \" + this.thisClass().visibleClassName());\n        this.setCanDelete(true);\n        this.setNodeCanAddSubnode(true);\n        this.setNodeCanReorderSubnodes(true);\n    }\n\n    init () {\n        super.init();\n        this.setSubnodeClasses([this.thisClass(), BMThemeClass, BMStringField, BMNumberField]);\n        return this;\n    }\n\n    styleMap () {\n        // this should be the same implementation of styleMap() as BMThemeClass\n        const map = new Map()\n        const title = this.title()\n        this.subnodes().forEach(sn => { \n            sn.styleMap().forEachKV((k, v) => {\n              map.set(title + \".\" + k, v)\n            })\n        })\n        return map\n    }\n\n}.initThisClass());\n",
  "+uQrVo9TefapQiIpHkFvers9sBEm4MzThB0YrhoxHjg=": "\"use strict\";\n\n/*\n\n    BMThemeClass\n\n    Notes on attribute lookup:\n\n    If we have the following path of theme classes:\n\n      Default -(child)-> Tile -(child)-> TextTile\n\n    Example lookup path for a selected TextTile:\n\n      TextTile/selected   -> Tile/selected   -> Default->selected\n      TextTile/unselected -> Tile/unselected -> Default->unselected\n      TextTile/disabled   -> Tile/disabled   -> Default->disabled\n\n*/\n\n(class BMThemeClass extends BMThemeFolder {\n\n  init () {\n    super.init();\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n\n    this.setNodeCanEditTitle(true);\n    this.setTitle(\"Untitled \" + this.thisClass().visibleClassName());\n    this.setSubtitle(\"class\")\n    this.setCanDelete(true);\n    this.setSubnodeClasses([BMThemeState, BMThemeFolder]);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n  finalInit () {\n    super.finalInit();\n    if (!this.hasSubnodes()) {\n      this.subnodeWithTitleIfAbsentInsertProto(\"states\", BMThemeStates);\n      this.subnodeWithTitleIfAbsentInsertProto(\"children\", BMThemeClassChildren);\n    }\n  }\n\n  parentThemeClass () {\n    const parentChildrenNode = this.parentNode()\n    if (parentChildrenNode.title() !== \"children\") {\n      // it's a root themeClass under the Theme\n      return null\n    }\n    if (parentChildrenNode) {\n        const parentThemeClass = parentChildrenNode.parentNode()\n        return parentThemeClass\n    }\n    return null\n }\n\n  // --- default ---\n\n  setupAsDefault() {\n    this.setTitle(\"Tile\");\n    //this.setupSubnodes();\n    this.states().setupAsDefault()\n    this.children().addSubnode(BMThemeClass.clone().setTitle(\"HeaderTile\"));\n    this.children().addSubnode(BMThemeClass.clone().setTitle(\"BreadCrumbsTile\"));\n    return this;\n  }\n\n  stateWithName (name) {\n    return this.states().stateWithName(name);\n  }\n\n  states () {\n    return this.firstSubnodeWithTitle(\"states\");\n  }\n\n  children () {\n    return this.firstSubnodeWithTitle(\"children\");\n  }\n\n  selfAndAllThemeChildren () {\n    const children = this.children().subnodes().map(themeClass => themeClass.selfAndAllThemeChildren())\n    return [this].concat(children.flat())\n  }\n\n}.initThisClass());\n",
  "5tYdIGtKBWLZLznebF8x39UekaoFFC7Bx53mXo/xEAE=": "\"use strict\";\n\n/*\n\n    BMTheme\n\n\n    BMThemeResources.shared().activeTheme().newThemeClassOptions()\n*/\n\n(class BMTheme extends BMThemeFolder {\n  \n  initPrototypeSlots () {\n  }\n\n  initPrototype () {\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanEditTitle(true);\n    this.setTitle(\"Untitled \" + this.thisClass().visibleClassName());\n    this.setSubtitle(\"theme\")\n    //this.setSubtitle(\"Theme\")\n    this.setCanDelete(true);\n    this.setNodeCanAddSubnode(true);\n    //this.setSubnodeClasses([BMThemeLevel]);\n    this.setSubnodeClasses([BMThemeClass]);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n  init () {\n    super.init();\n    //this.setupSubnodes()\n  }\n\n  setupAsDefault () {\n    debugger\n    this.setTitle(\"DefaultTheme\");\n    const defaultThemeClass = BMThemeClass.clone().setupAsDefault();\n    this.addSubnode(defaultThemeClass);\n    return this;\n  }\n\n  // --- \n\n  themeClassNamed (name) {\n    return this.firstSubnodeWithTitle(name)\n  }\n\n  themeClassNames () {\n    return this.subnodes().map(themeClass => themeClass.title())\n  }\n\n  newThemeClassOptions () {\n    const options = BMOptionsNode.clone()\n    this.subnodes().forEach(themeClass => {\n        const name = themeClass.title()\n        const option = BMOptionNode.clone().setLabel(name).setValue(name)\n        options.addSubnode(option)\n    })\n    return options\n  }\n\n  themeClassNamed (name) {\n    return this.allThemeClasses().detect(themeClass => themeClass.title() === name)\n/*\n    const themeClass = this.firstSubnodeWithTitle(className)\n    if (themeClass) {\n      return themeClass.themeClassNamed(name)\n    }\n    return null\n    */\n  }\n\n  allThemeClasses () {\n    return this.subnodes().map(themeClass => themeClass.selfAndAllThemeChildren()).flat()\n  }\n\n  allThemeClassesMap () {\n    const map = new Map()\n    this.allThemeClasses().forEach(themeClass => map.set(themeClass.title(), themeClass))\n    return map\n  }\n\n  stateWithName (name) {\n    return this.states().stateWithName(name)\n  }\n\n}.initThisClass());\n",
  "o5xdQPtb0o8rQmOfqFvRV85Ew22nL2VnrhhWz51C9Ss=": "\"use strict\";\n\n/*\n\n    BMDefaultTheme\n\n*/\n\n(class BMDefaultTheme extends BMTheme {\n\n    init () {\n        super.init()\n        return this\n    }\n\n    finalInit () {\n        super.finalInit();\n        this.setupAsDefault() \n    }\n\n    setupAsDefault () {\n        if (!this.hasSubnodes()) {\n            //debugger\n            this.setTitle(\"DefaultTheme\")\n            const defaultThemeClass = BMThemeClass.clone().setupAsDefault()\n            this.addSubnode(defaultThemeClass)\n        }\n        return this\n   }\n\n}.initThisClass());\n",
  "pBS/QOqVga+Vw/P6c/KStuqdASS5T9CQQnUWGUW4GYA=": "\"use strict\";\n\n/*\n\n    BMThemeResources\n\n    hierarchy:\n\n        BMThemeResources -> Theme -> ThemeClass -> ThemeState -> ThemeAttribute\n\n    example:\n    \n        global           -> \"Dark\" -> \"Field\"   -> \"active\"   -> \"opacity\" : \"0.5\"\n\n    Example use by views:\n\n        BMThemeResources.shared().currentTheme().classNamed(\"x\").attributeNamed(\"y\").value()\n\n    We'd like to implement some form  of inheritance system.\n    Example:\n\n    The ThemeClass \"FieldValue\" has a \"unselected\" ThemeState, but no \"active\" ThemeState, \n    so we default to the \"unselected\" ThemeState.\n\n    Should ThemeClass implement a defaultSubnode() method for failed lookups?\n    Should it ask subnodes isDefault()? \n\n\n*/\n\n(class BMThemeResources extends BMStorableNode {\n    \n    static initClass () {\n        this.setIsSingleton(true)\n    }\n\n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setTitle(\"Themes\")\n\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true)\n\n        this.setNoteIsSubnodeCount(true)\n        this.setNodeCanAddSubnode(true)\n        this.setSubnodeClasses([BMTheme, BMDefaultTheme])\n        this.setNodeCanReorderSubnodes(true)\n\n        //this.setSubnodes([BMDefaultTheme.clone()]) // hack\n    }\n\n    finalInit () {\n        super.finalInit();\n        if (!this.hasSubnodes()) {\n            this.addSubnode(BMDefaultTheme.clone()) // hack\n        }\n    }\n\n    activeTheme () {\n        return this.subnodes().first()\n    }\n\n    defaultThemeClass () {\n        return this.activeTheme().subnodes().first()\n    }\n    \n}.initThisClass());\n",
  "xKLOqdMVZ69ABDIRLW5/szO4LXMnEfJ62qOyqL52gZ4=": "\"use strict\";\n\n/*\n\n    BMThemeState\n\n    Replaces BMStyle\n\n*/\n\n(class BMThemeState extends BMThemeFolder {\n    \n    static styleNames () {\n        return [\n            \"color\", // start with [\"#000\", \"#111\", \"#222\", \"#333\", \"#444\", .. to #fff by X\n            \"backgroundColor\", \n            \"opacity\", // 0 to 1 by 0.1\n\n            \"fontFamily\",\n            //\"font-variant\", // normal, small-caps\n            //\"fontStyle\", // normal, italic, oblique\n            \"fontWeight\", // normal, bold, lighter, bolder, 100-900 by 100\n            \"fontSize\", // 3px to 50px by 1px\n\n            \"lineHeight\", // 0.8em to 3em by 0.1em\n            \"letterSpacing\" // 0.1 em to 2em by 0.1em\n\n            /*\n            \"paddingLeft\", // 0px to 100px by 1px\n            \"paddingRight\", \n            \"paddingTop\", \n            \"paddingBottom\",\n\n            // for border we need to support \n            // left, right, top, bottom\n            // border-style\n            // border-width\n            // border-radius\n            \"borderLeft\", // 0px to 100px by 1px \n            \"borderRight\", \n            \"borderTop\", \n            \"borderBottom\",\n            \"borderRadius\"\n            */\n        ];\n    }\n\n    static validLetterSpacingValues () {\n        const values = [\"inherit\"]\n        for (let i = 0; i < 0.51; i += 0.01) {\n            const s = (i + \"\").slice(0, 4)\n            values.push(s + \"em\")\n        }\n        return values\n    }\n\n    static validLineHeightValues () {\n        const values = [\"inherit\"]\n        for (let i = 1; i < 3; i += 0.1) {\n            const s = (i + \"\").slice(0, 3)\n            values.push(s + \"em\")\n        }\n        return values\n    }\n\n    static validColors () {\n        return [\"inherit\", \"\", \"transparent\", \"white\", \"black\", \"#000\", \"#111\", \"rgb(25, 25, 25)\", \"#222\", \"#333\", \"#444\", \"#555\", \"#666\", \"#777\", \"#888\", \"#999\", \"#aaa\", \"#bbb\", \"#ccc\", \"#ddd\", \"#fff\"]\n    }\n\n    static validPaddingValues () {\n        const values = [\"inherit\"]\n        for (let i = 0; i < 41; i ++) {\n            values.push(i + \"px\")\n        }\n        return values\n    }\n\n    static validBorderWidthValues () {\n        const values = [\"inherit\"]\n        for (let i = 0; i < 10; i ++) {\n            values.push(i + \"px\")\n        }\n        return values\n    }\n\n    static validBorderStyleValues () {\n        return [\"inherit\", \"none\", \"dotted\", \"dashed\", \"solid\", /*\"groove\", \"inset\"*/]\n    }\n\n    static validFontSizes () {\n        const values = [\"inherit\"]\n        for (let i = 6; i < 80; i ++) {\n            values.push(i + \"px\")\n        }\n        return values\n    }\n\n    initPrototypeSlots () {\n        const styleSlots = [];\n\n        {\n            const slot = this.newSlot(\"styleSlots\", styleSlots);\n            slot.setSlotType(\"Array\");\n        }\n\n        // -----------------\n\n        const addSlot = (name, path, label, values) => {\n            const slot = this.newSlot(name, \"\")\n            slot.setInspectorPath(path)\n            slot.setLabel(label)\n            slot.setShouldStoreSlot(true)\n            slot.setDuplicateOp(\"duplicate\")\n            slot.setSlotType(\"String\")\n\n            //slot.setValidValues(values)\n            \n            if (values) {\n                const initValue = values.first();\n                //console.log(\"BMThemeState setting \" + JSON.stringify([name, path, label]) + \" to initValue '\" + initValue + \"'\");\n                slot.setInitValue(initValue) // first value is typically \"inherit\"\n                slot.setValidValues(values)\n            }\n            \n            styleSlots.push(slot)\n        }\n\n        // --- colors ---\n\n        addSlot(\"color\", \"colors\", \"color\", this.thisClass().validColors())\n        addSlot(\"backgroundColor\", \"colors\", \"background\", this.thisClass().validColors())\n        addSlot(\"opacity\", \"colors\", \"opacity\", [\"inherit\", \"0.0\", \"0.1\", \"0.2\", \"0.3\", \"0.4\", \"0.5\", \"0.6\", \"0.7\", \"0.8\", \"0.9\", \"1.0\", \"\"])\n\n        // --- font ---\n\n        addSlot(\"fontFamily\", \"font\", \"family\", null)\n        addSlot(\"fontSize\", \"font\", \"size\", this.thisClass().validFontSizes())\n\n        // weight and style don't work with some good fonts like\n        // helvetica as it uses a different font for each,\n        // so hold off on these until we have a UI to manage this stuff\n        //addSlot(\"fontWeight\", \"font\", \"weight\", [\"inherit\", \"normal\", \"bold\"])\n        //addSlot(\"fontStyle\", \"font\", \"style\", [\"inherit\", \"normal\", \"italic\", \"oblique\"])\n\n        addSlot(\"letterSpacing\", \"font\", \"letter spacing\", this.thisClass().validLetterSpacingValues())\n        addSlot(\"lineHeight\", \"font\", \"line height\", this.thisClass().validLineHeightValues())\n\n\n        // --- padding ---\n\n        {\n            const paddings = this.thisClass().validPaddingValues()\n            addSlot(\"paddingLeft\", \"padding\", \"left\", paddings)\n            addSlot(\"paddingRight\", \"padding\", \"right\", paddings)\n            addSlot(\"paddingTop\", \"padding\", \"top\", paddings)\n            addSlot(\"paddingBottom\", \"padding\", \"bottom\", paddings)\n        }\n\n        // --- margin ---\n\n        {\n            const margins = this.thisClass().validPaddingValues()\n            addSlot(\"marginLeft\", \"margin\", \"left\", margins)\n            addSlot(\"marginRight\", \"margin\", \"right\", margins)\n            addSlot(\"marginTop\", \"margin\", \"top\", margins)\n            addSlot(\"marginBottom\", \"margin\", \"bottom\", margins)\n        }\n        \n\n        // --- border ---\n        \n        {\n            const styles = this.thisClass().validBorderStyleValues()\n            addSlot(\"borderLeftStyle\", \"border/left\", \"style\", styles)\n            addSlot(\"borderRightStyle\", \"border/right\", \"style\", styles)\n            addSlot(\"borderTopStyle\", \"border/top\", \"style\", styles)\n            addSlot(\"borderBottomStyle\", \"border/bottom\", \"style\", styles)\n\n            const widths = this.thisClass().validBorderWidthValues()\n            addSlot(\"borderLeftWidth\", \"border/left\", \"width\", widths)\n            addSlot(\"borderRightWidth\", \"border/right\", \"width\", widths)\n            addSlot(\"borderTopWidth\", \"border/top\", \"width\", widths)\n            addSlot(\"borderBottomWidth\", \"border/bottom\", \"width\", widths)\n\n            const colors = this.thisClass().validColors()\n            addSlot(\"borderLeftColor\", \"border/left\", \"color\", colors)\n            addSlot(\"borderRightColor\", \"border/right\", \"color\", colors)\n            addSlot(\"borderTopColor\", \"border/top\", \"color\", colors)\n            addSlot(\"borderBottomColor\", \"border/bottom\", \"color\", colors)\n\n            const radii = this.thisClass().validBorderWidthValues()\n            addSlot(\"borderLeftRadius\", \"border/left\", \"radius\", radii)\n            addSlot(\"borderRightRadius\", \"border/right\", \"radius\", radii)\n            addSlot(\"borderTopRadius\", \"border/top\", \"radius\", radii)\n            addSlot(\"borderBottomRadius\", \"border/bottom\", \"radius\", radii)\n        }\n\n        // ---------------------\n\n        /*\n            We want to apply:\n            - border and margin to Tile\n            - padding and others to TileContentView\n        */\n\n        //this.newSlot(\"paddingStyleSlots\", styleSlots.select(slot => slot.name().beginsWith(\"padding\"))); // cached for efficiency\n        {\n            const slot = this.newSlot(\"borderStyleSlots\", styleSlots.select(slot => slot.name().beginsWith(\"border\") || slot.name().beginsWith(\"margin\"))); // cached for efficiency\n            slot.setSlotType(\"Array\");\n        }\n\n        {\n            const slot = this.newSlot(\"nonBorderStyleSlots\", styleSlots.select(slot => !(slot.name().beginsWith(\"border\") || slot.name().beginsWith(\"margin\")))); // cached for efficiency\n            slot.setSlotType(\"Array\");\n        }\n        \n        {\n            const slot = this.newSlot(\"styleCacheMap\", null);\n            slot.setSlotType(\"Map\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setStyleCacheMap(null) // null is used to indicate cache needs to be built when accessed\n        this.setShouldStore(true)\n      //  debugger;\n        this.setShouldStoreSubnodes(false) \n\n        let slot = this.thisPrototype().slotNamed(\"subnodes\")\n        if (slot.shouldStoreSlotOnInstance(this)) {\n            debugger;\n            let b = slot.shouldStoreSlotOnInstance(this)\n            assert(!b)\n        }\n        this.setNodeCanAddSubnode(false)\n        this.setSubtitle(\"state\")\n\n        //this.setSubnodeClasses([BMStringField])\n        //this._didChangeThemeNote = this.newNoteNamed(\"didChangeTheme\")\n    }\n\n    finalInit () {\n        super.finalInit();\n        if (!this.hasSubnodes()) {\n            this.setupSubnodes()\n        }\n    }\n\n    setThemeAttribute (key, value) {\n        this[key.asSetter()].apply(this, [value])\n        //this.firstSubnodeWithTitle(key).setValue(value)\n        return this\n    }\n\n    syncFromViewStyle () {\n        return this\n    }\n\n    // prepareForAccess\n    prepareForFirstAccess () {\n        const fields = this.getFields()\n        if (fields.length) {\n            fields.forEach(field => {\n                if (field.pickLeafSubnodesMatchingValue) {\n                    field.pickLeafSubnodesMatchingValue() \n                }\n            })\n        }\n    }\n\n    getFields () {\n        return this.selectSubnodesRecursively(sn => {\n            return sn.thisClass().isKindOf(BMField)\n        })\n    }\n\n    setupSubnodes () {\n        this.removeAllSubnodes()\n\n        // need this because the fonts typically aren't loaded until after this prototype is initialized\n        this.thisPrototype().slotNamed(\"fontFamily\").setValidValuesClosure((instance) => { \n            //debugger;\n            return BMResources.shared().fonts().allFontNames() \n        })\n\n        this.addSubnodeFieldsForSlots(this.styleSlots())\n    }\n\n    // --- style cache ---\n\n    clearStyleCache () {\n        this.setStyleCacheMap(null)\n        //console.log(\"clearStyleCache\")\n        return this\n    }\n\n    getCachedStyleValueNamed (name) {\n        return this.getStyleCacheMap().at(name)\n    }\n\n    getStyleCacheMap () {\n        if (!this.styleCacheMap()) {\n            this.setStyleCacheMap(this.computeStyleCacheMap())\n        }\n        return this.styleCacheMap()\n    }\n\n    computeStyleCacheMap () {\n        const map = new Map()\n        this.styleSlots().forEach(slot => { \n            const name = slot.name()\n            const v = this.getStyleValueNamed(name)\n            map.set(name, v)\n        })\n        return map\n    }\n\n    // --- applying styles ---\n\n    themeClass () {\n        return this.themeStates().parentNode()\n    }\n\n    parentThemeClass () {\n        return this.themeClass().parentThemeClass()\n    }\n\n    themeStates () {\n        return this.parentNode()\n    }\n\n    parentThemeState () {\n        return this.themeStates().subnodeBefore(this)\n    }\n\n    /*\n       See notes at top of this file for explaination of lookup order.\n    */\n    \n    getStyleValueNamed (name, depth = 1) {\n        assert(depth < 20)\n\n        const getterMethod = this[name]\n\n        /*\n            const themeClassName = this.themeClass().title()\n            const stateName = this.title()\n            const spacer = \"-\".repeat(depth)\n            console.log(\" \" + spacer + \" \" + themeClassName + \"/\" + stateName + \".getStyleValueNamed('\" + name + \"')\")\n            //debugger\n        */\n        \n        let v = null\n\n        if (getterMethod) {\n            v = getterMethod.apply(this)\n            if (v === \"\" || v === \"inherit\") { \n                v = null\n            }\n        } else {\n            const errorMsg = \"missing getter method: \" + this.type() + \".\" + name + \"()\"\n            console.warn(errorMsg)\n            //throw new Error(errorMsg)\n        }\n\n        // lookup in ThemeClass's parent\n        if (v === null) {\n            const parent = this.parentThemeClass() // parent theme class eg: Default -(child)-> Tile -(child)-> TextTile\n            assert(parent !== this.themeClass())\n            if (parent) {\n                const stateName = this.title()\n                const state = parent.stateWithName(stateName)\n                v = state.getStyleValueNamed(name, depth+1) // will recurse through themeClass parents\n            }\n        }\n\n        // lookup in ThemeState's parent\n        if (v === null) {\n            const parent = this.parentThemeState()// parent theme state eg: active -(child)-> selected -(child)-> unselected\n            assert(parent !== this)\n            if (parent) {\n                v = parent.getStyleValueNamed(name, depth+1) // will recurse through themeStates and each state will recurse themeClass parents\n            }\n        }\n\n        if (v) {\n            //console.log(\"found: '\" + v + \"'\")\n        }\n\n        return v\n    }\n\n    // --- apply style  ---\n\n    applyToView (aView) {\n        this.applyStyleSlotsToView(this.styleSlots(), aView)\n        return this\n    }\n\n    applyNonBorderStylesToView (aView) {\n        //debugger\n        this.applyStyleSlotsToView(this.nonBorderStyleSlots(), aView)\n        return this\n    }\n\n    applyBorderStylesToView (aView) {\n        this.applyStyleSlotsToView(this.borderStyleSlots(), aView)\n        return this\n    }\n\n    // --- apply styles slots ---\n\n    applyStyleSlotsToView (styleSlots, aView) {\n        const lockedSet = aView.lockedStyleAttributeSet ? aView.lockedStyleAttributeSet() : null;\n        //console.log(\"applyStyleSlotsToView \", aView.debugTypeId())\n        styleSlots.forEach(slot => { \n            const name = slot.name()\n            const isLocked = lockedSet ? lockedSet.has(name) : false;\n            if (!isLocked) {\n                const v = this.getCachedStyleValueNamed(name)\n                /*\n                if (v) {\n                    const themeClassName = this.themeClass().title()\n                    const stateName = this.title()\n                    console.log(themeClassName + \" / \" + stateName + \" '\" + v + \"' -> \" + aView.type())// + \"/\" + aView.node())\n                }\n                */\n                aView.performIfResponding(aView.setterNameForSlot(name), v)\n            } else {\n                console.log(\"style \" + name + \" locked on view \" + aView.type())\n            }\n        })\n        return this\n    }\n\n    // --- changes ---\n    \n    onDidEdit () {\n        console.log(this.typeId() + \" onDidEdit\")\n        this.setStyleCacheMap(null)\n        debugger;\n        return false\n    }\n\n    didUpdateSlot (aSlot, oldValue, newValue) {\n        if (this.hasDoneInit()) {\n            if (aSlot.name() !== \"styleCacheMap\") { // hack\n                DocumentBody.shared().resyncAllViews() // this will apply any new styles\n                this.scheduleCacheClears()\n            }\n        }\n        return super.didUpdateSlot(aSlot, oldValue, newValue) \n    }\n\n    scheduleCacheClears () {\n        // need to clear our sibling caches as there is inheritance between states,\n        // so our change may invalidate attributes of states that inherit from us\n        this.parentNode().subnodes().forEach(sn => sn.scheduleMethod(\"clearStyleCache\"))\n    }\n    \n    didReorderParentSubnodes () {\n        this.scheduleMethod(\"clearStyleCache\")\n    }\n\n    styleMap () {\n        const map = new Map()\n        const title = this.title()\n        this.styleSlots().forEach(slot => { \n            const name = slot.name()\n            //const v = this.getCachedStyleValueNamed(name)\n            const v = this.getStyleValueNamed(name)\n            map.set(title + \". \" + name, v)\n            // these look like: disabled.backgroundColor: \"black\"\n        })\n        return map\n    }\n\n    // --- helpers ---\n\n    attributeNamed (name) {\n        return this.firstSubnodeWithTitle(name)\n    }\n\n    // --- defaults ----\n\n    setupAsDefault () {\n        const title = this.title()\n        const methodName = \"setupAsDefault\" + this.title().capitalized() + \"State\"\n        this[methodName].call(this)\n        return this\n    }\n\n    setupAsDefaultActiveState () {\n        //this.setColor(\"white\")\n        //this.setBackgroundColor(\"#333\")\n        this.setThemeAttribute(\"color\", \"white\");\n        this.setThemeAttribute(\"backgroundColor\", \"#333\");\n        //this.setThemeAttribute(\"fontWeight\", \"normal\");\n      }\n    \n      setupAsDefaultUnselectedState () {\n        this.setThemeAttribute(\"color\", \"#bbb\");\n        this.setThemeAttribute(\"backgroundColor\", \"transparent\");\n        //this.setThemeAttribute(\"fontWeight\", \"normal\");\n      }\n    \n      setupAsDefaultSelectedState () {\n        this.setThemeAttribute(\"color\", \"white\");\n        this.setThemeAttribute(\"backgroundColor\", \"#222\");\n        //this.setThemeAttribute(\"fontWeight\", \"normal\");\n      }\n    \n      setupAsDefaultDisabledState () {\n        this.setThemeAttribute(\"color\", \"#ccc\");\n        //this.setThemeAttribute(\"backgroundColor\", \"transparent\");\n        //this.setThemeAttribute(\"fontWeight\", \"normal\");\n\n        this.setThemeAttribute(\"paddingLeft\", \"22px\");\n        this.setThemeAttribute(\"paddingRight\", \"22px\");\n        this.setThemeAttribute(\"paddingTop\", \"8px\");\n        this.setThemeAttribute(\"paddingBottom\", \"8px\");\n      }\n\n}.initThisClass());\n\n\n",
  "cDygc5nrDJQlGarFah62aA6y77JczasFOIaOkbpXSUM=": "\"use strict\";\n\n/*\n\n    BMThemeStates\n\n*/\n\n(class BMThemeStates extends BMThemeFolder {\n  initPrototypeSlots () {\n    {\n      const slot =this.newSlot(\"standardStateNames\", [\n        \"disabled\",\n        \"unselected\", \n        \"selected\", \n        \"active\"\n      ]);\n      slot.setSlotType(\"Array\");\n    }\n  }\n\n  init () {\n    super.init();\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n\n    this.setNodeCanEditTitle(true);\n    this.setTitle(\"States\");\n    this.setSubtitle(\"\")\n    this.setCanDelete(true);\n    this.setSubnodeClasses([BMThemeState]);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.setupSubnodes()\n  }\n\n  setupSubnodes () {\n    if (!this.hasSubnodes()) {\n      const subnodeClass = this.subnodeClasses().first();\n      this.standardStateNames().forEach((name) => {\n        const subnode = this.subnodeWithTitleIfAbsentInsertProto(\n          name,\n          subnodeClass\n        );\n      });\n    }\n  }\n\n  // --- states ---\n\n  stateWithName (name) {\n    assert(this.standardStateNames().contains(name))\n    return this.firstSubnodeWithTitle(name);\n  }\n\n  activeThemeState () {\n    return this.stateWithName(\"active\");\n  }\n\n  unselectedThemeState () {\n    return this.stateWithName(\"unselected\");\n  }\n\n  selectedThemeState () {\n    return this.stateWithName(\"selected\");\n  }\n\n  disabledThemeState () {\n    return this.stateWithName(\"disabled\");\n  }\n\n  // --- default ---\n\n  setupAsDefault () {\n    this.setTitle(\"states\");\n    this.setupSubnodes();\n\n    this.subnodes().forEach(state => state.setupAsDefault())\n    //this.setupColumnsDefault()\n    return this;\n  }\n\n  /*\n  setupColumnsDefault () {\n    const columns = BMThemeFolder.clone().setTitle(\"columns\");\n    this.addSubnode(columns);\n\n    const colors = [\n      [60, 60, 60],\n      [48, 48, 48],\n      [32, 32, 32],\n      [26, 26, 26],\n      [16, 16, 16],\n    ];\n\n    colors.forEach((c) => {\n      const cssColorString = \"rgb(\" + c.join(\",\") + \")\";\n      const field = BMStringField.clone()\n        .setKey(\"backgroundColor\")\n        .setValue(cssColorString);\n      columns.addSubnode(field);\n    });\n  }\n  */\n\n}.initThisClass());\n",
  "JT8N/l1KSXPo1xU7c/8MqcH98fcJlMfIHlEtvcp9axM=": "\"use strict\";\n\n/*\n\n    BMThemeFolder\n\n*/\n\n(class BMThemeClassChildren extends BMThemeFolder {\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setShouldStore(true)\n        this.setShouldStoreSubnodes(true) \n        this.setNodeCanEditTitle(true)\n        this.setTitle(\"children\")\n        this.setCanDelete(true)\n        this.setNodeCanAddSubnode(true)\n        this.setSubnodeClasses([BMThemeClass])\n        this.setNodeCanReorderSubnodes(true)\n    }\n\n    themeClassNamed (name) {\n        return this.subnodes().detect(sn => sn.title() === name)\n    }\n\n}.initThisClass());\n",
  "I/kKep2SVKVZ8y60h0U1gCvOJ1n6d0fHHszwMGdHmYE=": "\"use strict\";\r\n\r\n/*\r\n    \r\n\tBMIconResources\r\n\t\r\n\tHack to put SVG files into Javascript strings to avoid cross site loading issues.\r\n    \r\n*/\r\n\r\n(class BMIconResources extends BMResourceGroup {\r\n\r\n\tinit () {\r\n\t\tsuper.init()\r\n\t\tthis.setTitle(\"Icons\")\r\n\t\treturn this\r\n\t}\r\n\r\n\tsetup () {\r\n        super.setup();\r\n        this.setResourceClasses([SvgIconNode]);\r\n\t\tthis.setSubnodeClasses([SvgIconNode]);\r\n    }\r\n\r\n\t// --- old code to add svg directly using a string ---\r\n\r\n    addIcon (aName, svgString) {\r\n\t\tconst node = SvgIconNode.clone().setTitle(aName).setSvgString(svgString)\r\n\t\tthis.addSubnode(node)\r\n        return this\r\n\t}\r\n\t\r\n\ticonWithName (aName) {\r\n\t\tconst node = this.firstSubnodeWithTitle(aName)\r\n\t\tif (node) {\r\n\t\t\treturn node.svgIconView()\r\n\t\t}\r\n\t\treturn null\r\n\t}\r\n\r\n\ticonNames () {\r\n\t\treturn this.subnodes().map(sn => sn.title())\r\n\t}\r\n\r\n}.initThisClass());\r\n\r\n\r\n\r\n",
  "I3h189lMI3RUeZ55HcTvQVZyhy+K11atDeHIvgEPO1Q=": "\"use strict\";\r\n\r\n/*\r\n    \r\n  SvgIconNode\r\n\t\r\n    \r\n*/\r\n\r\n(class SvgIconNode extends BMResource {\r\n\r\n  static supportedExtensions () {\r\n    return [\"svg\"]\r\n  }\r\n\r\n  initPrototypeSlots () {\r\n    {\r\n      const slot = this.newSlot(\"svgString\", null)\r\n      slot.setCanInspect(true)\r\n      slot.setSlotType(\"String\")\r\n      slot.setLabel(\"SVG string\")\r\n    }\r\n  }\r\n\r\n  initPrototype () {\r\n  }\r\n\r\n  onDidLoad () {\r\n    super.onDidLoad()\r\n    //debugger\r\n    this.setSvgString(this.urlResource().dataAsText())\r\n    return this\r\n  }\r\n\r\n  svgIconView () {\r\n    // TODO: this view stuff probably shouldn't be in the model\r\n    debugger\r\n    const icon = SvgIconView.clone().setSvgString(this.svgString())\r\n    return icon\r\n  }\r\n\r\n  noteIconName () {\r\n    return this.title()\r\n  }\r\n\r\n}.initThisClass());\r\n\r\n\r\n\r\n",
  "ZocUgCvj/mmjUSd2l8XAUL194AypyW7OOpKvdS0Un1w=": "\"use strict\";\n\n/*\n\n    BMImage\n\n*/\n\n(class BMJsonResource extends BMResource {\n    \n    static supportedExtensions () {\n        return [\"json\"];\n    }\n\n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n    }\n\n    async asyncDecodeData () {\n        const value = JSON.parse(this.data().asString());\n        this.setValue(value);\n        return this;\n    }\n\n}.initThisClass());\n\n",
  "fDXYL7+/2suazvljEhAFizNXjFOT5q/odnrmLsbVviU=": "\"use strict\";\n\n/*\n\n    BMJsonResources\n\n*/\n\n(class BMJsonResources extends BMResourceGroup {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n    \n    initPrototypeSlots () {\n    }\n\n    initPrototype () {\n        this.setTitle(\"Json\");\n        this.setNoteIsSubnodeCount(true);\n        return this;\n    }\n\n    setup () {\n        super.setup();\n        this.setResourceClasses([BMJsonResource]);\n        this.setSubnodeClasses([BMJsonResource]);\n        return this;\n    }\n\n    /*\n    resourceClassesForFileExtension (extension) {\n        debugger;\n        return super.resourceClassesForFileExtension(extension);\n    }\n    */\n\n}.initThisClass());\n\n\n",
  "AcW8m2nU/t8DBXDYur7mnp70cC74lhj66+8L4CowwBc=": "\"use strict\";\n\n/* \n    XhrWrapper\n\n    Wrapper for request to API\n    delegate methods:\n\n    onRequestBegin(request)\n    onRequestRead(request)\n    onRequestComplete(request)\n    onRequestError(request, error)\n    onRequestAbort(request)\n\n    onStreamStart(request)\n    onStreamData(request, newContent)\n    onStreamEnd(request)\n\n    delegate can get info via: \n      request.fullContent() \n      request.status()\n      request.error()\n\n\n    PLAN: \n\n    Transition these classes using xhr (or fetch) to use this wrapper.\n\n    Classes:\n\n      using xhr:\n        AiRequest\n        StrvctHttpsServerRequest?\n        AnthropicRequest\n        OpenAiRequest\n        OpenAiImage\n\n      using fetch:\n        AiService\n        AzureTtsRequest\n        OpenAiImagePrompt\n        OpenAiImage\n        OpenAiTtsRequest\n        RzSigServer\n        SceneView\n\n      1. replace onStream* API methods with onRequest*.\n      2. replace xhr/fetch within the above classes with XhrWrapper instance\n\n\n\n*/\n\n(class XhrWrapper extends BMStorableNode {\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"delegate\", null); // optional ref\n    }\n\n    {\n      const slot = this.newSlot(\"url\", null);\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"needsProxy\", true);\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n\n    {\n      const slot = this.newSlot(\"method\", \"POST\");\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"headers\", null);\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"JSON Dictionary\");  // TODO: make this a dictionary\n      slot.setIsSubnodeField(false);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"requestOptions\", null); // this will contain the model choice and messages\n      slot.setSlotType(\"JSON Dictionary\");  // TODO: make this a dictionary\n    }\n\n    {\n      const slot = this.newSlot(\"body\", null); \n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    // streaming\n\n    {\n      const slot = this.newSlot(\"isStreaming\", false); // external read-only\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Boolean\");\n      slot.setIsSubnodeField(true);\n    } \n\n    {\n      const slot = this.newSlot(\"xhr\", null);\n      slot.setSlotType(\"XMLHttpRequest\");\n    }\n\n    {\n      const slot = this.newSlot(\"xhrPromise\", null); \n      slot.setSlotType(\"Promise\");\n    }\n\n    {\n      const slot = this.newSlot(\"requestId\", null);\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"readIndex\", 0);\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"fullContent\", null); \n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setSlotType(\"Error\");\n    }\n\n    {\n      const slot = this.newSlot(\"status\", \"\");\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    this.setShouldStore(false);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(true);\n    this.setRequestId(this.puuid());\n    this.setRequesstOptions({\n      method:\"POST\",\n      headers: {\n      },\n      body: \"\"\n    });\n    this.setTitle(this.type());\n    this.setIsDebugging(true);\n  }\n\n  subtitle () {\n    return this.status();\n  }\n\n  // --- options ---\n\n  requestOptions () {\n    return {\n      method: this.method(),\n      headers: this.headers(),\n      body: this.body()\n    };\n  }\n\n  // ----------------------------\n\n  assertValidUrl () {\n    if (!this.url()) {\n      throw new Error(this.type() + \" url missing\");\n    }\n  }\n\n  activeUrl () {\n    const url = this.url();\n    if (this.needsProxy()) {\n      return ProxyServers.shared().defaultServer().proxyUrlForUrl(url);\n    }\n    return url;\n  }\n\n  proxyUrl () {\n    const proxyUrl = ProxyServers.shared().defaultServer().proxyUrlForUrl(this.url());\n    return proxyUrl;\n  }\n\n  showRequest () {\n    this.debugLog(this.description());\n  }\n\n  showResponse () {\n    if (json.error) {\n      console.warn(this.type() + \" ERROR:\", json.error.message);\n    }\n  }\n\n  // --- normal response --- \n\n  responseSizeDescription () {\n    const size = this.xhr() ? this.xhr().responseText.length : 0;\n    return ByteFormatter.clone().setValue(size).formattedValue();\n  }\n\n  // --- helpers ---\n\n  curlCommand () {\n    const commandParts = [];\n    commandParts.push(`curl  --insecure \"` + this.activeUrl() + '\"');\n    const headers = this.requestOptions().headers;\n\n     Object.keys(headers).forEach((key) => {\n      const value = headers[key];\n      commandParts.push(` --header \"${key}: ${value}\"`);\n    });\n\n    // TODO: deal with binary body data\n    commandParts.push(` --data '` + this.body() + `'`);\n    return commandParts.join(\" \\\\\\n\");\n  }\n\n  description () {\n    const json = {\n      requestId: this.requestId(),\n      options: this.requestOptions(),\n      url:  this.url(),\n      activeUrl: this.activeUrl(),\n      body: this.body()\n    };\n    return JSON.stringify(json, 2, 2);\n  }\n\n  // --- streaming response --- \n\n  assertValidDelegate () {\n    const d = this.delegate();\n    if (d) {\n      assert(d.onStreamStart);\n      assert(d.onStreamData);\n      assert(d.onStreamEnd);\n    }\n  }\n\n  async send () {\n    assert(!this.xhrPromise());\n\n    this.setXhrPromise(Promise.clone());\n\n    this.assertValidUrl();\n    assert(!this.xhr(), \"xhr should be null\");\n\n    this.assertValidDelegate();\n\n    this.setIsStreaming(true);\n    this.setStatus(\"streaming\");\n\n    const xhr = new XMLHttpRequest();\n    this.setXhr(xhr);\n    xhr.open(this.method(), this.activeUrl());\n\n    // set headers\n    const options = this.requestOptions();\n    \n    const headers = this.headers();\n    for (const k in headers) {\n      const v = headers[header];\n      xhr.setRequestHeader(k, v);\n    }\n\n    xhr.responseType = \"\"; // \"\" or \"text\" is required for streams\n\n    this.setFullContent(\"\");\n\n    // TODO: move to a standard wrapped XHR class?\n    \n    // why false arg? see https://stackoverflow.com/questions/51204603/read-response-stream-via-xmlhttprequest\n    xhr.addEventListener(\"progress\", (event) => {\n      EventManager.shared().safeWrapEvent(() => { \n        this.onXhrProgress(event) \n      }, event)\n    }, false);\n\n    xhr.addEventListener(\"loadend\", (event) => {\n      try { \n        EventManager.shared().safeWrapEvent(() => { \n          this.onXhrLoadEnd(event) \n        }, event);\n      } catch (error) {\n       this.onError(error); \n      }\n    });\n\n    xhr.addEventListener(\"error\", (event) => {\n      EventManager.shared().safeWrapEvent(() => { \n        this.onXhrError(event) \n      }, event)\n    });\n\n    xhr.addEventListener(\"abort\", (event) => {\n      EventManager.shared().safeWrapEvent(() => { \n        this.onXhrAbort(event) \n      }, event)\n    });\n\n    this.sendDelegate(\"onRequestBegin\");\n    this.sendDelegate(\"onStreamStart\");\n\n    xhr.send(this.body());\n\n    return this.xhrPromise();\n  }\n\n  // --- xhr request event handlers ---\n\n  onXhrProgress (event) {\n    //console.log(this.typeId() + \" onXhrProgress() bytes \" + this.fullContent().length);\n    this.onXhrRead();\n    this.sendDelegate(\"onRequestRead\");\n  }\n\n  statusCode () {\n    return this.xhr().status;\n  }\n\n  onXhrLoadEnd (event) {\n    //console.log(this.typeId() + \" onXhrLoadEnd() bytes [[\" + this.fullContent() + \"]]\");\n    //const hasError = this.xhr().status >= 300;\n\n    this.sendDelegate(\"onStreamEnd\"); // all data chunks should have already been sent via onStreamData\n    this.sendDelegate(\"onRequestComplete\");\n    this.setStatus(\"completed \" + this.responseSizeDescription());\n    this.xhrPromise().callResolveFunc(this.fullContent()); \n\n    console.log(this.typeId() + \" onXhrLoadEnd()\");\n  }\n\n  onXhrError (event) {\n    const xhr = this.xhr();\n    // error events don't contain messages - need to look at xhr and guess at what happened\n    //let s = \"Error on Xhr requestId \" + this.requestId() + \" \";\n    let s = \"Xhr error: \" + this.description() + \" \";\n    s += \" status: \" + this.nameForXhrStatusCode(xhr.status); // e.g. 404 = file not found\n    s += \", statusText: '\" + xhr.statusText + \"'\";\n    s += \", readyState: \" + this.nameForXhrReadyState(xhr.readyState); // e.g.. 4 === DONE\n    const error = new Error(s);\n    this.onError(error);\n    this.sendDelegate(\"onStreamError\", [this, error]);\n    this.sendDelegate(\"onStreamEnd\");\n    this.xhrPromise().callRejectFunc(error);\n  }\n\n  onXhrAbort (event) {\n    this.setStatus(\"aborted\")\n    this.sendDelegate(\"onRequestComplete\");\n    this.sendDelegate(\"onStreamEnd\");\n    this.xhrPromise().callRejectFunc(new Error(\"aborted\"));\n  }\n\n  onXhrRead () {\n    //this.sendDelegate(\"onStreamData\", [this, this.fullContent()]);\n    //this.readXhrLines()\n  }\n\n  // --- error ---\n\n  didUpdateSlotError (oldValue, newValue) {\n    if (newValue) {\n      this.setStatus(\"ERROR: \" + newValue.message)\n    }\n  }\n\n  onError (e) {\n    this.setError(e);\n    this.sendDelegate(\"onRequestError\", [this, e])\n\n    if (e) {\n      console.warn(this.debugTypeId() + \" \" + e.message);\n    }\n    return this;\n  }\n\n  // --- abort ---\n\n  isActive () {\n    const xhr = this.xhr();\n    if (xhr) {\n      const state = xhr.readyState;\n      return (state >= 1 && state <= 3);\n    }\n    return false;\n  }\n  \n  abort () {\n    if (this.isActive()) {\n      this.xhr().abort();\n    }\n    return this;\n  }\n\n  // --- delegate ---\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate()\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        this.debugLog(this.typeId() + \" sending \" + d.typeId() + \".\" + methodName + \"()\")\n        f.apply(d, args)\n        return true\n      }\n    }\n    return false\n  }\n\n  // --- helpers ---\n\n\tnameForXhrStatusCode (statusCode) {\n\t\t/**\n\t\t   * This function returns a brief description of an XHR status code.\n\t\t   * \n\t\t   * @param {number} statusCode - The XHR status code.\n\t\t   * @returns {string} - A brief description of the status, or \"Unknown status\".\n\t\t   */\n\t\n\t\tconst xhrStatuses = {\n\t\t  0: \"Not started: Network Error, Request Blocked, or CORS issue\",\n\t\t  100: \"Continue\",\n\t\t  101: \"Switching protocols\",\n\t\t  200: \"OK - Request successful\",\n\t\t  201: \"Created - Resource created\",\n\t\t  301: \"Moved permanently\",\n\t\t  304: \"Not modified\",\n\t\t  400: \"Bad request\", \n\t\t  401: \"Unauthorized\",\n\t\t  403: \"Forbidden\",\n\t\t  404: \"Not found\",\n\t\t  500: \"Internal server error\" \n\t\t};\n\t\n\t\treturn statusCode + \" (\" + (xhrStatuses[statusCode] || \"Unknown status\") + \")\";\n\t  }\n\n  nameForXhrReadyState (readyState) {\n    /**\n     * This function returns a brief description of an XHR readyState.\n     * \n     * @param {number} readyState - The XHR readyState value.\n     * @returns {string} - A brief description of the state, or \"Unknown state\".\n     */\n\n    const xhrStates = {\n      0: \"Request not initialized\",\n      1: \"Server connection established\",\n      2: \"Request received\",\n      3: \"Processing request\",\n      4: \"Request finished\"\n    };\n\n    return status + \" (\" + (xhrStates[readyState] || \"Unknown ready state\") + \")\";\n  }\n\n}).initThisClass();\n",
  "x/gRdXiJ6RgZnLH+03DrEVMpxJ8+FIvJ4oy6oGw3tYc=": "\"use strict\";\n\n/**\n * @module AiServiceKit\n * @class\n * @memberof module:AiServiceKit\n * @extends BMSummaryNode\n*/\n\n(class AiChatModel extends BMSummaryNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"service\", null);\n      slot.setSlotType(\"AiService\");\n    }\n\n    {\n      const slot = this.newSlot(\"modelName\", null);\n      //slot.setInspectorPath(\"\");\n      slot.setLabel(\"name\");\n      slot.setShouldStoreSlot(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      //slot.setValidValues(values);\n    }\n\n\n    {\n      const slot = this.newSlot(\"inputTokenLimit\", 8000); // max input tokens allowed by model\n      slot.setLabel(\"context window\");\n      slot.setShouldStoreSlot(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init () {\n    super.init();\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"AI Model\");\n    this.setSummaryFormat(\"value\");\n    this.setHasNewlineAfterSummary(true);\n  }\n\n  service () {\n    if (this._service) {\n      return this._service;\n    }\n    return this.parentNode().parentNode();\n  }\n\n  subtitle () {\n    return this.modelName();\n  }\n\n  validateKey (s) {\n    return s.startsWith(\"sk-\");\n  }\n\n  hasApiKey () {\n    return this.apiKey() && this.apiKey().length > 0 && this.validateKey(this.apiKey());\n  }\n\n  setJson (json) {\n    assert(json.name);\n    this.setModelName(json.name);\n\n    if (json.title) {\n      this.setTitle(json.title);\n    } else {\n      this.setTitle(json.name);\n    }\n\n    const cw = json.contextWindow;\n    assert(Type.isNumber(cw));\n    this.setInputTokenLimit(cw);\n    return this;\n  }\n\n  summary () {\n    const cw = NumberFormatter.clone().setValue(this.inputTokenLimit()).setSignificantDigits(2).formattedValue();\n\n    return this.modelName() + \" (\" + cw + \")\\n\";\n  }\n\n}.initThisClass());\n",
  "vz4+Gz4267W8SDKBNJDBOuyByKaX2UgZqVdA+HplIZk=": "\"use strict\";\n\n/* \n    AiChatModels\n\n*/\n\n(class AiChatModels extends BMSummaryNode {\n  initPrototypeSlots () {\n  }\n\n  init() {\n    super.init();\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setNoteIsSubnodeCount(true);\n    this.setSubnodeClasses([AiChatModel]);\n    this.setNodeSubtitleIsChildrenSummary(true);\n    this.setTitle(\"Models\");\n  }\n\n  subviewsScrollSticksToBottom () {\n    return false;\n  }\n\n  service () {\n    return this.parentNode();\n  }\n\n}.initThisClass());\n",
  "4MVFpfHidvorCynrApf1FpeMvHkW+//mJYqTsNFVDzw=": "\"use strict\";\n\n/* \n    AiRequest\n\n    AiRequest <- on -> XhrWrapper \n\n    Wrapper for request to API service that manages streaming the response and checking for various errors.\n    \n    Delegate protocol:\n\n      onRequestBegin(request)\n      onRequestComplete(request)\n      onRequestError(request, error)\n\n      onStreamStart(request)\n      onStreamData(request, newContent)\n      onStreamEnd(request)\n\n    Delegate can get info via:\n\n      request.fullContent() \n      request.status()\n      request.error()\n\n*/\n\n(class AiRequest extends BMStorableNode {\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"delegate\", null); // optional reference to object that owns request\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"service\", null);\n      slot.setSlotType(\"AiService\");\n\n    }\n\n    {\n      const slot = this.newSlot(\"needsProxy\", true);\n      slot.setCanInspect(true);\n      slot.setCanEditInspection(false);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setInspectorPath(this.type());\n      slot.setIsSubnodeField(true);\n      slot.setShouldStoreSlot(true);\n      slot.setSlotType(\"Boolean\");\n      slot.setSyncsToView(true);\n    }\n\n    {\n      const slot = this.newSlot(\"bodyJson\", null); // this will contain the model choice and messages\n      slot.setSlotType(\"JSON Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"body\", null); \n      slot.setCanInspect(true);\n      slot.setCanEditInspection(false);\n      slot.setInspectorPath(this.type() + \"/body\");\n      slot.setIsSubnodeField(true);\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"json\", null);\n      slot.setSlotType(\"JSON Object\");\n    }\n\n    // streaming\n\n\n    {\n      const slot = this.newSlot(\"xhr\", null);\n      slot.setSlotType(\"XMLHttpRequest\");\n    }\n\n    {\n      const slot = this.newSlot(\"isStreaming\", false); // external read-only\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n    }\n\n    {\n      const slot = this.newSlot(\"xhrPromise\", null); \n      slot.setSlotType(\"Promise\");\n    }\n\n    {\n      const slot = this.newSlot(\"requestId\", null);\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"readIndex\", 0); // current read index in the responseText\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"readLines\", null);\n      slot.setSlotType(\"Array\");\n    }\n\n    {\n      const slot = this.newSlot(\"isContinuation\", false); // flag to skip \"start\" delegate message\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Boolean\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n\n    {\n      // where the continued request started in the fullContext (not the responseText)\n      // Need to remove fullContent after this point if we need to retry the request\n      const slot = this.newSlot(\"continuationStartIndex\", 0); \n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"stopReason\", null);\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"retryDelaySeconds\", 1);\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"fullContent\", null); \n      slot.setInspectorPath(this.type() + \"/fullContent\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setSlotType(\"Error\");\n    }\n\n    {\n      const slot = this.newSlot(\"status\", \"\");\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n\n    {\n      const slot = this.newSlot(\"didAbort\", false);\n      slot.setInspectorPath(this.type());\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Boolean\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"retryRequestAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Retry Request\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"retryRequest\");\n    }\n\n    {\n      const slot = this.newSlot(\"copyBodyAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Copy Body\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"copyBody\");\n    }\n\n    {\n      const slot = this.newSlot(\"copyMessagesAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Copy Messages\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"copyMessages\");\n    }\n\n    this.setShouldStore(false);\n    this.setShouldStoreSubnodes(false);\n  }\n\n\n  init () {\n    super.init();\n    this.setIsDebugging(false);\n    this.setRequestId(this.puuid());\n    this.setTitle(\"Request\");\n    this.setIsDebugging(true);\n  }\n\n  subtitle () {\n    return [this.fullContent().length + \" bytes\", this.status()].join(\"\\n\");\n  }\n\n  // --- service properties ---\n\n  apiUrl () {\n    return this.service().chatEndpoint();\n  }\n\n  apiKey () {\n    return this.service().apiKey();\n  }\n\n  // --- fetch ---\n\n  body () {\n    return JSON.stringify(this.bodyJson(), 2, 2);\n  }\n\n  requestOptions () {\n    const apiKey = this.apiKey();\n    return {\n      method: \"POST\",\n      headers: {\n        //\"Content-Type\": \"application/json\",\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        \"Authorization\": `Bearer ${apiKey}`,\n        'Accept-Encoding': 'identity'\n      },\n      body: JSON.stringify(this.bodyJson())\n    };\n  }\n\n  assertValid () {\n    if (!this.apiUrl()) {\n      throw new Error(this.type() + \" apiUrl missing\");\n    }\n\n    if (!this.apiKey()) {\n      throw new Error(this.type() + \" apiKey missing\");\n    }\n  }\n\n  activeApiUrl () {\n    let url = this.apiUrl();\n    if (this.needsProxy()) {\n      url = ProxyServers.shared().defaultServer().proxyUrlForUrl(url);\n    }\n    return url;\n  }\n\n  proxyUrl () {\n    const proxyUrl = ProxyServers.shared().defaultServer().proxyUrlForUrl(this.url());\n    return proxyUrl;\n    //return WebBrowserWindow.shared().rootUrl() + \"/?proxyUrl=\" + encodeURIComponent(this.url())\n  }\n\n  showRequest () {\n    this.debugLog(this.description());\n  }\n\n  showResponse () {\n    const json = this.json();\n    this.debugLog(\" response json: \", json);\n    if (json.error) {\n      console.warn(this.type() + \" ERROR:\", json.error.message);\n    }\n  }\n\n  // --- normal response --- \n\n  responseSizeDescription () {\n    const size = this.xhr() ? this.xhr().responseText.length : 0;\n    return ByteFormatter.clone().setValue(size).formattedValue();\n  }\n\n  // --- helpers ---\n\n  curlCommand () {\n    const commandParts = [];\n    commandParts.push(`curl  --insecure \"` + this.activeApiUrl() + '\"');\n    const headers = this.requestOptions().headers;\n\n     Object.keys(headers).forEach((key) => {\n      const value = headers[key];\n      commandParts.push(` --header \"${key}: ${value}\"`);\n    });\n\n    const data = JSON.stringify(this.bodyJson());\n    commandParts.push(` --data '` + data + `'`);\n    return commandParts.join(\" \\\\\\n\");\n  }\n\n  description () {\n    const json = {\n      requestId: this.requestId(),\n      options: this.requestOptions(),\n      activeApiUrl:  this.activeApiUrl(),\n      apiUrl:  this.apiUrl(),\n      body: this.bodyJson()\n    };\n    return JSON.stringify(json, 2, 2);\n  }\n\n  // --- streaming response --- \n\n  assertReadyToStream () {\n    const target = this.delegate();\n    if (target) {\n      // verify streamTarget protocol is implemented by target\n      assert(target.onStreamStart);\n      assert(target.onStreamData);\n      assert(target.onStreamEnd);\n    }\n  }\n\n  setupForStreaming () {\n    // subclasses should override this method to set up the request for streaming\n    return this;\n  }\n\n  async asyncSendAndStreamResponse () {\n\n    if (this.isContinuation()) {\n      //console.log(this.typeId() + \" asyncSendAndStreamResponse() isContinuation\");\n    }\n\n    this.service().prepareToSendRequest(this); // give anthropic a chance to ensure alternating user/assistant messages\n\n    this.setError(null); // clear error (in case we are retrying)\n    assert(!this.xhr());\n\n    if (!this.isContinuation()) {\n      assert(!this.xhrPromise());\n      this.setXhrPromise(Promise.clone());\n    }\n\n    this.assertValid();\n    this.assertReadyToStream();\n\n    //console.log(\"--- URL ---\\n\", this.activeApiUrl(), \"\\n-----------\");\n    //console.log(\"--- CURL ---\\n\", this.curlCommand(), \"\\n-----------\");\n\n    this.setIsStreaming(true);\n    this.setStatus(\"streaming\");\n\n    this.setupForStreaming();\n    this.setReadLines([]);\n\n    const xhr = new XMLHttpRequest();\n    this.setXhr(xhr);\n    xhr.open(\"POST\", this.activeApiUrl());\n\n    // set headers\n    const options = this.requestOptions();\n    \n    for (const header in options.headers) {\n      const value = options.headers[header];\n      xhr.setRequestHeader(header, value);\n    }\n\n    xhr.responseType = \"\"; // \"\" or \"text\" is required for streams\n\n    if (!this.isContinuation()) {\n      this.setFullContent(\"\");\n    }\n\n    // TODO: move to a standard wrapped XHR class?\n    \n    // why false arg? see https://stackoverflow.com/questions/51204603/read-response-stream-via-xmlhttprequest\n    xhr.addEventListener(\"progress\", (event) => {\n     EventManager.shared().safeWrapEvent(() => { this.onXhrProgress(event) }, event)\n     //this.onXhrProgress(event)\n    }, false);\n\n    xhr.addEventListener(\"loadend\", (event) => {\n      try { \n        EventManager.shared().safeWrapEvent(() => { this.onXhrLoadEnd(event) }, event);\n      } catch (error) {\n       this.onError(error); \n      }\n      //this.onXhrLoadEnd(event)\n    });\n\n    xhr.addEventListener(\"error\", (event) => {\n      EventManager.shared().safeWrapEvent(() => { this.onXhrError(event) }, event)\n      //this.onXhrError(event)\n    });\n\n    xhr.addEventListener(\"abort\", (event) => {\n      EventManager.shared().safeWrapEvent(() => { this.onXhrAbort(event) }, event)\n      //this.onXhrAbort(event)\n    });\n\n    //  EventManager.shared().safeWrapEvent(() => { ... })\n    \n    if (!this.isContinuation()) {\n      this.sendDelegate(\"onRequestBegin\");\n      this.sendDelegate(\"onStreamStart\");\n    }\n\n    //const s = JSON.stringify(options, 2, 2);\n    //this.debugLog(\"SENDING REQUEST BODY:\", options.body);\n    xhr.send(options.body);\n\n    return this.xhrPromise();\n  }\n\n\n  onXhrProgress (event) {\n    /*\n    const txt = event.currentTarget.responseText;\n    const latestString = txt.substr(txt.length - event.loaded, event.loaded);\n    console.log(this.typeId() + \" onXhrProgress() read [\" + latestString + \"]\");\n    */\n    //debugger;\n    this.onXhrRead();\n\n  }\n\n  onXhrLoadEnd (event) {\n    if (this.didAbort()) {\n      return;\n    }\n    //console.log(this.typeId() + \" onXhrLoadEnd() bytes [[\" + this.fullContent() + \"]]\");\n\n    //debugger\n    const isError = this.xhr().status >= 300\n    if (isError) {\n      console.log(this.description());\n      console.error(this.xhr().responseText);\n      const json = JSON.parse(this.xhr().responseText);\n      if (json.error) {\n        this.onError(new Error(json.error.message));\n      } else {\n        this.onError(new Error(\"request error code:\" + this.xhr().status + \")\"));\n      }\n    } else {\n      this.readXhrLines() // finish reading any remaining lines\n    }\n\n\n    if (this.stoppedDueToMaxTokens()) {\n      // continue with another request\n      this.continueRequest();\n      return;\n    } else if (this.stopError()) {\n      if (!this.error()) {\n        // we don't want to overwrite a custom error if it's already set\n        this.onError(this.stopError());\n      }\n      return;\n    }\n    this.sendDelegate(\"onStreamEnd\");\n    this.sendDelegate(\"onRequestComplete\")\n\n    this.setStatus(\"completed \" + this.responseSizeDescription());\n    this.xhrPromise().callResolveFunc(this.fullContent()); \n\n    console.log(this.typeId() + \" onXhrLoadEnd()\");\n\n    //const completionDict = this.bodyJson();\n    //console.log(\"completionDict.usage:\", JSON.stringify(completionDict.usage, 2, 2)); // no usage property!\n  }\n\n  continueMessage () {\n    return { \n      role: \"user\", \n      content: `Your last request was truncated due to the response size limit. \n      Please continue exactly where you left off. \n      I will paste this message at the end of your last message in the conversation so it is critical that you continue exactly where you left off, so do not add any comments about the fact that you are continuing the prior response.\n      Such comments would break any structured data, such as JSON, that is being returned.`\n    };\n  }\n\n  responseMessage () {\n    return {\n      role: \"assistant\",\n      content: this.fullContent()\n    }\n  }\n\n  lastMessageIsContinueRequest () {\n    const messages = this.bodyJson().messages;\n    const lastMessage = messages.last();\n    // continueMessage is the user request for the ai to continue it's last message \n    return lastMessage && lastMessage.content === this.continueMessage().content;\n  }\n\n  retryRequest () {\n    this.setError(null);\n    this.setFullContent(this.fullContent().substring(0, this.continuationStartIndex()));\n    this.setXhr(null);\n    // TODO need to track where coninutation read index was\n    this.setReadIndex(0); // this is the read index on the new xhr responseText, not the AiRequest fullContent\n    this.setStopReason(null);\n    this.setStatus(\"retrying\");\n    this.setXhrPromise(null);\n    this.asyncSendAndStreamResponse();\n  }\n\n  copyBody () {\n    this.body().copyToClipboard();\n    return this;\n  }\n\n  copyMessages () {\n    const messages = this.bodyJson().messages;\n    const content = JSON.stringify(messages, 2, 2);\n    content.copyToClipboard();\n    return this;\n  }\n\n  continueRequest () {\n    console.log(\"========================================== \" + this.typeId() + \" continueRequest() =====================================\");\n    const lastBit = this.fullContent().slice(-100);\n    console.log(\"continuing lastBit: [[[\" + lastBit + \"]]]\");\n    // add a continue message to the end of the messages array if needed\n    //if (this.lastMessageIsContinueRequest()) {\n    const messages = this.bodyJson().messages;\n    this.setContinuationStartIndex(this.fullContent().length); // clip back to here if we retry the new request\n    if (this.isContinuation()) {\n      messages.secondToLast().content += this.fullContent();\n    } else {\n      messages.push(this.responseMessage());\n      messages.push(this.continueMessage());\n    }\n\n    // clear request state except fullContent\n    this.setXhr(null);\n    this.setReadIndex(0); // this is the read index on the responseText, not the fullContent\n    this.setStopReason(null);\n    this.setStatus(\"continuing\");\n\n   // debugger;\n    this.setIsContinuation(true); // so the fullContent isn't cleared\n    // send request again to continue where we left off\n    this.asyncSendAndStreamResponse();\n  }\n\n  didUpdateSlotError (oldValue, newValue) {\n    //debugger\n    if (newValue) {\n      this.setStatus(\"ERROR: \" + newValue.message)\n    }\n  }\n\n  retryWithDelay (seconds) {\n    console.log(this.typeId() + \" retrying in \" + seconds + \" seconds\");\n    this.addTimeout(() => { \n      this.retryRequest();\n    }, seconds*1000);\n  }\n\n  \n  onError (e) {\n    this.setError(e);\n\n    if (this.isRecoverableError()) {\n      const d = this.retryDelaySeconds();\n      const f = 2; // exponential backoff factor\n      const nd = (d*f).randomBetween(d*f*f); // random spot between the next two exponential points\n      this.retryWithDelay(nd);\n      this.setRetryDelaySeconds(nd);\n      const ts = TimePeriodFormatter.clone().setValueInSeconds(nd).formattedValue();\n      e.message = this.service().title() + \" overloaded, retrying in \" + ts;\n    }\n\n    console.warn(\" ======================= \" + this.type() + \" ERROR: \" + e.message + \" ======================= \");\n    //debugger;\n    this.sendDelegate(\"onRequestError\", [this, e]);\n\n    if (e) {\n      console.warn(this.debugTypeId() + \" \" + e.message);\n    }\n    return this;\n  }\n\n  onXhrError (event) {\n    debugger;\n    const xhr = this.xhr();\n    // error events don't contain messages - need to look at xhr and guess at what happened\n    //let s = \"Error on Xhr requestId \" + this.requestId() + \" \";\n    let s = \"Xhr error: \" + this.description() + \" \";\n    s += \" status: \" + this.nameForXhrStatusCode(xhr.status); // e.g. 404 = file not found\n    s += \", statusText: '\" + xhr.statusText + \"'\";\n    s += \", readyState: \" + this.nameForXhrReadyState(xhr.readyState); // e.g.. 4 === DONE\n    const error = new Error(s);\n    this.onError(error);\n    this.sendDelegate(\"onStreamEnd\");\n    this.xhrPromise().callRejectFunc(error);\n  }\n\n\tnameForXhrStatusCode (statusCode) {\n\t\t/**\n\t\t   * This function returns a brief description of an XHR status code.\n\t\t   * \n\t\t   * @param {number} statusCode - The XHR status code.\n\t\t   * @returns {string} - A brief description of the status, or \"Unknown status\".\n\t\t   */\n\t\n\t\tconst xhrStatuses = {\n\t\t  0: \"Not started: Network Error, Request Blocked, or CORS issue\",\n\t\t  100: \"Continue\",\n\t\t  101: \"Switching protocols\",\n\t\t  200: \"OK - Request successful\",\n\t\t  201: \"Created - Resource created\",\n\t\t  301: \"Moved permanently\",\n\t\t  304: \"Not modified\",\n\t\t  400: \"Bad request\", \n\t\t  401: \"Unauthorized\",\n\t\t  403: \"Forbidden\",\n\t\t  404: \"Not found\",\n\t\t  500: \"Internal server error\" \n\t\t};\n\t\n\t\treturn statusCode + \" (\" + (xhrStatuses[statusCode] || \"Unknown status\") + \")\";\n\t  }\n\n  nameForXhrReadyState (readyState) {\n    /**\n     * This function returns a brief description of an XHR readyState.\n     * \n     * @param {number} readyState - The XHR readyState value.\n     * @returns {string} - A brief description of the state, or \"Unknown state\".\n     */\n\n    const xhrStates = {\n      0: \"Request not initialized\",\n      1: \"Server connection established\",\n      2: \"Request received\",\n      3: \"Processing request\",\n      4: \"Request finished\"\n    };\n\n    return status + \" (\" + (xhrStates[readyState] || \"Unknown ready state\") + \")\";\n  }\n\n  onXhrAbort (event) {\n    this.setDidAbort(true);\n    this.setStatus(\"aborted\");\n    this.sendDelegate(\"onStreamEnd\");\n    //this.sendDelegate(\"onStreamAbort\");\n    this.xhrPromise().callRejectFunc(new Error(\"aborted\"));\n  }\n\n  unreadResponse () {\n    const unread = this.xhr().responseText.substr(this.readIndex());\n    return unread\n  }\n\n  readRemaining () {\n    const responseText = this.xhr().responseText;\n\n    if (this.readIndex() >= responseText.length) {\n      return undefined;\n    }\n\n    const newLineIndex = responseText.length;\n    const newLine = responseText.substring(this.readIndex(), newLineIndex);\n    this.setReadIndex(newLineIndex); // advance the read index\n    return newLine;\n  }\n  \n  readNextXhrLine () {\n    const responseText = this.xhr().responseText;\n    const newLineIndex = responseText.indexOf(\"\\n\", this.readIndex());\n  \n    if (newLineIndex === -1) {\n      return undefined; // no new line found\n    }\n  \n    const newLine = responseText.substring(this.readIndex(), newLineIndex);\n\n    /*\n    console.log(\"responseText: [\" + responseText + \"]\");\n    console.log(\"indexes: \" + this.readIndex() + \" -> \" + newLineIndex);\n    console.log(\"newLine: [\" + newLine + \"]\");\n    */\n    this.setReadIndex(newLineIndex + 1); // advance the read index\n  \n    return newLine;\n  }\n\n\n  onXhrRead () {\n    this.readXhrLines()\n  }\n\n  readXhrLines () {\n    throw new Error(this.type() + \" readXhrLines not implemented\");\n  }\n\n  onStreamJsonChunk (json) {\n    throw new Error(this.type() + \" onStreamJsonChunk not implemented\");\n  }\n\n  isActive () {\n    const xhr = this.xhr();\n    if (xhr) {\n      const state = xhr.readyState;\n      return (state >= 1 && state <= 3);\n    }\n    return false;\n  }\n  \n  abort () {\n    if (this.isActive()) {\n      this.xhr().abort();\n    }\n    return this;\n  }\n\n  shutdown () {\n    this.abort();\n    return this;\n  }\n\n  onNewContent (newContent) {\n    //console.log(this.typeId() + \".onNewContent(`\" + newContent + \"`)\");\n    this.setFullContent(this.fullContent() + newContent);\n    this.sendDelegate(\"onStreamData\", [this, newContent]);\n  }\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate()\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        //this.debugLog(this.typeId() + \" sending \" + d.typeId() + \".\" + methodName + \"(\" + (args[1]? args[1] : \"\") + \")\")\n        f.apply(d, args)\n        return true\n      }\n    }\n    return false\n  }\n\n  // --- stopping ---\n\n  okStopReasons () {\n    return [null];\n  }\n\n  hasStopError () {\n    return !this.okStopReasons().includes(this.stopReason());\n  }\n\n  stopError () {\n    if (this.hasStopError()) { \n      return new Error(this.stopReasonDescription());\n    }\n    return null;\n  }\n\n  stopReasonDict () {\n    return new Error(this.type() + \" stopReasonDict not implemented\");\n  }\n\n  stopReasonDescription () {\n    const reason = this.stopReason();\n    const dict = this.stopReasonDict();\n    return dict[reason];\n  }\n\n  stoppedDueToMaxTokens () {\n    throw new Error(this.type() + \" stoppedDueToMaxTokens not implemented\");\n  }\n\n  retriableStopReasons () {\n    return new Set([\"overloaded_error\"]);\n  }\n\n  isRecoverableError () {\n    const e = this.error();\n    if (e) {\n      return this.retriableStopReasons().has(e.name);\n    }\n    return false;\n  }\n\n}).initThisClass();\n",
  "Idwqsp8vXVz8swzhynAf6Ym6IxB9Scf8S0drByKV6Fo=": "\"use strict\";\n\n/* \n    Conversation\n\n*/\n\n(class Conversation extends BMStorableNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"footerNode\", null);\n      slot.setSlotType(\"BMNode\");\n    }\n\n    {\n      //const slot = this.newSlot(\"delegate\", null);\n      //slot.setSlotType(\"Object\");\n    }\n\n  }\n\n  initPrototype () {\n    this.setCanDelete(true);\n    this.setNodeCanEditTitle(true);\n    this.setTitle(\"Untitled\");\n    this.setSubtitle(\"conversation\");\n    this.setNodeCanReorderSubnodes(false);\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n\n    this.setSubnodeClasses([]);\n    this.setNodeChildrenAlignment(\"flex-start\"); // make the messages stick to the bottom\n  }\n\n  init() {\n    super.init();\n\n    {\n      const f = ChatInputNode.clone();\n      f.setCanDelete(false);\n      f.setConversation(this);\n      f.setHasValueButton(true);\n      this.setFooterNode(f);\n    }\n\n  }\n\n  onChatEditValue (v) {\n    // for subclasses to override\n  }\n\n  /*\n  nodeFillsRemainingWidth () {\n    return true;\n  }\n  */\n\n  subviewsScrollSticksToBottom () {\n    return true;\n  }\n\n  finalInit () {\n    super.finalInit();\n    try {\n     // assert(this.subnodeClasses().length > 0, this.type() + \" has no subnode classes\");\n      this.messages().forEach(m => {\n        //assert(this.subnodeClasses().includes(m.thisClass()), m.type() + \" is not in \" + JSON.stringify(this.subnodeClasses().map(c => c.type())));\n        if(!m.setConversation) {\n          debugger;\n          throw new Error(m.type() + \" missing setConversation() \");\n        }\n      });\n    } catch (error) {\n      //debugger;\n      console.log(this.type() + \" finalInit error: \" + error.message);\n      this.removeAllSubnodes();\n    }\n    //debugger;\n    this.messages().forEach(m => m.setConversation(this));\n    this.setNodeCanAddSubnode(false);\n    //this.setNodeFillsRemainingWidth(true);\n    this.setNodeChildrenAlignment(\"flex-end\");\n    this.setCanDelete(true);\n  }\n\n  // --- messages ---\n\n  messages () {\n    return this.subnodes()\n  }\n\n  clear () {\n    this.subnodes().forEach(msg => { \n      if (msg.shutdown) { \n        msg.shutdown() \n      }\n    });\n    this.removeAllSubnodes();\n    return this\n  } \n\n\n  onMessageUpdate (aMsg) {\n    // e.g. sent by OpenAiMessage for things like streaming updates\n    // can be useful for sharing the changes with other clients\n  }\n\n  onMessageComplete (aMsg) {\n    this.footerNode().setValueIsEditable(true)\n    if (aMsg.error() === null) {\n      const pmsg = aMsg.previousMessage() \n      /*\n      if (pmsg && pmsg.value() === this.summaryRequestPrompt()) {\n        // it's a response to a summary request\n        //this.removeSubnodes(aMsg.previousMessages())\n      }\n      */\n      this.checkTokenCount()\n    }\n  }\n\n  onMessageComplete (aMsg) {\n  }\n\n  // -- creating new messages ---\n\n  newMessageOfClass (msgClass) {\n    const m = msgClass.clone();\n    m.setConversation(this);\n    return m;\n  }\n\n  // -- new message instances ---\n\n  newMessage () {\n    const msgClass = this.subnodeClasses().first();\n    const m = this.newMessageOfClass(msgClass);\n    this.addSubnode(m);\n    return m;\n  }\n\n  // --- chat input ---\n\n  acceptsChatInput () {\n    return true;\n  }\n\n  onChatInputValue (v) {\n    debugger;\n    if (!this.acceptsChatInput()) {\n      console.warn(this.type() + \" does not accept chat input\");\n      return;\n    }\n    const m = this.newMessage();\n    m.setContent(v);\n    m.setIsComplete(true);\n    //this.footerNode().setValueIsEditable(false)\n  }\n\n  setChatInputIsEnabled (aBool) {\n    this.footerNode().setValueIsEditable(aBool);\n    return this\n  }\n\n  clearInput () {\n    debugger; // shouldn't need this as TextField has option to do this\n  }\n\n  // --- json ---\n\n  jsonArchive () {\n    const msgsJson = [];\n    this.messages().forEach(msg => {\n      msgsJson.push(msg.jsonArchive());\n    }) // we don't use map because it returns a SubnodesArray instance...\n    assert(Type.isArray(msgsJson));\n\n    const json = {\n      type: this.type(),\n      messages: msgsJson\n    };\n    return json;\n  }\n\n  setJsonArchive (json) {\n    assert(Type.isArray(json.messages)); // sanity check\n\n    this.removeAllSubnodes();\n\n    json.messages.forEach(msgJson => {\n      this.newMessageFromJson(msgJson);\n    });\n    return this;\n  }\n  \n  messageWithId (messageId) {\n    return this.messages().detect(msg => msg.messageId() === messageId)\n  }\n\n  newMessageFromJson (msgJson) {\n    const msg = ConversationMessage.fromJsonArchive(msgJson)\n    msg.setConversation(this)\n    this.addSubnode(msg)\n    return msg\n  }\n\n  updateMessageJson (msgJson) {\n    const oldMsg = this.messageWithId(msgJson.messageId);\n\n    if (oldMsg) {\n      oldMsg.setJsonArchive(msgJson)\n      return oldMsg\n    } else {\n      const newMsg = this.newMessageFromJson(msgJson);\n      if (newMsg.onNewFromNetwork) {\n        newMsg.scheduleMethod(\"onNewFromNetwork\");\n      }\n      SimpleSynth.clone().playReceiveBeep();\n      this.onNewMessageFromUpdate(newMsg);\n      //console.warn(this.typeId() + \" updateMessageJson no message found with messageId '\" + messageId + \"'\");\n      return newMsg;\n    }\n  }\n\n  onNewMessageFromUpdate (newMsg) {\n    // for subclasses to override\n  }\n\n  // --- enable / disable input ---\n\n  /*\n  disableInput () {\n    this.footerNode().disableEnter();\n    return this\n  }\n\n  enableInput () {\n    this.footerNode().enableEnter();\n    return this\n  }\n  */\n\n}.initThisClass());\n",
  "yueHwaqmxLU2bzfvzeTB43EzvAHUMBvShXsU0fpqdRk=": "\"use strict\";\n\n/* \n    ConversationMessage\n\n*/\n\n(class ConversationMessage extends BMTextAreaField {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.overrideSlot(\"key\");\n      slot.setShouldJsonArchive(true);\n      slot.setCanInspect(true);\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.overrideSlot(\"value\");\n      slot.setInitValue(\"\");\n      slot.setShouldJsonArchive(true);\n      slot.setCanInspect(true);\n      slot.setInspectorPath(\"Node/Field/Value\");\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"conversation\", null);\n      slot.setCanInspect(false);\n      slot.setShouldStoreSlot(false);\n      slot.setSlotType(\"Conversation\");\n    }\n\n    {\n      const slot = this.newSlot(\"messageId\", null);\n      slot.setShouldJsonArchive(true)\n      slot.setCanInspect(true);\n      slot.setInspectorPath(\"ConversationMessage\");\n      slot.setShouldStoreSlot(true);\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"senderId\", null);\n      slot.setSlotType(\"String\");\n      slot.setCanInspect(true);\n      slot.setInspectorPath(\"ConversationMessage\");\n      slot.setShouldStoreSlot(true);\n      slot.setShouldJsonArchive(true);\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"inReplyToMessageId\", null);\n      slot.setShouldStoreSlot(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setCanInspect(true);\n      slot.setInspectorPath(\"ConversationMessage\");\n      slot.setShouldStoreSlot(true)\n      slot.setSlotType(\"String\");\n      slot.setShouldJsonArchive(true)\n    }\n\n    {\n      const slot = this.newSlot(\"timestamp\", null);\n      slot.setCanInspect(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setInspectorPath(\"ConversationMessage\");\n      slot.setShouldStoreSlot(true)\n      slot.setSlotType(\"Number\");\n      //slot.setShouldJsonArchive(true)\n    }\n\n    /*\n    {\n      const slot = this.newSlot(\"annotations\", null); // a place for any sort of extra JSON info\n      slot.setShouldStoreSlot(true)\n      slot.setShouldJsonArchive(false)\n    }\n    */\n\n    {\n      const slot = this.newSlot(\"isComplete\", false);\n      slot.setShouldJsonArchive(true)\n      slot.setCanInspect(true);\n      //slot.setDoesHookSetter(true); // no longer needed?\n      slot.setInspectorPath(\"ConversationMessage\");\n      slot.setShouldStoreSlot(true);\n      slot.setSlotType(\"Boolean\");\n      slot.setSyncsToView(true)\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setCanInspect(false);\n      slot.setShouldStoreSlot(false);\n      slot.setSlotType(\"Error\");\n    }\n\n    {\n      const slot = this.newSlot(\"isVisibleToUser\", true);\n      slot.setCanInspect(true);\n      slot.setInspectorPath(\"ConversationMessage\");\n      slot.setSlotType(\"Boolean\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true)\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null);\n      slot.setSlotType(\"Object\");\n      slot.setCanInspect(false);\n      slot.setShouldStoreSlot(false)\n    }\n\n    {\n      const slot = this.newSlot(\"deleteAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Delete\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setCanInspect(true)\n      slot.setActionMethodName(\"delete\");\n    }\n\n    {\n      const slot = this.newSlot(\"deleteFollowingMessagesAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Delete Following Messages\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setCanInspect(true)\n      slot.setActionMethodName(\"deleteFollowingMessages\");\n    }\n  }\n\n  initPrototype () {\n    this.setNodeTileClassName(\"BMChatInputTile\");\n    //this.setOverrideSubviewProto(this.nodeTileClass());\n    this.setKeyIsVisible(true);\n    this.setValueIsEditable(false);\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setCanDelete(true);\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.createIdIfAbsent();\n    //this. (BMTextAreaFieldTile);\n  }\n\n  createIdIfAbsent () {\n    if (!this.messageId()) {\n      this.setMessageId(Object.newUuid());\n    }\n  }\n\n  inReplyToMessage () {\n    const id = this.inReplyToMessageId();\n    if (id) {\n      return this.conversation().messageWithId(id);\n    }\n    return null\n  }\n\n  replies () {\n    const mid = this.messageId()\n    return this.conversation().messages().select(m => m.inReplyToMessageId() === mid)\n  }\n\n  didUpdateSlotIsComplete (oldValue, newValue) {\n    //debugger;\n    if(newValue && this.conversation()) { // so not called during deserialization\n      this.scheduleMethod(\"onComplete\");\n    }\n  }\n\n  onComplete () {\n    // to be overridden by subclasses\n    this.sendDelegate(\"onMessageComplete\");\n  }\n\n  valueIsEditable () {\n    debugger;\n    return this._valueIsEditable && !this.isComplete();\n  }\n\n  setSendInConversation (v) {\n    debugger;\n  }\n\n  valueIsEditable () {\n    return true\n  }\n\n  content () {\n    return this.value()\n  }\n\n  setValue (s) {\n    super.setValue(s)\n    this.directDidUpdateNode() // so updates trigger UI refresh\n    return this\n  }\n\n  setContent (s) {\n    this.setValue(s)\n    //this.directDidUpdateNode()\n    return this\n  }\n\n  subtitle () {\n    let s = this.content()\n    const max = 40\n    if (s.length > max) {\n      s = this.content().slice(0, max) + \"...\"\n    }\n    return this.speakerName() + \"\\n\" + s\n  }\n\n  speakerName () {\n    return this.key()\n  }\n\n  setSpeakerName (s) {\n    return this.setKey(s)\n  }\n\n  // --- conversation history ---\n\n  // --- previous ---\n\n  visiblePreviousMessages () {\n    // subclasses should override for different behaviors\n    return this.previousMessages()\n  }\n\n  previousMessages () {\n    const msgs = this.conversation().messages();\n    assert(msgs.includes(this));\n    return msgs.before(this);\n  }\n\n  /*\n  history () {\n    // previous messqages + this message\n    // doing it this way gives each message (and message sublclass a chance to filter messages\n    const pm = this.previousMessage();\n    const history = pm ? pm.history() : [];\n    history.push(this);\n    return history;\n  }\n  */\n\n  previousMessagesIncludingSelf () {\n    const messages = this.previousMessages();\n    messages.push(this);\n    return messages;\n  }\n\n  previousMessage () {\n    const messages = this.conversation().messages()\n    const i = messages.indexOf(this)\n    if (i > -1) {\n      return messages[i-1]\n    }\n    return null\n  }\n\n  // --- following ---\n\n  followingMessages () {\n    return this.conversation().messages().after(this);\n  }\n\n  followingMessagesIncludingSelf () {\n    const messages = this.followingMessages();\n    messages.unshift(this);\n    return messages;\n  }\n\n  // --- deleting ---\n\n  deleteFollowingMessages () {\n    const messages = this.followingMessages();\n    messages.forEach(m => m.delete());\n    return this;\n  }\n\n  // --- sending ---\n\n  send () {\n  }\n\n  valueError () {\n    const e = this.error()\n    return e ? e.message : null\n  }\n\n  onValueInput () {\n    this.requestResponse()\n  }\n\n  /*\n  cssVariableDict () {\n    return {\n      //\"background-color\": \"var(--body-background-color)\",\n      //\"color\": \"var(--body-color)\",\n      //\"--body-background-color\": \"inherit\"\n    }\n  }\n  */\n\n  delegate () {\n    if (!this._delegate) {\n      return this.conversation()\n    }\n    return this._delegate\n  }\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate()\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        f.apply(d, args)\n        return true\n      }\n    }\n    return false\n  }\n\n  cleanupIfIncomplete () {\n    // called on startup to clean up any incomplete messages\n    // subclasses should override, as needed\n  }\n\n}.initThisClass());\n",
  "5d7V3Om3VoKzGSIATOB3PDNfbqryg3nDUxIPjXMINc0=": "\"use strict\";\n\n/* \n    ChatInputNode \n\n*/\n\n(class ChatInputNode extends BMTextAreaField {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"conversation\", null); \n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"role\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      //slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Object\");\n      //slot.setCanInspect(true)\n    }\n\n    {\n      const slot = this.newSlot(\"hasValueButton\", false);\n      slot.setSlotType(\"Boolean\");\n      slot.setSyncsToView(true);\n    }\n\n    {\n      const slot = this.newSlot(\"isMicOn\", false);\n      slot.setSlotType(\"Boolean\");\n      slot.setSyncsToView(true);\n    }\n\n    /*\n    {\n      const slot = this.newSlot(\"sttSession\", null);\n    }\n    */\n  }\n\n  initPrototype () {\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n\n    this.setNodeTileClassName(\"BMChatInputTile\");\n    this.setKeyIsVisible(false);\n    this.setValue(\"\");\n    this.setCanDelete(true);\n  }\n\n\n  /*\n  didUpdateSlotValue (oldValue, newValue) {\n    super.didUpdateSlotValue(oldValue, newValue);\n    return this;\n  }\n  */\n\n  setValue (v) {\n    //console.log(\"ChatInputNode setValue('\" + v + \"')\");\n    super.setValue(v);\n    return this;\n  }\n\n  // --- value change events ---\n\n  onDidEditValue (valueView) {\n    this.conversation().onChatEditValue(this.value())\n  }\n\n  acceptsValueInput () {\n    return this.conversation() && this.conversation().acceptsChatInput();\n  }\n\n  onValueInput (changedView) {\n    if (this.value()) {\n      this.send()\n    }\n  }\n\n  // --- sending ---\n\n  send () {\n    //this.conversation().onChatInput(this)\n    const v = this.value();\n    this.conversation().onChatInputValue(v);\n    //debugger;\n    this.setValue(\"\"); // clear input view\n    //this.addTimeout(() => {\n      // there seems to be an issue sometimes with the view not getting the update \n      // this timeout is a temporary fix\n      this.scheduleSyncToView();\n    //}, 1);\n    //this.scheduleSyncToView();\n  }\n\n  /*\n\n  valueButtonIconName () {\n    return this.isMicOn() ? \"Mic On\" : \"Mic Off\";\n  }\n\n  onClickValueButton () {\n    this.setIsMicOn(!this.isMicOn());\n    console.log(\"this.isMicOn():\", this.isMicOn());\n    if (this.isMicOn()) {\n      this.setupSttSessionIfNeeded();\n      this.sttSession().start();\n    } else {\n      if (this.sttSession()) {\n        this.sttSession().stop();\n      }\n    }\n    this.didUpdateNode();\n  }\n  */\n\n  /*\n  disable () {\n    //this.setValueIsEditable(false);\n    return this;\n  }\n\n  enable () {\n    //this.setValueIsEditable(true);\n    return this;\n  }\n  */\n\n}.initThisClass());\n",
  "cteuV2aaS1XLzj5I3GPqVPtOXbJV+CnFCdLO/qqT4j8=": "\"use strict\";\n\n/* \n    AiMessage\n\n*/\n\n(class AiMessage extends ConversationMessage {\n\n  validRoles () {\n    /* \n      system: high-level instructions to guide the model's behavior throughout the conversation. \n      user: role represents the user or the person initiating the conversation. You provide user messages or prompts in this role to instruct the model.\n      assistant: role represents the AI model or the assistant. \n      The model generates responses in this role based on the user's prompts and the conversation history.\n    */\n   \n    return [\n      \"system\", \n      \"user\",\n      \"assistant\" \n    ];\n  }\n  \n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"role\", \"user\"); \n      slot.setShouldJsonArchive(true)\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues(this.validRoles())\n      slot.setCanInspect(true);\n      slot.setInspectorPath(this.type());\n    }\n\n    {\n      const slot = this.newSlot(\"isVisibleToAi\", true);\n      slot.setSlotType(\"Boolean\");\n      slot.setShouldStoreSlot(true);\n      slot.setCanInspect(true);\n      slot.setInspectorPath(this.type());\n    }\n\n    {\n      const slot = this.newSlot(\"requestResponseAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Request Response\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setCanInspect(true)\n      slot.setActionMethodName(\"requestResponse\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setCanDelete(true);\n  }\n\n  init () {\n    super.init();\n    this.setContent(\"\");\n  }\n\n  isResponse () {\n    return false;\n  }\n\n  isVisible () {\n    return this.role() !== \"system\";\n  }\n\n  valueIsEditable () {\n    return this.role() === \"user\";\n  }\n\n  aiSpeakerName () {\n    return \"LLM\";\n  }\n\n  content () {\n    return this.value()\n  }\n\n  setContent (s) {\n    this.setValue(s)\n    this.directDidUpdateNode()\n    return this\n  }\n\n  subtitle () {\n    let s = this.content()\n    if (Type.isNullOrUndefined(s)) {\n      s = \"\";\n    }\n\n    const max = 40\n    if (s.length > max) {\n      s = this.content().slice(0, max) + \"...\"\n    }\n    return this.role() + \"\\n\" + s\n  }\n\n  tokenCount () {\n    const s = this.content()\n    if (Type.isNullOrUndefined(s)) {\n      return 0\n    }\n    return Math.ceil(s.length / 4); // approximation\n  }\n\n  service () {\n    return this.conversation().service();\n  }\n\n  messagesJson () {\n    return {\n      role: this.service().serviceRoleNameForRole(this.role()),\n      content: this.contentVisisbleToAi()\n    }\n  }\n\n  contentVisisbleToAi () {\n    return this.content()\n  }\n\n  // --- request response action ---\n\n  canRequestResponse () {\n    return this.isVisibleToAi()\n  }\n\n  requestResponseActionInfo () {\n    return {\n        isEnabled: this.canRequestResponse(),\n        //title: \"\",\n        isVisible: this.canRequestResponse()\n    }\n  }\n\n  send () {\n    throw new Error(\"use requestResponse instead\");\n  }\n\n  responseMsgClass () {\n    return this.conversation().responseMsgClass();\n  }\n\n  requestResponse () {\n    //debugger;\n    const response = this.conversation().newMessageOfClass(this.responseMsgClass());\n    this.conversation().addSubnode(response);\n    response.setSpeakerName(this.conversation().aiSpeakerName());\n    //this.conversation().postShouldFocusSubnode(responseMessage)\n    response.makeRequest();\n    return response;\n  }\n\n  valueError () {\n    const e = this.error()\n    return e ? e.message : null\n  }\n\n  onComplete () {\n    super.onComplete() // sends a delegate message\n    // to be overridden by subclasses\n  }\n  \n  onValueInput () {\n    this.requestResponse()\n  }\n\n  // --- temporary ---\n\n  jsonMsgForSet () {\n    return {\n      name: \"updateAiChatMessage\",\n      payload: this.jsonArchive()\n    }\n  }\n\n  cleanupIfIncomplete () {\n    super.cleanupIfIncomplete();\n    if (!this.isComplete()) {\n      if (this.role() === \"user\") {\n        this.cleanupUserMessage();\n      } else {\n        this.cleanupAssistantMessage();\n      }\n    }\n  }\n\n  cleanupAssistantMessage () {\n    if (this.type() === \"AiResponseMessage\") {\n    //if (this.type() !== \"HwRollRequestMessage\" && this.type() !== \"HwImageMessage\") {\n      //debugger;\n      // TODO: add sanity check before deleting\n      this.deleteFollowingMessages(); \n      this.setContent(\"\");\n      this.makeRequest();\n    }\n  }\n\n  cleanupUserMessage () {\n    //debugger;\n    // TODO: add sanity check before deleting\n    this.deleteFollowingMessages();\n    this.requestResponse();\n  }\n\n}.initThisClass());\n",
  "vt6XIyLIGvXLynjInxVZHdsYdnqeWZsOQxSy8+luxmw=": "\"use strict\";\n\n/* \n    AiResponseMessage\n\n*/\n\n(class AiResponseMessage extends AiMessage {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"request\", null);\n      slot.setAllowsNullValue(true);\n      slot.setLabel(\"request\");\n      slot.setShouldStoreSlot(true); // TODO: remove when not debugging\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"AiRequest\");\n      slot.setCanInspect(true);\n    }\n\n    {\n      const slot = this.newSlot(\"requestClass\", null);\n      slot.setAllowsNullValue(true);\n      slot.setLabel(\"Request Class\");\n      slot.setShouldStoreSlot(false);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"AiRequest Class\");\n      slot.setCanInspect(false);\n    }\n\n    {\n      const slot = this.newSlot(\"isResponse\", false);\n      slot.setShouldStoreSlot(true)\n      slot.setSlotType(\"Boolean\")\n      slot.setCanInspect(true);\n      slot.setInspectorPath(this.type());\n    }\n\n    {\n      const slot = this.newSlot(\"retryCount\", 0);\n      slot.setCanInspect(true);\n      slot.setInspectorPath(this.type());\n      slot.setSlotType(\"Number\");\n      //slot.setShouldStoreSlot(true);\n    }\n\n    {\n      const slot = this.newSlot(\"summaryMessage\", null);\n      slot.setSlotType(\"String\");\n      slot.setInspectorPath(this.type());\n      //slot.setShouldStoreSlot(true);\n    }\n\n    {\n      // See: https://aipromptskit.com/openai-temperature-parameter/\n      const slot = this.newSlot(\"temperature\", 0.7); // 0-1, higher = more creative // was 0.7\n      slot.setCanInspect(true);\n      slot.setInspectorPath(this.type());\n      slot.setSlotType(\"Number\");\n      //slot.setShouldStoreSlot(true);\n    }\n\n    {\n      // See: https://aipromptskit.com/openai-temperature-parameter/\n      const slot = this.newSlot(\"topP\", 0.8); // 0-1, higher = more diverse // top_p on Claude3 // was 0.8\n      slot.setCanInspect(true);\n      slot.setInspectorPath(this.type());\n      slot.setSlotType(\"Number\");\n      //slot.setShouldStoreSlot(true);\n    }\n\n    {\n      const slot = this.newSlot(\"completionPromise\", null);\n      slot.setSlotType(\"Promise\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n  }\n\n  init () {\n    super.init();\n    this.setContent(\"\")\n    this.setCanDelete(true);\n    this.setIsVisibleToAi(true);\n    this.setRole(\"assistant\");\n\n    this.setRequestClass(AiRequest); // subclasses should set this\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.setCompletionPromise(Promise.clone());\n    if (this.isComplete()) {\n      this.completionPromise().callResolveFunc(this.content());\n    }\n  }\n\n  requestClass () {\n    const node = this.firstParentChainNodeThatRespondsTo(\"chatRequestClass\");\n    return node.chatRequestClass();\n  }\n\n  isResponse () {\n    return true;\n  }\n\n  /*\n  finalInit () {\n    super.finalInit();\n  }\n  */\n\n  valueIsEditable () {\n    return false;\n  }\n\n  aiSpeakerName () {\n    return \"OpenAI\"\n  }\n\n  send () {\n    throw new Error(\"shouldn't call send on a response\");\n    // NOTE: things like system messages for prompt are not response messages, so we can send them\n  }\n\n  requestResponse () {\n    throw new Error(\"shouldn't call requestResponse on a response\");\n  }\n\n  // --- send request -------------\n\n  chatModel () {\n    return this.conversation().chatModel()\n  }\n\n  service () {\n    return this.conversation().service()\n  }\n\n  apiKey () {\n    return this.service().apiKey()\n  }\n\n  // --- make a request --- \n\n  /*\n  assertValidRequest () {\n    assert(this.validRoles().includes(this.role()))\n  }\n  */\n\n  makeRequest () {\n    this.setError(null);\n    const request = this.newRequest();\n    this.setRequest(request);\n    request.asyncSendAndStreamResponse();\n    return this\n  }\n\n  /*\n  historySummary () {\n    const lines = [];\n    messages.forEach((m, i) => { \n      const v = m.isVisibleToAi() ? \"V\" : \"X\";\n      const parts = [i, v, m.type(), m.role()];\n      const size = Math.floor(m.content().length/1000) + \" k\";\n      let description = \"\"\n      if (m.reason) {\n        description = m.reason() \n      }\n\n      if (m.content().length < 500) {\n        description = '\"' + m.content() + '\"';\n      }\n\n      parts.push(description);\n\n      if (m.content().length > 500) {\n        parts.push(\"(\" + size + \")\");\n      }\n\n      const line = parts.join(\" \");\n      lines.push(line);\n    });\n\n    //console.log(this.type() + \".newRequest() history:\"); \n    //console.log(lines.join(\"\\n\"));\n    //debugger;\n    //this.visiblePreviousMessages(); // TODO : REMOVE AFTER DEBUGGING\n  } \n  */\n\n  jsonHistory () {\n    // subclasses can override this to modify the history sent with the request\n    const messages = this.visiblePreviousMessages();\n    let jsonHistory = messages.map(m => m.messagesJson());\n    if (this.conversation().filterJsonHistory) {\n      jsonHistory = this.conversation().onFilterJsonHistory(jsonHistory);\n    }\n    return jsonHistory;\n  }\n\n  newRequest () {\n    const request = this.requestClass().clone();\n    request.setService(this.service());\n\n    request.setDelegate(this);\n    //request.setStreamTarget(this); // unify with delegate\n\n    request.setBodyJson({\n      model: this.chatModel().modelName(),\n      temperature: this.temperature(), \n      top_p: this.topP(),\n      messages: this.jsonHistory()\n    });\n    return request;\n  }\n\n  showRequestInfo () {\n\n  }\n\n  visiblePreviousMessages () {\n    // give conversation a chance to control this\n    // which may be useful for summaries\n    const messages = this.conversation().aiVisibleHistoryForResponse(this); \n    return messages;\n  }\n\n  // --- handle request delegate messages ---\n\n  onRequestBegin (aRequest) {\n\n  }\n\n  onRequestError (aRequest) {\n    console.log(\"ERROR: \", aRequest.error().message);\n    this.setError(aRequest.error());\n    const msg = aRequest.error().message;\n    /*\n    if (msg.includes(\"Please try again in 6ms.\")) {\n      this.setRetryCount(this.retryCount() + 1);\n      const seconds = Math.pow(2, this.retryCount());\n      console.warn(\"WARNING: retrying openai request in \" + seconds + \" seconds\");\n      this.addTimeout(() => this.makeRequest(), seconds*1000);\n    }\n    */\n  }\n\n  valueError () {\n    const e = this.error();\n    return e ? e.message : null;\n  }\n\n  onComplete () {\n    super.onComplete() // sends a delegate message\n    this.completionPromise().callResolveFunc();\n    // to be overridden by subclasses\n  }\n\n  onRequestComplete (aRequest) {\n   // debugger;\n    //this.setRequest(null)\n    //this.setStatus(\"complete\")\n    this.setIsComplete(true);\n    this.sendDelegate(\"onMessageComplete\");\n  }\n\n  // --- response tag ---\n\n  beginsWithResponseTag () {\n    return this.fullContent().startsWith(\"<response>\");\n  }\n\n  endsWithResponseTag () {\n    return this.fullContent().endsWith(\"</response>\");\n  }\n\n  // --- stream target events ---\n\n  onStreamStart (request) {\n  }\n  \n  onStreamData (request, newContent) {\n    this.setContent(request.fullContent())\n    this.sendDelegate(\"onMessageUpdate\")\n  }\n  \n  onStreamEnd (request) {\n    //debugger;\n    //this.setContent(request.fullContent()); // all data has already been sent\n    this.setIsComplete(true);\n    this.sendDelegate(\"onMessageUpdate\");\n  }\n\n  onValueInput () {\n    this.requestResponse();\n  }\n\n  shutdown () {\n    if (this.request()) {\n      this.request().shutdown();\n      this.setRequest(null);\n    }\n  }\n\n  delete () {\n    this.shutdown();\n    return super.delete();\n  }\n\n}.initThisClass());\n",
  "//Ugbl+Lx4XV84hS9cwFw3TgYNnv2vX4Y7rp8sLxDWg=": "\"use strict\";\n\n/* \n    AiConversation\n\n*/\n\n(class AiConversation extends Conversation {\n\n  /*\n  static oneShotRequest (prompt) {\n    const conversation = this.clone();\n    const responseMessage = conversation.startWithPrompt(prompt);\n    return responseMessage;\n  }\n  */\n  \n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"chatModel\", null); // ref to AiChatModel\n      slot.setSlotType(\"AiChatModel\");\n    }\n\n\n    {\n      const slot = this.newSlot(\"initialMessagesCount\", 3); // Number of initial messages to always keep\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"responseMsgClass\", null); \n      slot.setSlotType(\"AiResponseMessage\");\n    }\n\n    // token counting\n\n    {\n      const slot = this.newSlot(\"tokenCount\", 0); // sum of tokens of all messages\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"tokenBuffer\", 400); // Buffer to ensure approximation doesn't exceed limit\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"service\", null); // pointer to AiService instance\n      slot.setSlotType(\"AiService\");\n    }\n\n    {\n      const slot = this.newSlot(\"tagDelegate\", null); // delegate to receive tag messages from responses\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"aiSpeakerName\", null); // name of the AI speaker\n      slot.setSlotType(\"String\");\n    }\n\n  }\n\n  initPrototype () {\n    this.setSubnodeClasses([AiMessage]);\n    this.setResponseMsgClass(AiResponseMessage);\n  }\n\n  // -------- \n\n  service () {\n    return this.chatModel().service();\n  }\n\n  chatModel () {\n    if (this._chatModel) {\n      return this._chatModel;\n    }\n\n    if (this.conversations()) {\n      return this.conversations().service().defaultChatModel();\n    } else {\n      const model = App.shared().services().defaultChatModel();\n      assert(model, \"no default chat model\");\n      return model;\n    }\n\n    throw new Error(\"no chatModel\");\n    return null;\n  }\n\n  conversations () {\n    const p = this.parentNode();\n    if (p && p.thisClass().isKindOf(AiConversations)) {\n      return p;\n    }\n    return null;\n  }\n\n  // --- summary ---\n\n  inputTokenLimit () {\n    return this.chatModel().inputTokenLimit();\n  }\n\n  updateTokenCount () {\n    /*\n    const count = this.subnodes().sum(message => message.tokenCount())\n    this.setTokenCount(count)\n    */\n    return this\n  }\n\n  // -- managing tokens ---\n\n  checkTokenCount () {\n    this.updateTokenCount()\n    const tc = this.tokenCount()\n    //console.log(\"token count: \", tc)\n    if (tc > this.inputTokenLimit() * 0.9) {\n      this.compactTokens()\n    }\n  }\n\n  compactTokens () {\n    // skip for now\n    /*\n    const m = this.messages().last()\n    m.sendSummaryMessage()\n    */\n  }\n\n  // --- new messages ---\n  // this is a bit verbose, but (for now) I like the explicitness \n  // and that it might make it easier to support other AI services\n\n  newAssistantMessage () {\n    const m = this.newMessage();\n    m.setSpeakerName(this.aiSpeakerName());\n    m.setRole(\"assistant\");\n    m.setConversation(this);\n    return m;\n  }\n\n  newSystemMessage () {\n    const m = this.newMessage();\n    m.setSpeakerName(\"System Message\");\n    m.setRole(\"system\");\n    m.setIsComplete(true);\n    m.setIsVisibleToUser(false);\n    m.setConversation(this);\n    return m;\n  }\n\n  newUserMessage () {\n    const m = this.newMessage();\n    m.setSpeakerName(\"User\"); // caller should override this\n    m.setRole(\"user\");\n    m.setConversation(this);\n    return m;\n  }\n\n  newResponseMessage () {\n    const m = this.newMessageOfClass(this.responseMsgClass());\n    m.setConversation(this);\n    this.addSubnode(m);\n    return m;\n  }\n\n  // --- chat actions ---\n\n  aiSpeakerName () {\n    if (this._aiSpeakerName) {\n      return this._aiSpeakerName;\n    }\n    return this.chatModel().title().toUpperCase()\n  }\n\n  onChatInputValue (v) {\n    const userMsg = this.newUserMessage();\n    userMsg.setContent(v);\n    userMsg.setIsComplete(true);\n    const responseMessage = userMsg.requestResponse();\n    //this.footerNode().setValueIsEditable(false); // wait for response to enable again\n    SimpleSynth.clone().playSendBeep();\n    return responseMessage; \n  }\n\n  startWithPrompt (prompt) {\n    this.clear();\n    const promptMsg = this.newSystemMessage();\n    promptMsg.setContent(prompt);\n    const responseMessage = promptMsg.requestResponse();\n    return responseMessage;\n  }\n\n  onNewMessageFromUpdate (newMsg) {\n    // TODO: we only want to do this when message isComplete\n    /*\n    if (!this.session().isHost() && newMsg.isComplete()) {\n      const responseMessage = newMsg.requestResponse();\n    }\n    */\n  }\n\n  aiVisibleHistoryForResponse (aResponseMessage) {\n    assert(this.messages().includes(aResponseMessage));\n    const previousMessages = this.messages().before(aResponseMessage);\n    const visibleMessages = previousMessages.select(m => m.isVisibleToAi());\n    /*\n      override to support summaries\n    */\n    return visibleMessages;\n  }\n\n  chatRequestClass () {\n    return this.service().chatRequestClass();\n  }\n\n  onMessageComplete (aMsg) {\n    super.onMessageComplete(aMsg);\n    return this;\n  } \n\n  shutdown () {\n    this.messages().forEach(m => m.performIfResponding(\"shutdown\"));\n    return this;\n  }\n\n  // search helpers\n\n  nonImageMessages () {\n    return this.messages().select(m => !m.thisClass().isKindOf(HwImageMessage));\n  }\n\n  incompleteMessages () {\n    return this.nonImageMessages().select(m => !m.isComplete());\n  }\n\n  hasIncompleteMessages () {\n    return this.incompleteMessages().length > 0;\n  }\n\n  activeResponses () {\n    return this.incompleteMessages().filter(m => m.isResponse());\n  }\n\n  hasActiveResponses () {\n    return this.activeResponses().length > 0;\n  }\n\n  syncChatInputState () {\n    //this.footerNode().setValueIsEditable(this.activeResponses().length === 0);\n    return this;\n  }\n\n  acceptsChatInput () {\n    // override Conversation implementation\n    return !this.hasIncompleteMessages();\n  }\n\n  /*\n  prepareForFirstAccess () {\n    super.prepareForFirstAccess();\n    const delegate = this.tagDelegate();\n    if (delegate && delegate.onConversationPrepareForFirstAccess) {\n      delegate.onConversationPrepareForFirstAccess(this);\n    }\n  }\n  */\n\n  sessionStateTagNames () {\n    return [\"session-json\", \"session-update\"];\n  }\n\n  sessionStateTagMap () {\n    const m = new Map();\n    m.set(\"session-json\", \"{content removed as it has been outdated. See session-json tag in the last message of the conversation for the latest session state}\");\n    m.set(\"session-update\", \"{content removed as the patch is already applied. See session-json tag in the last message of the conversation for the latest session state}\");\n    return m;\n  }\n\n  sessionJson () {\n    return null;\n  }\n\n  onFilterJsonHistory (messages) {\n    // subclasses can override this to modify the history sent with the request\n    const json = this.sessionJson();\n    if (json) {\n\n      const lastMessage = messages.last();\n      const jsonHistory = messages.map(m => {\n        if (m !== lastMessage) {\n          m.content = m.content.replaceContentOfHtmlTagMap(this.sessionStateTagMap());\n        } else {\n            const sessionJsonString = JSON.stableStringify(json, 2, 2);\n            m.content = m.content + \"\\n\\n\" +\"<session-json>\" + sessionJsonString + \"</session-json>\";\n          }\n        return m;\n      });\n      return jsonHistory;\n    }\n\n    return messages;\n  }\n\n}.initThisClass());\n",
  "Byr1xdQhXAuFFSpdroLI5HTaGvFNDAlWaU7tQuTsOUQ=": "\"use strict\";\n\n/* \n    AiConversations\n\n    conversations\n    - conversation\n    - - requests\n    - - - request, response\n\n\n*/\n\n(class AiConversations extends BMSummaryNode {\n  initPrototypeSlots () {\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"Conversations\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setNoteIsSubnodeCount(true);\n\n    // subclasses should set this\n    this.setSubnodeClasses([AiConversation]);\n  }\n\n  subviewsScrollSticksToBottom () {\n    return false;\n  }\n\n  service () {\n    return this.parentNode();\n  }\n\n}.initThisClass());\n",
  "W3rmPjCABhbi1jTFAgMqgpC0zJx1ARt5NEZdsEcqdK4=": "\"use strict\";\n\n/* \n    AiService\n\n    A BMSummaryNode that holds the API key and subnodes related to the service.\n\n    Example:\n\n    AiService.shared().setApiKey(\"sk-1234567890\");\n    const hasApiKey = AiService.shared().hasApiKey();\n\n\n*/\n\n(class AiService extends BMSummaryNode {\n\n  modelsJson () {\n    return [];\n  }\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"serviceInfo\", null);\n      //slot.setInspectorPath(\"\");\n      slot.setLabel(\"info\");\n      slot.setShouldStoreSlot(false);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"JSON Object\");\n      slot.setIsSubnodeField(false);\n\n      //slot.setValidValues(values);\n    }\n\n    {\n      const slot = this.newSlot(\"chatEndpoint\", null);\n      //slot.setInspectorPath(\"\");\n      slot.setLabel(\"Chat Endpoint URL\");\n      slot.setShouldStoreSlot(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n    }\n\n    {\n      const slot = this.newSlot(\"apiKey\", \"\")\n      //slot.setInspectorPath(\"\")\n      slot.setLabel(\"API Key\")\n      slot.setShouldStoreSlot(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n    }\n\n      // Role names\n\n      {\n        const slot = this.newSlot(\"systemRoleName\", \"system\");\n        slot.setSlotType(\"String\");\n      }\n  \n      {\n        const slot = this.newSlot(\"assistantRoleName\", \"assistant\");\n        slot.setSlotType(\"String\");\n      }\n  \n      {\n        const slot = this.newSlot(\"userRoleName\", \"user\");\n        slot.setSlotType(\"String\");\n      }\n\n\n    {\n      const slot = this.newSlot(\"models\", null);\n      slot.setFinalInitProto(AiChatModels);\n      slot.setShouldStoreSlot(true); // will need to sync when loading from json\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"AiChatModels\");\n    }\n\n    {\n      const slot = this.newSlot(\"conversations\", null);\n      slot.setFinalInitProto(AiConversations);\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"AiConversations\");\n    }\n\n    {\n      const slot = this.newSlot(\"imagesPrompts\", null);\n      //slot.setFinalInitProto(OpenAiImagePrompts);\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(false);\n      slot.setSlotType(\"OpenAiImagePrompts\");\n    }\n\n    {\n      const slot = this.newSlot(\"ttsSessions\", null);\n      //slot.setFinalInitProto(OpenAiTtsSessions);\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(false);\n      slot.setSlotType(\"OpenAiTtsSessions\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init () {\n    super.init();\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"AI Service\");\n    this.setSubtitle(\"ai services\");\n    this.setModels(AiChatModels.clone());\n    this.setModelsJson(this.modelsJson());\n\n    /*\n    // add a default model, in case there are no models\n    if (this.models().subnodeCount() === 0) {\n      this.models().addSubnode(AiChatModel.clone());\n    }\n    */\n\n    this.fetchAndSetupInfo(); // can't just cache this as key or models may have changed\n  }\n\n  defaultChatModel () {\n    return this.models().subnodes().first(); // first model is the default\n  }\n\n  validateKey (s) {\n    return s.startsWith(\"sk-\");\n  }\n\n  hasApiKey () {\n    return this.apiKey() && this.apiKey().length > 0 && this.validateKey(this.apiKey());\n  }\n\n  defaultChatModelName () {\n    return this.defaultChatModel().modelName();\n  }\n\n  serviceRoleNameForRole (role) {\n    if (role === \"system\") {\n      return this.systemRoleName();\n    }\n\n    if (role === \"assistant\") {\n      return this.assistantRoleName();\n    }\n\n    if (role === \"user\") {\n      return this.userRoleName();\n    }\n\n    throw new Error(\"unknown role \" + role);\n    return role;\n  }\n\n  prepareToSendRequest (aRequest) {\n    // subclasses should override\n    return this;\n  }\n\n  /*\n  fetchAndSetupInfo () {\n    const resourcePath = \"app/info/\" + this.type() + \".json\";\n    const resource = BMResources.shared().resourceForPath(resourcePath);\n    if (!resource) {\n      throw new Error(\"resource not found for path '\" + resourcePath + \"'\");\n    }\n    const data = resource.data();\n    const info = JSON.parse(data);\n    this.setServiceInfo(info);\n    this.setupFromInfo();\n    return this;\n  }\n  */\n\n  async fetchAndSetupInfo () {\n    let info;\n\n    try {\n      info = await this.fetchInfo();\n      this.setServiceInfo(info);\n      this.setupFromInfo();\n    } catch (error) {\n      console.log(this.type() + \".fetchAndSetupInfo() [\" + this.fetchInfoUrl() + \" error: \", error);\n      return;\n    }\n  }\n\n  setupFromInfo () {\n    const info = this.serviceInfo();\n\n    if (info.apiKey) {\n      this.setApiKey(info.apiKey);\n    }\n\n    if (info.chatEndpoint) {\n      this.setChatEndpoint(info.chatEndpoint);\n    }\n\n    if (info.models) {\n      this.setModelsJson(info.models);\n    }\n  }\n\n  setModelsJson (json) {\n    this.models().removeAllSubnodes();\n    json.forEach(modelInfo => {\n      const model = AiChatModel.clone().setJson(modelInfo).setService(this);\n      this.models().addSubnode(model);\n    });\n    return this;\n  }\n\n  fetchInfoUrl () {\n    const baseUrl = window.location.protocol + \"//\" + window.location.hostname + \":\" + window.location.port;\n    const url = baseUrl + \"/app/info/\" + this.type() + \".json\";\n    return url;\n  }\n\n  async fetchInfo () {\n    return fetch(this.fetchInfoUrl())\n      .then(response => response.json())\n      .then(json => {\n        //console.log(\"info response\", json);\n        return json;\n      });\n  }\n\n  chatRequestClass () {\n    // compose the class name from the service name e.g. AnthropicService -> AnthropicRequest \n    const className = this.type().split(\"Service\")[0] + \"Request\";\n    const requestClass = getGlobalThis()[className];\n    if (!requestClass) {\n      throw new Error(\"chatRequestClass \" + className + \" not found\");\n    }\n    return requestClass;\n  }\n\n}.initThisClass());\n",
  "CbofXMIilY2MNfyM1l6d8JMaw7czXmj2e+fVwPuRx4k=": "\"use strict\";\n\n/* \n    AnthropicRequest\n\n    Example request:\n\n\n    curl https://api.anthropic.com/v1/messages \\\n     --header \"anthropic-version: 2023-06-01\" \\\n     --header \"anthropic-beta: messages-2023-12-15\" \\\n     --header \"content-type: application/json\" \\\n     --header \"x-api-key: $ANTHROPIC_API_KEY\" \\\n     --data \\\n    '{\n      \"model\": \"claude-3-opus-20240229\",\n      \"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}],\n      \"max_tokens\": 256,\n      \"stream\": true\n    }'\n\n    Example response:\n\n    {\n      \"completion\": \"Hello! How can I assist you today?\",\n      \"stop_reason\": \"stop_sequence\",\n      \"truncated\": false,\n      \"log_id\": \"abc123\", // the conversation id, used for continuation requests\n      \"usage\": {\n        \"prompt_tokens\": 10,\n        \"completion_tokens\": 20,\n        \"total_tokens\": 30\n      }\n    }\n\n    Contniuation request:\n\n    curl https://api.anthropic.com/v1/complete \\\n      -H \"Content-Type: application/json\" \\\n      -H \"X-API-Key: YOUR_API_KEY\" \\\n      -d '{\n        \"conversation_id\": \"abc123\",\n        \"continuation\": true,\n        \"parent_message_id\": \"def456\"\n      }'\n\n*/\n\n(class AnthropicRequest extends AiRequest {\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"usageInputTokenCount\", 0);\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"usageOutputTokenCount\", 0);\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"betaVersion\", \"tools-2024-05-16\"); // \"messages-2023-12-15\"\n      slot.setSlotType(\"NumbeStringr\");\n    }\n\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(true);\n  }\n\n  apiKey () {\n    return AnthropicService.shared().apiKey();\n  }\n\n  requestOptions () {\n    const apiKey = this.apiKey();\n    const json = {\n      method: \"POST\",\n      headers: {\n        //\"Content-Type\": \"application/json\",\n        \"Content-Type\": \"application/json; charset=UTF-8\",\n        \"anthropic-version\": \"2023-06-01\",\n        \"anthropic-beta\": this.betaVersion(),\n        \"x-api-key\": apiKey,\n        'Accept-Encoding': \"identity\"\n      },\n      body: JSON.stringify(this.bodyJson()),\n    };\n    return json;\n  }\n\n  setupForStreaming () {\n    // subclasses should override this method to set up the request for streaming\n    const body = this.bodyJson();\n    body.stream = true;\n    body.max_tokens = 4096; // current max output tokens allowed by anthropic (as of Claude 3 Opus)\n    return this;\n  }\n\n   // --- streaming ---\n\n  readXhrLines () {\n    try {\n      let line = this.readNextXhrLine();\n\n      while (line !== undefined) {\n        line = line.trim();\n        //console.warn(this.type() + \" readXhrLines() read line: [\" + line + \"]\");\n\n        if (line.length) {\n          if (line.startsWith(\"data:\")) {\n            const s = line.after(\"data:\");\n            const json = JSON.parse(s);\n            this.onStreamJsonChunk(json);\n          } else if (line.startsWith(\"event:\")) {\n            // ingore\n          } else {\n            console.warn(this.type() + \" WARNING: don't know what to do with this line: [\" + line + \"]\");\n            debugger;\n          }\n        }\n        line = this.readNextXhrLine();\n      }\n    } catch (error) {\n      this.onError(error);\n      this.xhrPromise().callRejectFunc(new Error(error));      \n    }\n  }\n\n  onStreamJsonChunk (json) {\n    const type = json.type;\n    if (json.type === \"error\") {\n      const error = new Error(json.error.message);\n      error.name = json.error.type;\n      this.onError(error);\n      this.setStopReason(json.error.type);\n      if (json.error.message === \"Output blocked by content filtering policy\") {\n        //this.fullContent().copyToClipboard();\n      }\n      this.abort();\n //     debugger;\n      return;\n    } else if (type === \"message_start\") {\n      // nothing to do?\n      // example {\"type\": \"message_start\", \"message\": {\"id\": \"msg_1nZdL29xx5MUA1yADyHTEsnR8uuvGzszyY\", \"type\": \"message\", \"role\": \"assistant\", \"content\": [], \n      // \"model\": \"claude-3-opus-20240229, \"stop_reason\": null, \"stop_sequence\": null, \"usage\": {\"input_tokens\": 25, \"output_tokens\": 1}}}\n      if (json.message.usage) {\n        this.setUsageInputTokenCount(json.message.usage.input_tokens);\n      }\n    } else if (type === \"content_block_start\") {\n        this.onNewContent(json.content_block.text);\n    } else if (type === \"content_block_delta\") {\n      this.onNewContent(json.delta.text);\n    } else if (type === \"content_block_stop\") {\n      // nothing to do?\n      // example: {\"type\": \"content_block_stop\", \"index\": 0}\n    } else if (type === \"message_delta\") {\n      // nothing to do?\n      // example: {\"type\": \"message_delta\", \"delta\": {\"stop_reason\": \"end_turn\", \"stop_sequence\":null, \"usage\":{\"output_tokens\": 15}}}\n      this.setStopReason(json.delta.stop_reason);\n    } else if (type === \"message_stop\") {\n      // example: {\"type\": \"message_delta\", \"delta\": {\"stop_reason\": \"end_turn\", \"stop_sequence\":null, \"usage\":{\"output_tokens\": 15}}}\n      if (json.stop_reason) {\n        this.setStopReason(json.stop_reason);\n      } \n    } else if (json.delta) {\n        if (json.delta.usage) {\n          this.setUsageOutputTokenCount(json.delta.usage.output_tokens);\n        }\n        if (json.delta.stop_reason && json.delta.stop_reason !== \"end_turn\") {\n          this.setStopReason(json.delta.stop_reason);\n        }\n    } else if (type === \"ping\") {\n      // a keep alive message?\n      // example: {\"type\": \"message_stop\"}\n    } else {\n      console.warn(this.type() + \" WARNING: don't know what to do with this JsonChunk\", json);\n      debugger;\n    }\n  }\n\n  stopReasonDict () {\n    /*\n    {\n    \"invalid_request_error\": \"Indicates a problem with the format of your request to the API (incorrect parameters, invalid syntax, missing data, etc.).\",\n    \"authentication_error\": \"Your API key is incorrect or invalid.\",\n    \"permission_error\": \"Your API key lacks the permissions required for the endpoint/feature.\",\n    \"not_found_error\": \"The requested resource (e.g., model) was not found.\",\n    \"rate_limit_error\": \"You've exceeded the usage rate limit for your API key.\",\n    \"overloaded_error\": \"Anthropic's systems are temporarily overloaded.\",\n    \"api_error\": \"An unexpected internal error on Anthropic's side\"\n  }\n  */\n\n    return {\n      \"invalid_api_key_error\": \"The provided API key is invalid.\",\n      \"invalid_model_error\": \"The specified model is invalid.\",\n      \"insufficient_quota_error\": \"The account associated with the API key has insufficient quota for this request.\",\n      \"user_rate_limited_error\": \"The user has sent too many requests and is being rate limited.\",\n      \"server_overloaded_error\": \"The server is currently overloaded. Please try again later.\",\n      \"bad_request_error\": \"The request is invalid or malformed.\",\n      \"invalid_response_format_error\": \"The specified response format is invalid.\",\n      \"invalid_temperature_error\": \"The specified temperature value is invalid. It must be a float between 0 and 1.\",\n      \"invalid_max_tokens_error\": \"The specified max_tokens value is invalid. It must be a positive integer.\",\n      \"invalid_stop_sequences_error\": \"The specified stop sequences are invalid.\",\n      \"invalid_top_p_error\": \"The specified top_p value is invalid. It must be a float between 0 and 1.\",\n      \"invalid_presence_penalty_error\": \"The specified presence_penalty value is invalid. It must be a float between -2.0 and 2.0.\",\n      \"invalid_frequency_penalty_error\": \"The specified frequency_penalty value is invalid. It must be a float between -2.0 and 2.0.\",\n      \"invalid_logit_bias_error\": \"The specified logit_bias is invalid.\",\n      \"text_too_long_error\": \"The specified text input exceeds the maximum allowed length.\",\n      \"invalid_stream_error\": \"The specified stream value is invalid. It must be a boolean.\",\n      \"api_key_missing_error\": \"The API key is missing from the request.\",\n      \"model_overloaded_error\": \"The specified model is currently overloaded. Please try again later.\",\n      \"internal_server_error\": \"An unexpected internal server error occurred.\",\n      \"service_unavailable_error\": \"The API service is currently unavailable.\",\n\n      // not sure above errors are correct\n\n      \"api_error\": \"A general API error occurred.\",\n      \"overloaded_error\": \"Anthropic service overloaded\",\n\n      \"invalid_request_error\" : \"Invalid request. Content may be blocked by filter policy.\",\n      \"stop_sequence\": \"The model stopped because it encountered a stop sequence specified in the `stop` parameter of the API request. This is used to stop generation when a particular substring is encountered.\",\n      \"max_tokens\": \"The model stopped because it reached the maximum number of tokens allowed for the response, as specified by the `max_tokens_to_sample` parameter in the API request.\",\n      \"api_request\": \"The model stopped because the `/completions` API endpoint was called again with the same `conversation_id`, interrupting the previous generation.\", \n      null: \"If the model completed its generation normally without encountering a stop sequence, reaching the max tokens limit, or being interrupted, the `stop_reason` will be `null`.\"\n    };\n  }\n\n  okStopReasons () {\n    return [null, \"end_turn\"];\n  }\n  \n  stoppedDueToMaxTokens () {\n    return this.stopReason() === \"max_tokens\";\n  }\n\n  retriableStopReasons () {\n    return new Set([\"overloaded_error\", \"server_overloaded_error\", \"service_unavailable_error\"]);\n  }\n\n  onXhrLoadEnd (event) {\n    const s = this.xhr().responseText;\n    if (s.endsWith(\"Internal Server Error\")) {\n      this.setStopReason(\"internal_server_error\");\n      this.setStopError(new Error(\"Anthropic Internal Server Error\"));\n    }\n    return super.onXhrLoadEnd(event);\n  }\n\n}).initThisClass();\n",
  "u5tPKbrKVIklxZdvoEuWl+C7FC50tOs4oJMqi2yOhTo=": "\"use strict\";\n\n/** \n * @module AiServiceKit.Anthropic\n * @class AnthropicService\n * @extends AiService\n * @description A BMSummaryNode that holds the API key and subnodes for the various Anthropic services.\n * \n * @example\n * AnthropicService.shared().setApiKey(\"sk-1234567890\");\n * const hasApiKey = AnthropicService.shared().hasApiKey();\n*/\n\n(class AnthropicService extends AiService {\n\n  /**\n   * Initializes the class as a singleton.\n   */\n  static initClass () {\n    this.setIsSingleton(true);\n  }\n\n  /**\n   * Returns an array of model configurations.\n   * @returns {Array<Object>} An array of model configuration objects.\n   */\n  modelsJson () {\n    return [\n      {\n        \"name\": \"claude-3-5-sonnet-20240620\",\n        \"title\": \"Claude 3.5 Sonnet\",\n        \"subtitle\": \"Better than 3 with same context size.\",\n        \"contextWindow\": 200000,\n        \"notes\": \"\"\n      },\n      {\n          \"name\": \"claude-3-opus-20240229\",\n          \"title\": \"Claude 3 Opus\",\n          \"subtitle\": \"Largest/Slowest\",\n          \"contextWindow\": 200000,\n          \"notes\": \"\"\n      },\n      {\n          \"name\": \"claude-3-sonnet-20240229\",\n          \"title\": \"Claude 3 Sonnet\",\n          \"subtitle\": \"Medium size and speed\",\n          \"contextWindow\": 200000,\n          \"notes\": \"This model is missing opening description, doesn't make roll request json with required fields\"\n      },\n      {\n          \"name\": \"claude-3-haiku-20240307\",\n          \"title\": \"Claude 3 Haiku\",\n          \"subtitle\": \"Smallest/Fastest\",\n          \"contextWindow\": 200000,\n          \"notes\": \"This model also doesn't make roll request json with required fields\"\n      }\n    ];\n  }\n  \n  /**\n   * Initializes the prototype slots.\n   */\n\n  initPrototypeSlots () {\n  }\n\n  /**\n   * Initializes the service.\n   */\n  init () {\n    super.init();\n  }\n\n  /**\n   * Performs final initialization steps.\n   */\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"Anthropic\");\n    //this.setSystemRoleName(\"user\"); // only replaced in outbound request json // we now move this message into the system property\n  }\n\n  /**\n   * Validates the API key format.\n   * @param {string} s - The API key to validate.\n   * @returns {boolean} True if the API key is valid, false otherwise.\n   */\n  validateKey (s) {\n    return s.startsWith(\"sk-\");\n  }\n\n  /**\n   * Checks if a valid API key is set.\n   * @returns {boolean} True if a valid API key is set, false otherwise.\n   */\n  hasApiKey () {\n    return this.apiKey().length > 0 && this.validateKey(this.apiKey());\n  }\n\n  /**\n   * Prepares the request before sending it to the API.\n   * @param {Object} aRequest - The request object to prepare.\n   * @returns {AnthropicService} The service instance.\n   */\n  prepareToSendRequest (aRequest) {\n    const bodyJson = aRequest.bodyJson();\n    let messages = bodyJson.messages;\n\n    // remove initial system message and place it in the request json\n\n    if (messages.length > 0) {\n      const firstMessage = messages.first();\n      if (firstMessage.role === this.systemRoleName()) {\n        bodyJson.system = firstMessage.content;\n        //firstMessage.content = \"Please begin the game now. Remember to not make action decisions for the players, to use roll requests (instead of making up roll results), and to ask for initiative rolls before combat.\";\n        firstMessage.content = \"Please begin our session now.\";\n        //messages.shift();\n      }\n    }\n\n    // remove messages with empy content\n    messages = messages.filter((message) => { return message.content.length > 0; });\n\n    // merge messages in order to ensure messages alternate between user and assistant roles\n\n    const newMessages = [];\n    let lastRole = null;\n    let mergedMessageCount = 0;\n    messages.forEach((message) => {\n      if (message.role === \"system\") {\n        message.role = this.userRoleName(); //  need to do this now that we're using the system property\n      }\n      if (message.role === lastRole) {\n        const lastMessage = newMessages.last();\n        //lastMessage.content += \"\\n- - - <comment>merged message content</comment> - - -\\n\" \n        lastMessage.content = lastMessage.content + \"\\n\" + message.content;\n      } else {\n        newMessages.push(message);\n      }\n      lastRole = message.role;\n      mergedMessageCount += 1;\n    });\n\n    bodyJson.messages = newMessages;\n    aRequest.setBodyJson(bodyJson);\n\n    if (mergedMessageCount) {\n      //console.log(\"AnthropicService.prepareToSendRequest() merged \" + mergedMessageCount + \" messages\");\n    }\n    return this;\n  }\n\n}.initThisClass());\n",
  "q1y1Ap0QeGBDq/dNg96bGLKMJDaJhPgLqT4YOYOWBZY=": "\"use strict\";\n\n/* \n    OpenAiImage\n\n*/\n\n(class OpenAiImage extends BMSummaryNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"imageUrl\", null);\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"image\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"ImageWell\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n    }\n\n\n    {\n      const slot = this.newSlot(\"revisedPrompt\", null);\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"revised prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n    }\n\n    {\n      const slot = this.newSlot(\"url\", null);\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"url\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n    }\n\n\n    {\n      const slot = this.newSlot(\"fetchAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Fetch\");\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"fetch\");\n    }\n\n    {\n      const slot = this.newSlot(\"error\", \"\"); // String\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      //slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"status\", \"\"); // String\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"isLoading\", false); // String\n      slot.setSlotType(\"Boolean\");\n    }\n\n    this.setTitle(\"Image\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setSubnodeClasses([]);\n    this.setNodeCanAddSubnode(false);\n    this.setNodeCanReorderSubnodes(false);\n    this.setCanDelete(true);\n    this.setNodeFillsRemainingWidth(true);\n  }\n\n  subtitle () {\n    return this.status();\n  }\n\n  images () {\n    return this.parentNode();\n  }\n\n  service () {\n    //return this.images().service()\n    return UndreamedOfApp.shared().services().openAiService();\n  }\n\n  imagePrompt () {\n    return this.images().imagePrompt();\n  }\n\n  // --- checks ---\n\n  isLoaded () {\n    return this.imageUrl() !== null;\n  }\n\n  hasError () {\n    return this.error() !== \"\" && this.error() !== null;\n  }\n\n  // --- generate action ---\n\n  canFetch () {\n    return Type.isString(this.url());\n  }\n\n  fetchActionInfo () {\n    return {\n        isEnabled: this.canFetch(),\n        //title: this.title(),\n        isVisible: true\n    }\n  }\n\n  // --- fetching the image ---\n\n  getProxyUrl () {\n    const proxyUrl = ProxyServers.shared().defaultServer().proxyUrlForUrl(this.url());\n    console.log(this.type() + \" url: '\" + this.url() + \"'\");\n    console.log(this.type() + \" proxy url: '\" + proxyUrl + \"'\");\n    return proxyUrl;\n    //return WebBrowserWindow.shared().rootUrl() + \"/?proxyUrl=\" + encodeURIComponent(this.url())\n  }\n\n  async fetch () {\n    this.setIsLoading(true);\n\n    const url = this.getProxyUrl();\n    this.setStatus(\"fetching...\");\n    //console.log(\"fetch url \" + this.url());\n    console.log(this.type() + \" fetch proxy url: \" + url);\n\n    try {\n      const response = await fetch(url);\n\n      if (!response.ok) {\n          const error = new Error(`HTTP error! Status: ${response.status}`);\n          throw error;\n      }\n\n      const blob = await response.blob();\n      const dataUrl = await blob.asyncToDataUrl();\n      this.onLoaded(dataUrl);\n    } catch (error) {\n      this.onError(error);\n      //error.rethrow();\n    }\n  }\n\n  shutdown () {\n    /*\n    if (this.xhr()) {\n      this.xhr().abort();\n    }\n    */\n   return this;\n  }\n\n  // --- events ---\n\n  onLoaded (imageDataUrl) {\n    this.setIsLoading(false)\n    console.log('Image Data URL: ' + imageDataUrl.length + \" bytes\");\n    this.setImageUrl(imageDataUrl);\n    this.setStatus(\"complete\")\n    this.sendDelegate(\"onImageLoaded\", [this])\n  }\n\n  onError (error) {\n    this.setIsLoading(false)\n    const s = \"ERROR: \" + error.message;\n    console.error(s);\n    this.setError(s);\n    this.setStatus(s)\n    this.sendDelegate(\"onImageError\", [this])\n  }\n\n  delegate () {\n    return this.imagePrompt()\n  }\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate();\n    if (d) {\n      const f = d[methodName];\n      if (f) {\n        f.apply(d, args);\n        return true;\n      }\n    }\n    return false;\n  }\n\n}.initThisClass());\n",
  "AZeJXCa2ISNAq8cIEEPNw5pQbHwa8z6hBmL5jxI5GAw=": "\"use strict\";\n\n/* \n    OpenAiImages\n\n*/\n\n(class OpenAiImages extends BMSummaryNode {\n\n  initPrototypeSlots () {\n    this.setTitle(\"image results\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setSubnodeClasses([OpenAiImage]);\n    this.setNodeCanAddSubnode(false);\n    this.setNodeCanReorderSubnodes(false);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  subtitle () {\n    return this.status()\n  }\n\n  status () {\n    if (this.subnodeCount() && this.hasLoadedAllImages()) {\n      return \"complete\"\n    } else if (this.hasError()) {\n      return \"error loading image\"\n    } else if (this.isLoading()) {\n      return \"loading images...\"\n    }\n    return \"\"\n  }\n\n  imagePrompt () {\n    return this.parentNode()\n  }\n\n  hasLoadedAllImages () {\n    return !this.subnodes().canDetect(sn => !sn.isLoaded())\n  }\n\n  hasError () {\n    return this.subnodes().canDetect(sn => sn.hasError())\n  }\n\n  isLoading () {\n    return this.subnodes().canDetect(sn => sn.isLoading())\n  }\n\n}.initThisClass());\n",
  "n2LYWhqSK83Ztkr6YwZ7DirS6724fbb4sFiahNOecXQ=": "\"use strict\";\n\n/* \n    OpenAiImagePrompt\n\n*/\n\n(class OpenAiImagePrompt extends BMSummaryNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"prompt\", \"\");\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n    }\n\n    {\n      const slot = this.newSlot(\"model\", \"dall-e-3\");\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues([\"dall-e-3\", \"dall-e-2\"])\n      slot.setIsSubnodeField(true)\n    }\n\n    {\n      const slot = this.newSlot(\"quality\", \"standard\");\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues([\"standard\", \"hd\"])\n      slot.setIsSubnodeField(true)\n    }\n\n    {\n      const slot = this.newSlot(\"imageCount\", 1);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"image count\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setValidValues([1]) // dall-e-3 only supports 1\n      //slot.setIsSubnodeField(true)\n    }\n\n    {\n      const slot = this.newSlot(\"imageSize\", \"1792x1024\");\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"image size\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues([\n        \"1024x1024\", // 1:1 (square)\n        \"1792x1024\", // 16:9 (wide)\n        \"1024x1792\"  // 9:16 (tall)\n      ])\n      slot.setIsSubnodeField(true)\n    }\n\n    {\n      const slot = this.newSlot(\"generateAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Generate\");\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"generate\");\n    }\n\n    {\n      const slot = this.newSlot(\"error\", \"\"); // null or String\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      //slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false);\n    }\n\n\n    {\n      const slot = this.newSlot(\"images\", null)\n      slot.setFinalInitProto(OpenAiImages)\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"Array\");\n    }\n\n\n    {\n      const slot = this.newSlot(\"status\", \"\"); // String\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null); \n      slot.setSlotType(\"Object\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setSubnodeClasses([]);\n    this.setNodeCanAddSubnode(false);\n    this.setCanDelete(true);\n    this.setNodeCanReorderSubnodes(false);\n  }\n\n  title () {\n    const p = this.prompt().clipWithEllipsis(15);\n    return p ? p : \"Image Prompt\";\n  }\n\n  subtitle () {\n    return this.status()\n  }\n\n  finalInit() {\n    super.finalInit()\n    this.setCanDelete(true)\n  }\n\n  imagePrompts () {\n    return this.parentNode()\n  }\n\n  service () {\n    //return this.imagePrompts().service()\n    return UndreamedOfApp.shared().services().openAiService()\n  }\n\n  // --- generate action ---\n\n  canGenerate () {\n    return this.prompt().length !== 0;\n  }\n\n  generate () {\n    this.start()\n  }\n\n  generateActionInfo () {\n    return {\n        isEnabled: this.canGenerate(),\n        //title: this.title(),\n        isVisible: true\n    }\n  }\n\n  // --- fetch ---\n\n  async start () {\n    this.setError(\"\");\n    this.setStatus(\"fetching response...\");\n    this.sendDelegate(\"onImagePromptStart\", [this]);\n\n    const apiKey = this.service().apiKey(); // Replace with your actual API key\n    const endpoint = 'https://api.openai.com/v1/images/generations'; // DALL·E 2 API endpoint\n    \n    const bodyJson = {\n        model: this.model(), // not sure this is valid, but it's used in the python API\n        quality: this.quality(), // not sure this is valid, but it's used in the python API\n        prompt: this.prompt(),\n        n: this.imageCount(), \n        size: this.imageSize()\n    };\n    \n    try {\n      const response = await fetch(endpoint, {\n          method: 'POST',\n          headers: {\n              'Authorization': `Bearer ` + apiKey,\n              'Content-Type': 'application/json'\n          },\n          body: JSON.stringify(bodyJson)\n      });\n\n      const resultData = await response.json();\n      this.onSuccess(resultData);\n    } catch (error) {\n      this.onError(error);\n      error.rethrow();\n    }\n  }\n\n  onSuccess (json) {\n    this.sendDelegate(\"onImagePromptLoading\", [this]);\n    /*\n      json format:\n\n      {\n        created: date,\n        data: [\n          {\n            revised_prompt: \"...\",\n            url: \"...\",\n        ]\n    */\n\n    if (json.error) {\n      this.setStatus(\"ERROR: \" + json.error.message);\n      return\n    }\n    \n    // now we need load the images\n    json.data.forEach(imageDict => {\n      const image = this.images().add();\n      //imageResult.setCreated(json.created);\n      image.setTitle(\"image \" + this.images().subnodeCount());\n      image.setRevisedPrompt(imageDict.revised_prompt);\n      image.setUrl(imageDict.url);\n      image.fetch();\n    })\n\n    this.updateStatus()\n    console.log('Success:', json.data);\n  }\n\n  onError (error) {\n    const s = \"ERROR: \" + error.message;\n    console.error(s);\n    this.setError(error.message);\n    this.setStatus(s);\n    this.sendDelegate(\"onImagePromptError\", [this]);\n    this.onEnd();\n  }\n\n  // --- image delegate messages ---\n\n  onImageLoaded (aiImage) {\n    this.didUpdateNode();\n    this.updateStatus();\n    this.sendDelegate(\"onImagePromptImageLoaded\", [this, aiImage]);\n    this.onEnd();\n  }\n\n  onImageError (aiImage) {\n    this.didUpdateNode();\n    this.updateStatus();\n    this.sendDelegate(\"onImagePromptImageError\", [this, aiImage]);\n    this.onEnd();\n  }\n\n  onEnd () {\n    this.sendDelegate(\"onImagePromptEnd\", [this]);\n  }\n\n  updateStatus () {\n    const s = this.images().status();\n    if (s) {\n      this.setStatus(s);\n    }\n  }\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate();\n    if (d) {\n      const f = d[methodName];\n      if (f) {\n        f.apply(d, args);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  shutdown () {\n    // TODO: add request ivar and abort it\n    this.images().subnodes().forEach(image => image.shutdown());\n    return this;\n  }\n\n}.initThisClass());\n",
  "cHC4L1XCWrUBp4untdxA60SDY8iKV3wCiAKGUz1WLKo=": "\"use strict\";\n\n/* \n    OpenAiImagePrompts\n\n*/\n\n(class OpenAiImagePrompts extends BMSummaryNode {\n  \n  initPrototypeSlots () {\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setSubnodeClasses([OpenAiImagePrompt]);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setTitle(\"Text to Image\");\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  service () {\n    return this.parentNode();\n  }\n\n}.initThisClass());\n",
  "2tZiZxuyn0N/jtgd9WuqHjnBqIDZtYf4cC9rdQdmPCI=": "\"use strict\";\n\n/* \n    OpenAiTtsRequest\n \n*/\n\n(class OpenAiTtsRequest extends BMSummaryNode {\n \n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"delegate\", null); // optional reference to service object that owns request \n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"requestId\", null); // needed?\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"apiUrl\", null);\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"bodyJson\", null); // this will contain the model choice and messages\n      slot.setSlotType(\"JSON Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"body\", null); \n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    // fetching\n\n    {\n      const slot = this.newSlot(\"fetchRequest\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"isFetchActive\", false);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"fetchAbortController\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setSlotType(\"Error\");\n    }\n\n    {\n      const slot = this.newSlot(\"status\", \"\");\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"fetchPromise\", null);\n      slot.setSlotType(\"Promise\");\n    }\n\n    {\n      const slot = this.newSlot(\"audioBlob\", null);\n      slot.setSlotType(\"Blob\");\n    }\n\n    {\n      const slot = this.newSlot(\"sound\", null); // WASound\n      slot.setSlotType(\"WASound\");\n    }\n\n    this.setShouldStore(false);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(false);\n    this.setRequestId(this.puuid());\n    this.setTitle(\"Request\");\n\n    this.setFetchPromise(Promise.clone());\n    this.setSound(WASound.clone());\n    this.sound().setFetchPromise(this.fetchPromise());\n  }\n\n  service () {\n    return OpenAiService.shared();\n  }\n\n  subtitle () {\n    return this.status();\n  }\n\n  setService (anObject) {\n    debugger;\n    this.setDelegate(anObject);\n    return this;\n  }\n\n  body () {\n    return JSON.stringify(this.bodyJson(), 2, 2);\n  }\n\n  requestOptions () {\n    const apiKey = this.service().apiKey();\n    return {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${apiKey}`,\n      },\n      body: JSON.stringify(this.bodyJson()),\n    };\n  }\n\n  assertValid () {\n    assert(this.service().hasApiKey(), this.type() + \" apiKey missing\");\n    assert(this.apiUrl(), this.type() + \" apiUrl missing\");\n  }\n\n  showRequest () {\n    this.debugLog(\n      \" request \" +\n      this.requestId() +\n      \" apiUrl: \" +\n        this.apiUrl() +\n        \" body: \" + \n        JSON.stringify(this.bodyJson()) +\n        \"'\"\n    );\n  }\n\n  showResponse () {\n    const json = this.json();\n    this.debugLog(\" response json: \", json);\n    if (json.error) {\n      console.warn(this.type() + \" ERROR:\", json.error.message);\n    }\n  }\n\n  // --- normal response --- \n\n  async asyncSend () {\n    try {\n      this.setStatus(\"fetching\");\n      //this.setIsStreaming(false);\n      this.sendDelegate(\"onRequestBegin\");\n\n      this.assertValid();\n      if (this.isDebugging()) {\n        this.showRequest();\n      }\n\n      const options = this.requestOptions();\n      const controller = new AbortController();\n      this.setFetchAbortController(controller);\n      options.signal = controller.signal; // add the abort controller so we can abort the fetch if needed\n\n      const response = await fetch(this.apiUrl(), options);\n      this.setIsFetchActive(false);\n      this.setFetchAbortController(null);\n      //this.sendDelegate(\"onRequestConnected\");\n\n      const audioBlob = await response.blob();\n      this.fetchPromise().callResolveFunc();\n      this.setAudioBlob(audioBlob);\n      //this.sendDelegate(\"onRequestGotAudioBlob\");\n\n      // need to call asyncPrepareToStoreSynchronously as OutputAudioBlob slot is stored,\n      // and all writes to the store tx need to be sync so the store is in a consistent state for it's\n      // next read/write\n      //await audioBlob.asyncPrepareToStoreSynchronously() \n      //const sound = WASound.fromBlob(audioBlob);\n      this.sound().asyncLoadFromDataBlob(audioBlob);\n\n      this.sendDelegate(\"onRequestComplete\");\n\n    } catch (error) {\n      this.setIsFetchActive(false);\n      console.error('Error:', error);\n      this.onError(error);\n    }\n  }\n\n  abort () {\n    if (this.isFetchActive()) {\n      if (this.fetchAbortController()) {\n        this.fetchAbortController().abort();\n      }\n      return this;\n    } \n\n    return this;\n  }\n\n  shutdown () {\n    this.abort();\n    return this;\n  }\n\n  onError (error) {\n    this.sendDelegate(\"onRequestError\", [this, error]);\n    this.fetchPromise().callRejectFunc(error);\n  }\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate()\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        f.apply(d, args)\n        return true\n      }\n    }\n    return false\n  }\n\n}.initThisClass());\n",
  "GcfyA6jkunJ5sScihMe9TcRfKw6Q20yMQztbNajEqD4=": "\"use strict\";\n\n/* \n    OpenAiTtsSession\n \n    Text to Speech\n\n*/\n\n(class OpenAiTtsSession extends BMSummaryNode {\n\n  speedOptionsJson () {\n    return [1, 1.05, 1.10, 1.15, 1.2, 1.25, 1.5, 1.75, 2];\n    /*\n    return [\n      {\n        \"value\": 1,\n        \"label\": \"1x\",\n      },\n      {\n        \"value\": 1.25,\n        \"label\": \"1.25x\",\n      },\n      {\n        \"value\": 1.5,\n        \"label\": \"1.5x\",\n      },\n      {\n        \"value\": 1.75,\n        \"label\": \"1.75x\",\n      },\n      {\n        \"value\": 2,\n        \"label\": \"2x\",\n      },\n    ];\n    */\n  }\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"prompt\", \"\");\n      slot.setInspectorPath(\"\");\n      //slot.setLabel(\"prompt\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setSummaryFormat(\"none\");\n    }\n\n    {\n      const validModels = [\"tts-1\", \"tts-1-hd\"];\n      const slot = this.newSlot(\"model\", validModels.first());\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues(validModels)\n      slot.setIsSubnodeField(true)\n      slot.setSummaryFormat(\"none\")\n    }\n\n    {\n      const validVoices = [\"alloy\", \"echo\", \"fable\", \"onyx\", \"nova\", \"shimmer\"];\n      //const slot = this.newSlot(\"voice\", validVoices.first());\n      const slot = this.newSlot(\"voice\", \"fable\");\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues(validVoices)\n      slot.setIsSubnodeField(true)\n      slot.setSummaryFormat(\"value key\")\n    }\n\n    {\n      const validResponseFormats = [\"mp3\", \"opus\", \"aac\", \"flac\"];\n      const slot = this.newSlot(\"responseFormat\", validResponseFormats.first());\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"format\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setValidValues(validResponseFormats)\n      slot.setIsSubnodeField(true)\n    }\n\n    {\n      const validValuesJson = this.speedOptionsJson()\n      const slot = this.newSlot(\"speed\", validValuesJson.first());\n      //const slot = this.newSlot(\"speed\", validValuesJson.first().value);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"speed\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setIsSubnodeField(true)\n      slot.setSummaryFormat(\"value key\")\n      slot.setValidValues(validValuesJson)\n    }\n\n    {\n      const slot = this.newSlot(\"generateAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Generate\");\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"generate\");\n    }\n\n    {\n      const slot = this.newSlot(\"error\", \"\"); // null or String\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      //slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false);\n    }\n\n    // --- playing ---\n\n    {\n      const slot = this.newSlot(\"isMuted\", false);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"is muted\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n      slot.setSummaryFormat(\"none\");\n    }\n\n    {\n      const slot = this.newSlot(\"ttsRequestQueue\", null);\n      slot.setDuplicateOp(\"copyValue\")\n      slot.setShouldStoreSlot(false);\n      slot.setSummaryFormat(\"none\");\n      slot.setSlotType(\"Array\");\n\n    }\n\n    {\n      const slot = this.newSlot(\"audioQueue\", null);\n      slot.setDuplicateOp(\"copyValue\")\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"AudioQueue\");\n      slot.setSummaryFormat(\"none\");\n    }\n\n    /*\n    {\n      const slot = this.newSlot(\"outputAudioBlob\", null)\n      slot.setShouldStoreSlot(false);\n      //slot.setIsSubnode(true);\n      slot.setSlotType(\"Blob\");\n    }\n    */\n\n    {\n      const slot = this.newSlot(\"status\", \"\"); // String\n      slot.setInspectorPath(\"\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false);\n      slot.setSummaryFormat(\"none\");\n    }\n\n    {\n      const slot = this.newSlot(\"sound\", null); // latest sound being generated\n      slot.setSlotType(\"WASound\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null); \n      slot.setSlotType(\"Object\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setSubnodeClasses([]);\n    this.setNodeCanAddSubnode(false);\n    this.setCanDelete(true);\n    this.setNodeCanReorderSubnodes(false);\n\n    this.setNodeSubtitleIsChildrenSummary(true);\n    this.setTitle(\"Text to Speech Session\");\n    this.setNoteIsSubnodeCount(true);\n    this.setCanDelete(true);\n  }\n\n  init () {\n    super.init();\n    this.setTtsRequestQueue([]);\n    //if (!this.audioQueue()) {\n      this.setAudioQueue(AudioQueue.clone());\n    //}\n    return this;\n  }\n  \n  /*\n  title () {\n    const p = this.prompt().clipWithEllipsis(30);\n    return p ? p : \"Text to Speech Prompt\";\n  }\n\n  subtitle () {\n    return this.status()\n  }\n  */\n\n  ttsSessions () {\n    return this.parentNode()\n  }\n\n  service () {\n    //return this.ttsSessions().service()\n    return OpenAiService.shared();\n  }\n\n  // ---\n\n  setIsMuted (aBool) {\n    this.audioQueue().setIsMuted(aBool);\n    return this;\n  }\n\n  isMuted () {\n    return this.audioQueue().isMuted();\n  }\n\n  // ---\n\n  // --- generate action ---\n\n  canGenerate () {\n    return this.prompt().length > 0;\n  }\n\n  generateActionInfo () {\n    return {\n        isEnabled: this.canGenerate(),\n        //title: this.title(),\n        isVisible: true\n    }\n  }\n\n  // --- fetch ---\n\n  endpoint () {\n    return \"https://api.openai.com/v1/audio/speech\";\n  }\n\n  newRequest () {\n    const request = OpenAiTtsRequest.clone();\n    request.setApiUrl(this.endpoint());\n    request.setDelegate(this)\n\n    const bodyJson = {\n      model: this.model(), \n      voice: this.voice(), \n      input: this.prompt(),\n      response_format: this.responseFormat(), \n      speed: this.speed()\n    };\n\n    request.setBodyJson(bodyJson);\n    return request;\n  }\n\n  generate () {\n    const request = this.newRequest();\n    this.ttsRequestQueue().unshift(request); // needed?\n    const sound = request.sound();\n    sound.setTranscript(this.prompt());\n    this.queueSound(sound);\n    request.asyncSend();\n    return sound;\n  }\n\n  queueSound (sound) {\n    this.audioQueue().queueWASound(sound);\n    return this;\n  }\n\n  shutdown () {\n    this.stopAndClearQueue();\n    return this;\n  }\n\n  stopAndClearQueue () {\n    this.ttsRequestQueue().forEach(r => r.shutdown());\n    this.setTtsRequestQueue([]);\n\n    this.audioQueue().stopAndClearQueue();\n  }\n\n  onRequestBegin (request) {\n\n  }\n\n  async onRequestComplete (request) {\n    this.setStatus(\"success\");    \n    //this.onEnd();\n    //console.log('Success: got audio blob of size: ' + audioBlob.size);\n  }\n\n  onRequestError (request, error) {\n    const s = \"ERROR: \" + error.message;\n    console.error(s);\n    this.setError(error.message);\n    this.setStatus(s)\n    this.sendDelegate(\"onTtsPromptError\", [this]);\n    //this.onEnd();\n    PanelView.showError(new Error(\"Text to Speech request \" + s));\n    debugger;\n  }\n\n  //onEnd () {\n    // on success or error\n  //}\n\n  sendDelegate (methodName, args = [this]) {\n    const d = this.delegate()\n    if (d) {\n      const f = d[methodName]\n      if (f) {\n        f.apply(d, args)\n        return true\n      }\n    }\n    return false\n  }\n\n  // --- playing audio ---- \n\n  /*\n  queueAudioBlob (audioBlob) { // called by the request once it's complete\n    this.audioQueue().queueAudioBlob(audioBlob);\n    return this;\n  }\n  */\n  \n  pause() {\n    this.debugLog(\"pause()\");\n    this.audioQueue().pause();\n  }\n\n  resume () {\n    this.debugLog(\"resume()\");\n    this.audioQueue().resume();\n  }\n\n}.initThisClass());\n",
  "lrIoZIlDvxpV7L6rNJa9+TRF09Ul6mY6kwFLIfm8pQE=": "\"use strict\";\n\n/* \n    OpenAiTtsSessions\n\n*/\n\n(class OpenAiTtsSessions extends BMSummaryNode {\n  \n  initPrototypeSlots () {\n    this.setSubnodeClasses([OpenAiTtsSession]);\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setTitle(\"Text to Speech Sessions\");\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  service () {\n    return this.parentNode();\n  }\n\n}.initThisClass());\n",
  "jWuM9cPLw5NOcT142rwj4IRG78PR9WEc9jRuhiDXss8=": "\"use strict\";\n\n/* \n    OpenAiRequest\n\n    request:\n\n    curl https://api.openai.com/v1/chat/completions \\\n  -H \"Authorization: Bearer YOUR_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"model\": \"gpt-3.5-turbo\",\n    \"messages\": [{\"role\": \"user\", \"content\": \"Hello!\"}],\n    \"usage\": true\n  }'\n\n\n    response: \n\n    {\n  \"id\": \"chatcmpl-abc123\",\n  \"object\": \"chat.completion\",\n  \"created\": 1677858242,\n  \"model\": \"gpt-3.5-turbo-0301\",\n  \"usage\": {\n    \"prompt_tokens\": 10,\n    \"completion_tokens\": 20,\n    \"total_tokens\": 30\n  },\n  \"choices\": [\n    {\n      \"message\": {\n        \"role\": \"assistant\",\n        \"content\": \"Hello! How can I assist you today?\"\n      },\n      \"finish_reason\": \"stop\",\n      \"index\": 0\n    }\n  ]\n}\n\n*/\n\n(class OpenAiRequest extends AiRequest {\n\n  initPrototypeSlots () {\n\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(true);\n  }\n\n  apiKey () {\n    return OpenAiService.shared().apiKey();\n  }\n\n  requestOptions () {\n    const apiKey = this.apiKey();\n    const bodyJson = this.bodyJson();\n    bodyJson.stream = true;\n    //bodyJson.usage = true;\n    return {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Content-Type\": \"application/json; charset=UTF-8\",\n        \"Authorization\": `Bearer ${apiKey}`,\n        'Accept-Encoding': 'identity', // to avoid dealing with gzip\n      },\n      body: JSON.stringify(this.bodyJson()),\n    };\n  }\n\n   // --- streaming ---\n\n  readXhrLines () {\n    try {\n      let line = this.readNextXhrLine();\n      \n      //console.log(\"LINE: \" + line);\n\n      while (line !== undefined) {\n        line = line.trim()\n        if (line.length) {\n          if (line.startsWith(\"data:\")) {\n            const s = line.after(\"data:\");\n            if (line.includes(\"[DONE]\")) {\n              // skip, stream is done and will close\n              const errorFinishReasons = [\"length\", \"content_filter\", null];\n              if (errorFinishReasons.includes(this.stopReason())) {\n                this.setError(\"finish reason: '\" + this.stopReason() + \"'\");\n              }\n            } else {\n              // we should expect json\n              //console.log(\"LINE: \" + s)\n              const json = JSON.parse(s);\n              this.onStreamJsonChunk(json);\n            }\n          } \n        }\n        line = this.readNextXhrLine();\n      }\n    } catch (error) {\n      this.onError(error);\n      console.warn(this.type() + \" ERROR:\", error);\n      this.xhrPromise().callRejectFunc(new Error(error));      \n    }\n  }\n\n  onStreamJsonChunk (json) {\n    if (json.error) {\n      console.warn(\"ERROR: \" + json.error.message);\n      this.xhrPromise().callRejectFunc(new Error(json.error.message));\n    } else if (\n        json.choices &&\n        json.choices.length > 0\n      ) {\n        const choice = json.choices[0];\n        const stopReason = choice.finish_reason;\n\n        if (choice.delta && choice.delta.content) {\n          const newContent = choice.delta.content;\n          this.onNewContent(newContent);\n          //console.warn(\"CONTENT: \", newContent);\n        }\n\n        if (stopReason) {\n          //debugger;\n          this.setStopReason(stopReason);\n        }\n    } else {\n      if (json.id) {\n        //console.warn(\"HEADER: \", JSON.stringify(json));\n        // this is the header chunk - do we need to keep this around?\n      } else {\n        console.warn(\"WARNING: don't know what to do with this JsonChunk\", json);\n      }\n    }\n  }\n\n  // --- finish reason ---\n\n  okStopReasons () {\n    return [null, \"stop\"];\n  }\n\n  stopReasonDict () {\n    return {\n      \"stop\": \"Natural end or encountered user specified stop sequence.\",\n      \"length\": \"The response reached the specified maximum number of tokens.\",\n      \"null\": \"Likely an internal error or issue. If you encounter this frequently, it's best to contact OpenAI support.\" \n    }\n  }\n\n  stoppedDueToMaxTokens () {\n    const b = this.stopReason() === \"length\";\n    if (b) {\n      debugger;\n    }\n    return b;\n  }\n\n}).initThisClass();\n",
  "gIEyMDeLDsgjGYJWoB9jPmXMpsaVlMkjgR74/x9OfTs=": "\"use strict\";\n\n/* \n    OpenAiService\n\n    OpenAiService is a BMSummaryNode that holds the API key and subnodes for the various OpenAI services.\n\n    Example:\n\n    OpenAiService.shared().setApiKey(\"sk-1234567890\");\n    const hasApiKey = OpenAiService.shared().hasApiKey();\n\n*/\n\n(class OpenAiService extends AiService {\n\n  static initClass () {\n    this.setIsSingleton(true);\n  }\n\n  modelsJson () {\n    return [\n      {\n          \"name\": \"gpt-4o\",\n          \"note\": \"Cheaper and faster than GPT-4 Turbo.\",\n          \"contextWindow\": 128000\n      },\n      {\n          \"name\": \"gpt-4-1106-preview\",\n          \"note\": \"better instruction following\",\n          \"contextWindow\": 128000\n      },\n      {\n          \"name\": \"gpt-4-turbo\",\n          \"contextWindow\": 128000\n      },\n      {\n          \"name\": \"gpt-4-turbo-2024-04-09\",\n          \"contextWindow\": 128000\n      }\n    ];\n  }\n  \n  initPrototypeSlots () {\n    {\n      const slot = this.overrideSlot(\"imagesPrompts\", null);\n      slot.setFinalInitProto(OpenAiImagePrompts);\n      slot.setIsSubnode(true);\n    }\n\n    {\n      const slot = this.overrideSlot(\"ttsSessions\", null);\n      slot.setFinalInitProto(OpenAiTtsSessions);\n      slot.setIsSubnode(true);\n    }\n  }\n\n  init () {\n    super.init();\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"OpenAI\");\n\n    // model and other info is set via OpenAiService.json file\n    // see: https://platform.openai.com/docs/models/gpt-4-turbo-and-gpt-4\n  }\n\n  validateKey (s) {\n    return s.length === 51 && s.startsWith(\"sk-\");\n  }\n\n  hasApiKey () {\n    return this.apiKey().length > 0 && this.validateKey(this.apiKey());\n  }\n\n}.initThisClass());\n",
  "hWhbUplVAQe5zcsglwUrZik8CdXTMMLqRzsvPNP2Ruo=": "\"use strict\";\n\n/* \n    GroqRequest\n\n    Example request:\n\n    curl -X POST \"https://api.groq.com/openai/v1/chat/completions\" \\\n     -H \"Authorization: Bearer $GROQ_API_KEY\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"messages\": [{\"role\": \"user\", \"content\": \"Explain the importance of low latency LLMs\"}], \"model\": \"mixtral-8x7b-32768\"}'\n\n*/\n\n(class GroqRequest extends OpenAiRequest {\n\n  initPrototypeSlots () {\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(true);\n  }\n\n  apiKey () {\n    return GroqService.shared().apiKey();\n  }\n\n  setupForStreaming () {\n    // subclasses should override this method to set up the request for streaming\n    const body = this.bodyJson();\n    body.stream = true;\n    body.max_tokens = 4096; // current max output tokens allowed by Groq\n    return this;\n  }\n\n}).initThisClass();\n",
  "EcBvWM4HpqvzqEqUtAe8COh/HEq/iRDYsiD7Txo3TlM=": "\"use strict\";\n\n/* \n    GroqService\n\n    Holds API key and subnodes for the various Groq services.\n\n*/\n\n(class GroqService extends AiService {\n\n  static initClass () {\n    this.setIsSingleton(true);\n  }\n\n  modelsJson () {\n    return [\n      {\n        \"name\": \"llama-3.1-405b-reasoning\",\n        \"contextWindow\": 131072 \n      },\n      {\n          \"name\": \"llama-3.1-70b-versatile\",\n          \"contextWindow\": 131072\n      },\n      {\n          \"name\": \"llama-3.1-8b-instant\",\n          \"contextWindow\": 131072\n      },\n      {\n          \"name\": \"mixtral-8x7b-32768\",\n          \"contextWindow\": 32768\n      },\n      {\n          \"name\": \"gemma-7b-it\",\n          \"contextWindow\": 8192\n      }\n    ];\n  }\n    \n  initPrototypeSlots () {\n  }\n\n  init () {\n    super.init();\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"Groq\");\n    this.setSystemRoleName(\"user\"); // only replaced in outbound request json\n  }\n\n  hasApiKey () {\n    return this.apiKey().length > 0 && this.validateKey(this.apiKey());\n  }\n\n  validateKey (s) {\n    return s.startsWith(\"gsk_\");\n  }\n\n}.initThisClass());\n",
  "vPF9B8tAxxUALKQZz871XIZfAyRWejgMx3Rb2ZvrL+I=": "\"use strict\";\n\n/* \n    GeminiRequest\n\n    Example CURL request:\n\n  curl -X POST \\\n      -H \"Authorization: Bearer $(gcloud auth print-access-token)\" \\\n      -H \"Content-Type: application/json; charset=utf-8\" \\\n      -d @request.json \\\n      \"https://us-central1-aiplatform.googleapis.com/v1/projects/PROJECT_ID/locations/us-central1/publishers/google/models/gemini-1.0-pro:streamGenerateContent?alt=sse\"\n\n  Example request body JSON:\n\n    {\n      \"contents\": {\n        \"role\": \"ROLE\",\n        \"parts\": { \"text\": \"TEXT\" }\n      },\n      \"system_instruction\":\n      {\n        \"parts\": [\n          {\n            \"text\": \"SYSTEM_INSTRUCTION\"\n          }\n        ]\n      },\n      \"safety_settings\": {\n        \"category\": \"SAFETY_CATEGORY\",\n        \"threshold\": \"THRESHOLD\"\n      },\n      \"generation_config\": {\n        \"temperature\": TEMPERATURE,\n        \"topP\": TOP_P,\n        \"topK\": TOP_K,\n        \"candidateCount\": 1,\n        \"outputTokenLimit\": MAX_OUTPUT_TOKENS,\n        \"stopSequences\": STOP_SEQUENCES,\n      }\n    }\n\n*/\n\n(class GeminiRequest extends AiRequest { \n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"jsonStreamReader\", null);\n    }\n    \n    {\n      const slot = this.newSlot(\"usageOutputTokenCount\", null);\n    }\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(true);\n\n\n    const reader = JsonStreamReader.clone();\n    reader.setDelegate(this);\n    this.setJsonStreamReader(reader);\n    //reader.endJsonStream();\n  }\n\n  apiKey () {\n    return GeminiService.shared().apiKey();\n  }\n\n  setupForStreaming () {\n    return this;\n  }\n\n  requestOptions () {\n    const apiKey = this.apiKey();\n    return {\n      method: \"POST\",\n      headers: {\n        //\"Content-Type\": \"application/json\",\n        \"Content-Type\": \"application/json; charset=utf-8\",\n        'Accept-Encoding': 'identity'\n      },\n      body: JSON.stringify(this.bodyJson())\n    };\n  }\n\n   // --- streaming ---\n\n  async asyncSendAndStreamResponse () {\n    if (!this.isContinuation()) {\n      this.jsonStreamReader().beginJsonStream();\n    }\n    return super.asyncSendAndStreamResponse();\n  }\n    /*\n\n   // NOTE: the data dictionary is all on one line, but I've broken it up here for readability\n\n   data: {\n   \"candidates\":[\n      {\n         \"content\":{\n            \"role\":\"model\",\n            \"parts\":[\n               {\n                  \"text\":\"Avast there, landlubber! Ye be mistaken. I be but a\"\n               }\n            ]\n         },\n         \"safetyRatings\":[\n            {\n               \"category\":\"HARM_CATEGORY_HARASSMENT\",\n               \"probability\":\"LOW\"\n            },\n            {\n               \"category\":\"HARM_CATEGORY_HATE_SPEECH\",\n               \"probability\":\"NEGLIGIBLE\"\n            },\n            {\n               \"category\":\"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n               \"probability\":\"NEGLIGIBLE\"\n            },\n            {\n               \"category\":\"HARM_CATEGORY_DANGEROUS_CONTENT\",\n               \"probability\":\"NEGLIGIBLE\"\n            }\n         ]\n      }\n   ]\n}\n\n   */\n\n   readXhrLines () {\n    try {\n      const newText = this.readRemaining();\n      //console.warn(this.type() + \".readXhrLines() newText: \", newText);\n      if (newText) {\n        this.jsonStreamReader().onStreamJson(newText);\n      } else {\n      }\n    } catch (error) {\n      this.onError(error);\n      this.xhrPromise().callRejectFunc(new Error(error));      \n    }\n  }\n\n  stoppedDueToMaxTokens () {\n    return false; // stopped due to max output tokens per request\n  }\n\n\n  onJsonStreamReaderError (reader, error) {\n    this.setError(error);\n    this.abort();\n  }\n\n  onJsonStreamReaderPopContainer (reader, json) {\n    if (reader.containerStack().length === 2) {\n      this.onStreamJsonChunk(json);\n    }\n  }\n\n  onStreamJsonChunk (json) {\n\n    /*\n      example json:\n      \n      {\n        \"content\":{\n        \"role\":\"model\",\n        \"parts\":[\n            {\n              \"text\":\"Avast there, landlubber! Ye be mistaken. I be but a\"\n            }\n        ]\n      }\n\n\n      data: {\n        \"candidates\":[\n            {\n              \"content\":{\n                  \"role\":\"model\",\n                  \"parts\":[\n                    {\n                        \"text\":\". I be no real-life pirate, but I be mighty good at pretendin'!\"\n                    }\n                  ]\n              },\n              \"finishReason\":\"STOP\",\n              \"safetyRatings\":[\n                  {\n                    \"category\":\"HARM_CATEGORY_HARASSMENT\",\n                    \"probability\":\"NEGLIGIBLE\"\n                  },\n                  {\n                    \"category\":\"HARM_CATEGORY_HATE_SPEECH\",\n                    \"probability\":\"NEGLIGIBLE\"\n                  },\n                  {\n                    \"category\":\"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n                    \"probability\":\"NEGLIGIBLE\"\n                  },\n                  {\n                    \"category\":\"HARM_CATEGORY_DANGEROUS_CONTENT\",\n                    \"probability\":\"NEGLIGIBLE\"\n                  }\n              ]\n            }\n        ],\n        \"usageMetadata\":{\n            \"promptTokenCount\":23,\n            \"candidatesTokenCount\":50,\n            \"totalTokenCount\":73\n        }\n      }\n\n  */\n\n    const candidates = json.candidates;\n\n    if (candidates) {\n      const candidate = candidates[0];\n      if (candidate.content) {\n        const text = candidate.content.parts[0].text;\n        this.onNewContent(text);\n      }\n\n      if (candidate.finishReason) {\n        if (candidate.finishReason !== \"STOP\") {\n          console.warn(\"finishReason: \", candidate.finishReason);\n          this.setStopReason(candidates.finishReason);\n        }\n      }\n\n      if (candidate.safetyRatings) {\n        console.log(\"candidate.safetyRatings: \", candidate.safetyRatings);\n      }\n    }\n\n    if (json.usageMetadata) {\n      this.setUsageOutputTokenCount(json.usageMetadata.totalTokenCount);\n    }\n  }\n\n  stopReasonDict () {\n    return {\n      \"FINISH_REASON_UNSPECIFIED\": \"Default value. This value is unused.\",\n      \"STOP\": \"Natural stop point of the model or provided stop sequence.\",\n      \"MAX_TOKENS\": \"The maximum number of tokens as specified in the request was reached.\",\n      \"SAFETY\": \"The candidate content was flagged for safety reasons.\",\n      \"RECITATION\": \"The candidate content was flagged for recitation reasons.\",\n      \"OTHER\": \"Unknown reason.\"\n    }\n  }\n\n  stoppedDueToMaxTokens () {\n    return this.stopReason() === \"MAX_TOKENS\";\n  }\n\n}).initThisClass();\n",
  "eLjIm9HYjOwa2nWSc1ruLOwXa8l6HxsmSbui1WhZQbE=": "\"use strict\";\n\n/* \n    GeminiService\n\n    GeminiService is a BMSummaryNode that holds the API key and subnodes for the various Groq services.\n\n    REST:\n\n    POST https://{location id}-aiplatform.googleapis.com/v1/projects/{project id}/locations/{location id}/publishers/google/models/{model id}:{generate response method}\n\n\n\n    Example:\n\n    GeminiService.shared().setApiKey(\"sk-1234567890\");\n    const hasApiKey = GeminiService.shared().hasApiKey();\n\n\n    Models:\n\n        Model ID: gemini-1.5-pro\n        Max total tokens (input and output): 1M\n        Max output tokens: 8,192\n\n        Model ID: gemini-1.0-pro\n        Max total tokens (input and output): 32,760\n        Max output tokens: 8,192\n\n*/\n\n(class GeminiService extends AiService {\n\n  static initClass () {\n    this.setIsSingleton(true);\n  }\n\n  modelsJson () {\n    return [\n      {\n          \"name\": \"gemini-1.5-pro-latest\",\n          \"title\": \"Gemini 1.5 Pro\",\n          \"contextWindow\": 2097152,\n          \"outputTokenLimit\": 8192\n      },\n      {\n          \"name\": \"gemini-1.5-flash-latest\",\n          \"title\": \"Gemini 1.5 Flash\",\n          \"contextWindow\": 1048576\n      }\n    ];\n  }\n  \n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"projectId\", null);\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"locationId\", null);\n      slot.setSlotType(\"String\");\n    }\n  }\n\n  init () {\n    super.init();\n  }\n\n  /*\n  requestOptions () {\n    const options = super.requestOptions();\n  }\n  */\n\n  /*\n  endPointUrlFormat () {\n    return \"https://{location id}-aiplatform.googleapis.com/v1/projects/{project id}/locations/{location id}/publishers/google/models/{model id}:{generate response method}\";\n  }\n  */\n\n  endPointUrlFormat () {\n    return \"https://generativelanguage.googleapis.com/v1beta/models/{model id}:{generate response method}?key={api key}\";\n  }\n\n  setupChatEndpoint () {\n    let url = this.endPointUrlFormat();\n    //url = url.replaceAll(\"{location id}\", this.locationId());\n    //url = url.replaceAll(\"{project id}\", this.projectId());\n    url = url.replaceAll(\"{model id}\", this.defaultChatModel().modelName());\n    url = url.replaceAll(\"{generate response method}\", \"streamGenerateContent\");\n    url = url.replaceAll(\"{api key}\", this.apiKey());\n    this.setChatEndpoint(url);\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"Gemini\");\n\n    this.setSystemRoleName(null); // only replaced in outbound request json\n    this.setUserRoleName(\"USER\");\n    this.setAssistantRoleName(\"MODEL\");\n\n    this.setChatEndpoint(null);\n    //this.setupDefault();\n    this.setSystemRoleName(\"user\"); // only replaced in outbound request json\n  }\n\n  /*\n  setupDefault () {\n    this.defaultChatModel().setModelName(\"gemini-1.5-pro\");\n    this.defaultChatModel().setInputTokenLimit(1000000); // wow!\n  }\n  */\n\n  validateKey (s) {\n    return s.startsWith(\"sk-\");\n  }\n\n  hasApiKey () {\n    return this.apiKey().length > 0; // && this.validateKey(this.apiKey());\n  }\n\n  validateKey (token) {\n    /*\n    // 1. Split on Dots:\n    const tokenParts = token.split('.');\n\n    // 2. Check for Three Parts:\n    if (tokenParts.length !== 3) {\n      return false; // A JWT must have header, payload, and signature\n    }\n\n    // 3. Validate Base64URL Encoding:\n    const isValidEncoding = /^[a-zA-Z0-9_-]+\\.[a-zA-Z0-9_-]+\\.[a-zA-Z0-9_-]+$/.test(token);\n\n    // 4. Combined Result:\n    return isValidEncoding;\n    */\n  }\n\n\n  setupFromInfo () {\n    super.setupFromInfo();\n\n    const info = this.serviceInfo();\n\n    if (info.locationId) {\n      this.setLocationId(info.locationId);\n    }\n\n    if (info.projectId) {\n      this.setProjectId(info.projectId);\n    }\n\n    //debugger;\n    this.setupChatEndpoint();\n  }\n\n  /*\n  {\n  \"contents\": [\n    {\n      \"role\": \"USER\",\n      \"parts\": { \"text\": \"Hello!\" }\n    },\n    {\n      \"role\": \"MODEL\",\n      \"parts\": { \"text\": \"Argh! What brings ye to my ship?\" }\n    },\n    {\n      \"role\": \"USER\",\n      \"parts\": { \"text\": \"Wow! You are a real-life priate!\" }\n    }\n  ],\n  \"safety_settings\": {\n    \"category\": \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n    \"threshold\": \"BLOCK_LOW_AND_ABOVE\"\n  },\n  \"generation_config\": {\n    \"temperature\": 0.2,\n    \"topP\": 0.8,\n    \"topK\": 40,\n    \"outputTokenLimit\": 200,\n  }\n}\n*/\n\n  prepareToSendRequest (aRequest) {\n    const bodyJson = aRequest.bodyJson();\n    const geminiBody = {};\n\n    geminiBody.safety_settings = {\n      \"category\": \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n      \"threshold\": \"BLOCK_LOW_AND_ABOVE\"\n    }\n\n    geminiBody.generation_config = {\n      \"temperature\": bodyJson.temperature,\n      \"topP\": bodyJson.top_p,\n      \"topK\": 40,\n      \"outputTokenLimit\": 100000,\n    }\n\n    let messages = bodyJson.messages;\n    \n    // remove initial system message and place it in the request json\n\n    if (messages.length > 0) {\n      const firstMessage = messages.first();\n      if (firstMessage.role === this.systemRoleName()) {\n        bodyJson.system_instruction = {\n          parts: [ \n            { \n              text: firstMessage.content\n            }\n          ]\n        }\n        firstMessage.content = \"Please begin the game now.\";\n        //messages.shift();\n      }\n    }\n\n    geminiBody.contents = messages.map((message) => {\n      return {\n        role: message.role,\n        parts: { \n          text: message.content \n        }\n      }\n    });\n\n    // remove messages with empy content\n    messages = messages.filter((message) => { return message.content.length > 0; });\n\n    aRequest.setBodyJson(geminiBody);\n  }\n\n\n}.initThisClass());\n",
  "K5LTCQ15b4lNBFL+TPtc/EkZClXO3teNhabUkfX5pj0=": "\"use strict\";\n\n/* \n\n  MusicTrack\n\n\n*/\n\n\n\n\n(class MusicTrack extends BMSummaryNode {\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"name\", \"unnamed\");\n      slot.setLabel(\"name\");\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"trackId\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"id\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      //slot.setIsSubnodeField(true);\n      //slot.setCanEditInspection(true);\n    }\n\n    /*\n    {\n      const slot = this.newSlot(\"service\", \"YouTube\");\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"service\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n    }\n    */\n\n    {\n      const slot = this.newSlot(\"togglePlayAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Play\");\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"togglePlay\");\n    }\n\n    {\n      const slot = this.newSlot(\"shouldPlayOnAccess\", true);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    /*\n\n      // optional info\n      {\n        const slot = this.newSlot(\"label\", null);\n        slot.setShouldJsonArchive(true);\n        slot.setSlotType(\"String\");\n      }\n\n      {\n        const slot = this.newSlot(\"transcript\", null);\n        slot.setShouldJsonArchive(true);\n        slot.setSlotType(\"String\");\n      }\n\n    */\n\n    {\n      const slot = this.newSlot(\"isPlaying\", false);\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegateSet\", null);\n      slot.setSlotType(\"Set\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    this.setDelegateSet(new Set());\n    //this.setIsDebugging(true);\n  }\n\n  finalInit () {   \n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setCanDelete(true);\n    super.finalInit();\n  }\n\n  title () {\n    return this.name();\n  }\n\n  subtitle () {\n    return this.isPlaying() ? \"playing\" : \"\";\n  }\n\n    /*\n\n  prepareToAccess () {\n    super.prepareToAccess();\n    if (this.shouldPlayOnAccess()) {\n      this.play();\n    }\n  }\n  */\n\n  library () {\n    return this.firstParentChainNodeOfClass(MusicLibrary)\n  }\n\n  folder () {\n    return this.firstParentChainNodeOfClass(MusicFolder)\n  }\n\n  async play () {\n    const player = this.library().musicPlayer()\n    player.setTrackName(this.name());\n    player.setVideoId(this.trackId());\n    player.setShouldRepeat(false);\n\n    this.setIsPlaying(true);\n    this.post(\"onSoundStarted\");\n    await player.play();\n\n    this.setIsPlaying(false);\n    this.post(\"onSoundEnded\");\n  }\n\n  async stop () {\n    const player = this.library().musicPlayer()\n    await player.stop();\n    this.setIsPlaying(false);\n\n    this.post(\"onSoundEnded\");\n  }\n\n  isMusicTrack () {\n    return true;\n  }\n\n  // --- play action ---\n\n  togglePlay () {\n    if (this.isPlaying()) {\n      this.stop();\n    } else {\n      this.play();\n    }\n    return this;\n  }\n\n  togglePlayActionInfo () {\n    return {\n      isEnabled: true,\n      title: this.isPlaying() ? \"Stop\" : \"Play\",\n      isVisible: true,\n    };\n  }\n\n  // --- delegates --- \n\n  post (methodName) {\n    this.postNoteNamed(methodName);\n    this.sendDelegate(methodName);\n    return this;\n  }\n\n  addDelegate (d) {\n      this.delegateSet().add(d);\n      return this;\n  }\n\n  removeDelegate (d) {\n      this.delegateSet().delete(d);\n      return this;\n  }\n\n  sendDelegate (methodName, args = [this]) {\n      const sendDelegate = (d, methodName, args) => {\n          const f = d[methodName]\n          if (f) {\n            f.apply(d, args)\n          }\n      };\n\n      this.delegateSet().forEach(d => { \n          sendDelegate(d, methodName, args); \n      });\n  }\n\n}).initThisClass();\n",
  "thAaZl/l9IUs6l5jXSMRKAnKtk4y5ejdB1s5Gs3uYKM=": "\"use strict\";\n\n/* \n\n  MusicFolder\n\n\n*/\n\n\n(class MusicFolder extends BMSummaryNode {\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"name\", null);\n      slot.setLabel(\"name\");\n      slot.setInspectorPath(\"\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setSubnodeClasses([MusicTrack, MusicFolder]);\n    this.setNodeCanAddSubnode(true);\n    this.setCanDelete(true);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.makeSortSubnodesByTitle();\n  }\n\n  title () {\n    return this.name();\n  }\n\n  setJson (json) {\n    // json should be an dict of trackName:trackId entries\n\n    Object.keys(json).forEach(trackName => {\n      const trackId = json[trackName];\n      this.newTrack().setName(trackName).setTrackId(trackId);\n    })\n  }\n\n  newTrack () {\n    const track = MusicTrack.clone();\n    this.addSubnode(track);\n    return track;\n  }\n\n  folders () {\n    return this.subnodes().select(sn => sn.thisClass().isKindOf(MusicFolder));\n  }\n\n  tracks () {\n    return this.subnodes().select(sn => sn.thisClass().isKindOf(MusicTrack));\n  }\n\n  trackNames () {\n    return this.tracks().map(sn => sn.name());\n  }\n\n  trackWithName (name) {\n    let track = this.tracks().detect(track => track.name() === name);\n    if (!track) {\n      track = this.folders().detectAndReturnValue(folder => folder.trackWithName(name));\n    }\n    return track;\n  }\n\n  clear () {\n    this.removeAllSubnodes();\n    return this;\n  }\n\n  /*\n  copyMergeTracks (tracks) {\n    tracks.forEach(track => {\n      if (!this.trackWithName(track.name())) {\n        this.newTrack().setName(track.name()).setTrackId(track.trackId());\n      }\n    })\n  }\n  */\n\n}).initThisClass();\n",
  "6H9wniYoCdckTzkOSSS5D/Sj4eZAAcQVrr/w7GumBrI=": "\"use strict\";\n\n/* \n\n  MusicLibrary\n\n  // all tracks are under a Creative Commons License\n\n*/\n\n(class MusicLibrary extends BMSummaryNode {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"currentTrack\", null);\n      slot.setInspectorPath(\"\");\n      //slot.setLabel(\"mute\")\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      //slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true);\n    }\n\n    {\n      const slot = this.newSlot(\"folder\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Folder\")\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setFinalInitProto(MusicFolder);\n      slot.setIsSubnode(true)\n      slot.setSlotType(\"MusicFolder\");\n\n    }\n\n    {\n      const slot = this.newSlot(\"musicPlayer\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Music Player\")\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"YouTubeAudioPlayer\");\n    }\n\n    {\n      const slot = this.newSlot(\"soundEffectPlayer\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Sound Effect Player\")\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"YouTubeAudioPlayer\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setSubnodeClasses([MusicFolder]);\n\n    this.setNodeCanAddSubnode(true);\n    this.setTitle(\"Music Library\");\n    //this.setIsDebugging(true);\n\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setupPlaylists();\n    this.folder().setName(\"Playlists\");\n  }\n\n  musicPlayer () {\n    if (!this._musicPlayer) {\n      const p = YouTubeAudioPlayer.clone();\n      p.setTitle(\"Music Player\");\n      p.setVolume(0.1);\n      this._musicPlayer = p;\n    }\n    return this._musicPlayer;\n  }\n\n  soundEffectPlayer () {\n    if (!this._soundEffectPlayer) {\n      const p = YouTubeAudioPlayer.clone();\n      p.setTitle(\"Sound Effect Player\");\n      p.setVolume(0.5);\n      this._soundEffectPlayer = p;\n    }\n    return this._soundEffectPlayer;\n  }\n\n  shutdown () {\n    if (this._musicPlayer) {\n      this._musicPlayer.shutdown();\n      this.setMusicPlayer(null);\n    }\n\n    if (this._soundEffectPlayer) {\n      this._soundEffectPlayer.shutdown();\n      this.setSoundEffectPlayer(null);\n    }\n\n    return this;\n  }\n\n  setupPlaylists () {\n    const playlistNames = Object.keys(this.playlistDicts());\n    playlistNames.forEach((name) => {\n      const playlist = MusicFolder.clone();\n      playlist.setName(name);\n      this.folder().addSubnode(playlist);\n      playlist.setJson(this.playlistDicts()[name]);\n    });\n    return this;\n  }\n\n  playlistWithName (name) {\n    const match = this.folder().firstSubnodeWithTitle(name);\n    assert(match);\n    return match;\n  }\n\n  playlists () {\n    return this.folder().subnodes();\n  }\n\n  trackWithName (name) {\n    const track = this.playlists().detectAndReturnValue(playlist => {\n      return playlist.trackWithName(name)\n    });\n    return track;\n  }\n\n  playTrackWithName (name) {\n    //debugger;\n    this.debugLog(\"playTrackWithName('\" + name + \"')\");\n    const track = this.trackWithName(name);\n    if (!track) {\n      console.warn(this.type() + \" couldn't find track '\" + name + \"'\");\n      return;\n    }\n    const player = this.musicPlayer();\n    player.setTrackName(track.name());\n    player.setVideoId(track.trackId());\n    player.setShouldRepeat(true);\n    player.play();\n  }\n\n  tracksForPlaylistsWithNames (playlistNames) {\n    const playlists = playlistNames.map(pName => this.playlistWithName(pName));\n    return playlists.map(playlist => playlist.tracks()).flat();\n  }\n\n  async playSoundEffectWithName (name) {\n    const track = this.trackWithName(name);\n    if (!track) {\n      console.warn(this.type() + \" couldn't find track '\" + name + \"'\");\n      return;\n    }\n    const player = this.soundEffectPlayer();\n    player.setTrackName(track.name());\n    player.setVideoId(track.trackId());\n    player.setShouldRepeat(false);\n    await player.play();\n  }\n\n  playlistDicts () {\n    return {\n      Fantasy: {\n        // from https://www.youtube.com/@TheAmbienceChannel\n        \"Underground Drill\": \"V4LMFa1fZGU\",\n        \"Crowded Hall\": \"PuItqOyTDlk\",\n        \"Jade Conquest\": \"t6mNGG6g378\",\n        \"Ingvar's Mead\": \"Os1yu1ZXyUI\",\n        \"Tyrant's March\": \"rA9nO-De1Zc\",\n        \"Ghost Ship\": \"1NzLmREZqSY\",\n        \"Through the Underworld\": \"vFR7QFVCkHs\",\n        Serenity: \"z3UB3yaJee4\",\n        Courage: \"owqcy7sfkE4\",\n        \"They Are Coming\": \"L_BhK3C-u3g\",\n        \"A Dangerous Quest\": \"eQFbkmHjx6I\",\n        \"A City in the Distance\": \"UhyD0m5igv8\",\n        \"Flooding City\": \"BaWvLbEHt28\",\n        \"Bard College\": \"JzRclrjcHV8\",\n        \"Orc Horde\": \"LA_usD5h640\",\n        \"Marid / Water Genie Realms\": \"7phUzXCPmWc\",\n        \"Dao / Earth Genie Realms\": \"80IXXagr_B4\",\n        \"Djinn / Air Genie Realms\": \"ZHB-Yy_4dzU\",\n        \"Mountain Camp\": \"18KN9L4VIGk\",\n        \"Witch's Hut\": \"zIY_-M2lPJY\",\n        \"Revolutionary War / 18th Century War\": \"bfGdYOKBZus\",\n        \"Tropical Coast\": \"LboMqM5mEFA\",\n        \"Haunted Battlefield\": \"QGQltGAWAU0\",\n        \"Haunted House / Creepy Cabin\": \"QVQD9_eB8Qg\",\n        \"Ghostly Procession\": \"wflzworJizA\",\n        \"Monster Parade\": \"fXnIDBEa0Qs\",\n        \"Firework Festival\": \"rkHA54puEhk\",\n        \"Violent Storm\": \"B7PQv77VmSw\",\n        \"Magical Catacombs\": \"pOm1dVXSqG0\",\n        \"Viking Ship\": \"HB_1VXOQbEo\",\n        \"Vampire Castle\": \"8tMZWESYXAA\",\n        \"Preparing for a Trial\": \"sSTVlP1v6-M\",\n        \"Royal Palace\": \"KTH8CuWEOvc\",\n        \"Cursed City - dogs barking, faint conversations, naying of horses\": \"nI-iFEFCySE\",\n        \"Mechanical Dungeon\": \"8lZWC0PwaLA\",\n        Stables: \"QZyoM1nXWRo\",\n        \"Scroll Shop, Scribe's Office\": \"eYKWDUptWA4\",\n        \"Ship Cabin\": \"iVLpFoo7ToA\",\n        \"Burning Star\": \"4hLE7zm1yww\",\n        \"Tavern Party\": \"x3skYa2i6Bg\",\n        \"After a Battle / Empty Battlefield\": \"JElsb_pLXqg\",\n        \"Collapsing Mine\": \"ou245Tc6tt4\",\n        \"New Adventure\": \"5FVpHQJBeKM\",\n        \"Empty Steppe\": \"345Cf-nsdnI\",\n        \"Horse Carriage Chase\": \"WSoBRWF-Cw4\",\n        \"Atlantis Underwater City\": \"T_4VNSHOnGU\",\n        \"Giant's Forge\": \"PEtel5NTwAQ\",\n        \"Training Ground\": \"DnmcTBFZRwU\",\n        \"Autumn Night\": \"8Hr6QEQPhJY\",\n        \"Flagellant Procession\": \"PdhVCPe3XA4\",\n        \"Greek Maritime City\": \"dhQPzfmbjJE\",\n        \"Horror from the Deep | Haunted Lighthouse\": \"_BUlHXNExPM\",\n        \"Will-o'-the-Wisp Swamp\": \"nSm-RIO-1H8\",\n        \"Eldritch Horror\": \"HYkhuvqkOdw\",\n        Watefall: \"sJr1JK3149M\",\n        \"Public Whipping / Flogging\": \"2AsBiBm7YqA\",\n        \"Autumn Forest\": \"TdBX9cjY2mA\",\n        \"Practice Duel Sparring\": \"7DVo4NiYyUc\",\n        \"Steppe / Savanna\": \"gXJM1L1cFpw\",\n        \"Campfire Rest\": \"A1y09YspJvQ\",\n        \"Bubbling Caldron or Acid Pool\": \"E-J9oPhdB5k\",\n        \"Pagan Festival\": \"Z6six5WeZVY\",\n        Brothel: \"_ft7Nk2il_4\",\n        \"Marching Through Rain\": \"nfK5wGJEjjs\",\n        \"Giant Whirlpool\": \"3qo2dMkDEJk\",\n        \"Abandoned Village\": \"FzzZ0Ll7UoA\",\n        \"Peaceful Forest\": \"4B-tHXtHw_k\",\n        \"Midsummer Festival\": \"50kEdch_4ao\",\n        \"Coming of Angels\": \"G2Zmffr4iBU\",\n        \"Water Mill\": \"l123ewMXptU\",\n        \"Spider Cave\": \"qP9lmVaBhDI\",\n        \"Inside a Monster\": \"G7HS6hP21LA\",\n        \"City Gates\": \"u6q2mjSNuU0\",\n        \"Sunset Forest\": \"mcuZQFauy0w\",\n        \"Old Library\": \"1TwQY4dkWv0\",\n        \"Winter War\": \"PFpAPHbYTWo\",\n        \"Tavern Kitchen\": \"qJxSYTRxkiQ\",\n        \"Slave Galley\": \"Rpim1NAFT18\",\n        \"Winter River\": \"VqJ841bDbGo\",\n        \"Making an Ambience\": \"K1AuH72oi5I\",\n        \"End of the World\": \"fDogW8-RL-4\",\n        \"Village Fire\": \"rVmIsBn_dyI\",\n        \"Nighttime Inn\": \"-UmkWl4nvsk\",\n        \"Torture Chambers\": \"lrZA4RoxO_M\",\n        \"Ice Dragon\": \"7B9W6gFZNS0\",\n        \"Trading Post\": \"gOyBE-oBicc\",\n        \"Dangerous Forest\": \"LEs2J01gZX8\",\n        \"Sick Bay\": \"1QLWFguij-Y\",\n        \"Giant Sand Worm\": \"NkziO7QkExk\",\n        \"Carriage in a Storm\": \"8HHtObBH0iE\",\n        \"Cursed Wastes\": \"Af5-S2o7bcM\",\n        \"Blood War\": \"Vx0bqo88XG8\",\n        \"Elemental Chaos\": \"PPQtr5PDaL8\",\n        Abyss: \"aQLvd6h6WTM\",\n        \"Slime Cave\": \"LZeNKZOXAOo\",\n        \"Avernus [Descent Into Avernus]\": \"TTyOsAYD-Ng\",\n        Kraken: \"3hEY8hFQ55o\",\n        Shipwreck: \"z4sWBPr4wGM\",\n        \"Jungle Ruins\": \"f6Ohca45lY4\",\n        \"Garden Pond\": \"8Ic9-r417gs\",\n        \"Cave City\": \"nfjrgINw0l4\",\n        \"Clockwork Tower\": \"RukWUhWekcU\",\n        \"Chariot Battle\": \"vXqVrspYuLs\",\n        \"Forest City\": \"4dmPmVywWMw\",\n        \"Giant's Rage\": \"rJlbizvKSGU\",\n        \"Magic Realm\": \"-zyK1nv5l5s\",\n        \"Giant Heart\": \"m3qV0ZvHLXU\",\n        \"Valhalla | Eternal Battle\": \"3bY-zIGNZxs\",\n        \"Steampunk Airship\": \"jFCTt0VH2R4\",\n        \"Active Mine\": \"vnoLRJJJ8BQ\",\n        \"Skeleton Horde\": \"IgoCbdd7yfY\",\n        \"Lumber Mill\": \"EZJ4vU5aesc\",\n        \"Ice Blizzard\": \"YyKW2EmGVO8\",\n        \"Waiting in Ambush\": \"V7vl9iIZgMI\",\n        \"Filthy Sewers\": \"7N5D5niaBWQ\",\n        \"Bloody Slaughter\": \"TUKaKXdam9s\",\n        \"Faerie Forest\": \"exf2967RCjg\",\n        \"Knight Tournament\": \"Kws7g5Qqae0\",\n        \"Ghostly Castle\": \"6A6IRkaNrx4\",\n        \"Amazonian Baths\": \"DKYvu3hmH2Q\",\n        Hydra: \"CK4X-tNnR1M\",\n        \"Jewelry Workshop\": \"uWcC1jlbwSA\",\n        Earthquake: \"9ta0_OKYADg\",\n        \"Volcano Eruption\": \"lxNvXSpvc3s\",\n        \"Orc Gang\": \"PxalDgmxAFo\",\n        Underwater: \"IaPEdWTPopA\",\n        \"Ship in a Storm\": \"HoWVCG1H_bg\",\n        \"Lighthouse Fire\": \"mXbwarVE52U\",\n        \"Treasure Cave\": \"8jA_Q0oHSrg\",\n        \"Holy Temple\": \"BTVkNq072UE\",\n        \"Military Encampment\": \"J-1JR8lU1is\",\n        \"Forest Battle\": \"thnSlpl5pIU\",\n        \"Burning Forest\": \"mOMOX0FoKP4\",\n        \"Public Bathhouse\": \"bPyLzYYugn0\",\n        \"Cozy Home\": \"V7PpeZzltLI\",\n        \"Empty Tavern\": \"H01x22_PKok\",\n        \"Dwarven Smithy\": \"7LqWV3KZcPo\",\n        \"Human Sacrifice\": \"OKY_wpP-ZAo\",\n        \"Naval Battle\": \"RoBjokc-s8M\",\n        \"Tavern Bard\": \"an6-eSSAIM8\",\n        \"Scary Forest\": \"BkmO28ihl2Y\",\n        \"Fiery Volcano\": \"kUhDNbBPPhQ\",\n        \"Horse Archer\": \"gD8o7ShYnXo\",\n        \"Horse Cart\": \"-bP2oZy9Kjg\",\n        \"Beast Lands\": \"tZSLkRLreFQ\",\n        \"Sword Duel\": \"oBsHWwmXbcM\",\n        \"Mayan / Amerindian City\": \"7sEI8_MW16Q\",\n        \"Banshee's Cry\": \"PJ7ePH9eVZ0\",\n        \"Harpy Nest\": \"bXujtcFHcxc\",\n        \"Summer Night\": \"kSK2iyMS8GY\",\n        \"Dragon's Rampage\": \"26Byt2pNV4M\",\n        \"Werewolf Forest\": \"128kAIlwh4g\",\n        \"Giant's Home\": \"HkCSrnsd2F8\",\n        \"Plague & Disease\": \"p2tO8lNCRRI\",\n        \"Dark Prison\": \"gbYGvsTSk9k\",\n        \"Tavern Brawl\": \"wo1Z8DdOrqA\",\n        \"Pilgrim's Path\": \"xcdBdAUXo3Y\",\n        \"Tribal Charge\": \"g-qPRt4IRMo\",\n        \"Stealthy Burglary\": \"SXYLUuEjbqk\",\n        \"Druid's Cave\": \"W3Ep_LocbAY\",\n        \"Town Panic\": \"Sw9yC8rKcAY\",\n        \"World Tree\": \"J2RiEp-M4Og\",\n        \"Magic Academy\": \"nd3nIxU3g7Y\",\n        \"Hookah Den\": \"q5dQT7-Xoh0\",\n        \"Artisan Street\": \"Hoba6ktJ1NA\",\n        \"Warriors of the Dunes\": \"6aA1Jh0ohd4\",\n        \"Street Preacher\": \"glnsdpLN-40\",\n        \"Electric Dragon\": \"qXAkVD4qvHY\",\n        \"Castle Guard\": \"J5HWAUgwITg\",\n        \"River Boat\": \"UxNILOXJVhM\",\n        \"Roman Lavatory\": \"XgZivLuAnaU\",\n        \"Archer Volleys\": \"tELTUn9jP5M\",\n        \"Village Barn\": \"V5l2SxH6RgY\",\n        \"Dragon's Lair\": \"4BAdhivcV90\",\n        \"Battle Charge\": \"Bz0Cye__3AQ\",\n        \"Monster Infested Caves\": \"nNpDCYUaaFg\",\n        \"Desert Winds\": \"_5SwTjctJ-w\",\n        \"Underground Forge\": \"gsn1HnI1pCQ\",\n        \"Nesting Cliffs\": \"9I3ShuKYiFk\",\n        \"Canyon Bridge\": \"8WrKG28WTVM\",\n        \"Undead Crypt\": \"QVtwZW7YQik\",\n        \"Monument Construction\": \"gJpb9I3I1N8\",\n        \"Clock Tower\": \"6XQZWTfS5CE\",\n        \"Ice City\": \"6XTV76qBtCs\",\n        \"Desert Canyon\": \"4ovTEOsPnCk\",\n        \"War Dance\": \"EQIrzBh1EIk\",\n        \"Royal Treasury\": \"QgJsoaUdHys\",\n        \"Alchemist's Lab\": \"KWbo3PslD-M\",\n        \"Medieval Feast\": \"klIstouu6pU\",\n        \"Rainy Funeral\": \"aio5v9Fs870\",\n        \"Snake Temple\": \"8wvtDdEWqms\",\n        \"Buzzing Hive\": \"oZ2aCy43AOI\",\n        \"Misty Swamp\": \"LC4am6qDWrk\",\n        \"Eldritch Spell\": \"cuUb08zzBTY\",\n        \"Nomad Camp\": \"pmuRfU8RS0A\",\n        \"Ancient Tomb\": \"FWYqxqXkyXc\",\n        \"Pirate Harbour\": \"h8dL9Igch60\",\n        \"Tribunal of the Dead\": \"BzpdJXyR9Io\",\n        \"Insanity Mansion\": \"qHsUQSRaqpg\",\n        \"Secret Cult\": \"HuKBWPd-PI4\",\n        \"Battle March\": \"MGQDtF_-UvE\",\n        \"Thunder Forge\": \"N5M6stAd8uY\",\n        \"Great Caravan\": \"_LmC4aDniAM\",\n        \"Long Road\": \"PtktRQWAcxQ\",\n        \"Frantic Chase\": \"bzHqm-AyaNM\",\n        \"Public Execution\": \"oRP9mnTkgac\",\n        \"Secluded Monastery\": \"wSUgTrA4u4M\",\n        \"Sailing Ship\": \"pzn9t1Me6qk\",\n        \"Heavenly Abode\": \"-LpBf87xuEw\",\n        \"Crowded Tavern\": \"cbs558TPI3I\",\n        \"Wild Tribe\": \"Ys5KpQSEsG8\",\n        \"Slave Mines\": \"y6a66O0LIwE\",\n        \"Spring Forest\": \"lJpJRygR6vQ\",\n        \"Magical Vortex\": \"VzUVQMWyrWE\",\n        \"Rowdy Arena\": \"OvX9YrCg0K4\",\n        \"Burning Pits\": \"5Ze-4Ez0mXc\",\n        \"Dreadful Hunt\": \"vNHisdJfBKA\",\n        \"Lush Jungle\": \"2X71luNaHQc\",\n        \"Joyful Festival\": \"gcPSA3sUilc\",\n        \"Solemn Temple\": \"4ZDht1QyTjc\",\n        \"Busy Market\": \"6ksms45EOIg\",\n        \"Haunted Graveyard\": \"Ll0vtrU2oaI\",\n        \"Calm Sea\": \"wm6AaLi-pzQ\",\n        \"Raging Battle with many human warriors\": \"JEUTQJzKef4\",\n        \"Winter Forest\": \"vuc0LK4LNWI\",\n\n        // from various\n        \"Pirate Battle\": \"6Ewt26G7ZE0\",\n        \"Flight of the Dragons\": \"c7BCiWO7JVI\",\n        \"Ride of the Valkyries\": \"jPlsEunHX-Q\", // Wagner\n        \"Entrance of the Gods\": \"qEKnfbozTKw\", // Wagner\n        \"Riding to Adventure\": \"h6YUm_sKjSA\", // Holst, Jupiter\n        \"Battling the Titan\": \"zx0L0Zjjkms\", // Holst, Mars\n        \"Great Hall\": \"9gfvqQ9_21M\", // Holst, Vivace\n        \"Call of the Forest\": \"rf2GmdwFw80\",\n        \"Tavern/Inn\": \"roABNwbjZf4\",\n        \"The Adventure Begins\": \"q8R4MxLoOZM\", // eh\n        \"Knight Tournament\": \"Kws7g5Qqae0\", // eh\n\n        // from https://www.youtube.com/@AjsDnDMusic/videos\n        \"Auril Rises Once More\": \"T4tCCZN_h5Q\",\n        \"Fight Begins: Battling the Winter Goddess\": \"OJVKN5WPsjI\",\n        \"Surviving Test of Frost\": \"oN4yv472eK0\",\n        \"Frostmaiden's Abode\": \"hLxpatMoQ0o\",\n        \"Bedtime Lullaby\": \"p3wpPG5e0Uk\",\n        \"Fortress Of A God\": \"m67ZVI1PhtY\",\n        \"Hopeless Night\": \"-v6T81lUtdQ\",\n        \"Destruction's Light, Dragon's Devastation\": \"A2regj5sJMo\",\n        \"Dragon Unleashed\": \"QStg_jjHNxY\",\n        \"Assault on Sunblight Fortress\": \"eA7oX9cZyW8\",\n        \"Sunblight Fortress, Impending Doom\": \"QoXdqL5bfaE\",\n        \"Goliath Home\": \"q5Vrb-YYrcw\",\n        \"Goblin Den\": \"KcBhMN0QLlI\",\n        \"Lost Spire\": \"vr-mNBtC8OY\",\n        \"Cackling Chasm\": \"VzihbhHejPY\",\n        \"Giant's Jarlmoot\": \"x5kEkTE5J4M\",\n        \"Dark Duchess\": \"DUf4mIiMdH8\",\n        \"Cave of Berserkers\": \"lyBdRDQEnzg\",\n        \"Sky Tower Shelter\": \"kDmE5yi1_1c\",\n        \"Cauldron Caves\": \"0-4zFkXAocU\",\n        \"Holed Up\": \"jB0qSv7IjNU\",\n        \"Reghed Tribe Camp\": \"dclB2jVjV6c\",\n        \"Revel's End\": \"DBJoJq0aFKc\",\n        \"Mountain Climb\": \"RYBw_1__IuU\",\n        \"Unseen Outpost\": \"Udl2NanfN0A\",\n        \"Angajuk's Bell\": \"RRagMZWRfs8\",\n        \"Id Ascendant\": \"tlNkZ-BxCck\",\n        \"Black Cabin\": \"B56KxMtXc8Q\",\n        Combat: \"ribfyGXZID8\",\n        \"Nature Spirits\": \"udzOE6BqtXk\",\n        \"Cold Hearted Killer\": \"RvF6FhWtnQs\",\n        \"Cold Wind\": \"7ILGlFDVpQY\",\n        \"Beautiful Town\": \"pSnl0Y5iF9M\",\n        \"Fishing Fleet Town\": \"vfnnCWyprLQ\",\n        \"Shady People in Lonelywood\": \"uIB1qrw8xuA\",\n        \"Heart of the North, Good Mead\": \"-SJNs39kyUc\",\n        \"Town of Tradition\": \"E4h6QNuvPRs\",\n        \"Lonely Town\": \"sJdfw2nnsWk\",\n        \"Invisible Thieves\": \"TVYb4t0k3ow\",\n        \"Secret in Caer-Dineval\": \"Pg7FNacZCL8\",\n        \"Cozy Inns of the North\": \"c40x9RW1r1E\",\n        \"Gateway Town of the North\": \"Oiori413Y-8\",\n        \"Lake Monster of Maer Dualdon\": \"ZXHy5CLPoNk\",\n        \"Sleepy Town\": \"kEUj4U335YI\",\n        \"Welcome To The Far North!\": \"u6wieZVCp9E\",\n        \"A Calm Journey on the Seas\": \"832xOOXnjpk\",\n\n        \"Sleeping Dragon\": \"51pRMJpjYvk\",\n        \"Heavenly Crystal Bells\": \"9Q4DzzV2PW8\",\n\n        \"Meditative Oud Music\": \"dRU494VecTw\"\n      },\n\n      \"Harry Potter\": {\n        \"harry potter opening\": \"84j5uMdspmQ\",\n        // from https://www.youtube.com/watch?v=bVmlq3oThyA&list=PLgKQekWF68FoUGKh3XN7gyAOg3naozVuc\n        \"Brother Theme\": \"bVmlq3oThyA\",\n        \"Main Music\": \"MgkIHQvCJRk\",\n        \"Common Room Ravenclaw\": \"YJjuLE6b4pU\",\n        \"Common Room Slytherin\": \"BinDSorqT-s\",\n        \"Common Room Hufflepuff\": \"DXFAvnESj2Q\",\n        \"Avatar Creation\": \"rlZpPJxdSDE\",\n        \"Common Room Gryffindor\": \"aGg3DUg3u78\",\n        \"Flying Class\": \"UowG3JGOsa8\",\n        \"Diagon Alley Hagrid's Theme\": \"Xssu4pugmxQ\",\n        \"Social Encounter\": \"sgr6oz5uGUk\",\n        \"Three Broomsticks\": \"640-Fa-EzDI\",\n        \"Dueling 1\": \"s0t5ZcNl9fk\",\n        Transfiguration: \"8ll3-vcedpI\",\n        Hogsmeade: \"f3QwKB2nOSw\",\n        \"Merula Theme\": \"Jd3Qyh2GeHc\",\n        \"General Suspense\": \"00eKgcXXEVQ\",\n        \"Chores Studying\": \"r5jsDGmcUuI\",\n        \"End of Year Graduation\": \"HULMJttWPVA\",\n        \"Herbology Class\": \"f-1b_Wlj51c\",\n        \"Welcome Feast\": \"1Wc-tqRCU6A\",\n        \"Boss Fight Devils Snare\": \"BVU9kRUzTbM\",\n        \"Plot Advance\": \"8SGIpHaNtXg\",\n        \"Dueling 2\": \"g0qjMSxeAuo\",\n        \"Intro To Hogwarts\": \"3YGKp1671yY\",\n        Zonkos: \"A8rQIKe7YVs\",\n\n        // from https://www.youtube.com/playlist?list=PLbLGu6ODJC_8sIIc7QyOqtBXt8CJE9c2j\n        \"Slytherin Fireplace\": \"jqadj1gOORI\",\n        \"Hufflepuff Fireplace\": \"c5eqVORqPN4\",\n        \"Ravenclaw Fireplace\": \"ucHZ2KViPcA\",\n        \"Gryffindor Fireplace\": \"hvDmfxqiV0g\",\n\n        // from https://www.youtube.com/watch?v=PzkE3dOYFVo\n        \"Tchaikovsky Waltz of the Flowers\": \"PzkE3dOYFVo\",\n        \"Tchaikovsky Dance of the Sugar Plum Fairy\": \"w600ZPxZzSk\"\n      },\n\n      \"Studio Ghibli\": {\n        // various sources\n        \"Light a Way\": \"Le5zp7j7g1U\",\n        \"Ghibli Piano LOFI\": \"ziEO5OS-Rdk\",\n        \"Ghibli's Totoro Path of the Wind\": \"dOVoHFl1UyE\",\n        \"Relaxing Piano Studio Ghibli\": \"0KPBxqjSjDc\",\n        \"Ghibli Piano Medley\": \"UJMgdSRDZtI\",\n        \"Peaceful Piano and soft nature sounds\": \"mym0_m5EgtU\",\n        \"Stroll Sanpo\": \"5Wn2LOVlPPU\",\n        \"Relaxing Vibrato Piano\": \"o56Jgs94Z_Q\",\n        \"lofi chillpop\": \"0IwFM4LzX8Q\",\n        \"Musicbox Grave of the Fireflies\": \"tFJotEXEri8\",\n        \"Princess Mononoke Music On The Boat\": \"WUR7t__ICZw\",\n        \"Princess Mononoke Ashitaka to San on Guitar\": \"2Z_xdUqbAQ4\",\n        \"Princess Mononoke Legend of Ashitaka\": \"OP-wnnOn2ao\",\n        \"Princess Mononoke Gods and Demons\": \"7k5GmlPJ6n8\",\n        \"Journey to the West\": \"x-Qjej2zLFs\", // eh\n        //\"Zelda Relaxing Breath of the Wild\": \"dHGrnuCEo4\", // 1 hour\n        //\"Happy Ghibli Piano music\": \"aznnUTdg5Mk\", // 3 hours\n      },\n\n      Trivia: {\n        // from https://www.youtube.com/watch?v=3dSCuAu4ge4\n        \"waiting loop\": \"yVZ7g-EQzY8\",\n        countdown: \"mXtIVwsRh3Q\",\n        question: \"DliUjhJcgs4\",\n        winner: \"CnFiJIgh1fE\",\n        \"waiting oneshot\": \"sXdxe7uYKb8\",\n        \"it's my time\": \"EItvLXjgcMA\",\n        \"winner splash\": \"mz-sYKe3ES0\",\n        waiting: \"8WGbzIXjSRw\"\n      },\n\n      \"Sound FX\": {\n        \"gong\": \"_grH3Z5YHdI\",\n        \"explosion\": \"HTXiJpCDiH4\",\n        \"knocking on door\": \"HIJunF3DIjw\",\n        \"creaking door opening\": \"ij5bdBI_JVA\",\n        \"door closing\": \"PAPcSY20DYA\",\n        \"heavy metal door opening and closing\": \"c90uCjVbW_g\",\n        \"dramatic jungle drums\": \"3e1Acwh8GmQ\",\n        \"sword fight\": \"4g-iCX2oST4\",\n        \"sword slice\": \"VjrY6foiTxw\",\n        \"critical axe hit\": \"Q6ab0gpaKIw\",\n        \"dementor wailing\": \"8XbN5nIBuew\",\n        \"dementor soul kiss\": \"ZUqDcr4lznU\",\n        \"card shuffling\": \"dbfwV0-XCRY\",\n        \"demonic laugh\": \"9Il8gAr7Ar4\",\n        \"dark war horn\": \"kUw-fc2BYLo\",\n        \"bright war horn\": \"o54owbOXrro\",\n        \"cinematic war horn\": \"tsl854orF1I\",\n        \"war horn with echo\": \"enQyoFCrSXY\",\n        \"long war horn\": \"uHHMV8hukBI\",\n        \"ork battle horn\": \"hPKTrrgMrmBc\",\n        \"distant ominous war horn\": \"GCilFSXdLuM\",\n        \"scary war horn\": \"C7YbRGABJ3U\"\n      },\n\n      \"Science Fiction\": {\n          //\"Deep Thought\": \"IngU5tGtJQY\", // only good for first 90 seconds\n          \"space hitchhiker harpsicord\": \"nGd7Zphv1J0\", // good for hitchhikers\n          \"upbeat exploration\": \"sB6jXSr7_wQ\", // good for hitchhikers\n          \"jaunty scifi\": \"vvkofC411Mo\",\n          \"dramatic meditative exploration\": \"1E31BLIY4bQ\",\n          \"dark suspenseful\": \"FSryKsTMp2M\",\n          \"dark caverns and hallways\": \"pE7AwMfNYhM\",\n          \"ethereal spooky\": \"gPcEQC5kzf4\",\n          \"orbital surveillance\": \"iLUZgqrRU_U\", // eh\n          \"deep into the core\": \"1GTfMOx01tI\"\n      },\n\n      Horror: {\n          \"rough droning\": \"_z-Ew1L-iWc\"\n      },\n\n      Humor: {\n          \"goofy detective\": \"ORNvyUiUTO8\"\n      }\n    }\n  }\n}).initThisClass();\n",
  "zGn4wHHZnPKtCCNoqfcio0Eh1Thqz1T7iYBVKWWJ6Ag=": "\"use strict\";\n\n/* \n    YouTubePlayerFrame\n\n    A singleton that loads the YouTubeAPI script.\n\n    Use the following before calling the YouTube API to wait for it to load:\n    \n    await YouTubePlayerFrame.shared().frameReadyPromise();\n*/\n\n(class YouTubePlayerFrame extends ProtoClass {\n\n  static initClass () {\n    this.setIsSingleton(true);\n  }\n  \n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"frameReadyPromise\", null);\n      slot.setSlotType(\"Promise\");\n    }\n\n    this.setIsDebugging(false);\n  }\n\n  init () {\n    super.init();\n    /*\n    const p = Promise.clone();\n    p.setLabel(this.typeId() + \".frameReadyPromise\");\n    //p.setOnAwaitFunc(() => { this.setup(); });\n    this.setFrameReadyPromise(p);\n    */\n  }\n\n  frameReadyPromise () {\n    if (!this._frameReadyPromise) {\n      this.setFrameReadyPromise(Promise.clone().setLabel(this.typeId() + \".frameReadyPromise\"));\n      this.setup();\n    }\n    return this._frameReadyPromise;\n  }\n\n  setup () {\n      // Load the YouTube IFrame Player API asynchronously\n      this.debugLog(\"setup()\");\n      const tag = document.createElement(\"script\");\n      tag.src = \"https://www.youtube.com/iframe_api\";\n      const firstScriptTag = document.getElementsByTagName(\"script\")[0];\n      firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);\n  }\n\n  onLoaded () {\n    this.debugLog(\"onLoaded()\");\n    this.frameReadyPromise().callResolveFunc();\n  }\n\n}).initThisClass();\n\ngetGlobalThis().onYouTubeIframeAPIReady = function (arg1, arg2, arg3) {\n  // a global function called after YouTube API code downloads\n  YouTubePlayerFrame.shared().onLoaded();\n};\n",
  "wvk11t+ysausj9S5Ta2EEKB1yjCUo6u0bKOHz2KKa7A=": "\"use strict\";\n\n/* \n    YouTubeAudioPlayer\n\n\n    One shot use example:\n\n      const player = YouTubeAudioPlayer.clone();\n      player.setTrackName(this.name());\n      player.setVideoId(this.trackId());\n      player.setShouldRepeat(false);\n      await player.play();\n      await player.shutdown();\n\n*/\n\n(class YouTubeAudioPlayer extends BMStorableNode {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"element\", null);\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"Element\");\n    }\n    \n    { \n      const slot = this.newSlot(\"playerPromise\", null); // resolves once player is available\n      slot.setSlotType(\"Promise\");\n    }\n\n    {\n      const slot = this.newSlot(\"playPromise\", null);\n      slot.setSlotType(\"Promise\");\n    }\n\n    {\n      const slot = this.newSlot(\"player\", null); // reference to store the YouTube player\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"stateName\", \"\");\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Status\");\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"trackName\", \"\");      \n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"track name\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"videoId\", null);      \n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"track id\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"shouldRepeat\", true);      \n      slot.setCanEditInspection(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setInspectorPath(\"\");\n      slot.setIsSubnodeField(true);\n      slot.setLabel(\"repeat\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"mute\", false);      \n      slot.setCanEditInspection(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setInspectorPath(\"\");\n      slot.setIsSubnodeField(true);\n      slot.setLabel(\"mute\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"volume\", 0.05);\n      slot.setInspectorPath(\"\");\n      //slot.setLabel(\"\");\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(true);\n      slot.setAllowsMultiplePicks(false);\n      slot.setValidValues(this.validVolumeValues());\n    }\n\n    {\n      const slot = this.newSlot(\"togglePlayAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Play\");\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"togglePlay\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init () {\n    super.init();\n    this.setIsDebugging(false);\n  }\n\n  playerPromise () {\n    if (!this._playerPromise) {\n      this._playerPromise = Promise.clone().setLabel(this.type() + \" setup\");\n      this.setupFrame();\n    }\n    return this._playerPromise\n  }\n\n  finalInit () {\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    \n    super.finalInit();\n    this.setTitle(\"YouTube Audio Player\");\n  }\n\n  subtitle () {\n    if (this.isPlaying()) {\n      const lines = []\n      lines.push(this.stateName() + \" '\" + this.trackName() + \"'\");\n      /*\n      const secs = this.secondsBuffered();\n      if (secs) {\n        const percentBufferred = Math.round(this.fractionBuffered()*100) + \"%\";\n        lines.push(percentBufferred + \" buffered (\" + secs + \"s)\");\n        //lines.push(secs + \"s buffered\");\n      }\n      */\n      lines.push(\"volume: \" + Math.round(this.volume()*100) + \"%\");\n      return lines.join(\"\\n\");\n    }\n    return \"\"\n  }\n\n  validVolumeValues () {\n    const values = [];\n    let v = 0;\n    while (v <= 1.0) {\n      values.push(v);\n      //values.push({ label: (v*100) + \"%\", value: v });\n      v += 0.05;\n      v = Math.round(v*100)/100;\n    }\n    return values;\n  }\n\n  async setupFrame () {\n    //debugger;\n    await EventManager.shared().firstUserEventPromise();\n    await YouTubePlayerFrame.shared().frameReadyPromise();\n    //this.playerPromise().beginTimeout(3000);\n    this.setupPlayer();\n  }\n\n  setupPlayer () {\n    console.log(\"------------- setup YouTubePlayer ---------------\");\n    //debugger;\n    this.debugLog(\"setupPlayer()\");\n    const json = {\n      height: \"0\",\n      width: \"0\",\n      events: {\n        onReady: (event) => {\n          this.onPlayerReady(event);\n        },\n        onStateChange: (event) => {\n          this.onPlayerStateChange(event);\n        },\n        onError: (event) => {\n          debugger;\n          this.onPlayerError(event);\n        },\n      },\n      playerVars: {\n        autoplay: 1, // Auto-play the video\n        controls: 0, // Hide player controls\n        showinfo: 0, // Hide video information\n        rel: 0, // Do not show related videos\n        modestbranding: 1, // Show minimal YouTube branding\n      },\n    };\n\n    try {\n      const e = document.createElement(\"div\");\n      this.setElement(e);\n      e.id = \"YouTubePlayer_\" + this.puuid();\n      e.style.display = \"none\";\n      document.body.appendChild(e);\n      const player = new YT.Player(e.id, json);\n      assert(player);\n      this.setPlayer(player);\n    } catch (error) {\n      console.warn(error);\n      error.rethrow();\n    }\n    return this;\n  }\n\n  async play () {\n    if (this.mute()) {\n      return;\n    }\n\n    if (!this.videoId()) {\n      return;\n    }\n\n    await this.playerPromise(); // lazy load the player\n    this.debugLog(\"play() after promise\");\n\n    const startSeconds = 0.0;\n    if (this.videoId()) {\n      //this.stop(); // if we do this, the next video only gets cued but not played. Why?\n      this.resolvePlayPromise();\n\n      this.setPlayPromise(Promise.clone().setLabel(this.type() + \".playPromise\"));\n      this.player().loadVideoById(this.videoId(), startSeconds);\n      //this.player().pauseVideo()\n      //this.player().cueVideoById(this.videoId());\n      //this.playWhenBuffered();\n      return this.playPromise();\n    }\n  }\n\n  isReady () {\n    if (this._playerPromise) {\n      return this.playerPromise().isResolved();\n    }\n    return false;\n  }\n\n  statesMap () {\n    const statesDict = {\n      \"3\": \"buffering\",\n      \"5\": \"cued\",\n      \"0\": \"ended\",\n      \"2\": \"paused\",\n      \"1\": \"playing\",\n      \"-1\": \"unstarted\"\n    }\n    const statesMap = new Map(Object.entries(statesDict));\n    return statesMap;\n  }\n\n  stateName () {\n    if (this.isReady()) {\n      const k = String(this.player().getPlayerState());\n      assert(this.statesMap().has(k));\n      return this.statesMap().get(k);\n    }\n    return \"unitialized\";\n  }\n\n  isPlaying () {\n    if (this.isReady()) {\n      const currentState = this.player().getPlayerState();\n      //const playStates = [YT.PlayerState.CUED, YT.PlayerState.BUFFERING, YT.PlayerState.PLAYING];\n      const playStates = [YT.PlayerState.BUFFERING, YT.PlayerState.PLAYING];\n      return playStates.includes(currentState);\n\n    }\n    return false;\n  }\n\n  onPlayerError (event) {\n    debugger;\n    // Handle the error based on the error code\n    const error = Number(event.data);\n    this.debugLog(\n      \"------------------ onPlayerError \" +\n        error +\n        \" videoId: '\" +\n        this.videoId() +\n        \"'\"\n    );\n\n    switch (error) {\n      case 2: // Invalid parameter\n        console.error(\n          \"The request contains an invalid parameter value. For example, this error occurs if you specify a video ID that does not have 11 characters, or if the video ID contains invalid characters, such as exclamation points or asterisks.\"\n        );\n        break;\n      case 5:\n        console.error(\n          \"The requested content cannot be played in an HTML5 player or another error related to the HTML5 player has occurred.\"\n        );\n        break;\n      case 100: // Video not found\n        console.error(\"Video not found.\");\n        break;\n      case 101: // Playback not allowed\n        console.error(\n          \"The owner of the requested video does not allow it to be played in embedded players.\"\n        );\n        break;\n      case 150: // Playback not allowed\n        console.error(\n          \"The owner of the requested video does not allow it to be played in embedded players.\"\n        );\n        break;\n      default: // Unexpected error\n        console.error(\"An unexpected error occurred while loading the video.\");\n    }\n  }\n\n  onPlayerReady (event) {\n    this.debugLog(\"onPlayerReady()\");\n    this.updateVolume();\n\n    assert(this._playerPromise);\n    this.playerPromise().callResolveFunc();\n    //this.player().style.display = \"none\";\n  }\n\n  onPlayerStateChange (event) {\n    this.debugLog(\"onPlayerStateChange \" + event.data);\n\n    const state = Number(event.data);\n    switch (state) {\n      case -1:\n        this.debugLog(\"Video unstarted\");\n        break;\n\n      case YT.PlayerState.ENDED:\n        this.debugLog(\"Video ENDED\");\n        this.onPlayerEnd(event);\n        break;\n\n      case YT.PlayerState.PLAYING:\n        this.debugLog(\"Video PLAYING\");\n        break;\n\n      case YT.PlayerState.PAUSED:\n        this.debugLog(\"Video PAUSED\");\n        break;\n\n      case YT.PlayerState.BUFFERING:\n        this.debugLog(\"Video BUFFERING\");\n        break;\n\n      case YT.PlayerState.CUED:\n        this.debugLog(\"Video CUED\");\n        break;\n\n      default:\n        this.debugLog(\"Video unknown state chage\");\n    }\n\n    this.didUpdateNodeIfInitialized();\n  }\n\n  onPlayerEnd (event) {\n    if (this.shouldRepeat()) {\n      this.player().playVideo(); // Replay the video when it ends\n    } else {\n      this.resolvePlayPromise();\n    }\n  }\n\n  resolvePlayPromise () {\n    if (this.playPromise()) {\n      this.playPromise().callResolveFunc();\n      this.setPlayPromise(null);\n    }\n    return this;\n  }\n\n  didUpdateMute (oldValue, newValue) {\n    if (this.mute()) {\n      this.stop();\n    } \n  }\n\n  async setVolume (v) {\n    // 0.0 to 1.0\n    if (this._volume !== v) {\n      assert(v >= 0 && v <= 1.0);\n      this._volume = v;\n      if (this._playerPromise) {\n        this.updateVolume();\n      }\n    }\n    return this;\n  }\n\n  async updateVolume () {\n    await this.playerPromise();\n    const v = this.volume() * 100;\n    if (this.isReady()) {\n      this.player().setVolume(v);\n      if(v !== this.player().getVolume()) {\n        this.debugLog(\"WARNING: setVolume not equal getVolume after set\");\n        this.debugLog(\"set volume:\", v);\n        this.debugLog(\"getVolume: \", this.player().getVolume());\n      }\n    }\n  }\n\n  async stop () {\n    if (!this._playerPromise) {\n      // no one has asked player to play yet,\n      // so we can ignore the stop\n      return;\n    }\n    await this.playerPromise();\n    this.player().stopVideo();\n    this.resolvePlayPromise();\n  }\n\n  async shutdown () {\n    await this.playerPromise();\n    const player = this.player();\n    player.stopVideo();\n    player.destroy();\n    this.setPlayer(null);\n    console.log(\"------------- shutdown YouTubePlayer ---------------\");\n  }\n\n  secondsBuffered () {\n    if (this.isReady()) {\n      const player = this.player();\n      const fraction = player.getVideoLoadedFraction(); // Get the fraction of the video that has been loaded\n      const duration = player.getDuration(); // Get the total duration of the video\n      const bufferedTime = fraction * duration; // Calculate the amount of time that has been buffered\n\n      //console.log(\"Buffered time: \" + bufferedTime + \" seconds\");\n      return Math.round(bufferedTime);\n    }\n    return 0;\n  }\n\n  fractionBuffered () {\n    if (this.isReady()) {\n      const player = this.player();\n      const fraction = player.getVideoLoadedFraction(); // Get the fraction of the video that has been loaded\n      return fraction;\n    }\n    return 0;\n  }\n\n  playWhenBuffered () {\n    // this is trying to solve the problem of choppy playback by ensuring sufficient buffering\n    if (!this._checkBuffer) {\n      this._checkBuffer = setInterval(() => {\n        if (this.secondsBuffered() > 30) {\n          this.player().playVideo();\n          clearInterval(this._checkBuffer); // Stop checking the buffer size\n          this._checkBuffer = null;\n        }\n      }, 1000); // Check every second\n    }\n  }\n\n  // --- actions ---\n\n  togglePlay () {\n    if (this.isPlaying()) {\n      this.stop();\n    } else {\n      this.play();\n    }\n    return this;\n  }\n\n  togglePlayActionInfo () {\n    return {\n      isEnabled: this.videoId() !== null,\n      title: this.isPlaying() ? \"Stop\" : \"Play\",\n      isVisible: true,\n    };\n  }\n\n  async shutdown () {\n    if (this._playerPromise && this.playerPromise().hasAwaiters()) {\n      // it's in the middle of being setup so wait until that resolves/rejects\n      await this.playerPromise();\n    }\n\n    // cleanup player\n    const player = this.player();\n    if (player) {\n      player.stopVideo();\n      player.destroy();\n      this.setPlayer(null);\n    }\n\n    // cleanup element\n    const e = this.element();\n    if (e) {\n      e.parentNode.removeChild(e);\n      this.setElement(null);\n    }\n\n    this.setPlayerPromise(Promise.clone().setLabel(this.type() + \" setup\"));\n  }\n\n}).initThisClass();\n",
  "hhmVahie5rRWemnjyatBqX9L17ZJ/2GuIqWxFDOoORU=": "\"use strict\";\n\n/* \n    YouTubeService\n\n*/\n\n(class YouTubeService extends BMStorableNode {\n  initPrototypeSlots () {\n    /*\n    {\n      const slot = this.newSlot(\"musicLibrary\", null)\n      slot.setShouldStoreSlot(true);\n      slot.setFinalInitProto(MusicLibrary);\n      slot.setIsSubnode(true);\n    }\n\n    {\n        const slot = this.newSlot(\"musicPlayer\", null)\n        slot.setShouldStoreSlot(true);\n        slot.setFinalInitProto(MusicPlayer);\n        slot.setIsSubnode(true);\n    }\n    */\n\n    {\n        const slot = this.newSlot(\"youTubeAudioPlayer\", null)\n        slot.setShouldStoreSlot(true);\n        slot.setFinalInitProto(YouTubeAudioPlayer);\n        slot.setIsSubnode(true);\n        slot.setSlotType(\"YouTubeAudioPlayer\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"YouTube\");\n    this.setSubtitle(\"music service\");\n  }\n\n}).initThisClass();\n",
  "nufKVGl5kp6m085fNBEkPHmcvbllfN+F0vOu69wNT0I=": "var parcelRequire = (function (e, r, t, n) {\n  var i,\n    o = \"function\" == typeof parcelRequire && parcelRequire,\n    u = \"function\" == typeof require && require;\n  function f(t, n) {\n    if (!r[t]) {\n      if (!e[t]) {\n        var i = \"function\" == typeof parcelRequire && parcelRequire;\n        if (!n && i) return i(t, !0);\n        if (o) return o(t, !0);\n        if (u && \"string\" == typeof t) return u(t);\n        var c = new Error(\"Cannot find module '\" + t + \"'\");\n        throw ((c.code = \"MODULE_NOT_FOUND\"), c);\n      }\n      (p.resolve = function (r) {\n        return e[t][1][r] || r;\n      }),\n        (p.cache = {});\n      var l = (r[t] = new f.Module(t));\n      e[t][0].call(l.exports, p, l, l.exports, this);\n    }\n    return r[t].exports;\n    function p(e) {\n      return f(p.resolve(e));\n    }\n  }\n  (f.isParcelRequire = !0),\n    (f.Module = function (e) {\n      (this.id = e), (this.bundle = f), (this.exports = {});\n    }),\n    (f.modules = e),\n    (f.cache = r),\n    (f.parent = o),\n    (f.register = function (r, t) {\n      e[r] = [\n        function (e, r) {\n          r.exports = t;\n        },\n        {},\n      ];\n    });\n  for (var c = 0; c < t.length; c++)\n    try {\n      f(t[c]);\n    } catch (e) {\n      i || (i = e);\n    }\n  if (t.length) {\n    var l = f(t[t.length - 1]);\n    \"object\" == typeof exports && \"undefined\" != typeof module\n      ? (module.exports = l)\n      : \"function\" == typeof define && define.amd\n      ? define(function () {\n          return l;\n        })\n      : n && (this[n] = l);\n  }\n  if (((parcelRequire = f), i)) throw i;\n  return f;\n})(\n  {\n    EgBh: [\n      function (require, module, exports) {\n        var e = {};\n        (e.useBlobBuilder = (function () {\n          try {\n            return new Blob([]), !1;\n          } catch (e) {\n            return !0;\n          }\n        })()),\n          (e.useArrayBufferView =\n            !e.useBlobBuilder &&\n            (function () {\n              try {\n                return 0 === new Blob([new Uint8Array([])]).size;\n              } catch (e) {\n                return !0;\n              }\n            })()),\n          (module.exports.binaryFeatures = e);\n        var r = module.exports.BlobBuilder;\n        function t() {\n          (this._pieces = []), (this._parts = []);\n        }\n        \"undefined\" != typeof window &&\n          (r = module.exports.BlobBuilder =\n            window.WebKitBlobBuilder ||\n            window.MozBlobBuilder ||\n            window.MSBlobBuilder ||\n            window.BlobBuilder),\n          (t.prototype.append = function (e) {\n            \"number\" == typeof e\n              ? this._pieces.push(e)\n              : (this.flush(), this._parts.push(e));\n          }),\n          (t.prototype.flush = function () {\n            if (this._pieces.length > 0) {\n              var r = new Uint8Array(this._pieces);\n              e.useArrayBufferView || (r = r.buffer),\n                this._parts.push(r),\n                (this._pieces = []);\n            }\n          }),\n          (t.prototype.getBuffer = function () {\n            if ((this.flush(), e.useBlobBuilder)) {\n              for (var t = new r(), i = 0, u = this._parts.length; i < u; i++)\n                t.append(this._parts[i]);\n              return t.getBlob();\n            }\n            return new Blob(this._parts);\n          }),\n          (module.exports.BufferBuilder = t);\n      },\n      {},\n    ],\n    kdPp: [\n      function (require, module, exports) {\n        var t = require(\"./bufferbuilder\").BufferBuilder,\n          e = require(\"./bufferbuilder\").binaryFeatures,\n          i = {\n            unpack: function (t) {\n              return new r(t).unpack();\n            },\n            pack: function (t) {\n              var e = new n();\n              return e.pack(t), e.getBuffer();\n            },\n          };\n        function r(t) {\n          (this.index = 0),\n            (this.dataBuffer = t),\n            (this.dataView = new Uint8Array(this.dataBuffer)),\n            (this.length = this.dataBuffer.byteLength);\n        }\n        function n() {\n          this.bufferBuilder = new t();\n        }\n        function u(t) {\n          var e = t.charCodeAt(0);\n          return e <= 2047\n            ? \"00\"\n            : e <= 65535\n            ? \"000\"\n            : e <= 2097151\n            ? \"0000\"\n            : e <= 67108863\n            ? \"00000\"\n            : \"000000\";\n        }\n        function a(t) {\n          return t.length > 600\n            ? new Blob([t]).size\n            : t.replace(/[^\\u0000-\\u007F]/g, u).length;\n        }\n        (module.exports = i),\n          (r.prototype.unpack = function () {\n            var t,\n              e = this.unpack_uint8();\n            if (e < 128) return e;\n            if ((224 ^ e) < 32) return (224 ^ e) - 32;\n            if ((t = 160 ^ e) <= 15) return this.unpack_raw(t);\n            if ((t = 176 ^ e) <= 15) return this.unpack_string(t);\n            if ((t = 144 ^ e) <= 15) return this.unpack_array(t);\n            if ((t = 128 ^ e) <= 15) return this.unpack_map(t);\n            switch (e) {\n              case 192:\n                return null;\n              case 193:\n                return;\n              case 194:\n                return !1;\n              case 195:\n                return !0;\n              case 202:\n                return this.unpack_float();\n              case 203:\n                return this.unpack_double();\n              case 204:\n                return this.unpack_uint8();\n              case 205:\n                return this.unpack_uint16();\n              case 206:\n                return this.unpack_uint32();\n              case 207:\n                return this.unpack_uint64();\n              case 208:\n                return this.unpack_int8();\n              case 209:\n                return this.unpack_int16();\n              case 210:\n                return this.unpack_int32();\n              case 211:\n                return this.unpack_int64();\n              case 212:\n              case 213:\n              case 214:\n              case 215:\n                return;\n              case 216:\n                return (t = this.unpack_uint16()), this.unpack_string(t);\n              case 217:\n                return (t = this.unpack_uint32()), this.unpack_string(t);\n              case 218:\n                return (t = this.unpack_uint16()), this.unpack_raw(t);\n              case 219:\n                return (t = this.unpack_uint32()), this.unpack_raw(t);\n              case 220:\n                return (t = this.unpack_uint16()), this.unpack_array(t);\n              case 221:\n                return (t = this.unpack_uint32()), this.unpack_array(t);\n              case 222:\n                return (t = this.unpack_uint16()), this.unpack_map(t);\n              case 223:\n                return (t = this.unpack_uint32()), this.unpack_map(t);\n            }\n          }),\n          (r.prototype.unpack_uint8 = function () {\n            var t = 255 & this.dataView[this.index];\n            return this.index++, t;\n          }),\n          (r.prototype.unpack_uint16 = function () {\n            var t = this.read(2),\n              e = 256 * (255 & t[0]) + (255 & t[1]);\n            return (this.index += 2), e;\n          }),\n          (r.prototype.unpack_uint32 = function () {\n            var t = this.read(4),\n              e = 256 * (256 * (256 * t[0] + t[1]) + t[2]) + t[3];\n            return (this.index += 4), e;\n          }),\n          (r.prototype.unpack_uint64 = function () {\n            var t = this.read(8),\n              e =\n                256 *\n                  (256 *\n                    (256 *\n                      (256 * (256 * (256 * (256 * t[0] + t[1]) + t[2]) + t[3]) +\n                        t[4]) +\n                      t[5]) +\n                    t[6]) +\n                t[7];\n            return (this.index += 8), e;\n          }),\n          (r.prototype.unpack_int8 = function () {\n            var t = this.unpack_uint8();\n            return t < 128 ? t : t - 256;\n          }),\n          (r.prototype.unpack_int16 = function () {\n            var t = this.unpack_uint16();\n            return t < 32768 ? t : t - 65536;\n          }),\n          (r.prototype.unpack_int32 = function () {\n            var t = this.unpack_uint32();\n            return t < Math.pow(2, 31) ? t : t - Math.pow(2, 32);\n          }),\n          (r.prototype.unpack_int64 = function () {\n            var t = this.unpack_uint64();\n            return t < Math.pow(2, 63) ? t : t - Math.pow(2, 64);\n          }),\n          (r.prototype.unpack_raw = function (t) {\n            if (this.length < this.index + t)\n              throw new Error(\n                \"BinaryPackFailure: index is out of range \" +\n                  this.index +\n                  \" \" +\n                  t +\n                  \" \" +\n                  this.length\n              );\n            var e = this.dataBuffer.slice(this.index, this.index + t);\n            return (this.index += t), e;\n          }),\n          (r.prototype.unpack_string = function (t) {\n            for (var e, i, r = this.read(t), n = 0, u = \"\"; n < t; )\n              (e = r[n]) < 128\n                ? ((u += String.fromCharCode(e)), n++)\n                : (192 ^ e) < 32\n                ? ((i = ((192 ^ e) << 6) | (63 & r[n + 1])),\n                  (u += String.fromCharCode(i)),\n                  (n += 2))\n                : ((i =\n                    ((15 & e) << 12) |\n                    ((63 & r[n + 1]) << 6) |\n                    (63 & r[n + 2])),\n                  (u += String.fromCharCode(i)),\n                  (n += 3));\n            return (this.index += t), u;\n          }),\n          (r.prototype.unpack_array = function (t) {\n            for (var e = new Array(t), i = 0; i < t; i++) e[i] = this.unpack();\n            return e;\n          }),\n          (r.prototype.unpack_map = function (t) {\n            for (var e = {}, i = 0; i < t; i++) {\n              var r = this.unpack(),\n                n = this.unpack();\n              e[r] = n;\n            }\n            return e;\n          }),\n          (r.prototype.unpack_float = function () {\n            var t = this.unpack_uint32(),\n              e = ((t >> 23) & 255) - 127;\n            return (\n              (0 === t >> 31 ? 1 : -1) *\n              ((8388607 & t) | 8388608) *\n              Math.pow(2, e - 23)\n            );\n          }),\n          (r.prototype.unpack_double = function () {\n            var t = this.unpack_uint32(),\n              e = this.unpack_uint32(),\n              i = ((t >> 20) & 2047) - 1023;\n            return (\n              (0 === t >> 31 ? 1 : -1) *\n              (((1048575 & t) | 1048576) * Math.pow(2, i - 20) +\n                e * Math.pow(2, i - 52))\n            );\n          }),\n          (r.prototype.read = function (t) {\n            var e = this.index;\n            if (e + t <= this.length) return this.dataView.subarray(e, e + t);\n            throw new Error(\"BinaryPackFailure: read index out of range\");\n          }),\n          (n.prototype.getBuffer = function () {\n            return this.bufferBuilder.getBuffer();\n          }),\n          (n.prototype.pack = function (t) {\n            var i = typeof t;\n            if (\"string\" === i) this.pack_string(t);\n            else if (\"number\" === i)\n              Math.floor(t) === t ? this.pack_integer(t) : this.pack_double(t);\n            else if (\"boolean\" === i)\n              !0 === t\n                ? this.bufferBuilder.append(195)\n                : !1 === t && this.bufferBuilder.append(194);\n            else if (\"undefined\" === i) this.bufferBuilder.append(192);\n            else {\n              if (\"object\" !== i)\n                throw new Error('Type \"' + i + '\" not yet supported');\n              if (null === t) this.bufferBuilder.append(192);\n              else {\n                var r = t.constructor;\n                if (r == Array) this.pack_array(t);\n                else if (\n                  r == Blob ||\n                  r == File ||\n                  t instanceof Blob ||\n                  t instanceof File\n                )\n                  this.pack_bin(t);\n                else if (r == ArrayBuffer)\n                  e.useArrayBufferView\n                    ? this.pack_bin(new Uint8Array(t))\n                    : this.pack_bin(t);\n                else if (\"BYTES_PER_ELEMENT\" in t)\n                  e.useArrayBufferView\n                    ? this.pack_bin(new Uint8Array(t.buffer))\n                    : this.pack_bin(t.buffer);\n                else if (r == Object || r.toString().startsWith(\"class\"))\n                  this.pack_object(t);\n                else if (r == Date) this.pack_string(t.toString());\n                else {\n                  if (\"function\" != typeof t.toBinaryPack)\n                    throw new Error(\n                      'Type \"' + r.toString() + '\" not yet supported'\n                    );\n                  this.bufferBuilder.append(t.toBinaryPack());\n                }\n              }\n            }\n            this.bufferBuilder.flush();\n          }),\n          (n.prototype.pack_bin = function (t) {\n            var e = t.length || t.byteLength || t.size;\n            if (e <= 15) this.pack_uint8(160 + e);\n            else if (e <= 65535)\n              this.bufferBuilder.append(218), this.pack_uint16(e);\n            else {\n              if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n              this.bufferBuilder.append(219), this.pack_uint32(e);\n            }\n            this.bufferBuilder.append(t);\n          }),\n          (n.prototype.pack_string = function (t) {\n            var e = a(t);\n            if (e <= 15) this.pack_uint8(176 + e);\n            else if (e <= 65535)\n              this.bufferBuilder.append(216), this.pack_uint16(e);\n            else {\n              if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n              this.bufferBuilder.append(217), this.pack_uint32(e);\n            }\n            this.bufferBuilder.append(t);\n          }),\n          (n.prototype.pack_array = function (t) {\n            var e = t.length;\n            if (e <= 15) this.pack_uint8(144 + e);\n            else if (e <= 65535)\n              this.bufferBuilder.append(220), this.pack_uint16(e);\n            else {\n              if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n              this.bufferBuilder.append(221), this.pack_uint32(e);\n            }\n            for (var i = 0; i < e; i++) this.pack(t[i]);\n          }),\n          (n.prototype.pack_integer = function (t) {\n            if (t >= -32 && t <= 127) this.bufferBuilder.append(255 & t);\n            else if (t >= 0 && t <= 255)\n              this.bufferBuilder.append(204), this.pack_uint8(t);\n            else if (t >= -128 && t <= 127)\n              this.bufferBuilder.append(208), this.pack_int8(t);\n            else if (t >= 0 && t <= 65535)\n              this.bufferBuilder.append(205), this.pack_uint16(t);\n            else if (t >= -32768 && t <= 32767)\n              this.bufferBuilder.append(209), this.pack_int16(t);\n            else if (t >= 0 && t <= 4294967295)\n              this.bufferBuilder.append(206), this.pack_uint32(t);\n            else if (t >= -2147483648 && t <= 2147483647)\n              this.bufferBuilder.append(210), this.pack_int32(t);\n            else if (t >= -0x8000000000000000 && t <= 0x8000000000000000)\n              this.bufferBuilder.append(211), this.pack_int64(t);\n            else {\n              if (!(t >= 0 && t <= 0x10000000000000000))\n                throw new Error(\"Invalid integer\");\n              this.bufferBuilder.append(207), this.pack_uint64(t);\n            }\n          }),\n          (n.prototype.pack_double = function (t) {\n            var e = 0;\n            t < 0 && ((e = 1), (t = -t));\n            var i = Math.floor(Math.log(t) / Math.LN2),\n              r = t / Math.pow(2, i) - 1,\n              n = Math.floor(r * Math.pow(2, 52)),\n              u = Math.pow(2, 32),\n              a = (e << 31) | ((i + 1023) << 20) | ((n / u) & 1048575),\n              p = n % u;\n            this.bufferBuilder.append(203),\n              this.pack_int32(a),\n              this.pack_int32(p);\n          }),\n          (n.prototype.pack_object = function (t) {\n            var e = Object.keys(t).length;\n            if (e <= 15) this.pack_uint8(128 + e);\n            else if (e <= 65535)\n              this.bufferBuilder.append(222), this.pack_uint16(e);\n            else {\n              if (!(e <= 4294967295)) throw new Error(\"Invalid length\");\n              this.bufferBuilder.append(223), this.pack_uint32(e);\n            }\n            for (var i in t)\n              t.hasOwnProperty(i) && (this.pack(i), this.pack(t[i]));\n          }),\n          (n.prototype.pack_uint8 = function (t) {\n            this.bufferBuilder.append(t);\n          }),\n          (n.prototype.pack_uint16 = function (t) {\n            this.bufferBuilder.append(t >> 8),\n              this.bufferBuilder.append(255 & t);\n          }),\n          (n.prototype.pack_uint32 = function (t) {\n            var e = 4294967295 & t;\n            this.bufferBuilder.append((4278190080 & e) >>> 24),\n              this.bufferBuilder.append((16711680 & e) >>> 16),\n              this.bufferBuilder.append((65280 & e) >>> 8),\n              this.bufferBuilder.append(255 & e);\n          }),\n          (n.prototype.pack_uint64 = function (t) {\n            var e = t / Math.pow(2, 32),\n              i = t % Math.pow(2, 32);\n            this.bufferBuilder.append((4278190080 & e) >>> 24),\n              this.bufferBuilder.append((16711680 & e) >>> 16),\n              this.bufferBuilder.append((65280 & e) >>> 8),\n              this.bufferBuilder.append(255 & e),\n              this.bufferBuilder.append((4278190080 & i) >>> 24),\n              this.bufferBuilder.append((16711680 & i) >>> 16),\n              this.bufferBuilder.append((65280 & i) >>> 8),\n              this.bufferBuilder.append(255 & i);\n          }),\n          (n.prototype.pack_int8 = function (t) {\n            this.bufferBuilder.append(255 & t);\n          }),\n          (n.prototype.pack_int16 = function (t) {\n            this.bufferBuilder.append((65280 & t) >> 8),\n              this.bufferBuilder.append(255 & t);\n          }),\n          (n.prototype.pack_int32 = function (t) {\n            this.bufferBuilder.append((t >>> 24) & 255),\n              this.bufferBuilder.append((16711680 & t) >>> 16),\n              this.bufferBuilder.append((65280 & t) >>> 8),\n              this.bufferBuilder.append(255 & t);\n          }),\n          (n.prototype.pack_int64 = function (t) {\n            var e = Math.floor(t / Math.pow(2, 32)),\n              i = t % Math.pow(2, 32);\n            this.bufferBuilder.append((4278190080 & e) >>> 24),\n              this.bufferBuilder.append((16711680 & e) >>> 16),\n              this.bufferBuilder.append((65280 & e) >>> 8),\n              this.bufferBuilder.append(255 & e),\n              this.bufferBuilder.append((4278190080 & i) >>> 24),\n              this.bufferBuilder.append((16711680 & i) >>> 16),\n              this.bufferBuilder.append((65280 & i) >>> 8),\n              this.bufferBuilder.append(255 & i);\n          });\n      },\n      { \"./bufferbuilder\": \"EgBh\" },\n    ],\n    iSxC: [\n      function (require, module, exports) {\n        \"use strict\";\n        function e(e, t, n) {\n          return (\n            t in e\n              ? Object.defineProperty(e, t, {\n                  value: n,\n                  enumerable: !0,\n                  configurable: !0,\n                  writable: !0,\n                })\n              : (e[t] = n),\n            e\n          );\n        }\n        function t(e) {\n          return (t =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.extractVersion = o),\n          (exports.wrapPeerConnectionEvent = i),\n          (exports.disableLog = s),\n          (exports.disableWarnings = a),\n          (exports.log = p),\n          (exports.deprecated = u),\n          (exports.detectBrowser = c),\n          (exports.compactObject = f),\n          (exports.walkStats = l),\n          (exports.filterStats = v);\n        var n = !0,\n          r = !0;\n        function o(e, t, n) {\n          var r = e.match(t);\n          return r && r.length >= n && parseInt(r[n], 10);\n        }\n        function i(e, t, n) {\n          if (e.RTCPeerConnection) {\n            var r = e.RTCPeerConnection.prototype,\n              o = r.addEventListener;\n            r.addEventListener = function (e, r) {\n              if (e !== t) return o.apply(this, arguments);\n              var i = function (e) {\n                var t = n(e);\n                t && (r.handleEvent ? r.handleEvent(t) : r(t));\n              };\n              return (\n                (this._eventMap = this._eventMap || {}),\n                this._eventMap[t] || (this._eventMap[t] = new Map()),\n                this._eventMap[t].set(r, i),\n                o.apply(this, [e, i])\n              );\n            };\n            var i = r.removeEventListener;\n            (r.removeEventListener = function (e, n) {\n              if (e !== t || !this._eventMap || !this._eventMap[t])\n                return i.apply(this, arguments);\n              if (!this._eventMap[t].has(n)) return i.apply(this, arguments);\n              var r = this._eventMap[t].get(n);\n              return (\n                this._eventMap[t].delete(n),\n                0 === this._eventMap[t].size && delete this._eventMap[t],\n                0 === Object.keys(this._eventMap).length &&\n                  delete this._eventMap,\n                i.apply(this, [e, r])\n              );\n            }),\n              Object.defineProperty(r, \"on\" + t, {\n                get: function () {\n                  return this[\"_on\" + t];\n                },\n                set: function (e) {\n                  this[\"_on\" + t] &&\n                    (this.removeEventListener(t, this[\"_on\" + t]),\n                    delete this[\"_on\" + t]),\n                    e && this.addEventListener(t, (this[\"_on\" + t] = e));\n                },\n                enumerable: !0,\n                configurable: !0,\n              });\n          }\n        }\n        function s(e) {\n          return \"boolean\" != typeof e\n            ? new Error(\"Argument type: \" + t(e) + \". Please use a boolean.\")\n            : ((n = e),\n              e ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\");\n        }\n        function a(e) {\n          return \"boolean\" != typeof e\n            ? new Error(\"Argument type: \" + t(e) + \". Please use a boolean.\")\n            : ((r = !e),\n              \"adapter.js deprecation warnings \" +\n                (e ? \"disabled\" : \"enabled\"));\n        }\n        function p() {\n          if (\n            \"object\" ===\n            (\"undefined\" == typeof window ? \"undefined\" : t(window))\n          ) {\n            if (n) return;\n            \"undefined\" != typeof console &&\n              \"function\" == typeof console.log &&\n              console.log.apply(console, arguments);\n          }\n        }\n        function u(e, t) {\n          r &&\n            console.warn(e + \" is deprecated, please use \" + t + \" instead.\");\n        }\n        function c(e) {\n          var t = { browser: null, version: null };\n          if (void 0 === e || !e.navigator)\n            return (t.browser = \"Not a browser.\"), t;\n          var { navigator: n } = e;\n          if (n.mozGetUserMedia)\n            (t.browser = \"firefox\"),\n              (t.version = o(n.userAgent, /Firefox\\/(\\d+)\\./, 1));\n          else if (\n            n.webkitGetUserMedia ||\n            (!1 === e.isSecureContext &&\n              e.webkitRTCPeerConnection &&\n              !e.RTCIceGatherer)\n          )\n            (t.browser = \"chrome\"),\n              (t.version = o(n.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2));\n          else if (n.mediaDevices && n.userAgent.match(/Edge\\/(\\d+).(\\d+)$/))\n            (t.browser = \"edge\"),\n              (t.version = o(n.userAgent, /Edge\\/(\\d+).(\\d+)$/, 2));\n          else {\n            if (\n              !e.RTCPeerConnection ||\n              !n.userAgent.match(/AppleWebKit\\/(\\d+)\\./)\n            )\n              return (t.browser = \"Not a supported browser.\"), t;\n            (t.browser = \"safari\"),\n              (t.version = o(n.userAgent, /AppleWebKit\\/(\\d+)\\./, 1)),\n              (t.supportsUnifiedPlan =\n                e.RTCRtpTransceiver &&\n                \"currentDirection\" in e.RTCRtpTransceiver.prototype);\n          }\n          return t;\n        }\n        function d(e) {\n          return \"[object Object]\" === Object.prototype.toString.call(e);\n        }\n        function f(t) {\n          return d(t)\n            ? Object.keys(t).reduce(function (n, r) {\n                var o = d(t[r]),\n                  i = o ? f(t[r]) : t[r],\n                  s = o && !Object.keys(i).length;\n                return void 0 === i || s ? n : Object.assign(n, e({}, r, i));\n              }, {})\n            : t;\n        }\n        function l(e, t, n) {\n          t &&\n            !n.has(t.id) &&\n            (n.set(t.id, t),\n            Object.keys(t).forEach(function (r) {\n              r.endsWith(\"Id\")\n                ? l(e, e.get(t[r]), n)\n                : r.endsWith(\"Ids\") &&\n                  t[r].forEach(function (t) {\n                    l(e, e.get(t), n);\n                  });\n            }));\n        }\n        function v(e, t, n) {\n          var r = n ? \"outbound-rtp\" : \"inbound-rtp\",\n            o = new Map();\n          if (null === t) return o;\n          var i = [];\n          return (\n            e.forEach(function (e) {\n              \"track\" === e.type && e.trackIdentifier === t.id && i.push(e);\n            }),\n            i.forEach(function (t) {\n              e.forEach(function (n) {\n                n.type === r && n.trackId === t.id && l(e, n, o);\n              });\n            }),\n            o\n          );\n        }\n      },\n      {},\n    ],\n    s6SN: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimGetUserMedia = i);\n        var e = t(require(\"../utils.js\"));\n        function r() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (r = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function t(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var t = r();\n          if (t && t.has(e)) return t.get(e);\n          var o = {},\n            n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in e)\n            if (Object.prototype.hasOwnProperty.call(e, i)) {\n              var a = n ? Object.getOwnPropertyDescriptor(e, i) : null;\n              a && (a.get || a.set)\n                ? Object.defineProperty(o, i, a)\n                : (o[i] = e[i]);\n            }\n          return (o.default = e), t && t.set(e, o), o;\n        }\n        function o(e) {\n          return (o =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        var n = e.log;\n        function i(e, r) {\n          var t = e && e.navigator;\n          if (t.mediaDevices) {\n            var i = function (e) {\n                if (\"object\" !== o(e) || e.mandatory || e.optional) return e;\n                var r = {};\n                return (\n                  Object.keys(e).forEach(function (t) {\n                    if (\n                      \"require\" !== t &&\n                      \"advanced\" !== t &&\n                      \"mediaSource\" !== t\n                    ) {\n                      var n = \"object\" === o(e[t]) ? e[t] : { ideal: e[t] };\n                      void 0 !== n.exact &&\n                        \"number\" == typeof n.exact &&\n                        (n.min = n.max = n.exact);\n                      var i = function (e, r) {\n                        return e\n                          ? e + r.charAt(0).toUpperCase() + r.slice(1)\n                          : \"deviceId\" === r\n                          ? \"sourceId\"\n                          : r;\n                      };\n                      if (void 0 !== n.ideal) {\n                        r.optional = r.optional || [];\n                        var a = {};\n                        \"number\" == typeof n.ideal\n                          ? ((a[i(\"min\", t)] = n.ideal),\n                            r.optional.push(a),\n                            ((a = {})[i(\"max\", t)] = n.ideal),\n                            r.optional.push(a))\n                          : ((a[i(\"\", t)] = n.ideal), r.optional.push(a));\n                      }\n                      void 0 !== n.exact && \"number\" != typeof n.exact\n                        ? ((r.mandatory = r.mandatory || {}),\n                          (r.mandatory[i(\"\", t)] = n.exact))\n                        : [\"min\", \"max\"].forEach(function (e) {\n                            void 0 !== n[e] &&\n                              ((r.mandatory = r.mandatory || {}),\n                              (r.mandatory[i(e, t)] = n[e]));\n                          });\n                    }\n                  }),\n                  e.advanced &&\n                    (r.optional = (r.optional || []).concat(e.advanced)),\n                  r\n                );\n              },\n              a = function (e, a) {\n                if (r.version >= 61) return a(e);\n                if (\n                  (e = JSON.parse(JSON.stringify(e))) &&\n                  \"object\" === o(e.audio)\n                ) {\n                  var c = function (e, r, t) {\n                    r in e && !(t in e) && ((e[t] = e[r]), delete e[r]);\n                  };\n                  c(\n                    (e = JSON.parse(JSON.stringify(e))).audio,\n                    \"autoGainControl\",\n                    \"googAutoGainControl\"\n                  ),\n                    c(e.audio, \"noiseSuppression\", \"googNoiseSuppression\"),\n                    (e.audio = i(e.audio));\n                }\n                if (e && \"object\" === o(e.video)) {\n                  var d = e.video.facingMode;\n                  d = d && (\"object\" === o(d) ? d : { ideal: d });\n                  var u,\n                    s = r.version < 66;\n                  if (\n                    d &&\n                    (\"user\" === d.exact ||\n                      \"environment\" === d.exact ||\n                      \"user\" === d.ideal ||\n                      \"environment\" === d.ideal) &&\n                    (!t.mediaDevices.getSupportedConstraints ||\n                      !t.mediaDevices.getSupportedConstraints().facingMode ||\n                      s)\n                  )\n                    if (\n                      (delete e.video.facingMode,\n                      \"environment\" === d.exact || \"environment\" === d.ideal\n                        ? (u = [\"back\", \"rear\"])\n                        : (\"user\" !== d.exact && \"user\" !== d.ideal) ||\n                          (u = [\"front\"]),\n                      u)\n                    )\n                      return t.mediaDevices\n                        .enumerateDevices()\n                        .then(function (r) {\n                          var t = (r = r.filter(function (e) {\n                            return \"videoinput\" === e.kind;\n                          })).find(function (e) {\n                            return u.some(function (r) {\n                              return e.label.toLowerCase().includes(r);\n                            });\n                          });\n                          return (\n                            !t &&\n                              r.length &&\n                              u.includes(\"back\") &&\n                              (t = r[r.length - 1]),\n                            t &&\n                              (e.video.deviceId = d.exact\n                                ? { exact: t.deviceId }\n                                : { ideal: t.deviceId }),\n                            (e.video = i(e.video)),\n                            n(\"chrome: \" + JSON.stringify(e)),\n                            a(e)\n                          );\n                        });\n                  e.video = i(e.video);\n                }\n                return n(\"chrome: \" + JSON.stringify(e)), a(e);\n              },\n              c = function (e) {\n                return r.version >= 64\n                  ? e\n                  : {\n                      name:\n                        {\n                          PermissionDeniedError: \"NotAllowedError\",\n                          PermissionDismissedError: \"NotAllowedError\",\n                          InvalidStateError: \"NotAllowedError\",\n                          DevicesNotFoundError: \"NotFoundError\",\n                          ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                          TrackStartError: \"NotReadableError\",\n                          MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                          MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                          TabCaptureError: \"AbortError\",\n                          ScreenCaptureError: \"AbortError\",\n                          DeviceCaptureError: \"AbortError\",\n                        }[e.name] || e.name,\n                      message: e.message,\n                      constraint: e.constraint || e.constraintName,\n                      toString: function () {\n                        return (\n                          this.name + (this.message && \": \") + this.message\n                        );\n                      },\n                    };\n              };\n            if (\n              ((t.getUserMedia = function (e, r, o) {\n                a(e, function (e) {\n                  t.webkitGetUserMedia(e, r, function (e) {\n                    o && o(c(e));\n                  });\n                });\n              }.bind(t)),\n              t.mediaDevices.getUserMedia)\n            ) {\n              var d = t.mediaDevices.getUserMedia.bind(t.mediaDevices);\n              t.mediaDevices.getUserMedia = function (e) {\n                return a(e, function (e) {\n                  return d(e).then(\n                    function (r) {\n                      if (\n                        (e.audio && !r.getAudioTracks().length) ||\n                        (e.video && !r.getVideoTracks().length)\n                      )\n                        throw (\n                          (r.getTracks().forEach(function (e) {\n                            e.stop();\n                          }),\n                          new DOMException(\"\", \"NotFoundError\"))\n                        );\n                      return r;\n                    },\n                    function (e) {\n                      return Promise.reject(c(e));\n                    }\n                  );\n                });\n              };\n            }\n          }\n        }\n      },\n      { \"../utils.js\": \"iSxC\" },\n    ],\n    VHa8: [\n      function (require, module, exports) {\n        \"use strict\";\n        function e(e, i) {\n          (e.navigator.mediaDevices &&\n            \"getDisplayMedia\" in e.navigator.mediaDevices) ||\n            (e.navigator.mediaDevices &&\n              (\"function\" == typeof i\n                ? (e.navigator.mediaDevices.getDisplayMedia = function (a) {\n                    return i(a).then(function (i) {\n                      var t = a.video && a.video.width,\n                        o = a.video && a.video.height,\n                        d = a.video && a.video.frameRate;\n                      return (\n                        (a.video = {\n                          mandatory: {\n                            chromeMediaSource: \"desktop\",\n                            chromeMediaSourceId: i,\n                            maxFrameRate: d || 3,\n                          },\n                        }),\n                        t && (a.video.mandatory.maxWidth = t),\n                        o && (a.video.mandatory.maxHeight = o),\n                        e.navigator.mediaDevices.getUserMedia(a)\n                      );\n                    });\n                  })\n                : console.error(\n                    \"shimGetDisplayMedia: getSourceId argument is not a function\"\n                  )));\n        }\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimGetDisplayMedia = e);\n      },\n      {},\n    ],\n    uI5X: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimMediaStream = a),\n          (exports.shimOnTrack = c),\n          (exports.shimGetSendersWithDtmf = p),\n          (exports.shimGetStats = d),\n          (exports.shimSenderReceiverGetStats = h),\n          (exports.shimAddTrackRemoveTrackWithNative = f),\n          (exports.shimAddTrackRemoveTrack = m),\n          (exports.shimPeerConnection = u),\n          (exports.fixNegotiationNeeded = l),\n          Object.defineProperty(exports, \"shimGetUserMedia\", {\n            enumerable: !0,\n            get: function () {\n              return t.shimGetUserMedia;\n            },\n          }),\n          Object.defineProperty(exports, \"shimGetDisplayMedia\", {\n            enumerable: !0,\n            get: function () {\n              return r.shimGetDisplayMedia;\n            },\n          });\n        var e = i(require(\"../utils.js\")),\n          t = require(\"./getusermedia\"),\n          r = require(\"./getdisplaymedia\");\n        function n() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (n = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function i(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var t = n();\n          if (t && t.has(e)) return t.get(e);\n          var r = {},\n            i = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var o in e)\n            if (Object.prototype.hasOwnProperty.call(e, o)) {\n              var s = i ? Object.getOwnPropertyDescriptor(e, o) : null;\n              s && (s.get || s.set)\n                ? Object.defineProperty(r, o, s)\n                : (r[o] = e[o]);\n            }\n          return (r.default = e), t && t.set(e, r), r;\n        }\n        function o(e, t, r) {\n          return (\n            t in e\n              ? Object.defineProperty(e, t, {\n                  value: r,\n                  enumerable: !0,\n                  configurable: !0,\n                  writable: !0,\n                })\n              : (e[t] = r),\n            e\n          );\n        }\n        function s(e) {\n          return (s =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        function a(e) {\n          e.MediaStream = e.MediaStream || e.webkitMediaStream;\n        }\n        function c(t) {\n          if (\n            \"object\" !== s(t) ||\n            !t.RTCPeerConnection ||\n            \"ontrack\" in t.RTCPeerConnection.prototype\n          )\n            e.wrapPeerConnectionEvent(t, \"track\", function (e) {\n              return (\n                e.transceiver ||\n                  Object.defineProperty(e, \"transceiver\", {\n                    value: { receiver: e.receiver },\n                  }),\n                e\n              );\n            });\n          else {\n            Object.defineProperty(t.RTCPeerConnection.prototype, \"ontrack\", {\n              get: function () {\n                return this._ontrack;\n              },\n              set: function (e) {\n                this._ontrack &&\n                  this.removeEventListener(\"track\", this._ontrack),\n                  this.addEventListener(\"track\", (this._ontrack = e));\n              },\n              enumerable: !0,\n              configurable: !0,\n            });\n            var r = t.RTCPeerConnection.prototype.setRemoteDescription;\n            t.RTCPeerConnection.prototype.setRemoteDescription = function () {\n              var e = this;\n              return (\n                this._ontrackpoly ||\n                  ((this._ontrackpoly = function (r) {\n                    r.stream.addEventListener(\"addtrack\", function (n) {\n                      var i;\n                      i = t.RTCPeerConnection.prototype.getReceivers\n                        ? e.getReceivers().find(function (e) {\n                            return e.track && e.track.id === n.track.id;\n                          })\n                        : { track: n.track };\n                      var o = new Event(\"track\");\n                      (o.track = n.track),\n                        (o.receiver = i),\n                        (o.transceiver = { receiver: i }),\n                        (o.streams = [r.stream]),\n                        e.dispatchEvent(o);\n                    }),\n                      r.stream.getTracks().forEach(function (n) {\n                        var i;\n                        i = t.RTCPeerConnection.prototype.getReceivers\n                          ? e.getReceivers().find(function (e) {\n                              return e.track && e.track.id === n.id;\n                            })\n                          : { track: n };\n                        var o = new Event(\"track\");\n                        (o.track = n),\n                          (o.receiver = i),\n                          (o.transceiver = { receiver: i }),\n                          (o.streams = [r.stream]),\n                          e.dispatchEvent(o);\n                      });\n                  }),\n                  this.addEventListener(\"addstream\", this._ontrackpoly)),\n                r.apply(this, arguments)\n              );\n            };\n          }\n        }\n        function p(e) {\n          if (\n            \"object\" === s(e) &&\n            e.RTCPeerConnection &&\n            !(\"getSenders\" in e.RTCPeerConnection.prototype) &&\n            \"createDTMFSender\" in e.RTCPeerConnection.prototype\n          ) {\n            var t = function (e, t) {\n              return {\n                track: t,\n                get dtmf() {\n                  return (\n                    void 0 === this._dtmf &&\n                      (\"audio\" === t.kind\n                        ? (this._dtmf = e.createDTMFSender(t))\n                        : (this._dtmf = null)),\n                    this._dtmf\n                  );\n                },\n                _pc: e,\n              };\n            };\n            if (!e.RTCPeerConnection.prototype.getSenders) {\n              e.RTCPeerConnection.prototype.getSenders = function () {\n                return (\n                  (this._senders = this._senders || []), this._senders.slice()\n                );\n              };\n              var r = e.RTCPeerConnection.prototype.addTrack;\n              e.RTCPeerConnection.prototype.addTrack = function (e, n) {\n                var i = r.apply(this, arguments);\n                return i || ((i = t(this, e)), this._senders.push(i)), i;\n              };\n              var n = e.RTCPeerConnection.prototype.removeTrack;\n              e.RTCPeerConnection.prototype.removeTrack = function (e) {\n                n.apply(this, arguments);\n                var t = this._senders.indexOf(e);\n                -1 !== t && this._senders.splice(t, 1);\n              };\n            }\n            var i = e.RTCPeerConnection.prototype.addStream;\n            e.RTCPeerConnection.prototype.addStream = function (e) {\n              var r = this;\n              (this._senders = this._senders || []),\n                i.apply(this, [e]),\n                e.getTracks().forEach(function (e) {\n                  r._senders.push(t(r, e));\n                });\n            };\n            var o = e.RTCPeerConnection.prototype.removeStream;\n            e.RTCPeerConnection.prototype.removeStream = function (e) {\n              var t = this;\n              (this._senders = this._senders || []),\n                o.apply(this, [e]),\n                e.getTracks().forEach(function (e) {\n                  var r = t._senders.find(function (t) {\n                    return t.track === e;\n                  });\n                  r && t._senders.splice(t._senders.indexOf(r), 1);\n                });\n            };\n          } else if (\n            \"object\" === s(e) &&\n            e.RTCPeerConnection &&\n            \"getSenders\" in e.RTCPeerConnection.prototype &&\n            \"createDTMFSender\" in e.RTCPeerConnection.prototype &&\n            e.RTCRtpSender &&\n            !(\"dtmf\" in e.RTCRtpSender.prototype)\n          ) {\n            var a = e.RTCPeerConnection.prototype.getSenders;\n            (e.RTCPeerConnection.prototype.getSenders = function () {\n              var e = this,\n                t = a.apply(this, []);\n              return (\n                t.forEach(function (t) {\n                  return (t._pc = e);\n                }),\n                t\n              );\n            }),\n              Object.defineProperty(e.RTCRtpSender.prototype, \"dtmf\", {\n                get: function () {\n                  return (\n                    void 0 === this._dtmf &&\n                      (\"audio\" === this.track.kind\n                        ? (this._dtmf = this._pc.createDTMFSender(this.track))\n                        : (this._dtmf = null)),\n                    this._dtmf\n                  );\n                },\n              });\n          }\n        }\n        function d(e) {\n          if (e.RTCPeerConnection) {\n            var t = e.RTCPeerConnection.prototype.getStats;\n            e.RTCPeerConnection.prototype.getStats = function () {\n              var e = this,\n                [r, n, i] = arguments;\n              if (arguments.length > 0 && \"function\" == typeof r)\n                return t.apply(this, arguments);\n              if (\n                0 === t.length &&\n                (0 === arguments.length || \"function\" != typeof r)\n              )\n                return t.apply(this, []);\n              var o = function (e) {\n                  var t = {};\n                  return (\n                    e.result().forEach(function (e) {\n                      var r = {\n                        id: e.id,\n                        timestamp: e.timestamp,\n                        type:\n                          {\n                            localcandidate: \"local-candidate\",\n                            remotecandidate: \"remote-candidate\",\n                          }[e.type] || e.type,\n                      };\n                      e.names().forEach(function (t) {\n                        r[t] = e.stat(t);\n                      }),\n                        (t[r.id] = r);\n                    }),\n                    t\n                  );\n                },\n                s = function (e) {\n                  return new Map(\n                    Object.keys(e).map(function (t) {\n                      return [t, e[t]];\n                    })\n                  );\n                };\n              if (arguments.length >= 2) {\n                return t.apply(this, [\n                  function (e) {\n                    n(s(o(e)));\n                  },\n                  r,\n                ]);\n              }\n              return new Promise(function (r, n) {\n                t.apply(e, [\n                  function (e) {\n                    r(s(o(e)));\n                  },\n                  n,\n                ]);\n              }).then(n, i);\n            };\n          }\n        }\n        function h(t) {\n          if (\n            \"object\" === s(t) &&\n            t.RTCPeerConnection &&\n            t.RTCRtpSender &&\n            t.RTCRtpReceiver\n          ) {\n            if (!(\"getStats\" in t.RTCRtpSender.prototype)) {\n              var r = t.RTCPeerConnection.prototype.getSenders;\n              r &&\n                (t.RTCPeerConnection.prototype.getSenders = function () {\n                  var e = this,\n                    t = r.apply(this, []);\n                  return (\n                    t.forEach(function (t) {\n                      return (t._pc = e);\n                    }),\n                    t\n                  );\n                });\n              var n = t.RTCPeerConnection.prototype.addTrack;\n              n &&\n                (t.RTCPeerConnection.prototype.addTrack = function () {\n                  var e = n.apply(this, arguments);\n                  return (e._pc = this), e;\n                }),\n                (t.RTCRtpSender.prototype.getStats = function () {\n                  var t = this;\n                  return this._pc.getStats().then(function (r) {\n                    return e.filterStats(r, t.track, !0);\n                  });\n                });\n            }\n            if (!(\"getStats\" in t.RTCRtpReceiver.prototype)) {\n              var i = t.RTCPeerConnection.prototype.getReceivers;\n              i &&\n                (t.RTCPeerConnection.prototype.getReceivers = function () {\n                  var e = this,\n                    t = i.apply(this, []);\n                  return (\n                    t.forEach(function (t) {\n                      return (t._pc = e);\n                    }),\n                    t\n                  );\n                }),\n                e.wrapPeerConnectionEvent(t, \"track\", function (e) {\n                  return (e.receiver._pc = e.srcElement), e;\n                }),\n                (t.RTCRtpReceiver.prototype.getStats = function () {\n                  var t = this;\n                  return this._pc.getStats().then(function (r) {\n                    return e.filterStats(r, t.track, !1);\n                  });\n                });\n            }\n            if (\n              \"getStats\" in t.RTCRtpSender.prototype &&\n              \"getStats\" in t.RTCRtpReceiver.prototype\n            ) {\n              var o = t.RTCPeerConnection.prototype.getStats;\n              t.RTCPeerConnection.prototype.getStats = function () {\n                if (\n                  arguments.length > 0 &&\n                  arguments[0] instanceof t.MediaStreamTrack\n                ) {\n                  var e,\n                    r,\n                    n,\n                    i = arguments[0];\n                  return (\n                    this.getSenders().forEach(function (t) {\n                      t.track === i && (e ? (n = !0) : (e = t));\n                    }),\n                    this.getReceivers().forEach(function (e) {\n                      return (\n                        e.track === i && (r ? (n = !0) : (r = e)), e.track === i\n                      );\n                    }),\n                    n || (e && r)\n                      ? Promise.reject(\n                          new DOMException(\n                            \"There are more than one sender or receiver for the track.\",\n                            \"InvalidAccessError\"\n                          )\n                        )\n                      : e\n                      ? e.getStats()\n                      : r\n                      ? r.getStats()\n                      : Promise.reject(\n                          new DOMException(\n                            \"There is no sender or receiver for the track.\",\n                            \"InvalidAccessError\"\n                          )\n                        )\n                  );\n                }\n                return o.apply(this, arguments);\n              };\n            }\n          }\n        }\n        function f(e) {\n          e.RTCPeerConnection.prototype.getLocalStreams = function () {\n            var e = this;\n            return (\n              (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),\n              Object.keys(this._shimmedLocalStreams).map(function (t) {\n                return e._shimmedLocalStreams[t][0];\n              })\n            );\n          };\n          var t = e.RTCPeerConnection.prototype.addTrack;\n          e.RTCPeerConnection.prototype.addTrack = function (e, r) {\n            if (!r) return t.apply(this, arguments);\n            this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n            var n = t.apply(this, arguments);\n            return (\n              this._shimmedLocalStreams[r.id]\n                ? -1 === this._shimmedLocalStreams[r.id].indexOf(n) &&\n                  this._shimmedLocalStreams[r.id].push(n)\n                : (this._shimmedLocalStreams[r.id] = [r, n]),\n              n\n            );\n          };\n          var r = e.RTCPeerConnection.prototype.addStream;\n          e.RTCPeerConnection.prototype.addStream = function (e) {\n            var t = this;\n            (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),\n              e.getTracks().forEach(function (e) {\n                if (\n                  t.getSenders().find(function (t) {\n                    return t.track === e;\n                  })\n                )\n                  throw new DOMException(\n                    \"Track already exists.\",\n                    \"InvalidAccessError\"\n                  );\n              });\n            var n = this.getSenders();\n            r.apply(this, arguments);\n            var i = this.getSenders().filter(function (e) {\n              return -1 === n.indexOf(e);\n            });\n            this._shimmedLocalStreams[e.id] = [e].concat(i);\n          };\n          var n = e.RTCPeerConnection.prototype.removeStream;\n          e.RTCPeerConnection.prototype.removeStream = function (e) {\n            return (\n              (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),\n              delete this._shimmedLocalStreams[e.id],\n              n.apply(this, arguments)\n            );\n          };\n          var i = e.RTCPeerConnection.prototype.removeTrack;\n          e.RTCPeerConnection.prototype.removeTrack = function (e) {\n            var t = this;\n            return (\n              (this._shimmedLocalStreams = this._shimmedLocalStreams || {}),\n              e &&\n                Object.keys(this._shimmedLocalStreams).forEach(function (r) {\n                  var n = t._shimmedLocalStreams[r].indexOf(e);\n                  -1 !== n && t._shimmedLocalStreams[r].splice(n, 1),\n                    1 === t._shimmedLocalStreams[r].length &&\n                      delete t._shimmedLocalStreams[r];\n                }),\n              i.apply(this, arguments)\n            );\n          };\n        }\n        function m(e, t) {\n          if (e.RTCPeerConnection) {\n            if (e.RTCPeerConnection.prototype.addTrack && t.version >= 65)\n              return f(e);\n            var r = e.RTCPeerConnection.prototype.getLocalStreams;\n            e.RTCPeerConnection.prototype.getLocalStreams = function () {\n              var e = this,\n                t = r.apply(this);\n              return (\n                (this._reverseStreams = this._reverseStreams || {}),\n                t.map(function (t) {\n                  return e._reverseStreams[t.id];\n                })\n              );\n            };\n            var n = e.RTCPeerConnection.prototype.addStream;\n            e.RTCPeerConnection.prototype.addStream = function (t) {\n              var r = this;\n              if (\n                ((this._streams = this._streams || {}),\n                (this._reverseStreams = this._reverseStreams || {}),\n                t.getTracks().forEach(function (e) {\n                  if (\n                    r.getSenders().find(function (t) {\n                      return t.track === e;\n                    })\n                  )\n                    throw new DOMException(\n                      \"Track already exists.\",\n                      \"InvalidAccessError\"\n                    );\n                }),\n                !this._reverseStreams[t.id])\n              ) {\n                var i = new e.MediaStream(t.getTracks());\n                (this._streams[t.id] = i),\n                  (this._reverseStreams[i.id] = t),\n                  (t = i);\n              }\n              n.apply(this, [t]);\n            };\n            var i = e.RTCPeerConnection.prototype.removeStream;\n            (e.RTCPeerConnection.prototype.removeStream = function (e) {\n              (this._streams = this._streams || {}),\n                (this._reverseStreams = this._reverseStreams || {}),\n                i.apply(this, [this._streams[e.id] || e]),\n                delete this._reverseStreams[\n                  this._streams[e.id] ? this._streams[e.id].id : e.id\n                ],\n                delete this._streams[e.id];\n            }),\n              (e.RTCPeerConnection.prototype.addTrack = function (t, r) {\n                var n = this;\n                if (\"closed\" === this.signalingState)\n                  throw new DOMException(\n                    \"The RTCPeerConnection's signalingState is 'closed'.\",\n                    \"InvalidStateError\"\n                  );\n                var i = [].slice.call(arguments, 1);\n                if (\n                  1 !== i.length ||\n                  !i[0].getTracks().find(function (e) {\n                    return e === t;\n                  })\n                )\n                  throw new DOMException(\n                    \"The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.\",\n                    \"NotSupportedError\"\n                  );\n                if (\n                  this.getSenders().find(function (e) {\n                    return e.track === t;\n                  })\n                )\n                  throw new DOMException(\n                    \"Track already exists.\",\n                    \"InvalidAccessError\"\n                  );\n                (this._streams = this._streams || {}),\n                  (this._reverseStreams = this._reverseStreams || {});\n                var o = this._streams[r.id];\n                if (o)\n                  o.addTrack(t),\n                    Promise.resolve().then(function () {\n                      n.dispatchEvent(new Event(\"negotiationneeded\"));\n                    });\n                else {\n                  var s = new e.MediaStream([t]);\n                  (this._streams[r.id] = s),\n                    (this._reverseStreams[s.id] = r),\n                    this.addStream(s);\n                }\n                return this.getSenders().find(function (e) {\n                  return e.track === t;\n                });\n              }),\n              [\"createOffer\", \"createAnswer\"].forEach(function (t) {\n                var r = e.RTCPeerConnection.prototype[t],\n                  n = o({}, t, function () {\n                    var e = this,\n                      t = arguments;\n                    return arguments.length && \"function\" == typeof arguments[0]\n                      ? r.apply(this, [\n                          function (r) {\n                            var n = c(e, r);\n                            t[0].apply(null, [n]);\n                          },\n                          function (e) {\n                            t[1] && t[1].apply(null, e);\n                          },\n                          arguments[2],\n                        ])\n                      : r.apply(this, arguments).then(function (t) {\n                          return c(e, t);\n                        });\n                  });\n                e.RTCPeerConnection.prototype[t] = n[t];\n              });\n            var s = e.RTCPeerConnection.prototype.setLocalDescription;\n            e.RTCPeerConnection.prototype.setLocalDescription = function () {\n              return arguments.length && arguments[0].type\n                ? ((arguments[0] =\n                    ((e = this),\n                    (t = arguments[0]),\n                    (r = t.sdp),\n                    Object.keys(e._reverseStreams || []).forEach(function (t) {\n                      var n = e._reverseStreams[t],\n                        i = e._streams[n.id];\n                      r = r.replace(new RegExp(n.id, \"g\"), i.id);\n                    }),\n                    new RTCSessionDescription({ type: t.type, sdp: r }))),\n                  s.apply(this, arguments))\n                : s.apply(this, arguments);\n              var e, t, r;\n            };\n            var a = Object.getOwnPropertyDescriptor(\n              e.RTCPeerConnection.prototype,\n              \"localDescription\"\n            );\n            Object.defineProperty(\n              e.RTCPeerConnection.prototype,\n              \"localDescription\",\n              {\n                get: function () {\n                  var e = a.get.apply(this);\n                  return \"\" === e.type ? e : c(this, e);\n                },\n              }\n            ),\n              (e.RTCPeerConnection.prototype.removeTrack = function (e) {\n                var t,\n                  r = this;\n                if (\"closed\" === this.signalingState)\n                  throw new DOMException(\n                    \"The RTCPeerConnection's signalingState is 'closed'.\",\n                    \"InvalidStateError\"\n                  );\n                if (!e._pc)\n                  throw new DOMException(\n                    \"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\",\n                    \"TypeError\"\n                  );\n                if (!(e._pc === this))\n                  throw new DOMException(\n                    \"Sender was not created by this connection.\",\n                    \"InvalidAccessError\"\n                  );\n                (this._streams = this._streams || {}),\n                  Object.keys(this._streams).forEach(function (n) {\n                    r._streams[n].getTracks().find(function (t) {\n                      return e.track === t;\n                    }) && (t = r._streams[n]);\n                  }),\n                  t &&\n                    (1 === t.getTracks().length\n                      ? this.removeStream(this._reverseStreams[t.id])\n                      : t.removeTrack(e.track),\n                    this.dispatchEvent(new Event(\"negotiationneeded\")));\n              });\n          }\n          function c(e, t) {\n            var r = t.sdp;\n            return (\n              Object.keys(e._reverseStreams || []).forEach(function (t) {\n                var n = e._reverseStreams[t],\n                  i = e._streams[n.id];\n                r = r.replace(new RegExp(i.id, \"g\"), n.id);\n              }),\n              new RTCSessionDescription({ type: t.type, sdp: r })\n            );\n          }\n        }\n        function u(e, t) {\n          !e.RTCPeerConnection &&\n            e.webkitRTCPeerConnection &&\n            (e.RTCPeerConnection = e.webkitRTCPeerConnection),\n            e.RTCPeerConnection &&\n              t.version < 53 &&\n              [\n                \"setLocalDescription\",\n                \"setRemoteDescription\",\n                \"addIceCandidate\",\n              ].forEach(function (t) {\n                var r = e.RTCPeerConnection.prototype[t],\n                  n = o({}, t, function () {\n                    return (\n                      (arguments[0] = new (\n                        \"addIceCandidate\" === t\n                          ? e.RTCIceCandidate\n                          : e.RTCSessionDescription\n                      )(arguments[0])),\n                      r.apply(this, arguments)\n                    );\n                  });\n                e.RTCPeerConnection.prototype[t] = n[t];\n              });\n        }\n        function l(t, r) {\n          e.wrapPeerConnectionEvent(t, \"negotiationneeded\", function (e) {\n            var t = e.target;\n            if (\n              !(\n                r.version < 72 ||\n                (t.getConfiguration &&\n                  \"plan-b\" === t.getConfiguration().sdpSemantics)\n              ) ||\n              \"stable\" === t.signalingState\n            )\n              return e;\n          });\n        }\n      },\n      {\n        \"../utils.js\": \"iSxC\",\n        \"./getusermedia\": \"s6SN\",\n        \"./getdisplaymedia\": \"VHa8\",\n      },\n    ],\n    NZ1C: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.filterIceServers = n);\n        var r = t(require(\"../utils\"));\n        function e() {\n          if (\"function\" != typeof WeakMap) return null;\n          var r = new WeakMap();\n          return (\n            (e = function () {\n              return r;\n            }),\n            r\n          );\n        }\n        function t(r) {\n          if (r && r.__esModule) return r;\n          if (null === r || (\"object\" != typeof r && \"function\" != typeof r))\n            return { default: r };\n          var t = e();\n          if (t && t.has(r)) return t.get(r);\n          var n = {},\n            u = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in r)\n            if (Object.prototype.hasOwnProperty.call(r, i)) {\n              var f = u ? Object.getOwnPropertyDescriptor(r, i) : null;\n              f && (f.get || f.set)\n                ? Object.defineProperty(n, i, f)\n                : (n[i] = r[i]);\n            }\n          return (n.default = r), t && t.set(r, n), n;\n        }\n        function n(e, t) {\n          var n = !1;\n          return (e = JSON.parse(JSON.stringify(e))).filter(function (e) {\n            if (e && (e.urls || e.url)) {\n              var t = e.urls || e.url;\n              e.url &&\n                !e.urls &&\n                r.deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n              var u = \"string\" == typeof t;\n              return (\n                u && (t = [t]),\n                (t = t.filter(function (r) {\n                  if (0 === r.indexOf(\"stun:\")) return !1;\n                  var e =\n                    r.startsWith(\"turn\") &&\n                    !r.startsWith(\"turn:[\") &&\n                    r.includes(\"transport=udp\");\n                  return e && !n ? ((n = !0), !0) : e && !n;\n                })),\n                delete e.url,\n                (e.urls = u ? t[0] : t),\n                !!t.length\n              );\n            }\n          });\n        }\n      },\n      { \"../utils\": \"iSxC\" },\n    ],\n    YHvh: [\n      function (require, module, exports) {\n        \"use strict\";\n        var r = {\n          generateIdentifier: function () {\n            return Math.random().toString(36).substr(2, 10);\n          },\n        };\n        (r.localCName = r.generateIdentifier()),\n          (r.splitLines = function (r) {\n            return r\n              .trim()\n              .split(\"\\n\")\n              .map(function (r) {\n                return r.trim();\n              });\n          }),\n          (r.splitSections = function (r) {\n            return r.split(\"\\nm=\").map(function (r, e) {\n              return (e > 0 ? \"m=\" + r : r).trim() + \"\\r\\n\";\n            });\n          }),\n          (r.getDescription = function (e) {\n            var t = r.splitSections(e);\n            return t && t[0];\n          }),\n          (r.getMediaSections = function (e) {\n            var t = r.splitSections(e);\n            return t.shift(), t;\n          }),\n          (r.matchPrefix = function (e, t) {\n            return r.splitLines(e).filter(function (r) {\n              return 0 === r.indexOf(t);\n            });\n          }),\n          (r.parseCandidate = function (r) {\n            for (\n              var e,\n                t = {\n                  foundation: (e =\n                    0 === r.indexOf(\"a=candidate:\")\n                      ? r.substring(12).split(\" \")\n                      : r.substring(10).split(\" \"))[0],\n                  component: parseInt(e[1], 10),\n                  protocol: e[2].toLowerCase(),\n                  priority: parseInt(e[3], 10),\n                  ip: e[4],\n                  address: e[4],\n                  port: parseInt(e[5], 10),\n                  type: e[7],\n                },\n                a = 8;\n              a < e.length;\n              a += 2\n            )\n              switch (e[a]) {\n                case \"raddr\":\n                  t.relatedAddress = e[a + 1];\n                  break;\n                case \"rport\":\n                  t.relatedPort = parseInt(e[a + 1], 10);\n                  break;\n                case \"tcptype\":\n                  t.tcpType = e[a + 1];\n                  break;\n                case \"ufrag\":\n                  (t.ufrag = e[a + 1]), (t.usernameFragment = e[a + 1]);\n                  break;\n                default:\n                  t[e[a]] = e[a + 1];\n              }\n            return t;\n          }),\n          (r.writeCandidate = function (r) {\n            var e = [];\n            e.push(r.foundation),\n              e.push(r.component),\n              e.push(r.protocol.toUpperCase()),\n              e.push(r.priority),\n              e.push(r.address || r.ip),\n              e.push(r.port);\n            var t = r.type;\n            return (\n              e.push(\"typ\"),\n              e.push(t),\n              \"host\" !== t &&\n                r.relatedAddress &&\n                r.relatedPort &&\n                (e.push(\"raddr\"),\n                e.push(r.relatedAddress),\n                e.push(\"rport\"),\n                e.push(r.relatedPort)),\n              r.tcpType &&\n                \"tcp\" === r.protocol.toLowerCase() &&\n                (e.push(\"tcptype\"), e.push(r.tcpType)),\n              (r.usernameFragment || r.ufrag) &&\n                (e.push(\"ufrag\"), e.push(r.usernameFragment || r.ufrag)),\n              \"candidate:\" + e.join(\" \")\n            );\n          }),\n          (r.parseIceOptions = function (r) {\n            return r.substr(14).split(\" \");\n          }),\n          (r.parseRtpMap = function (r) {\n            var e = r.substr(9).split(\" \"),\n              t = { payloadType: parseInt(e.shift(), 10) };\n            return (\n              (e = e[0].split(\"/\")),\n              (t.name = e[0]),\n              (t.clockRate = parseInt(e[1], 10)),\n              (t.channels = 3 === e.length ? parseInt(e[2], 10) : 1),\n              (t.numChannels = t.channels),\n              t\n            );\n          }),\n          (r.writeRtpMap = function (r) {\n            var e = r.payloadType;\n            void 0 !== r.preferredPayloadType && (e = r.preferredPayloadType);\n            var t = r.channels || r.numChannels || 1;\n            return (\n              \"a=rtpmap:\" +\n              e +\n              \" \" +\n              r.name +\n              \"/\" +\n              r.clockRate +\n              (1 !== t ? \"/\" + t : \"\") +\n              \"\\r\\n\"\n            );\n          }),\n          (r.parseExtmap = function (r) {\n            var e = r.substr(9).split(\" \");\n            return {\n              id: parseInt(e[0], 10),\n              direction:\n                e[0].indexOf(\"/\") > 0 ? e[0].split(\"/\")[1] : \"sendrecv\",\n              uri: e[1],\n            };\n          }),\n          (r.writeExtmap = function (r) {\n            return (\n              \"a=extmap:\" +\n              (r.id || r.preferredId) +\n              (r.direction && \"sendrecv\" !== r.direction\n                ? \"/\" + r.direction\n                : \"\") +\n              \" \" +\n              r.uri +\n              \"\\r\\n\"\n            );\n          }),\n          (r.parseFmtp = function (r) {\n            for (\n              var e, t = {}, a = r.substr(r.indexOf(\" \") + 1).split(\";\"), n = 0;\n              n < a.length;\n              n++\n            )\n              t[(e = a[n].trim().split(\"=\"))[0].trim()] = e[1];\n            return t;\n          }),\n          (r.writeFmtp = function (r) {\n            var e = \"\",\n              t = r.payloadType;\n            if (\n              (void 0 !== r.preferredPayloadType &&\n                (t = r.preferredPayloadType),\n              r.parameters && Object.keys(r.parameters).length)\n            ) {\n              var a = [];\n              Object.keys(r.parameters).forEach(function (e) {\n                r.parameters[e] ? a.push(e + \"=\" + r.parameters[e]) : a.push(e);\n              }),\n                (e += \"a=fmtp:\" + t + \" \" + a.join(\";\") + \"\\r\\n\");\n            }\n            return e;\n          }),\n          (r.parseRtcpFb = function (r) {\n            var e = r.substr(r.indexOf(\" \") + 1).split(\" \");\n            return { type: e.shift(), parameter: e.join(\" \") };\n          }),\n          (r.writeRtcpFb = function (r) {\n            var e = \"\",\n              t = r.payloadType;\n            return (\n              void 0 !== r.preferredPayloadType && (t = r.preferredPayloadType),\n              r.rtcpFeedback &&\n                r.rtcpFeedback.length &&\n                r.rtcpFeedback.forEach(function (r) {\n                  e +=\n                    \"a=rtcp-fb:\" +\n                    t +\n                    \" \" +\n                    r.type +\n                    (r.parameter && r.parameter.length\n                      ? \" \" + r.parameter\n                      : \"\") +\n                    \"\\r\\n\";\n                }),\n              e\n            );\n          }),\n          (r.parseSsrcMedia = function (r) {\n            var e = r.indexOf(\" \"),\n              t = { ssrc: parseInt(r.substr(7, e - 7), 10) },\n              a = r.indexOf(\":\", e);\n            return (\n              a > -1\n                ? ((t.attribute = r.substr(e + 1, a - e - 1)),\n                  (t.value = r.substr(a + 1)))\n                : (t.attribute = r.substr(e + 1)),\n              t\n            );\n          }),\n          (r.parseSsrcGroup = function (r) {\n            var e = r.substr(13).split(\" \");\n            return {\n              semantics: e.shift(),\n              ssrcs: e.map(function (r) {\n                return parseInt(r, 10);\n              }),\n            };\n          }),\n          (r.getMid = function (e) {\n            var t = r.matchPrefix(e, \"a=mid:\")[0];\n            if (t) return t.substr(6);\n          }),\n          (r.parseFingerprint = function (r) {\n            var e = r.substr(14).split(\" \");\n            return { algorithm: e[0].toLowerCase(), value: e[1] };\n          }),\n          (r.getDtlsParameters = function (e, t) {\n            return {\n              role: \"auto\",\n              fingerprints: r\n                .matchPrefix(e + t, \"a=fingerprint:\")\n                .map(r.parseFingerprint),\n            };\n          }),\n          (r.writeDtlsParameters = function (r, e) {\n            var t = \"a=setup:\" + e + \"\\r\\n\";\n            return (\n              r.fingerprints.forEach(function (r) {\n                t += \"a=fingerprint:\" + r.algorithm + \" \" + r.value + \"\\r\\n\";\n              }),\n              t\n            );\n          }),\n          (r.parseCryptoLine = function (r) {\n            var e = r.substr(9).split(\" \");\n            return {\n              tag: parseInt(e[0], 10),\n              cryptoSuite: e[1],\n              keyParams: e[2],\n              sessionParams: e.slice(3),\n            };\n          }),\n          (r.writeCryptoLine = function (e) {\n            return (\n              \"a=crypto:\" +\n              e.tag +\n              \" \" +\n              e.cryptoSuite +\n              \" \" +\n              (\"object\" == typeof e.keyParams\n                ? r.writeCryptoKeyParams(e.keyParams)\n                : e.keyParams) +\n              (e.sessionParams ? \" \" + e.sessionParams.join(\" \") : \"\") +\n              \"\\r\\n\"\n            );\n          }),\n          (r.parseCryptoKeyParams = function (r) {\n            if (0 !== r.indexOf(\"inline:\")) return null;\n            var e = r.substr(7).split(\"|\");\n            return {\n              keyMethod: \"inline\",\n              keySalt: e[0],\n              lifeTime: e[1],\n              mkiValue: e[2] ? e[2].split(\":\")[0] : void 0,\n              mkiLength: e[2] ? e[2].split(\":\")[1] : void 0,\n            };\n          }),\n          (r.writeCryptoKeyParams = function (r) {\n            return (\n              r.keyMethod +\n              \":\" +\n              r.keySalt +\n              (r.lifeTime ? \"|\" + r.lifeTime : \"\") +\n              (r.mkiValue && r.mkiLength\n                ? \"|\" + r.mkiValue + \":\" + r.mkiLength\n                : \"\")\n            );\n          }),\n          (r.getCryptoParameters = function (e, t) {\n            return r.matchPrefix(e + t, \"a=crypto:\").map(r.parseCryptoLine);\n          }),\n          (r.getIceParameters = function (e, t) {\n            var a = r.matchPrefix(e + t, \"a=ice-ufrag:\")[0],\n              n = r.matchPrefix(e + t, \"a=ice-pwd:\")[0];\n            return a && n\n              ? { usernameFragment: a.substr(12), password: n.substr(10) }\n              : null;\n          }),\n          (r.writeIceParameters = function (r) {\n            return (\n              \"a=ice-ufrag:\" +\n              r.usernameFragment +\n              \"\\r\\na=ice-pwd:\" +\n              r.password +\n              \"\\r\\n\"\n            );\n          }),\n          (r.parseRtpParameters = function (e) {\n            for (\n              var t = {\n                  codecs: [],\n                  headerExtensions: [],\n                  fecMechanisms: [],\n                  rtcp: [],\n                },\n                a = r.splitLines(e)[0].split(\" \"),\n                n = 3;\n              n < a.length;\n              n++\n            ) {\n              var s = a[n],\n                i = r.matchPrefix(e, \"a=rtpmap:\" + s + \" \")[0];\n              if (i) {\n                var p = r.parseRtpMap(i),\n                  c = r.matchPrefix(e, \"a=fmtp:\" + s + \" \");\n                switch (\n                  ((p.parameters = c.length ? r.parseFmtp(c[0]) : {}),\n                  (p.rtcpFeedback = r\n                    .matchPrefix(e, \"a=rtcp-fb:\" + s + \" \")\n                    .map(r.parseRtcpFb)),\n                  t.codecs.push(p),\n                  p.name.toUpperCase())\n                ) {\n                  case \"RED\":\n                  case \"ULPFEC\":\n                    t.fecMechanisms.push(p.name.toUpperCase());\n                }\n              }\n            }\n            return (\n              r.matchPrefix(e, \"a=extmap:\").forEach(function (e) {\n                t.headerExtensions.push(r.parseExtmap(e));\n              }),\n              t\n            );\n          }),\n          (r.writeRtpDescription = function (e, t) {\n            var a = \"\";\n            (a += \"m=\" + e + \" \"),\n              (a += t.codecs.length > 0 ? \"9\" : \"0\"),\n              (a += \" UDP/TLS/RTP/SAVPF \"),\n              (a +=\n                t.codecs\n                  .map(function (r) {\n                    return void 0 !== r.preferredPayloadType\n                      ? r.preferredPayloadType\n                      : r.payloadType;\n                  })\n                  .join(\" \") + \"\\r\\n\"),\n              (a += \"c=IN IP4 0.0.0.0\\r\\n\"),\n              (a += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\"),\n              t.codecs.forEach(function (e) {\n                (a += r.writeRtpMap(e)),\n                  (a += r.writeFmtp(e)),\n                  (a += r.writeRtcpFb(e));\n              });\n            var n = 0;\n            return (\n              t.codecs.forEach(function (r) {\n                r.maxptime > n && (n = r.maxptime);\n              }),\n              n > 0 && (a += \"a=maxptime:\" + n + \"\\r\\n\"),\n              (a += \"a=rtcp-mux\\r\\n\"),\n              t.headerExtensions &&\n                t.headerExtensions.forEach(function (e) {\n                  a += r.writeExtmap(e);\n                }),\n              a\n            );\n          }),\n          (r.parseRtpEncodingParameters = function (e) {\n            var t,\n              a = [],\n              n = r.parseRtpParameters(e),\n              s = -1 !== n.fecMechanisms.indexOf(\"RED\"),\n              i = -1 !== n.fecMechanisms.indexOf(\"ULPFEC\"),\n              p = r\n                .matchPrefix(e, \"a=ssrc:\")\n                .map(function (e) {\n                  return r.parseSsrcMedia(e);\n                })\n                .filter(function (r) {\n                  return \"cname\" === r.attribute;\n                }),\n              c = p.length > 0 && p[0].ssrc,\n              o = r.matchPrefix(e, \"a=ssrc-group:FID\").map(function (r) {\n                return r\n                  .substr(17)\n                  .split(\" \")\n                  .map(function (r) {\n                    return parseInt(r, 10);\n                  });\n              });\n            o.length > 0 && o[0].length > 1 && o[0][0] === c && (t = o[0][1]),\n              n.codecs.forEach(function (r) {\n                if (\"RTX\" === r.name.toUpperCase() && r.parameters.apt) {\n                  var e = {\n                    ssrc: c,\n                    codecPayloadType: parseInt(r.parameters.apt, 10),\n                  };\n                  c && t && (e.rtx = { ssrc: t }),\n                    a.push(e),\n                    s &&\n                      (((e = JSON.parse(JSON.stringify(e))).fec = {\n                        ssrc: c,\n                        mechanism: i ? \"red+ulpfec\" : \"red\",\n                      }),\n                      a.push(e));\n                }\n              }),\n              0 === a.length && c && a.push({ ssrc: c });\n            var u = r.matchPrefix(e, \"b=\");\n            return (\n              u.length &&\n                ((u =\n                  0 === u[0].indexOf(\"b=TIAS:\")\n                    ? parseInt(u[0].substr(7), 10)\n                    : 0 === u[0].indexOf(\"b=AS:\")\n                    ? 1e3 * parseInt(u[0].substr(5), 10) * 0.95 - 16e3\n                    : void 0),\n                a.forEach(function (r) {\n                  r.maxBitrate = u;\n                })),\n              a\n            );\n          }),\n          (r.parseRtcpParameters = function (e) {\n            var t = {},\n              a = r\n                .matchPrefix(e, \"a=ssrc:\")\n                .map(function (e) {\n                  return r.parseSsrcMedia(e);\n                })\n                .filter(function (r) {\n                  return \"cname\" === r.attribute;\n                })[0];\n            a && ((t.cname = a.value), (t.ssrc = a.ssrc));\n            var n = r.matchPrefix(e, \"a=rtcp-rsize\");\n            (t.reducedSize = n.length > 0), (t.compound = 0 === n.length);\n            var s = r.matchPrefix(e, \"a=rtcp-mux\");\n            return (t.mux = s.length > 0), t;\n          }),\n          (r.parseMsid = function (e) {\n            var t,\n              a = r.matchPrefix(e, \"a=msid:\");\n            if (1 === a.length)\n              return {\n                stream: (t = a[0].substr(7).split(\" \"))[0],\n                track: t[1],\n              };\n            var n = r\n              .matchPrefix(e, \"a=ssrc:\")\n              .map(function (e) {\n                return r.parseSsrcMedia(e);\n              })\n              .filter(function (r) {\n                return \"msid\" === r.attribute;\n              });\n            return n.length > 0\n              ? { stream: (t = n[0].value.split(\" \"))[0], track: t[1] }\n              : void 0;\n          }),\n          (r.parseSctpDescription = function (e) {\n            var t,\n              a = r.parseMLine(e),\n              n = r.matchPrefix(e, \"a=max-message-size:\");\n            n.length > 0 && (t = parseInt(n[0].substr(19), 10)),\n              isNaN(t) && (t = 65536);\n            var s = r.matchPrefix(e, \"a=sctp-port:\");\n            if (s.length > 0)\n              return {\n                port: parseInt(s[0].substr(12), 10),\n                protocol: a.fmt,\n                maxMessageSize: t,\n              };\n            if (r.matchPrefix(e, \"a=sctpmap:\").length > 0) {\n              var i = r.matchPrefix(e, \"a=sctpmap:\")[0].substr(10).split(\" \");\n              return {\n                port: parseInt(i[0], 10),\n                protocol: i[1],\n                maxMessageSize: t,\n              };\n            }\n          }),\n          (r.writeSctpDescription = function (r, e) {\n            var t = [];\n            return (\n              (t =\n                \"DTLS/SCTP\" !== r.protocol\n                  ? [\n                      \"m=\" +\n                        r.kind +\n                        \" 9 \" +\n                        r.protocol +\n                        \" \" +\n                        e.protocol +\n                        \"\\r\\n\",\n                      \"c=IN IP4 0.0.0.0\\r\\n\",\n                      \"a=sctp-port:\" + e.port + \"\\r\\n\",\n                    ]\n                  : [\n                      \"m=\" +\n                        r.kind +\n                        \" 9 \" +\n                        r.protocol +\n                        \" \" +\n                        e.port +\n                        \"\\r\\n\",\n                      \"c=IN IP4 0.0.0.0\\r\\n\",\n                      \"a=sctpmap:\" + e.port + \" \" + e.protocol + \" 65535\\r\\n\",\n                    ]),\n              void 0 !== e.maxMessageSize &&\n                t.push(\"a=max-message-size:\" + e.maxMessageSize + \"\\r\\n\"),\n              t.join(\"\")\n            );\n          }),\n          (r.generateSessionId = function () {\n            return Math.random().toString().substr(2, 21);\n          }),\n          (r.writeSessionBoilerplate = function (e, t, a) {\n            var n = void 0 !== t ? t : 2;\n            return (\n              \"v=0\\r\\no=\" +\n              (a || \"thisisadapterortc\") +\n              \" \" +\n              (e || r.generateSessionId()) +\n              \" \" +\n              n +\n              \" IN IP4 127.0.0.1\\r\\ns=-\\r\\nt=0 0\\r\\n\"\n            );\n          }),\n          (r.writeMediaSection = function (e, t, a, n) {\n            var s = r.writeRtpDescription(e.kind, t);\n            if (\n              ((s += r.writeIceParameters(e.iceGatherer.getLocalParameters())),\n              (s += r.writeDtlsParameters(\n                e.dtlsTransport.getLocalParameters(),\n                \"offer\" === a ? \"actpass\" : \"active\"\n              )),\n              (s += \"a=mid:\" + e.mid + \"\\r\\n\"),\n              e.direction\n                ? (s += \"a=\" + e.direction + \"\\r\\n\")\n                : e.rtpSender && e.rtpReceiver\n                ? (s += \"a=sendrecv\\r\\n\")\n                : e.rtpSender\n                ? (s += \"a=sendonly\\r\\n\")\n                : e.rtpReceiver\n                ? (s += \"a=recvonly\\r\\n\")\n                : (s += \"a=inactive\\r\\n\"),\n              e.rtpSender)\n            ) {\n              var i = \"msid:\" + n.id + \" \" + e.rtpSender.track.id + \"\\r\\n\";\n              (s += \"a=\" + i),\n                (s += \"a=ssrc:\" + e.sendEncodingParameters[0].ssrc + \" \" + i),\n                e.sendEncodingParameters[0].rtx &&\n                  ((s +=\n                    \"a=ssrc:\" + e.sendEncodingParameters[0].rtx.ssrc + \" \" + i),\n                  (s +=\n                    \"a=ssrc-group:FID \" +\n                    e.sendEncodingParameters[0].ssrc +\n                    \" \" +\n                    e.sendEncodingParameters[0].rtx.ssrc +\n                    \"\\r\\n\"));\n            }\n            return (\n              (s +=\n                \"a=ssrc:\" +\n                e.sendEncodingParameters[0].ssrc +\n                \" cname:\" +\n                r.localCName +\n                \"\\r\\n\"),\n              e.rtpSender &&\n                e.sendEncodingParameters[0].rtx &&\n                (s +=\n                  \"a=ssrc:\" +\n                  e.sendEncodingParameters[0].rtx.ssrc +\n                  \" cname:\" +\n                  r.localCName +\n                  \"\\r\\n\"),\n              s\n            );\n          }),\n          (r.getDirection = function (e, t) {\n            for (var a = r.splitLines(e), n = 0; n < a.length; n++)\n              switch (a[n]) {\n                case \"a=sendrecv\":\n                case \"a=sendonly\":\n                case \"a=recvonly\":\n                case \"a=inactive\":\n                  return a[n].substr(2);\n              }\n            return t ? r.getDirection(t) : \"sendrecv\";\n          }),\n          (r.getKind = function (e) {\n            return r.splitLines(e)[0].split(\" \")[0].substr(2);\n          }),\n          (r.isRejected = function (r) {\n            return \"0\" === r.split(\" \", 2)[1];\n          }),\n          (r.parseMLine = function (e) {\n            var t = r.splitLines(e)[0].substr(2).split(\" \");\n            return {\n              kind: t[0],\n              port: parseInt(t[1], 10),\n              protocol: t[2],\n              fmt: t.slice(3).join(\" \"),\n            };\n          }),\n          (r.parseOLine = function (e) {\n            var t = r.matchPrefix(e, \"o=\")[0].substr(2).split(\" \");\n            return {\n              username: t[0],\n              sessionId: t[1],\n              sessionVersion: parseInt(t[2], 10),\n              netType: t[3],\n              addressType: t[4],\n              address: t[5],\n            };\n          }),\n          (r.isValidSDP = function (e) {\n            if (\"string\" != typeof e || 0 === e.length) return !1;\n            for (var t = r.splitLines(e), a = 0; a < t.length; a++)\n              if (t[a].length < 2 || \"=\" !== t[a].charAt(1)) return !1;\n            return !0;\n          }),\n          \"object\" == typeof module && (module.exports = r);\n      },\n      {},\n    ],\n    NJ2u: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e = require(\"sdp\");\n        function t(e) {\n          return (\n            {\n              inboundrtp: \"inbound-rtp\",\n              outboundrtp: \"outbound-rtp\",\n              candidatepair: \"candidate-pair\",\n              localcandidate: \"local-candidate\",\n              remotecandidate: \"remote-candidate\",\n            }[e.type] || e.type\n          );\n        }\n        function r(t, r, n, a, i) {\n          var s = e.writeRtpDescription(t.kind, r);\n          if (\n            ((s += e.writeIceParameters(t.iceGatherer.getLocalParameters())),\n            (s += e.writeDtlsParameters(\n              t.dtlsTransport.getLocalParameters(),\n              \"offer\" === n ? \"actpass\" : i || \"active\"\n            )),\n            (s += \"a=mid:\" + t.mid + \"\\r\\n\"),\n            t.rtpSender && t.rtpReceiver\n              ? (s += \"a=sendrecv\\r\\n\")\n              : t.rtpSender\n              ? (s += \"a=sendonly\\r\\n\")\n              : t.rtpReceiver\n              ? (s += \"a=recvonly\\r\\n\")\n              : (s += \"a=inactive\\r\\n\"),\n            t.rtpSender)\n          ) {\n            var o = t.rtpSender._initialTrackId || t.rtpSender.track.id;\n            t.rtpSender._initialTrackId = o;\n            var c = \"msid:\" + (a ? a.id : \"-\") + \" \" + o + \"\\r\\n\";\n            (s += \"a=\" + c),\n              (s += \"a=ssrc:\" + t.sendEncodingParameters[0].ssrc + \" \" + c),\n              t.sendEncodingParameters[0].rtx &&\n                ((s +=\n                  \"a=ssrc:\" + t.sendEncodingParameters[0].rtx.ssrc + \" \" + c),\n                (s +=\n                  \"a=ssrc-group:FID \" +\n                  t.sendEncodingParameters[0].ssrc +\n                  \" \" +\n                  t.sendEncodingParameters[0].rtx.ssrc +\n                  \"\\r\\n\"));\n          }\n          return (\n            (s +=\n              \"a=ssrc:\" +\n              t.sendEncodingParameters[0].ssrc +\n              \" cname:\" +\n              e.localCName +\n              \"\\r\\n\"),\n            t.rtpSender &&\n              t.sendEncodingParameters[0].rtx &&\n              (s +=\n                \"a=ssrc:\" +\n                t.sendEncodingParameters[0].rtx.ssrc +\n                \" cname:\" +\n                e.localCName +\n                \"\\r\\n\"),\n            s\n          );\n        }\n        function n(e, t) {\n          var r = !1;\n          return (e = JSON.parse(JSON.stringify(e))).filter(function (e) {\n            if (e && (e.urls || e.url)) {\n              var n = e.urls || e.url;\n              e.url &&\n                !e.urls &&\n                console.warn(\n                  \"RTCIceServer.url is deprecated! Use urls instead.\"\n                );\n              var a = \"string\" == typeof n;\n              return (\n                a && (n = [n]),\n                (n = n.filter(function (e) {\n                  return 0 === e.indexOf(\"turn:\") &&\n                    -1 !== e.indexOf(\"transport=udp\") &&\n                    -1 === e.indexOf(\"turn:[\") &&\n                    !r\n                    ? ((r = !0), !0)\n                    : 0 === e.indexOf(\"stun:\") &&\n                        t >= 14393 &&\n                        -1 === e.indexOf(\"?transport=udp\");\n                })),\n                delete e.url,\n                (e.urls = a ? n[0] : n),\n                !!n.length\n              );\n            }\n          });\n        }\n        function a(e, t) {\n          var r = { codecs: [], headerExtensions: [], fecMechanisms: [] },\n            n = function (e, t) {\n              e = parseInt(e, 10);\n              for (var r = 0; r < t.length; r++)\n                if (t[r].payloadType === e || t[r].preferredPayloadType === e)\n                  return t[r];\n            },\n            a = function (e, t, r, a) {\n              var i = n(e.parameters.apt, r),\n                s = n(t.parameters.apt, a);\n              return i && s && i.name.toLowerCase() === s.name.toLowerCase();\n            };\n          return (\n            e.codecs.forEach(function (n) {\n              for (var i = 0; i < t.codecs.length; i++) {\n                var s = t.codecs[i];\n                if (\n                  n.name.toLowerCase() === s.name.toLowerCase() &&\n                  n.clockRate === s.clockRate\n                ) {\n                  if (\n                    \"rtx\" === n.name.toLowerCase() &&\n                    n.parameters &&\n                    s.parameters.apt &&\n                    !a(n, s, e.codecs, t.codecs)\n                  )\n                    continue;\n                  ((s = JSON.parse(JSON.stringify(s))).numChannels = Math.min(\n                    n.numChannels,\n                    s.numChannels\n                  )),\n                    r.codecs.push(s),\n                    (s.rtcpFeedback = s.rtcpFeedback.filter(function (e) {\n                      for (var t = 0; t < n.rtcpFeedback.length; t++)\n                        if (\n                          n.rtcpFeedback[t].type === e.type &&\n                          n.rtcpFeedback[t].parameter === e.parameter\n                        )\n                          return !0;\n                      return !1;\n                    }));\n                  break;\n                }\n              }\n            }),\n            e.headerExtensions.forEach(function (e) {\n              for (var n = 0; n < t.headerExtensions.length; n++) {\n                var a = t.headerExtensions[n];\n                if (e.uri === a.uri) {\n                  r.headerExtensions.push(a);\n                  break;\n                }\n              }\n            }),\n            r\n          );\n        }\n        function i(e, t, r) {\n          return (\n            -1 !==\n            {\n              offer: {\n                setLocalDescription: [\"stable\", \"have-local-offer\"],\n                setRemoteDescription: [\"stable\", \"have-remote-offer\"],\n              },\n              answer: {\n                setLocalDescription: [\n                  \"have-remote-offer\",\n                  \"have-local-pranswer\",\n                ],\n                setRemoteDescription: [\n                  \"have-local-offer\",\n                  \"have-remote-pranswer\",\n                ],\n              },\n            }[t][e].indexOf(r)\n          );\n        }\n        function s(e, t) {\n          var r = e.getRemoteCandidates().find(function (e) {\n            return (\n              t.foundation === e.foundation &&\n              t.ip === e.ip &&\n              t.port === e.port &&\n              t.priority === e.priority &&\n              t.protocol === e.protocol &&\n              t.type === e.type\n            );\n          });\n          return r || e.addRemoteCandidate(t), !r;\n        }\n        function o(e, t) {\n          var r = new Error(t);\n          return (\n            (r.name = e),\n            (r.code = {\n              NotSupportedError: 9,\n              InvalidStateError: 11,\n              InvalidAccessError: 15,\n              TypeError: void 0,\n              OperationError: void 0,\n            }[e]),\n            r\n          );\n        }\n        module.exports = function (c, d) {\n          function p(e, t) {\n            t.addTrack(e),\n              t.dispatchEvent(\n                new c.MediaStreamTrackEvent(\"addtrack\", { track: e })\n              );\n          }\n          function l(e, t, r, n) {\n            var a = new Event(\"track\");\n            (a.track = t),\n              (a.receiver = r),\n              (a.transceiver = { receiver: r }),\n              (a.streams = n),\n              c.setTimeout(function () {\n                e._dispatchEvent(\"track\", a);\n              });\n          }\n          var f = function (t) {\n            var r = this,\n              a = document.createDocumentFragment();\n            if (\n              ([\n                \"addEventListener\",\n                \"removeEventListener\",\n                \"dispatchEvent\",\n              ].forEach(function (e) {\n                r[e] = a[e].bind(a);\n              }),\n              (this.canTrickleIceCandidates = null),\n              (this.needNegotiation = !1),\n              (this.localStreams = []),\n              (this.remoteStreams = []),\n              (this._localDescription = null),\n              (this._remoteDescription = null),\n              (this.signalingState = \"stable\"),\n              (this.iceConnectionState = \"new\"),\n              (this.connectionState = \"new\"),\n              (this.iceGatheringState = \"new\"),\n              (t = JSON.parse(JSON.stringify(t || {}))),\n              (this.usingBundle = \"max-bundle\" === t.bundlePolicy),\n              \"negotiate\" === t.rtcpMuxPolicy)\n            )\n              throw o(\n                \"NotSupportedError\",\n                \"rtcpMuxPolicy 'negotiate' is not supported\"\n              );\n            switch (\n              (t.rtcpMuxPolicy || (t.rtcpMuxPolicy = \"require\"),\n              t.iceTransportPolicy)\n            ) {\n              case \"all\":\n              case \"relay\":\n                break;\n              default:\n                t.iceTransportPolicy = \"all\";\n            }\n            switch (t.bundlePolicy) {\n              case \"balanced\":\n              case \"max-compat\":\n              case \"max-bundle\":\n                break;\n              default:\n                t.bundlePolicy = \"balanced\";\n            }\n            if (\n              ((t.iceServers = n(t.iceServers || [], d)),\n              (this._iceGatherers = []),\n              t.iceCandidatePoolSize)\n            )\n              for (var i = t.iceCandidatePoolSize; i > 0; i--)\n                this._iceGatherers.push(\n                  new c.RTCIceGatherer({\n                    iceServers: t.iceServers,\n                    gatherPolicy: t.iceTransportPolicy,\n                  })\n                );\n            else t.iceCandidatePoolSize = 0;\n            (this._config = t),\n              (this.transceivers = []),\n              (this._sdpSessionId = e.generateSessionId()),\n              (this._sdpSessionVersion = 0),\n              (this._dtlsRole = void 0),\n              (this._isClosed = !1);\n          };\n          Object.defineProperty(f.prototype, \"localDescription\", {\n            configurable: !0,\n            get: function () {\n              return this._localDescription;\n            },\n          }),\n            Object.defineProperty(f.prototype, \"remoteDescription\", {\n              configurable: !0,\n              get: function () {\n                return this._remoteDescription;\n              },\n            }),\n            (f.prototype.onicecandidate = null),\n            (f.prototype.onaddstream = null),\n            (f.prototype.ontrack = null),\n            (f.prototype.onremovestream = null),\n            (f.prototype.onsignalingstatechange = null),\n            (f.prototype.oniceconnectionstatechange = null),\n            (f.prototype.onconnectionstatechange = null),\n            (f.prototype.onicegatheringstatechange = null),\n            (f.prototype.onnegotiationneeded = null),\n            (f.prototype.ondatachannel = null),\n            (f.prototype._dispatchEvent = function (e, t) {\n              this._isClosed ||\n                (this.dispatchEvent(t),\n                \"function\" == typeof this[\"on\" + e] && this[\"on\" + e](t));\n            }),\n            (f.prototype._emitGatheringStateChange = function () {\n              var e = new Event(\"icegatheringstatechange\");\n              this._dispatchEvent(\"icegatheringstatechange\", e);\n            }),\n            (f.prototype.getConfiguration = function () {\n              return this._config;\n            }),\n            (f.prototype.getLocalStreams = function () {\n              return this.localStreams;\n            }),\n            (f.prototype.getRemoteStreams = function () {\n              return this.remoteStreams;\n            }),\n            (f.prototype._createTransceiver = function (e, t) {\n              var r = this.transceivers.length > 0,\n                n = {\n                  track: null,\n                  iceGatherer: null,\n                  iceTransport: null,\n                  dtlsTransport: null,\n                  localCapabilities: null,\n                  remoteCapabilities: null,\n                  rtpSender: null,\n                  rtpReceiver: null,\n                  kind: e,\n                  mid: null,\n                  sendEncodingParameters: null,\n                  recvEncodingParameters: null,\n                  stream: null,\n                  associatedRemoteMediaStreams: [],\n                  wantReceive: !0,\n                };\n              if (this.usingBundle && r)\n                (n.iceTransport = this.transceivers[0].iceTransport),\n                  (n.dtlsTransport = this.transceivers[0].dtlsTransport);\n              else {\n                var a = this._createIceAndDtlsTransports();\n                (n.iceTransport = a.iceTransport),\n                  (n.dtlsTransport = a.dtlsTransport);\n              }\n              return t || this.transceivers.push(n), n;\n            }),\n            (f.prototype.addTrack = function (e, t) {\n              if (this._isClosed)\n                throw o(\n                  \"InvalidStateError\",\n                  \"Attempted to call addTrack on a closed peerconnection.\"\n                );\n              var r;\n              if (\n                this.transceivers.find(function (t) {\n                  return t.track === e;\n                })\n              )\n                throw o(\"InvalidAccessError\", \"Track already exists.\");\n              for (var n = 0; n < this.transceivers.length; n++)\n                this.transceivers[n].track ||\n                  this.transceivers[n].kind !== e.kind ||\n                  (r = this.transceivers[n]);\n              return (\n                r || (r = this._createTransceiver(e.kind)),\n                this._maybeFireNegotiationNeeded(),\n                -1 === this.localStreams.indexOf(t) &&\n                  this.localStreams.push(t),\n                (r.track = e),\n                (r.stream = t),\n                (r.rtpSender = new c.RTCRtpSender(e, r.dtlsTransport)),\n                r.rtpSender\n              );\n            }),\n            (f.prototype.addStream = function (e) {\n              var t = this;\n              if (d >= 15025)\n                e.getTracks().forEach(function (r) {\n                  t.addTrack(r, e);\n                });\n              else {\n                var r = e.clone();\n                e.getTracks().forEach(function (e, t) {\n                  var n = r.getTracks()[t];\n                  e.addEventListener(\"enabled\", function (e) {\n                    n.enabled = e.enabled;\n                  });\n                }),\n                  r.getTracks().forEach(function (e) {\n                    t.addTrack(e, r);\n                  });\n              }\n            }),\n            (f.prototype.removeTrack = function (e) {\n              if (this._isClosed)\n                throw o(\n                  \"InvalidStateError\",\n                  \"Attempted to call removeTrack on a closed peerconnection.\"\n                );\n              if (!(e instanceof c.RTCRtpSender))\n                throw new TypeError(\n                  \"Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.\"\n                );\n              var t = this.transceivers.find(function (t) {\n                return t.rtpSender === e;\n              });\n              if (!t)\n                throw o(\n                  \"InvalidAccessError\",\n                  \"Sender was not created by this connection.\"\n                );\n              var r = t.stream;\n              t.rtpSender.stop(),\n                (t.rtpSender = null),\n                (t.track = null),\n                (t.stream = null),\n                -1 ===\n                  this.transceivers\n                    .map(function (e) {\n                      return e.stream;\n                    })\n                    .indexOf(r) &&\n                  this.localStreams.indexOf(r) > -1 &&\n                  this.localStreams.splice(this.localStreams.indexOf(r), 1),\n                this._maybeFireNegotiationNeeded();\n            }),\n            (f.prototype.removeStream = function (e) {\n              var t = this;\n              e.getTracks().forEach(function (e) {\n                var r = t.getSenders().find(function (t) {\n                  return t.track === e;\n                });\n                r && t.removeTrack(r);\n              });\n            }),\n            (f.prototype.getSenders = function () {\n              return this.transceivers\n                .filter(function (e) {\n                  return !!e.rtpSender;\n                })\n                .map(function (e) {\n                  return e.rtpSender;\n                });\n            }),\n            (f.prototype.getReceivers = function () {\n              return this.transceivers\n                .filter(function (e) {\n                  return !!e.rtpReceiver;\n                })\n                .map(function (e) {\n                  return e.rtpReceiver;\n                });\n            }),\n            (f.prototype._createIceGatherer = function (e, t) {\n              var r = this;\n              if (t && e > 0) return this.transceivers[0].iceGatherer;\n              if (this._iceGatherers.length) return this._iceGatherers.shift();\n              var n = new c.RTCIceGatherer({\n                iceServers: this._config.iceServers,\n                gatherPolicy: this._config.iceTransportPolicy,\n              });\n              return (\n                Object.defineProperty(n, \"state\", {\n                  value: \"new\",\n                  writable: !0,\n                }),\n                (this.transceivers[e].bufferedCandidateEvents = []),\n                (this.transceivers[e].bufferCandidates = function (t) {\n                  var a = !t.candidate || 0 === Object.keys(t.candidate).length;\n                  (n.state = a ? \"completed\" : \"gathering\"),\n                    null !== r.transceivers[e].bufferedCandidateEvents &&\n                      r.transceivers[e].bufferedCandidateEvents.push(t);\n                }),\n                n.addEventListener(\n                  \"localcandidate\",\n                  this.transceivers[e].bufferCandidates\n                ),\n                n\n              );\n            }),\n            (f.prototype._gather = function (t, r) {\n              var n = this,\n                a = this.transceivers[r].iceGatherer;\n              if (!a.onlocalcandidate) {\n                var i = this.transceivers[r].bufferedCandidateEvents;\n                (this.transceivers[r].bufferedCandidateEvents = null),\n                  a.removeEventListener(\n                    \"localcandidate\",\n                    this.transceivers[r].bufferCandidates\n                  ),\n                  (a.onlocalcandidate = function (i) {\n                    if (!(n.usingBundle && r > 0)) {\n                      var s = new Event(\"icecandidate\");\n                      s.candidate = { sdpMid: t, sdpMLineIndex: r };\n                      var o = i.candidate,\n                        c = !o || 0 === Object.keys(o).length;\n                      if (c)\n                        (\"new\" !== a.state && \"gathering\" !== a.state) ||\n                          (a.state = \"completed\");\n                      else {\n                        \"new\" === a.state && (a.state = \"gathering\"),\n                          (o.component = 1),\n                          (o.ufrag = a.getLocalParameters().usernameFragment);\n                        var d = e.writeCandidate(o);\n                        (s.candidate = Object.assign(\n                          s.candidate,\n                          e.parseCandidate(d)\n                        )),\n                          (s.candidate.candidate = d),\n                          (s.candidate.toJSON = function () {\n                            return {\n                              candidate: s.candidate.candidate,\n                              sdpMid: s.candidate.sdpMid,\n                              sdpMLineIndex: s.candidate.sdpMLineIndex,\n                              usernameFragment: s.candidate.usernameFragment,\n                            };\n                          });\n                      }\n                      var p = e.getMediaSections(n._localDescription.sdp);\n                      (p[s.candidate.sdpMLineIndex] += c\n                        ? \"a=end-of-candidates\\r\\n\"\n                        : \"a=\" + s.candidate.candidate + \"\\r\\n\"),\n                        (n._localDescription.sdp =\n                          e.getDescription(n._localDescription.sdp) +\n                          p.join(\"\"));\n                      var l = n.transceivers.every(function (e) {\n                        return (\n                          e.iceGatherer && \"completed\" === e.iceGatherer.state\n                        );\n                      });\n                      \"gathering\" !== n.iceGatheringState &&\n                        ((n.iceGatheringState = \"gathering\"),\n                        n._emitGatheringStateChange()),\n                        c || n._dispatchEvent(\"icecandidate\", s),\n                        l &&\n                          (n._dispatchEvent(\n                            \"icecandidate\",\n                            new Event(\"icecandidate\")\n                          ),\n                          (n.iceGatheringState = \"complete\"),\n                          n._emitGatheringStateChange());\n                    }\n                  }),\n                  c.setTimeout(function () {\n                    i.forEach(function (e) {\n                      a.onlocalcandidate(e);\n                    });\n                  }, 0);\n              }\n            }),\n            (f.prototype._createIceAndDtlsTransports = function () {\n              var e = this,\n                t = new c.RTCIceTransport(null);\n              t.onicestatechange = function () {\n                e._updateIceConnectionState(), e._updateConnectionState();\n              };\n              var r = new c.RTCDtlsTransport(t);\n              return (\n                (r.ondtlsstatechange = function () {\n                  e._updateConnectionState();\n                }),\n                (r.onerror = function () {\n                  Object.defineProperty(r, \"state\", {\n                    value: \"failed\",\n                    writable: !0,\n                  }),\n                    e._updateConnectionState();\n                }),\n                { iceTransport: t, dtlsTransport: r }\n              );\n            }),\n            (f.prototype._disposeIceAndDtlsTransports = function (e) {\n              var t = this.transceivers[e].iceGatherer;\n              t &&\n                (delete t.onlocalcandidate,\n                delete this.transceivers[e].iceGatherer);\n              var r = this.transceivers[e].iceTransport;\n              r &&\n                (delete r.onicestatechange,\n                delete this.transceivers[e].iceTransport);\n              var n = this.transceivers[e].dtlsTransport;\n              n &&\n                (delete n.ondtlsstatechange,\n                delete n.onerror,\n                delete this.transceivers[e].dtlsTransport);\n            }),\n            (f.prototype._transceive = function (t, r, n) {\n              var i = a(t.localCapabilities, t.remoteCapabilities);\n              r &&\n                t.rtpSender &&\n                ((i.encodings = t.sendEncodingParameters),\n                (i.rtcp = {\n                  cname: e.localCName,\n                  compound: t.rtcpParameters.compound,\n                }),\n                t.recvEncodingParameters.length &&\n                  (i.rtcp.ssrc = t.recvEncodingParameters[0].ssrc),\n                t.rtpSender.send(i)),\n                n &&\n                  t.rtpReceiver &&\n                  i.codecs.length > 0 &&\n                  (\"video\" === t.kind &&\n                    t.recvEncodingParameters &&\n                    d < 15019 &&\n                    t.recvEncodingParameters.forEach(function (e) {\n                      delete e.rtx;\n                    }),\n                  t.recvEncodingParameters.length\n                    ? (i.encodings = t.recvEncodingParameters)\n                    : (i.encodings = [{}]),\n                  (i.rtcp = { compound: t.rtcpParameters.compound }),\n                  t.rtcpParameters.cname &&\n                    (i.rtcp.cname = t.rtcpParameters.cname),\n                  t.sendEncodingParameters.length &&\n                    (i.rtcp.ssrc = t.sendEncodingParameters[0].ssrc),\n                  t.rtpReceiver.receive(i));\n            }),\n            (f.prototype.setLocalDescription = function (t) {\n              var r,\n                n,\n                s = this;\n              if (-1 === [\"offer\", \"answer\"].indexOf(t.type))\n                return Promise.reject(\n                  o(\"TypeError\", 'Unsupported type \"' + t.type + '\"')\n                );\n              if (\n                !i(\"setLocalDescription\", t.type, s.signalingState) ||\n                s._isClosed\n              )\n                return Promise.reject(\n                  o(\n                    \"InvalidStateError\",\n                    \"Can not set local \" +\n                      t.type +\n                      \" in state \" +\n                      s.signalingState\n                  )\n                );\n              if (\"offer\" === t.type)\n                (r = e.splitSections(t.sdp)),\n                  (n = r.shift()),\n                  r.forEach(function (t, r) {\n                    var n = e.parseRtpParameters(t);\n                    s.transceivers[r].localCapabilities = n;\n                  }),\n                  s.transceivers.forEach(function (e, t) {\n                    s._gather(e.mid, t);\n                  });\n              else if (\"answer\" === t.type) {\n                (r = e.splitSections(s._remoteDescription.sdp)),\n                  (n = r.shift());\n                var c = e.matchPrefix(n, \"a=ice-lite\").length > 0;\n                r.forEach(function (t, r) {\n                  var i = s.transceivers[r],\n                    o = i.iceGatherer,\n                    d = i.iceTransport,\n                    p = i.dtlsTransport,\n                    l = i.localCapabilities,\n                    f = i.remoteCapabilities;\n                  if (\n                    !(\n                      e.isRejected(t) &&\n                      0 === e.matchPrefix(t, \"a=bundle-only\").length\n                    ) &&\n                    !i.rejected\n                  ) {\n                    var u = e.getIceParameters(t, n),\n                      v = e.getDtlsParameters(t, n);\n                    c && (v.role = \"server\"),\n                      (s.usingBundle && 0 !== r) ||\n                        (s._gather(i.mid, r),\n                        \"new\" === d.state &&\n                          d.start(o, u, c ? \"controlling\" : \"controlled\"),\n                        \"new\" === p.state && p.start(v));\n                    var h = a(l, f);\n                    s._transceive(i, h.codecs.length > 0, !1);\n                  }\n                });\n              }\n              return (\n                (s._localDescription = { type: t.type, sdp: t.sdp }),\n                \"offer\" === t.type\n                  ? s._updateSignalingState(\"have-local-offer\")\n                  : s._updateSignalingState(\"stable\"),\n                Promise.resolve()\n              );\n            }),\n            (f.prototype.setRemoteDescription = function (t) {\n              var r = this;\n              if (-1 === [\"offer\", \"answer\"].indexOf(t.type))\n                return Promise.reject(\n                  o(\"TypeError\", 'Unsupported type \"' + t.type + '\"')\n                );\n              if (\n                !i(\"setRemoteDescription\", t.type, r.signalingState) ||\n                r._isClosed\n              )\n                return Promise.reject(\n                  o(\n                    \"InvalidStateError\",\n                    \"Can not set remote \" +\n                      t.type +\n                      \" in state \" +\n                      r.signalingState\n                  )\n                );\n              var n = {};\n              r.remoteStreams.forEach(function (e) {\n                n[e.id] = e;\n              });\n              var f = [],\n                u = e.splitSections(t.sdp),\n                v = u.shift(),\n                h = e.matchPrefix(v, \"a=ice-lite\").length > 0,\n                m = e.matchPrefix(v, \"a=group:BUNDLE \").length > 0;\n              r.usingBundle = m;\n              var g = e.matchPrefix(v, \"a=ice-options:\")[0];\n              return (\n                (r.canTrickleIceCandidates =\n                  !!g && g.substr(14).split(\" \").indexOf(\"trickle\") >= 0),\n                u.forEach(function (i, o) {\n                  var l = e.splitLines(i),\n                    u = e.getKind(i),\n                    g =\n                      e.isRejected(i) &&\n                      0 === e.matchPrefix(i, \"a=bundle-only\").length,\n                    y = l[0].substr(2).split(\" \")[2],\n                    S = e.getDirection(i, v),\n                    T = e.parseMsid(i),\n                    E = e.getMid(i) || e.generateIdentifier();\n                  if (\n                    g ||\n                    (\"application\" === u &&\n                      (\"DTLS/SCTP\" === y || \"UDP/DTLS/SCTP\" === y))\n                  )\n                    r.transceivers[o] = {\n                      mid: E,\n                      kind: u,\n                      protocol: y,\n                      rejected: !0,\n                    };\n                  else {\n                    var C, P, w, R, _, k, b, x, D;\n                    !g &&\n                      r.transceivers[o] &&\n                      r.transceivers[o].rejected &&\n                      (r.transceivers[o] = r._createTransceiver(u, !0));\n                    var I,\n                      L,\n                      M = e.parseRtpParameters(i);\n                    g ||\n                      ((I = e.getIceParameters(i, v)),\n                      ((L = e.getDtlsParameters(i, v)).role = \"client\")),\n                      (b = e.parseRtpEncodingParameters(i));\n                    var O = e.parseRtcpParameters(i),\n                      G = e.matchPrefix(i, \"a=end-of-candidates\", v).length > 0,\n                      j = e\n                        .matchPrefix(i, \"a=candidate:\")\n                        .map(function (t) {\n                          return e.parseCandidate(t);\n                        })\n                        .filter(function (e) {\n                          return 1 === e.component;\n                        });\n                    if (\n                      ((\"offer\" === t.type || \"answer\" === t.type) &&\n                        !g &&\n                        m &&\n                        o > 0 &&\n                        r.transceivers[o] &&\n                        (r._disposeIceAndDtlsTransports(o),\n                        (r.transceivers[o].iceGatherer =\n                          r.transceivers[0].iceGatherer),\n                        (r.transceivers[o].iceTransport =\n                          r.transceivers[0].iceTransport),\n                        (r.transceivers[o].dtlsTransport =\n                          r.transceivers[0].dtlsTransport),\n                        r.transceivers[o].rtpSender &&\n                          r.transceivers[o].rtpSender.setTransport(\n                            r.transceivers[0].dtlsTransport\n                          ),\n                        r.transceivers[o].rtpReceiver &&\n                          r.transceivers[o].rtpReceiver.setTransport(\n                            r.transceivers[0].dtlsTransport\n                          )),\n                      \"offer\" !== t.type || g)\n                    ) {\n                      if (\"answer\" === t.type && !g) {\n                        (P = (C = r.transceivers[o]).iceGatherer),\n                          (w = C.iceTransport),\n                          (R = C.dtlsTransport),\n                          (_ = C.rtpReceiver),\n                          (k = C.sendEncodingParameters),\n                          (x = C.localCapabilities),\n                          (r.transceivers[o].recvEncodingParameters = b),\n                          (r.transceivers[o].remoteCapabilities = M),\n                          (r.transceivers[o].rtcpParameters = O),\n                          j.length &&\n                            \"new\" === w.state &&\n                            ((!h && !G) || (m && 0 !== o)\n                              ? j.forEach(function (e) {\n                                  s(C.iceTransport, e);\n                                })\n                              : w.setRemoteCandidates(j)),\n                          (m && 0 !== o) ||\n                            (\"new\" === w.state && w.start(P, I, \"controlling\"),\n                            \"new\" === R.state && R.start(L)),\n                          !a(\n                            C.localCapabilities,\n                            C.remoteCapabilities\n                          ).codecs.filter(function (e) {\n                            return \"rtx\" === e.name.toLowerCase();\n                          }).length &&\n                            C.sendEncodingParameters[0].rtx &&\n                            delete C.sendEncodingParameters[0].rtx,\n                          r._transceive(\n                            C,\n                            \"sendrecv\" === S || \"recvonly\" === S,\n                            \"sendrecv\" === S || \"sendonly\" === S\n                          ),\n                          !_ || (\"sendrecv\" !== S && \"sendonly\" !== S)\n                            ? delete C.rtpReceiver\n                            : ((D = _.track),\n                              T\n                                ? (n[T.stream] ||\n                                    (n[T.stream] = new c.MediaStream()),\n                                  p(D, n[T.stream]),\n                                  f.push([D, _, n[T.stream]]))\n                                : (n.default ||\n                                    (n.default = new c.MediaStream()),\n                                  p(D, n.default),\n                                  f.push([D, _, n.default])));\n                      }\n                    } else {\n                      ((C = r.transceivers[o] || r._createTransceiver(u)).mid =\n                        E),\n                        C.iceGatherer ||\n                          (C.iceGatherer = r._createIceGatherer(o, m)),\n                        j.length &&\n                          \"new\" === C.iceTransport.state &&\n                          (!G || (m && 0 !== o)\n                            ? j.forEach(function (e) {\n                                s(C.iceTransport, e);\n                              })\n                            : C.iceTransport.setRemoteCandidates(j)),\n                        (x = c.RTCRtpReceiver.getCapabilities(u)),\n                        d < 15019 &&\n                          (x.codecs = x.codecs.filter(function (e) {\n                            return \"rtx\" !== e.name;\n                          })),\n                        (k = C.sendEncodingParameters || [\n                          { ssrc: 1001 * (2 * o + 2) },\n                        ]);\n                      var N,\n                        A = !1;\n                      if (\"sendrecv\" === S || \"sendonly\" === S) {\n                        if (\n                          ((A = !C.rtpReceiver),\n                          (_ =\n                            C.rtpReceiver ||\n                            new c.RTCRtpReceiver(C.dtlsTransport, u)),\n                          A)\n                        )\n                          (D = _.track),\n                            (T && \"-\" === T.stream) ||\n                              (T\n                                ? (n[T.stream] ||\n                                    ((n[T.stream] = new c.MediaStream()),\n                                    Object.defineProperty(n[T.stream], \"id\", {\n                                      get: function () {\n                                        return T.stream;\n                                      },\n                                    })),\n                                  Object.defineProperty(D, \"id\", {\n                                    get: function () {\n                                      return T.track;\n                                    },\n                                  }),\n                                  (N = n[T.stream]))\n                                : (n.default ||\n                                    (n.default = new c.MediaStream()),\n                                  (N = n.default))),\n                            N &&\n                              (p(D, N), C.associatedRemoteMediaStreams.push(N)),\n                            f.push([D, _, N]);\n                      } else\n                        C.rtpReceiver &&\n                          C.rtpReceiver.track &&\n                          (C.associatedRemoteMediaStreams.forEach(function (e) {\n                            var t,\n                              r,\n                              n = e.getTracks().find(function (e) {\n                                return e.id === C.rtpReceiver.track.id;\n                              });\n                            n &&\n                              ((t = n),\n                              (r = e).removeTrack(t),\n                              r.dispatchEvent(\n                                new c.MediaStreamTrackEvent(\"removetrack\", {\n                                  track: t,\n                                })\n                              ));\n                          }),\n                          (C.associatedRemoteMediaStreams = []));\n                      (C.localCapabilities = x),\n                        (C.remoteCapabilities = M),\n                        (C.rtpReceiver = _),\n                        (C.rtcpParameters = O),\n                        (C.sendEncodingParameters = k),\n                        (C.recvEncodingParameters = b),\n                        r._transceive(r.transceivers[o], !1, A);\n                    }\n                  }\n                }),\n                void 0 === r._dtlsRole &&\n                  (r._dtlsRole = \"offer\" === t.type ? \"active\" : \"passive\"),\n                (r._remoteDescription = { type: t.type, sdp: t.sdp }),\n                \"offer\" === t.type\n                  ? r._updateSignalingState(\"have-remote-offer\")\n                  : r._updateSignalingState(\"stable\"),\n                Object.keys(n).forEach(function (e) {\n                  var t = n[e];\n                  if (t.getTracks().length) {\n                    if (-1 === r.remoteStreams.indexOf(t)) {\n                      r.remoteStreams.push(t);\n                      var a = new Event(\"addstream\");\n                      (a.stream = t),\n                        c.setTimeout(function () {\n                          r._dispatchEvent(\"addstream\", a);\n                        });\n                    }\n                    f.forEach(function (e) {\n                      var n = e[0],\n                        a = e[1];\n                      t.id === e[2].id && l(r, n, a, [t]);\n                    });\n                  }\n                }),\n                f.forEach(function (e) {\n                  e[2] || l(r, e[0], e[1], []);\n                }),\n                c.setTimeout(function () {\n                  r &&\n                    r.transceivers &&\n                    r.transceivers.forEach(function (e) {\n                      e.iceTransport &&\n                        \"new\" === e.iceTransport.state &&\n                        e.iceTransport.getRemoteCandidates().length > 0 &&\n                        (console.warn(\n                          \"Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification\"\n                        ),\n                        e.iceTransport.addRemoteCandidate({}));\n                    });\n                }, 4e3),\n                Promise.resolve()\n              );\n            }),\n            (f.prototype.close = function () {\n              this.transceivers.forEach(function (e) {\n                e.iceTransport && e.iceTransport.stop(),\n                  e.dtlsTransport && e.dtlsTransport.stop(),\n                  e.rtpSender && e.rtpSender.stop(),\n                  e.rtpReceiver && e.rtpReceiver.stop();\n              }),\n                (this._isClosed = !0),\n                this._updateSignalingState(\"closed\");\n            }),\n            (f.prototype._updateSignalingState = function (e) {\n              this.signalingState = e;\n              var t = new Event(\"signalingstatechange\");\n              this._dispatchEvent(\"signalingstatechange\", t);\n            }),\n            (f.prototype._maybeFireNegotiationNeeded = function () {\n              var e = this;\n              \"stable\" === this.signalingState &&\n                !0 !== this.needNegotiation &&\n                ((this.needNegotiation = !0),\n                c.setTimeout(function () {\n                  if (e.needNegotiation) {\n                    e.needNegotiation = !1;\n                    var t = new Event(\"negotiationneeded\");\n                    e._dispatchEvent(\"negotiationneeded\", t);\n                  }\n                }, 0));\n            }),\n            (f.prototype._updateIceConnectionState = function () {\n              var e,\n                t = {\n                  new: 0,\n                  closed: 0,\n                  checking: 0,\n                  connected: 0,\n                  completed: 0,\n                  disconnected: 0,\n                  failed: 0,\n                };\n              if (\n                (this.transceivers.forEach(function (e) {\n                  e.iceTransport && !e.rejected && t[e.iceTransport.state]++;\n                }),\n                (e = \"new\"),\n                t.failed > 0\n                  ? (e = \"failed\")\n                  : t.checking > 0\n                  ? (e = \"checking\")\n                  : t.disconnected > 0\n                  ? (e = \"disconnected\")\n                  : t.new > 0\n                  ? (e = \"new\")\n                  : t.connected > 0\n                  ? (e = \"connected\")\n                  : t.completed > 0 && (e = \"completed\"),\n                e !== this.iceConnectionState)\n              ) {\n                this.iceConnectionState = e;\n                var r = new Event(\"iceconnectionstatechange\");\n                this._dispatchEvent(\"iceconnectionstatechange\", r);\n              }\n            }),\n            (f.prototype._updateConnectionState = function () {\n              var e,\n                t = {\n                  new: 0,\n                  closed: 0,\n                  connecting: 0,\n                  connected: 0,\n                  completed: 0,\n                  disconnected: 0,\n                  failed: 0,\n                };\n              if (\n                (this.transceivers.forEach(function (e) {\n                  e.iceTransport &&\n                    e.dtlsTransport &&\n                    !e.rejected &&\n                    (t[e.iceTransport.state]++, t[e.dtlsTransport.state]++);\n                }),\n                (t.connected += t.completed),\n                (e = \"new\"),\n                t.failed > 0\n                  ? (e = \"failed\")\n                  : t.connecting > 0\n                  ? (e = \"connecting\")\n                  : t.disconnected > 0\n                  ? (e = \"disconnected\")\n                  : t.new > 0\n                  ? (e = \"new\")\n                  : t.connected > 0 && (e = \"connected\"),\n                e !== this.connectionState)\n              ) {\n                this.connectionState = e;\n                var r = new Event(\"connectionstatechange\");\n                this._dispatchEvent(\"connectionstatechange\", r);\n              }\n            }),\n            (f.prototype.createOffer = function () {\n              var t = this;\n              if (t._isClosed)\n                return Promise.reject(\n                  o(\"InvalidStateError\", \"Can not call createOffer after close\")\n                );\n              var n = t.transceivers.filter(function (e) {\n                  return \"audio\" === e.kind;\n                }).length,\n                a = t.transceivers.filter(function (e) {\n                  return \"video\" === e.kind;\n                }).length,\n                i = arguments[0];\n              if (i) {\n                if (i.mandatory || i.optional)\n                  throw new TypeError(\n                    \"Legacy mandatory/optional constraints not supported.\"\n                  );\n                void 0 !== i.offerToReceiveAudio &&\n                  (n =\n                    !0 === i.offerToReceiveAudio\n                      ? 1\n                      : !1 === i.offerToReceiveAudio\n                      ? 0\n                      : i.offerToReceiveAudio),\n                  void 0 !== i.offerToReceiveVideo &&\n                    (a =\n                      !0 === i.offerToReceiveVideo\n                        ? 1\n                        : !1 === i.offerToReceiveVideo\n                        ? 0\n                        : i.offerToReceiveVideo);\n              }\n              for (\n                t.transceivers.forEach(function (e) {\n                  \"audio\" === e.kind\n                    ? --n < 0 && (e.wantReceive = !1)\n                    : \"video\" === e.kind && --a < 0 && (e.wantReceive = !1);\n                });\n                n > 0 || a > 0;\n\n              )\n                n > 0 && (t._createTransceiver(\"audio\"), n--),\n                  a > 0 && (t._createTransceiver(\"video\"), a--);\n              var s = e.writeSessionBoilerplate(\n                t._sdpSessionId,\n                t._sdpSessionVersion++\n              );\n              t.transceivers.forEach(function (r, n) {\n                var a = r.track,\n                  i = r.kind,\n                  s = r.mid || e.generateIdentifier();\n                (r.mid = s),\n                  r.iceGatherer ||\n                    (r.iceGatherer = t._createIceGatherer(n, t.usingBundle));\n                var o = c.RTCRtpSender.getCapabilities(i);\n                d < 15019 &&\n                  (o.codecs = o.codecs.filter(function (e) {\n                    return \"rtx\" !== e.name;\n                  })),\n                  o.codecs.forEach(function (e) {\n                    \"H264\" === e.name &&\n                      void 0 === e.parameters[\"level-asymmetry-allowed\"] &&\n                      (e.parameters[\"level-asymmetry-allowed\"] = \"1\"),\n                      r.remoteCapabilities &&\n                        r.remoteCapabilities.codecs &&\n                        r.remoteCapabilities.codecs.forEach(function (t) {\n                          e.name.toLowerCase() === t.name.toLowerCase() &&\n                            e.clockRate === t.clockRate &&\n                            (e.preferredPayloadType = t.payloadType);\n                        });\n                  }),\n                  o.headerExtensions.forEach(function (e) {\n                    (\n                      (r.remoteCapabilities &&\n                        r.remoteCapabilities.headerExtensions) ||\n                      []\n                    ).forEach(function (t) {\n                      e.uri === t.uri && (e.id = t.id);\n                    });\n                  });\n                var p = r.sendEncodingParameters || [\n                  { ssrc: 1001 * (2 * n + 1) },\n                ];\n                a &&\n                  d >= 15019 &&\n                  \"video\" === i &&\n                  !p[0].rtx &&\n                  (p[0].rtx = { ssrc: p[0].ssrc + 1 }),\n                  r.wantReceive &&\n                    (r.rtpReceiver = new c.RTCRtpReceiver(r.dtlsTransport, i)),\n                  (r.localCapabilities = o),\n                  (r.sendEncodingParameters = p);\n              }),\n                \"max-compat\" !== t._config.bundlePolicy &&\n                  (s +=\n                    \"a=group:BUNDLE \" +\n                    t.transceivers\n                      .map(function (e) {\n                        return e.mid;\n                      })\n                      .join(\" \") +\n                    \"\\r\\n\"),\n                (s += \"a=ice-options:trickle\\r\\n\"),\n                t.transceivers.forEach(function (n, a) {\n                  (s += r(\n                    n,\n                    n.localCapabilities,\n                    \"offer\",\n                    n.stream,\n                    t._dtlsRole\n                  )),\n                    (s += \"a=rtcp-rsize\\r\\n\"),\n                    !n.iceGatherer ||\n                      \"new\" === t.iceGatheringState ||\n                      (0 !== a && t.usingBundle) ||\n                      (n.iceGatherer.getLocalCandidates().forEach(function (t) {\n                        (t.component = 1),\n                          (s += \"a=\" + e.writeCandidate(t) + \"\\r\\n\");\n                      }),\n                      \"completed\" === n.iceGatherer.state &&\n                        (s += \"a=end-of-candidates\\r\\n\"));\n                });\n              var p = new c.RTCSessionDescription({ type: \"offer\", sdp: s });\n              return Promise.resolve(p);\n            }),\n            (f.prototype.createAnswer = function () {\n              var t = this;\n              if (t._isClosed)\n                return Promise.reject(\n                  o(\n                    \"InvalidStateError\",\n                    \"Can not call createAnswer after close\"\n                  )\n                );\n              if (\n                \"have-remote-offer\" !== t.signalingState &&\n                \"have-local-pranswer\" !== t.signalingState\n              )\n                return Promise.reject(\n                  o(\n                    \"InvalidStateError\",\n                    \"Can not call createAnswer in signalingState \" +\n                      t.signalingState\n                  )\n                );\n              var n = e.writeSessionBoilerplate(\n                t._sdpSessionId,\n                t._sdpSessionVersion++\n              );\n              t.usingBundle &&\n                (n +=\n                  \"a=group:BUNDLE \" +\n                  t.transceivers\n                    .map(function (e) {\n                      return e.mid;\n                    })\n                    .join(\" \") +\n                  \"\\r\\n\"),\n                (n += \"a=ice-options:trickle\\r\\n\");\n              var i = e.getMediaSections(t._remoteDescription.sdp).length;\n              t.transceivers.forEach(function (e, s) {\n                if (!(s + 1 > i)) {\n                  if (e.rejected)\n                    return (\n                      \"application\" === e.kind\n                        ? \"DTLS/SCTP\" === e.protocol\n                          ? (n += \"m=application 0 DTLS/SCTP 5000\\r\\n\")\n                          : (n +=\n                              \"m=application 0 \" +\n                              e.protocol +\n                              \" webrtc-datachannel\\r\\n\")\n                        : \"audio\" === e.kind\n                        ? (n +=\n                            \"m=audio 0 UDP/TLS/RTP/SAVPF 0\\r\\na=rtpmap:0 PCMU/8000\\r\\n\")\n                        : \"video\" === e.kind &&\n                          (n +=\n                            \"m=video 0 UDP/TLS/RTP/SAVPF 120\\r\\na=rtpmap:120 VP8/90000\\r\\n\"),\n                      void (n +=\n                        \"c=IN IP4 0.0.0.0\\r\\na=inactive\\r\\na=mid:\" +\n                        e.mid +\n                        \"\\r\\n\")\n                    );\n                  var o;\n                  if (e.stream)\n                    \"audio\" === e.kind\n                      ? (o = e.stream.getAudioTracks()[0])\n                      : \"video\" === e.kind &&\n                        (o = e.stream.getVideoTracks()[0]),\n                      o &&\n                        d >= 15019 &&\n                        \"video\" === e.kind &&\n                        !e.sendEncodingParameters[0].rtx &&\n                        (e.sendEncodingParameters[0].rtx = {\n                          ssrc: e.sendEncodingParameters[0].ssrc + 1,\n                        });\n                  var c = a(e.localCapabilities, e.remoteCapabilities);\n                  !c.codecs.filter(function (e) {\n                    return \"rtx\" === e.name.toLowerCase();\n                  }).length &&\n                    e.sendEncodingParameters[0].rtx &&\n                    delete e.sendEncodingParameters[0].rtx,\n                    (n += r(e, c, \"answer\", e.stream, t._dtlsRole)),\n                    e.rtcpParameters &&\n                      e.rtcpParameters.reducedSize &&\n                      (n += \"a=rtcp-rsize\\r\\n\");\n                }\n              });\n              var s = new c.RTCSessionDescription({ type: \"answer\", sdp: n });\n              return Promise.resolve(s);\n            }),\n            (f.prototype.addIceCandidate = function (t) {\n              var r,\n                n = this;\n              return t && void 0 === t.sdpMLineIndex && !t.sdpMid\n                ? Promise.reject(\n                    new TypeError(\"sdpMLineIndex or sdpMid required\")\n                  )\n                : new Promise(function (a, i) {\n                    if (!n._remoteDescription)\n                      return i(\n                        o(\n                          \"InvalidStateError\",\n                          \"Can not add ICE candidate without a remote description\"\n                        )\n                      );\n                    if (t && \"\" !== t.candidate) {\n                      var c = t.sdpMLineIndex;\n                      if (t.sdpMid)\n                        for (var d = 0; d < n.transceivers.length; d++)\n                          if (n.transceivers[d].mid === t.sdpMid) {\n                            c = d;\n                            break;\n                          }\n                      var p = n.transceivers[c];\n                      if (!p)\n                        return i(\n                          o(\"OperationError\", \"Can not add ICE candidate\")\n                        );\n                      if (p.rejected) return a();\n                      var l =\n                        Object.keys(t.candidate).length > 0\n                          ? e.parseCandidate(t.candidate)\n                          : {};\n                      if (\n                        \"tcp\" === l.protocol &&\n                        (0 === l.port || 9 === l.port)\n                      )\n                        return a();\n                      if (l.component && 1 !== l.component) return a();\n                      if (\n                        (0 === c ||\n                          (c > 0 &&\n                            p.iceTransport !==\n                              n.transceivers[0].iceTransport)) &&\n                        !s(p.iceTransport, l)\n                      )\n                        return i(\n                          o(\"OperationError\", \"Can not add ICE candidate\")\n                        );\n                      var f = t.candidate.trim();\n                      0 === f.indexOf(\"a=\") && (f = f.substr(2)),\n                        ((r = e.getMediaSections(n._remoteDescription.sdp))[\n                          c\n                        ] +=\n                          \"a=\" + (l.type ? f : \"end-of-candidates\") + \"\\r\\n\"),\n                        (n._remoteDescription.sdp =\n                          e.getDescription(n._remoteDescription.sdp) +\n                          r.join(\"\"));\n                    } else for (var u = 0; u < n.transceivers.length && (n.transceivers[u].rejected || (n.transceivers[u].iceTransport.addRemoteCandidate({}), ((r = e.getMediaSections(n._remoteDescription.sdp))[u] += \"a=end-of-candidates\\r\\n\"), (n._remoteDescription.sdp = e.getDescription(n._remoteDescription.sdp) + r.join(\"\")), !n.usingBundle)); u++);\n                    a();\n                  });\n            }),\n            (f.prototype.getStats = function (e) {\n              if (e && e instanceof c.MediaStreamTrack) {\n                var t = null;\n                if (\n                  (this.transceivers.forEach(function (r) {\n                    r.rtpSender && r.rtpSender.track === e\n                      ? (t = r.rtpSender)\n                      : r.rtpReceiver &&\n                        r.rtpReceiver.track === e &&\n                        (t = r.rtpReceiver);\n                  }),\n                  !t)\n                )\n                  throw o(\"InvalidAccessError\", \"Invalid selector.\");\n                return t.getStats();\n              }\n              var r = [];\n              return (\n                this.transceivers.forEach(function (e) {\n                  [\n                    \"rtpSender\",\n                    \"rtpReceiver\",\n                    \"iceGatherer\",\n                    \"iceTransport\",\n                    \"dtlsTransport\",\n                  ].forEach(function (t) {\n                    e[t] && r.push(e[t].getStats());\n                  });\n                }),\n                Promise.all(r).then(function (e) {\n                  var t = new Map();\n                  return (\n                    e.forEach(function (e) {\n                      e.forEach(function (e) {\n                        t.set(e.id, e);\n                      });\n                    }),\n                    t\n                  );\n                })\n              );\n            });\n          [\n            \"RTCRtpSender\",\n            \"RTCRtpReceiver\",\n            \"RTCIceGatherer\",\n            \"RTCIceTransport\",\n            \"RTCDtlsTransport\",\n          ].forEach(function (e) {\n            var r = c[e];\n            if (r && r.prototype && r.prototype.getStats) {\n              var n = r.prototype.getStats;\n              r.prototype.getStats = function () {\n                return n.apply(this).then(function (e) {\n                  var r = new Map();\n                  return (\n                    Object.keys(e).forEach(function (n) {\n                      (e[n].type = t(e[n])), r.set(n, e[n]);\n                    }),\n                    r\n                  );\n                });\n              };\n            }\n          });\n          var u = [\"createOffer\", \"createAnswer\"];\n          return (\n            u.forEach(function (e) {\n              var t = f.prototype[e];\n              f.prototype[e] = function () {\n                var e = arguments;\n                return \"function\" == typeof e[0] || \"function\" == typeof e[1]\n                  ? t.apply(this, [arguments[2]]).then(\n                      function (t) {\n                        \"function\" == typeof e[0] && e[0].apply(null, [t]);\n                      },\n                      function (t) {\n                        \"function\" == typeof e[1] && e[1].apply(null, [t]);\n                      }\n                    )\n                  : t.apply(this, arguments);\n              };\n            }),\n            (u = [\n              \"setLocalDescription\",\n              \"setRemoteDescription\",\n              \"addIceCandidate\",\n            ]).forEach(function (e) {\n              var t = f.prototype[e];\n              f.prototype[e] = function () {\n                var e = arguments;\n                return \"function\" == typeof e[1] || \"function\" == typeof e[2]\n                  ? t.apply(this, arguments).then(\n                      function () {\n                        \"function\" == typeof e[1] && e[1].apply(null);\n                      },\n                      function (t) {\n                        \"function\" == typeof e[2] && e[2].apply(null, [t]);\n                      }\n                    )\n                  : t.apply(this, arguments);\n              };\n            }),\n            [\"getStats\"].forEach(function (e) {\n              var t = f.prototype[e];\n              f.prototype[e] = function () {\n                var e = arguments;\n                return \"function\" == typeof e[1]\n                  ? t.apply(this, arguments).then(function () {\n                      \"function\" == typeof e[1] && e[1].apply(null);\n                    })\n                  : t.apply(this, arguments);\n              };\n            }),\n            f\n          );\n        };\n      },\n      { sdp: \"YHvh\" },\n    ],\n    YdKx: [\n      function (require, module, exports) {\n        \"use strict\";\n        function e(e) {\n          var r = e && e.navigator,\n            t = r.mediaDevices.getUserMedia.bind(r.mediaDevices);\n          r.mediaDevices.getUserMedia = function (e) {\n            return t(e).catch(function (e) {\n              return Promise.reject(\n                (function (e) {\n                  return {\n                    name:\n                      { PermissionDeniedError: \"NotAllowedError\" }[e.name] ||\n                      e.name,\n                    message: e.message,\n                    constraint: e.constraint,\n                    toString: function () {\n                      return this.name;\n                    },\n                  };\n                })(e)\n              );\n            });\n          };\n        }\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimGetUserMedia = e);\n      },\n      {},\n    ],\n    P3bV: [\n      function (require, module, exports) {\n        \"use strict\";\n        function e(e) {\n          \"getDisplayMedia\" in e.navigator &&\n            e.navigator.mediaDevices &&\n            ((e.navigator.mediaDevices &&\n              \"getDisplayMedia\" in e.navigator.mediaDevices) ||\n              (e.navigator.mediaDevices.getDisplayMedia =\n                e.navigator.getDisplayMedia.bind(e.navigator)));\n        }\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimGetDisplayMedia = e);\n      },\n      {},\n    ],\n    XRic: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimPeerConnection = p),\n          (exports.shimReplaceTrack = a),\n          Object.defineProperty(exports, \"shimGetUserMedia\", {\n            enumerable: !0,\n            get: function () {\n              return n.shimGetUserMedia;\n            },\n          }),\n          Object.defineProperty(exports, \"shimGetDisplayMedia\", {\n            enumerable: !0,\n            get: function () {\n              return i.shimGetDisplayMedia;\n            },\n          });\n        var e = s(require(\"../utils\")),\n          t = require(\"./filtericeservers\"),\n          r = o(require(\"rtcpeerconnection-shim\")),\n          n = require(\"./getusermedia\"),\n          i = require(\"./getdisplaymedia\");\n        function o(e) {\n          return e && e.__esModule ? e : { default: e };\n        }\n        function c() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (c = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function s(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var t = c();\n          if (t && t.has(e)) return t.get(e);\n          var r = {},\n            n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in e)\n            if (Object.prototype.hasOwnProperty.call(e, i)) {\n              var o = n ? Object.getOwnPropertyDescriptor(e, i) : null;\n              o && (o.get || o.set)\n                ? Object.defineProperty(r, i, o)\n                : (r[i] = e[i]);\n            }\n          return (r.default = e), t && t.set(e, r), r;\n        }\n        function p(n, i) {\n          if (\n            n.RTCIceGatherer &&\n            (n.RTCIceCandidate ||\n              (n.RTCIceCandidate = function (e) {\n                return e;\n              }),\n            n.RTCSessionDescription ||\n              (n.RTCSessionDescription = function (e) {\n                return e;\n              }),\n            i.version < 15025)\n          ) {\n            var o = Object.getOwnPropertyDescriptor(\n              n.MediaStreamTrack.prototype,\n              \"enabled\"\n            );\n            Object.defineProperty(n.MediaStreamTrack.prototype, \"enabled\", {\n              set: function (e) {\n                o.set.call(this, e);\n                var t = new Event(\"enabled\");\n                (t.enabled = e), this.dispatchEvent(t);\n              },\n            });\n          }\n          !n.RTCRtpSender ||\n            \"dtmf\" in n.RTCRtpSender.prototype ||\n            Object.defineProperty(n.RTCRtpSender.prototype, \"dtmf\", {\n              get: function () {\n                return (\n                  void 0 === this._dtmf &&\n                    (\"audio\" === this.track.kind\n                      ? (this._dtmf = new n.RTCDtmfSender(this))\n                      : \"video\" === this.track.kind && (this._dtmf = null)),\n                  this._dtmf\n                );\n              },\n            }),\n            n.RTCDtmfSender &&\n              !n.RTCDTMFSender &&\n              (n.RTCDTMFSender = n.RTCDtmfSender);\n          var c = (0, r.default)(n, i.version);\n          (n.RTCPeerConnection = function (r) {\n            return (\n              r &&\n                r.iceServers &&\n                ((r.iceServers = (0, t.filterIceServers)(\n                  r.iceServers,\n                  i.version\n                )),\n                e.log(\"ICE servers after filtering:\", r.iceServers)),\n              new c(r)\n            );\n          }),\n            (n.RTCPeerConnection.prototype = c.prototype);\n        }\n        function a(e) {\n          !e.RTCRtpSender ||\n            \"replaceTrack\" in e.RTCRtpSender.prototype ||\n            (e.RTCRtpSender.prototype.replaceTrack =\n              e.RTCRtpSender.prototype.setTrack);\n        }\n      },\n      {\n        \"../utils\": \"iSxC\",\n        \"./filtericeservers\": \"NZ1C\",\n        \"rtcpeerconnection-shim\": \"NJ2u\",\n        \"./getusermedia\": \"YdKx\",\n        \"./getdisplaymedia\": \"P3bV\",\n      },\n    ],\n    GzSv: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimGetUserMedia = n);\n        var e = o(require(\"../utils\"));\n        function t() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (t = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function o(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var o = t();\n          if (o && o.has(e)) return o.get(e);\n          var r = {},\n            n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in e)\n            if (Object.prototype.hasOwnProperty.call(e, i)) {\n              var a = n ? Object.getOwnPropertyDescriptor(e, i) : null;\n              a && (a.get || a.set)\n                ? Object.defineProperty(r, i, a)\n                : (r[i] = e[i]);\n            }\n          return (r.default = e), o && o.set(e, r), r;\n        }\n        function r(e) {\n          return (r =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        function n(t, o) {\n          var n = t && t.navigator,\n            i = t && t.MediaStreamTrack;\n          if (\n            ((n.getUserMedia = function (t, o, r) {\n              e.deprecated(\n                \"navigator.getUserMedia\",\n                \"navigator.mediaDevices.getUserMedia\"\n              ),\n                n.mediaDevices.getUserMedia(t).then(o, r);\n            }),\n            !(\n              o.version > 55 &&\n              \"autoGainControl\" in n.mediaDevices.getSupportedConstraints()\n            ))\n          ) {\n            var a = function (e, t, o) {\n                t in e && !(o in e) && ((e[o] = e[t]), delete e[t]);\n              },\n              s = n.mediaDevices.getUserMedia.bind(n.mediaDevices);\n            if (\n              ((n.mediaDevices.getUserMedia = function (e) {\n                return (\n                  \"object\" === r(e) &&\n                    \"object\" === r(e.audio) &&\n                    ((e = JSON.parse(JSON.stringify(e))),\n                    a(e.audio, \"autoGainControl\", \"mozAutoGainControl\"),\n                    a(e.audio, \"noiseSuppression\", \"mozNoiseSuppression\")),\n                  s(e)\n                );\n              }),\n              i && i.prototype.getSettings)\n            ) {\n              var p = i.prototype.getSettings;\n              i.prototype.getSettings = function () {\n                var e = p.apply(this, arguments);\n                return (\n                  a(e, \"mozAutoGainControl\", \"autoGainControl\"),\n                  a(e, \"mozNoiseSuppression\", \"noiseSuppression\"),\n                  e\n                );\n              };\n            }\n            if (i && i.prototype.applyConstraints) {\n              var u = i.prototype.applyConstraints;\n              i.prototype.applyConstraints = function (e) {\n                return (\n                  \"audio\" === this.kind &&\n                    \"object\" === r(e) &&\n                    ((e = JSON.parse(JSON.stringify(e))),\n                    a(e, \"autoGainControl\", \"mozAutoGainControl\"),\n                    a(e, \"noiseSuppression\", \"mozNoiseSuppression\")),\n                  u.apply(this, [e])\n                );\n              };\n            }\n          }\n        }\n      },\n      { \"../utils\": \"iSxC\" },\n    ],\n    UuGU: [\n      function (require, module, exports) {\n        \"use strict\";\n        function e(e, i) {\n          (e.navigator.mediaDevices &&\n            \"getDisplayMedia\" in e.navigator.mediaDevices) ||\n            (e.navigator.mediaDevices &&\n              (e.navigator.mediaDevices.getDisplayMedia = function (a) {\n                if (!a || !a.video) {\n                  var t = new DOMException(\n                    \"getDisplayMedia without video constraints is undefined\"\n                  );\n                  return (\n                    (t.name = \"NotFoundError\"), (t.code = 8), Promise.reject(t)\n                  );\n                }\n                return (\n                  !0 === a.video\n                    ? (a.video = { mediaSource: i })\n                    : (a.video.mediaSource = i),\n                  e.navigator.mediaDevices.getUserMedia(a)\n                );\n              }));\n        }\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimGetDisplayMedia = e);\n      },\n      {},\n    ],\n    Fzdr: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimOnTrack = s),\n          (exports.shimPeerConnection = c),\n          (exports.shimSenderGetStats = p),\n          (exports.shimReceiverGetStats = u),\n          (exports.shimRemoveStream = f),\n          (exports.shimRTCDataChannel = d),\n          (exports.shimAddTransceiver = C),\n          (exports.shimGetParameters = y),\n          (exports.shimCreateOffer = l),\n          (exports.shimCreateAnswer = m),\n          Object.defineProperty(exports, \"shimGetUserMedia\", {\n            enumerable: !0,\n            get: function () {\n              return t.shimGetUserMedia;\n            },\n          }),\n          Object.defineProperty(exports, \"shimGetDisplayMedia\", {\n            enumerable: !0,\n            get: function () {\n              return n.shimGetDisplayMedia;\n            },\n          });\n        var e = o(require(\"../utils\")),\n          t = require(\"./getusermedia\"),\n          n = require(\"./getdisplaymedia\");\n        function r() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (r = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function o(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var t = r();\n          if (t && t.has(e)) return t.get(e);\n          var n = {},\n            o = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in e)\n            if (Object.prototype.hasOwnProperty.call(e, i)) {\n              var a = o ? Object.getOwnPropertyDescriptor(e, i) : null;\n              a && (a.get || a.set)\n                ? Object.defineProperty(n, i, a)\n                : (n[i] = e[i]);\n            }\n          return (n.default = e), t && t.set(e, n), n;\n        }\n        function i(e, t, n) {\n          return (\n            t in e\n              ? Object.defineProperty(e, t, {\n                  value: n,\n                  enumerable: !0,\n                  configurable: !0,\n                  writable: !0,\n                })\n              : (e[t] = n),\n            e\n          );\n        }\n        function a(e) {\n          return (a =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        function s(e) {\n          \"object\" === a(e) &&\n            e.RTCTrackEvent &&\n            \"receiver\" in e.RTCTrackEvent.prototype &&\n            !(\"transceiver\" in e.RTCTrackEvent.prototype) &&\n            Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n              get: function () {\n                return { receiver: this.receiver };\n              },\n            });\n        }\n        function c(e, t) {\n          if (\n            \"object\" === a(e) &&\n            (e.RTCPeerConnection || e.mozRTCPeerConnection)\n          ) {\n            !e.RTCPeerConnection &&\n              e.mozRTCPeerConnection &&\n              (e.RTCPeerConnection = e.mozRTCPeerConnection),\n              t.version < 53 &&\n                [\n                  \"setLocalDescription\",\n                  \"setRemoteDescription\",\n                  \"addIceCandidate\",\n                ].forEach(function (t) {\n                  var n = e.RTCPeerConnection.prototype[t],\n                    r = i({}, t, function () {\n                      return (\n                        (arguments[0] = new (\n                          \"addIceCandidate\" === t\n                            ? e.RTCIceCandidate\n                            : e.RTCSessionDescription\n                        )(arguments[0])),\n                        n.apply(this, arguments)\n                      );\n                    });\n                  e.RTCPeerConnection.prototype[t] = r[t];\n                });\n            var n = {\n                inboundrtp: \"inbound-rtp\",\n                outboundrtp: \"outbound-rtp\",\n                candidatepair: \"candidate-pair\",\n                localcandidate: \"local-candidate\",\n                remotecandidate: \"remote-candidate\",\n              },\n              r = e.RTCPeerConnection.prototype.getStats;\n            e.RTCPeerConnection.prototype.getStats = function () {\n              var [e, o, i] = arguments;\n              return r\n                .apply(this, [e || null])\n                .then(function (e) {\n                  if (t.version < 53 && !o)\n                    try {\n                      e.forEach(function (e) {\n                        e.type = n[e.type] || e.type;\n                      });\n                    } catch (r) {\n                      if (\"TypeError\" !== r.name) throw r;\n                      e.forEach(function (t, r) {\n                        e.set(\n                          r,\n                          Object.assign({}, t, { type: n[t.type] || t.type })\n                        );\n                      });\n                    }\n                  return e;\n                })\n                .then(o, i);\n            };\n          }\n        }\n        function p(e) {\n          if (\n            \"object\" === a(e) &&\n            e.RTCPeerConnection &&\n            e.RTCRtpSender &&\n            !(e.RTCRtpSender && \"getStats\" in e.RTCRtpSender.prototype)\n          ) {\n            var t = e.RTCPeerConnection.prototype.getSenders;\n            t &&\n              (e.RTCPeerConnection.prototype.getSenders = function () {\n                var e = this,\n                  n = t.apply(this, []);\n                return (\n                  n.forEach(function (t) {\n                    return (t._pc = e);\n                  }),\n                  n\n                );\n              });\n            var n = e.RTCPeerConnection.prototype.addTrack;\n            n &&\n              (e.RTCPeerConnection.prototype.addTrack = function () {\n                var e = n.apply(this, arguments);\n                return (e._pc = this), e;\n              }),\n              (e.RTCRtpSender.prototype.getStats = function () {\n                return this.track\n                  ? this._pc.getStats(this.track)\n                  : Promise.resolve(new Map());\n              });\n          }\n        }\n        function u(t) {\n          if (\n            \"object\" === a(t) &&\n            t.RTCPeerConnection &&\n            t.RTCRtpSender &&\n            !(t.RTCRtpSender && \"getStats\" in t.RTCRtpReceiver.prototype)\n          ) {\n            var n = t.RTCPeerConnection.prototype.getReceivers;\n            n &&\n              (t.RTCPeerConnection.prototype.getReceivers = function () {\n                var e = this,\n                  t = n.apply(this, []);\n                return (\n                  t.forEach(function (t) {\n                    return (t._pc = e);\n                  }),\n                  t\n                );\n              }),\n              e.wrapPeerConnectionEvent(t, \"track\", function (e) {\n                return (e.receiver._pc = e.srcElement), e;\n              }),\n              (t.RTCRtpReceiver.prototype.getStats = function () {\n                return this._pc.getStats(this.track);\n              });\n          }\n        }\n        function f(t) {\n          !t.RTCPeerConnection ||\n            \"removeStream\" in t.RTCPeerConnection.prototype ||\n            (t.RTCPeerConnection.prototype.removeStream = function (t) {\n              var n = this;\n              e.deprecated(\"removeStream\", \"removeTrack\"),\n                this.getSenders().forEach(function (e) {\n                  e.track &&\n                    t.getTracks().includes(e.track) &&\n                    n.removeTrack(e);\n                });\n            });\n        }\n        function d(e) {\n          e.DataChannel &&\n            !e.RTCDataChannel &&\n            (e.RTCDataChannel = e.DataChannel);\n        }\n        function C(e) {\n          if (\"object\" === a(e) && e.RTCPeerConnection) {\n            var t = e.RTCPeerConnection.prototype.addTransceiver;\n            t &&\n              (e.RTCPeerConnection.prototype.addTransceiver = function () {\n                this.setParametersPromises = [];\n                var e = arguments[1],\n                  n = e && \"sendEncodings\" in e;\n                n &&\n                  e.sendEncodings.forEach(function (e) {\n                    if (\"rid\" in e) {\n                      if (!/^[a-z0-9]{0,16}$/i.test(e.rid))\n                        throw new TypeError(\"Invalid RID value provided.\");\n                    }\n                    if (\n                      \"scaleResolutionDownBy\" in e &&\n                      !(parseFloat(e.scaleResolutionDownBy) >= 1)\n                    )\n                      throw new RangeError(\n                        \"scale_resolution_down_by must be >= 1.0\"\n                      );\n                    if (\n                      \"maxFramerate\" in e &&\n                      !(parseFloat(e.maxFramerate) >= 0)\n                    )\n                      throw new RangeError(\"max_framerate must be >= 0.0\");\n                  });\n                var r = t.apply(this, arguments);\n                if (n) {\n                  var { sender: o } = r,\n                    i = o.getParameters();\n                  (\"encodings\" in i &&\n                    (1 !== i.encodings.length ||\n                      0 !== Object.keys(i.encodings[0]).length)) ||\n                    ((i.encodings = e.sendEncodings),\n                    (o.sendEncodings = e.sendEncodings),\n                    this.setParametersPromises.push(\n                      o\n                        .setParameters(i)\n                        .then(function () {\n                          delete o.sendEncodings;\n                        })\n                        .catch(function () {\n                          delete o.sendEncodings;\n                        })\n                    ));\n                }\n                return r;\n              });\n          }\n        }\n        function y(e) {\n          if (\"object\" === a(e) && e.RTCRtpSender) {\n            var t = e.RTCRtpSender.prototype.getParameters;\n            t &&\n              (e.RTCRtpSender.prototype.getParameters = function () {\n                var e = t.apply(this, arguments);\n                return (\n                  \"encodings\" in e ||\n                    (e.encodings = [].concat(this.sendEncodings || [{}])),\n                  e\n                );\n              });\n          }\n        }\n        function l(e) {\n          if (\"object\" === a(e) && e.RTCPeerConnection) {\n            var t = e.RTCPeerConnection.prototype.createOffer;\n            e.RTCPeerConnection.prototype.createOffer = function () {\n              var e = arguments,\n                n = this;\n              return this.setParametersPromises &&\n                this.setParametersPromises.length\n                ? Promise.all(this.setParametersPromises)\n                    .then(function () {\n                      return t.apply(n, e);\n                    })\n                    .finally(function () {\n                      n.setParametersPromises = [];\n                    })\n                : t.apply(this, arguments);\n            };\n          }\n        }\n        function m(e) {\n          if (\"object\" === a(e) && e.RTCPeerConnection) {\n            var t = e.RTCPeerConnection.prototype.createAnswer;\n            e.RTCPeerConnection.prototype.createAnswer = function () {\n              var e = arguments,\n                n = this;\n              return this.setParametersPromises &&\n                this.setParametersPromises.length\n                ? Promise.all(this.setParametersPromises)\n                    .then(function () {\n                      return t.apply(n, e);\n                    })\n                    .finally(function () {\n                      n.setParametersPromises = [];\n                    })\n                : t.apply(this, arguments);\n            };\n          }\n        }\n      },\n      {\n        \"../utils\": \"iSxC\",\n        \"./getusermedia\": \"GzSv\",\n        \"./getdisplaymedia\": \"UuGU\",\n      },\n    ],\n    t1lL: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimLocalStreamsAPI = n),\n          (exports.shimRemoteStreamsAPI = i),\n          (exports.shimCallbacksAPI = a),\n          (exports.shimGetUserMedia = c),\n          (exports.shimConstraints = s),\n          (exports.shimRTCIceServerUrls = d),\n          (exports.shimTrackEventTransceiver = f),\n          (exports.shimCreateOfferLegacy = p),\n          (exports.shimAudioContext = u);\n        var e = r(require(\"../utils\"));\n        function t() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (t = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function r(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var r = t();\n          if (r && r.has(e)) return r.get(e);\n          var o = {},\n            n = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in e)\n            if (Object.prototype.hasOwnProperty.call(e, i)) {\n              var a = n ? Object.getOwnPropertyDescriptor(e, i) : null;\n              a && (a.get || a.set)\n                ? Object.defineProperty(o, i, a)\n                : (o[i] = e[i]);\n            }\n          return (o.default = e), r && r.set(e, o), o;\n        }\n        function o(e) {\n          return (o =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        function n(e) {\n          if (\"object\" === o(e) && e.RTCPeerConnection) {\n            if (\n              (\"getLocalStreams\" in e.RTCPeerConnection.prototype ||\n                (e.RTCPeerConnection.prototype.getLocalStreams = function () {\n                  return (\n                    this._localStreams || (this._localStreams = []),\n                    this._localStreams\n                  );\n                }),\n              !(\"addStream\" in e.RTCPeerConnection.prototype))\n            ) {\n              var t = e.RTCPeerConnection.prototype.addTrack;\n              (e.RTCPeerConnection.prototype.addStream = function (e) {\n                var r = this;\n                this._localStreams || (this._localStreams = []),\n                  this._localStreams.includes(e) || this._localStreams.push(e),\n                  e.getAudioTracks().forEach(function (o) {\n                    return t.call(r, o, e);\n                  }),\n                  e.getVideoTracks().forEach(function (o) {\n                    return t.call(r, o, e);\n                  });\n              }),\n                (e.RTCPeerConnection.prototype.addTrack = function (e) {\n                  for (\n                    var r = this,\n                      o = arguments.length,\n                      n = new Array(o > 1 ? o - 1 : 0),\n                      i = 1;\n                    i < o;\n                    i++\n                  )\n                    n[i - 1] = arguments[i];\n                  return (\n                    n &&\n                      n.forEach(function (e) {\n                        r._localStreams\n                          ? r._localStreams.includes(e) ||\n                            r._localStreams.push(e)\n                          : (r._localStreams = [e]);\n                      }),\n                    t.apply(this, arguments)\n                  );\n                });\n            }\n            \"removeStream\" in e.RTCPeerConnection.prototype ||\n              (e.RTCPeerConnection.prototype.removeStream = function (e) {\n                var t = this;\n                this._localStreams || (this._localStreams = []);\n                var r = this._localStreams.indexOf(e);\n                if (-1 !== r) {\n                  this._localStreams.splice(r, 1);\n                  var o = e.getTracks();\n                  this.getSenders().forEach(function (e) {\n                    o.includes(e.track) && t.removeTrack(e);\n                  });\n                }\n              });\n          }\n        }\n        function i(e) {\n          if (\n            \"object\" === o(e) &&\n            e.RTCPeerConnection &&\n            (\"getRemoteStreams\" in e.RTCPeerConnection.prototype ||\n              (e.RTCPeerConnection.prototype.getRemoteStreams = function () {\n                return this._remoteStreams ? this._remoteStreams : [];\n              }),\n            !(\"onaddstream\" in e.RTCPeerConnection.prototype))\n          ) {\n            Object.defineProperty(\n              e.RTCPeerConnection.prototype,\n              \"onaddstream\",\n              {\n                get: function () {\n                  return this._onaddstream;\n                },\n                set: function (e) {\n                  var t = this;\n                  this._onaddstream &&\n                    (this.removeEventListener(\"addstream\", this._onaddstream),\n                    this.removeEventListener(\"track\", this._onaddstreampoly)),\n                    this.addEventListener(\"addstream\", (this._onaddstream = e)),\n                    this.addEventListener(\n                      \"track\",\n                      (this._onaddstreampoly = function (e) {\n                        e.streams.forEach(function (e) {\n                          if (\n                            (t._remoteStreams || (t._remoteStreams = []),\n                            !t._remoteStreams.includes(e))\n                          ) {\n                            t._remoteStreams.push(e);\n                            var r = new Event(\"addstream\");\n                            (r.stream = e), t.dispatchEvent(r);\n                          }\n                        });\n                      })\n                    );\n                },\n              }\n            );\n            var t = e.RTCPeerConnection.prototype.setRemoteDescription;\n            e.RTCPeerConnection.prototype.setRemoteDescription = function () {\n              var e = this;\n              return (\n                this._onaddstreampoly ||\n                  this.addEventListener(\n                    \"track\",\n                    (this._onaddstreampoly = function (t) {\n                      t.streams.forEach(function (t) {\n                        if (\n                          (e._remoteStreams || (e._remoteStreams = []),\n                          !(e._remoteStreams.indexOf(t) >= 0))\n                        ) {\n                          e._remoteStreams.push(t);\n                          var r = new Event(\"addstream\");\n                          (r.stream = t), e.dispatchEvent(r);\n                        }\n                      });\n                    })\n                  ),\n                t.apply(e, arguments)\n              );\n            };\n          }\n        }\n        function a(e) {\n          if (\"object\" === o(e) && e.RTCPeerConnection) {\n            var t = e.RTCPeerConnection.prototype,\n              r = t.createOffer,\n              n = t.createAnswer,\n              i = t.setLocalDescription,\n              a = t.setRemoteDescription,\n              c = t.addIceCandidate;\n            (t.createOffer = function (e, t) {\n              var o = arguments.length >= 2 ? arguments[2] : arguments[0],\n                n = r.apply(this, [o]);\n              return t ? (n.then(e, t), Promise.resolve()) : n;\n            }),\n              (t.createAnswer = function (e, t) {\n                var r = arguments.length >= 2 ? arguments[2] : arguments[0],\n                  o = n.apply(this, [r]);\n                return t ? (o.then(e, t), Promise.resolve()) : o;\n              });\n            var s = function (e, t, r) {\n              var o = i.apply(this, [e]);\n              return r ? (o.then(t, r), Promise.resolve()) : o;\n            };\n            (t.setLocalDescription = s),\n              (s = function (e, t, r) {\n                var o = a.apply(this, [e]);\n                return r ? (o.then(t, r), Promise.resolve()) : o;\n              }),\n              (t.setRemoteDescription = s),\n              (s = function (e, t, r) {\n                var o = c.apply(this, [e]);\n                return r ? (o.then(t, r), Promise.resolve()) : o;\n              }),\n              (t.addIceCandidate = s);\n          }\n        }\n        function c(e) {\n          var t = e && e.navigator;\n          if (t.mediaDevices && t.mediaDevices.getUserMedia) {\n            var r = t.mediaDevices,\n              o = r.getUserMedia.bind(r);\n            t.mediaDevices.getUserMedia = function (e) {\n              return o(s(e));\n            };\n          }\n          !t.getUserMedia &&\n            t.mediaDevices &&\n            t.mediaDevices.getUserMedia &&\n            (t.getUserMedia = function (e, r, o) {\n              t.mediaDevices.getUserMedia(e).then(r, o);\n            }.bind(t));\n        }\n        function s(t) {\n          return t && void 0 !== t.video\n            ? Object.assign({}, t, { video: e.compactObject(t.video) })\n            : t;\n        }\n        function d(t) {\n          if (t.RTCPeerConnection) {\n            var r = t.RTCPeerConnection;\n            (t.RTCPeerConnection = function (t, o) {\n              if (t && t.iceServers) {\n                for (var n = [], i = 0; i < t.iceServers.length; i++) {\n                  var a = t.iceServers[i];\n                  !a.hasOwnProperty(\"urls\") && a.hasOwnProperty(\"url\")\n                    ? (e.deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\"),\n                      ((a = JSON.parse(JSON.stringify(a))).urls = a.url),\n                      delete a.url,\n                      n.push(a))\n                    : n.push(t.iceServers[i]);\n                }\n                t.iceServers = n;\n              }\n              return new r(t, o);\n            }),\n              (t.RTCPeerConnection.prototype = r.prototype),\n              \"generateCertificate\" in r &&\n                Object.defineProperty(\n                  t.RTCPeerConnection,\n                  \"generateCertificate\",\n                  {\n                    get: function () {\n                      return r.generateCertificate;\n                    },\n                  }\n                );\n          }\n        }\n        function f(e) {\n          \"object\" === o(e) &&\n            e.RTCTrackEvent &&\n            \"receiver\" in e.RTCTrackEvent.prototype &&\n            !(\"transceiver\" in e.RTCTrackEvent.prototype) &&\n            Object.defineProperty(e.RTCTrackEvent.prototype, \"transceiver\", {\n              get: function () {\n                return { receiver: this.receiver };\n              },\n            });\n        }\n        function p(e) {\n          var t = e.RTCPeerConnection.prototype.createOffer;\n          e.RTCPeerConnection.prototype.createOffer = function (e) {\n            if (e) {\n              void 0 !== e.offerToReceiveAudio &&\n                (e.offerToReceiveAudio = !!e.offerToReceiveAudio);\n              var r = this.getTransceivers().find(function (e) {\n                return \"audio\" === e.receiver.track.kind;\n              });\n              !1 === e.offerToReceiveAudio && r\n                ? \"sendrecv\" === r.direction\n                  ? r.setDirection\n                    ? r.setDirection(\"sendonly\")\n                    : (r.direction = \"sendonly\")\n                  : \"recvonly\" === r.direction &&\n                    (r.setDirection\n                      ? r.setDirection(\"inactive\")\n                      : (r.direction = \"inactive\"))\n                : !0 !== e.offerToReceiveAudio ||\n                  r ||\n                  this.addTransceiver(\"audio\"),\n                void 0 !== e.offerToReceiveVideo &&\n                  (e.offerToReceiveVideo = !!e.offerToReceiveVideo);\n              var o = this.getTransceivers().find(function (e) {\n                return \"video\" === e.receiver.track.kind;\n              });\n              !1 === e.offerToReceiveVideo && o\n                ? \"sendrecv\" === o.direction\n                  ? o.setDirection\n                    ? o.setDirection(\"sendonly\")\n                    : (o.direction = \"sendonly\")\n                  : \"recvonly\" === o.direction &&\n                    (o.setDirection\n                      ? o.setDirection(\"inactive\")\n                      : (o.direction = \"inactive\"))\n                : !0 !== e.offerToReceiveVideo ||\n                  o ||\n                  this.addTransceiver(\"video\");\n            }\n            return t.apply(this, arguments);\n          };\n        }\n        function u(e) {\n          \"object\" !== o(e) ||\n            e.AudioContext ||\n            (e.AudioContext = e.webkitAudioContext);\n        }\n      },\n      { \"../utils\": \"iSxC\" },\n    ],\n    GOQK: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.shimRTCIceCandidate = a),\n          (exports.shimMaxMessageSize = c),\n          (exports.shimSendThrowTypeError = s),\n          (exports.shimConnectionState = p),\n          (exports.removeExtmapAllowMixed = d),\n          (exports.shimAddIceCandidateNullOrEmpty = u);\n        var e = r(require(\"sdp\")),\n          t = o(require(\"./utils\"));\n        function n() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (n = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function o(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var t = n();\n          if (t && t.has(e)) return t.get(e);\n          var o = {},\n            r = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var i in e)\n            if (Object.prototype.hasOwnProperty.call(e, i)) {\n              var a = r ? Object.getOwnPropertyDescriptor(e, i) : null;\n              a && (a.get || a.set)\n                ? Object.defineProperty(o, i, a)\n                : (o[i] = e[i]);\n            }\n          return (o.default = e), t && t.set(e, o), o;\n        }\n        function r(e) {\n          return e && e.__esModule ? e : { default: e };\n        }\n        function i(e) {\n          return (i =\n            \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator\n              ? function (e) {\n                  return typeof e;\n                }\n              : function (e) {\n                  return e &&\n                    \"function\" == typeof Symbol &&\n                    e.constructor === Symbol &&\n                    e !== Symbol.prototype\n                    ? \"symbol\"\n                    : typeof e;\n                })(e);\n        }\n        function a(n) {\n          if (\n            n.RTCIceCandidate &&\n            !(n.RTCIceCandidate && \"foundation\" in n.RTCIceCandidate.prototype)\n          ) {\n            var o = n.RTCIceCandidate;\n            (n.RTCIceCandidate = function (t) {\n              if (\n                (\"object\" === i(t) &&\n                  t.candidate &&\n                  0 === t.candidate.indexOf(\"a=\") &&\n                  ((t = JSON.parse(JSON.stringify(t))).candidate =\n                    t.candidate.substr(2)),\n                t.candidate && t.candidate.length)\n              ) {\n                var n = new o(t),\n                  r = e.default.parseCandidate(t.candidate),\n                  a = Object.assign(n, r);\n                return (\n                  (a.toJSON = function () {\n                    return {\n                      candidate: a.candidate,\n                      sdpMid: a.sdpMid,\n                      sdpMLineIndex: a.sdpMLineIndex,\n                      usernameFragment: a.usernameFragment,\n                    };\n                  }),\n                  a\n                );\n              }\n              return new o(t);\n            }),\n              (n.RTCIceCandidate.prototype = o.prototype),\n              t.wrapPeerConnectionEvent(n, \"icecandidate\", function (e) {\n                return (\n                  e.candidate &&\n                    Object.defineProperty(e, \"candidate\", {\n                      value: new n.RTCIceCandidate(e.candidate),\n                      writable: \"false\",\n                    }),\n                  e\n                );\n              });\n          }\n        }\n        function c(t, n) {\n          if (t.RTCPeerConnection) {\n            \"sctp\" in t.RTCPeerConnection.prototype ||\n              Object.defineProperty(t.RTCPeerConnection.prototype, \"sctp\", {\n                get: function () {\n                  return void 0 === this._sctp ? null : this._sctp;\n                },\n              });\n            var o = t.RTCPeerConnection.prototype.setRemoteDescription;\n            t.RTCPeerConnection.prototype.setRemoteDescription = function () {\n              if (\n                ((this._sctp = null), \"chrome\" === n.browser && n.version >= 76)\n              ) {\n                var { sdpSemantics: t } = this.getConfiguration();\n                \"plan-b\" === t &&\n                  Object.defineProperty(this, \"sctp\", {\n                    get: function () {\n                      return void 0 === this._sctp ? null : this._sctp;\n                    },\n                    enumerable: !0,\n                    configurable: !0,\n                  });\n              }\n              if (\n                (function (t) {\n                  if (!t || !t.sdp) return !1;\n                  var n = e.default.splitSections(t.sdp);\n                  return (\n                    n.shift(),\n                    n.some(function (t) {\n                      var n = e.default.parseMLine(t);\n                      return (\n                        n &&\n                        \"application\" === n.kind &&\n                        -1 !== n.protocol.indexOf(\"SCTP\")\n                      );\n                    })\n                  );\n                })(arguments[0])\n              ) {\n                var r,\n                  i = (function (e) {\n                    var t = e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n                    if (null === t || t.length < 2) return -1;\n                    var n = parseInt(t[1], 10);\n                    return n != n ? -1 : n;\n                  })(arguments[0]),\n                  a =\n                    ((p = i),\n                    (d = 65536),\n                    \"firefox\" === n.browser &&\n                      (d =\n                        n.version < 57\n                          ? -1 === p\n                            ? 16384\n                            : 2147483637\n                          : n.version < 60\n                          ? 57 === n.version\n                            ? 65535\n                            : 65536\n                          : 2147483637),\n                    d),\n                  c = (function (t, o) {\n                    var r = 65536;\n                    \"firefox\" === n.browser && 57 === n.version && (r = 65535);\n                    var i = e.default.matchPrefix(t.sdp, \"a=max-message-size:\");\n                    return (\n                      i.length > 0\n                        ? (r = parseInt(i[0].substr(19), 10))\n                        : \"firefox\" === n.browser &&\n                          -1 !== o &&\n                          (r = 2147483637),\n                      r\n                    );\n                  })(arguments[0], i);\n                r =\n                  0 === a && 0 === c\n                    ? Number.POSITIVE_INFINITY\n                    : 0 === a || 0 === c\n                    ? Math.max(a, c)\n                    : Math.min(a, c);\n                var s = {};\n                Object.defineProperty(s, \"maxMessageSize\", {\n                  get: function () {\n                    return r;\n                  },\n                }),\n                  (this._sctp = s);\n              }\n              var p, d;\n              return o.apply(this, arguments);\n            };\n          }\n        }\n        function s(e) {\n          if (\n            e.RTCPeerConnection &&\n            \"createDataChannel\" in e.RTCPeerConnection.prototype\n          ) {\n            var n = e.RTCPeerConnection.prototype.createDataChannel;\n            (e.RTCPeerConnection.prototype.createDataChannel = function () {\n              var e = n.apply(this, arguments);\n              return o(e, this), e;\n            }),\n              t.wrapPeerConnectionEvent(e, \"datachannel\", function (e) {\n                return o(e.channel, e.target), e;\n              });\n          }\n          function o(e, t) {\n            var n = e.send;\n            e.send = function () {\n              var o = arguments[0],\n                r = o.length || o.size || o.byteLength;\n              if (\n                \"open\" === e.readyState &&\n                t.sctp &&\n                r > t.sctp.maxMessageSize\n              )\n                throw new TypeError(\n                  \"Message too large (can send a maximum of \" +\n                    t.sctp.maxMessageSize +\n                    \" bytes)\"\n                );\n              return n.apply(e, arguments);\n            };\n          }\n        }\n        function p(e) {\n          if (\n            e.RTCPeerConnection &&\n            !(\"connectionState\" in e.RTCPeerConnection.prototype)\n          ) {\n            var t = e.RTCPeerConnection.prototype;\n            Object.defineProperty(t, \"connectionState\", {\n              get: function () {\n                return (\n                  { completed: \"connected\", checking: \"connecting\" }[\n                    this.iceConnectionState\n                  ] || this.iceConnectionState\n                );\n              },\n              enumerable: !0,\n              configurable: !0,\n            }),\n              Object.defineProperty(t, \"onconnectionstatechange\", {\n                get: function () {\n                  return this._onconnectionstatechange || null;\n                },\n                set: function (e) {\n                  this._onconnectionstatechange &&\n                    (this.removeEventListener(\n                      \"connectionstatechange\",\n                      this._onconnectionstatechange\n                    ),\n                    delete this._onconnectionstatechange),\n                    e &&\n                      this.addEventListener(\n                        \"connectionstatechange\",\n                        (this._onconnectionstatechange = e)\n                      );\n                },\n                enumerable: !0,\n                configurable: !0,\n              }),\n              [\"setLocalDescription\", \"setRemoteDescription\"].forEach(function (\n                e\n              ) {\n                var n = t[e];\n                t[e] = function () {\n                  return (\n                    this._connectionstatechangepoly ||\n                      ((this._connectionstatechangepoly = function (e) {\n                        var t = e.target;\n                        if (t._lastConnectionState !== t.connectionState) {\n                          t._lastConnectionState = t.connectionState;\n                          var n = new Event(\"connectionstatechange\", e);\n                          t.dispatchEvent(n);\n                        }\n                        return e;\n                      }),\n                      this.addEventListener(\n                        \"iceconnectionstatechange\",\n                        this._connectionstatechangepoly\n                      )),\n                    n.apply(this, arguments)\n                  );\n                };\n              });\n          }\n        }\n        function d(e, t) {\n          if (\n            e.RTCPeerConnection &&\n            !(\n              (\"chrome\" === t.browser && t.version >= 71) ||\n              (\"safari\" === t.browser && t.version >= 605)\n            )\n          ) {\n            var n = e.RTCPeerConnection.prototype.setRemoteDescription;\n            e.RTCPeerConnection.prototype.setRemoteDescription = function (t) {\n              if (\n                t &&\n                t.sdp &&\n                -1 !== t.sdp.indexOf(\"\\na=extmap-allow-mixed\")\n              ) {\n                var o = t.sdp\n                  .split(\"\\n\")\n                  .filter(function (e) {\n                    return \"a=extmap-allow-mixed\" !== e.trim();\n                  })\n                  .join(\"\\n\");\n                e.RTCSessionDescription && t instanceof e.RTCSessionDescription\n                  ? (arguments[0] = new e.RTCSessionDescription({\n                      type: t.type,\n                      sdp: o,\n                    }))\n                  : (t.sdp = o);\n              }\n              return n.apply(this, arguments);\n            };\n          }\n        }\n        function u(e, t) {\n          if (e.RTCPeerConnection && e.RTCPeerConnection.prototype) {\n            var n = e.RTCPeerConnection.prototype.addIceCandidate;\n            n &&\n              0 !== n.length &&\n              (e.RTCPeerConnection.prototype.addIceCandidate = function () {\n                return arguments[0]\n                  ? ((\"chrome\" === t.browser && t.version < 78) ||\n                      (\"firefox\" === t.browser && t.version < 68) ||\n                      \"safari\" === t.browser) &&\n                    arguments[0] &&\n                    \"\" === arguments[0].candidate\n                    ? Promise.resolve()\n                    : n.apply(this, arguments)\n                  : (arguments[1] && arguments[1].apply(null),\n                    Promise.resolve());\n              });\n          }\n        }\n      },\n      { sdp: \"YHvh\", \"./utils\": \"iSxC\" },\n    ],\n    KtlG: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.adapterFactory = o);\n        var e = m(require(\"./utils\")),\n          i = m(require(\"./chrome/chrome_shim\")),\n          r = m(require(\"./edge/edge_shim\")),\n          s = m(require(\"./firefox/firefox_shim\")),\n          t = m(require(\"./safari/safari_shim\")),\n          a = m(require(\"./common_shim\"));\n        function n() {\n          if (\"function\" != typeof WeakMap) return null;\n          var e = new WeakMap();\n          return (\n            (n = function () {\n              return e;\n            }),\n            e\n          );\n        }\n        function m(e) {\n          if (e && e.__esModule) return e;\n          if (null === e || (\"object\" != typeof e && \"function\" != typeof e))\n            return { default: e };\n          var i = n();\n          if (i && i.has(e)) return i.get(e);\n          var r = {},\n            s = Object.defineProperty && Object.getOwnPropertyDescriptor;\n          for (var t in e)\n            if (Object.prototype.hasOwnProperty.call(e, t)) {\n              var a = s ? Object.getOwnPropertyDescriptor(e, t) : null;\n              a && (a.get || a.set)\n                ? Object.defineProperty(r, t, a)\n                : (r[t] = e[t]);\n            }\n          return (r.default = e), i && i.set(e, r), r;\n        }\n        function o() {\n          var { window: n } =\n              arguments.length > 0 && void 0 !== arguments[0]\n                ? arguments[0]\n                : {},\n            m =\n              arguments.length > 1 && void 0 !== arguments[1]\n                ? arguments[1]\n                : {\n                    shimChrome: !0,\n                    shimFirefox: !0,\n                    shimEdge: !0,\n                    shimSafari: !0,\n                  },\n            o = e.log,\n            h = e.detectBrowser(n),\n            d = {\n              browserDetails: h,\n              commonShim: a,\n              extractVersion: e.extractVersion,\n              disableLog: e.disableLog,\n              disableWarnings: e.disableWarnings,\n            };\n          switch (h.browser) {\n            case \"chrome\":\n              if (!i || !i.shimPeerConnection || !m.shimChrome)\n                return (\n                  o(\"Chrome shim is not included in this adapter release.\"), d\n                );\n              if (null === h.version)\n                return (\n                  o(\"Chrome shim can not determine version, not shimming.\"), d\n                );\n              o(\"adapter.js shimming chrome.\"),\n                (d.browserShim = i),\n                a.shimAddIceCandidateNullOrEmpty(n, h),\n                i.shimGetUserMedia(n, h),\n                i.shimMediaStream(n, h),\n                i.shimPeerConnection(n, h),\n                i.shimOnTrack(n, h),\n                i.shimAddTrackRemoveTrack(n, h),\n                i.shimGetSendersWithDtmf(n, h),\n                i.shimGetStats(n, h),\n                i.shimSenderReceiverGetStats(n, h),\n                i.fixNegotiationNeeded(n, h),\n                a.shimRTCIceCandidate(n, h),\n                a.shimConnectionState(n, h),\n                a.shimMaxMessageSize(n, h),\n                a.shimSendThrowTypeError(n, h),\n                a.removeExtmapAllowMixed(n, h);\n              break;\n            case \"firefox\":\n              if (!s || !s.shimPeerConnection || !m.shimFirefox)\n                return (\n                  o(\"Firefox shim is not included in this adapter release.\"), d\n                );\n              o(\"adapter.js shimming firefox.\"),\n                (d.browserShim = s),\n                a.shimAddIceCandidateNullOrEmpty(n, h),\n                s.shimGetUserMedia(n, h),\n                s.shimPeerConnection(n, h),\n                s.shimOnTrack(n, h),\n                s.shimRemoveStream(n, h),\n                s.shimSenderGetStats(n, h),\n                s.shimReceiverGetStats(n, h),\n                s.shimRTCDataChannel(n, h),\n                s.shimAddTransceiver(n, h),\n                s.shimGetParameters(n, h),\n                s.shimCreateOffer(n, h),\n                s.shimCreateAnswer(n, h),\n                a.shimRTCIceCandidate(n, h),\n                a.shimConnectionState(n, h),\n                a.shimMaxMessageSize(n, h),\n                a.shimSendThrowTypeError(n, h);\n              break;\n            case \"edge\":\n              if (!r || !r.shimPeerConnection || !m.shimEdge)\n                return (\n                  o(\"MS edge shim is not included in this adapter release.\"), d\n                );\n              o(\"adapter.js shimming edge.\"),\n                (d.browserShim = r),\n                r.shimGetUserMedia(n, h),\n                r.shimGetDisplayMedia(n, h),\n                r.shimPeerConnection(n, h),\n                r.shimReplaceTrack(n, h),\n                a.shimMaxMessageSize(n, h),\n                a.shimSendThrowTypeError(n, h);\n              break;\n            case \"safari\":\n              if (!t || !m.shimSafari)\n                return (\n                  o(\"Safari shim is not included in this adapter release.\"), d\n                );\n              o(\"adapter.js shimming safari.\"),\n                (d.browserShim = t),\n                a.shimAddIceCandidateNullOrEmpty(n, h),\n                t.shimRTCIceServerUrls(n, h),\n                t.shimCreateOfferLegacy(n, h),\n                t.shimCallbacksAPI(n, h),\n                t.shimLocalStreamsAPI(n, h),\n                t.shimRemoteStreamsAPI(n, h),\n                t.shimTrackEventTransceiver(n, h),\n                t.shimGetUserMedia(n, h),\n                t.shimAudioContext(n, h),\n                a.shimRTCIceCandidate(n, h),\n                a.shimMaxMessageSize(n, h),\n                a.shimSendThrowTypeError(n, h),\n                a.removeExtmapAllowMixed(n, h);\n              break;\n            default:\n              o(\"Unsupported browser!\");\n          }\n          return d;\n        }\n      },\n      {\n        \"./utils\": \"iSxC\",\n        \"./chrome/chrome_shim\": \"uI5X\",\n        \"./edge/edge_shim\": \"XRic\",\n        \"./firefox/firefox_shim\": \"Fzdr\",\n        \"./safari/safari_shim\": \"t1lL\",\n        \"./common_shim\": \"GOQK\",\n      },\n    ],\n    tI1X: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.default = void 0);\n        var e = require(\"./adapter_factory.js\"),\n          t = (0, e.adapterFactory)({\n            window: \"undefined\" == typeof window ? void 0 : window,\n          }),\n          d = t;\n        exports.default = d;\n      },\n      { \"./adapter_factory.js\": \"KtlG\" },\n    ],\n    sXtV: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n          (this && this.__importDefault) ||\n          function (e) {\n            return e && e.__esModule ? e : { default: e };\n          };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.webRTCAdapter = void 0);\n        var t = e(require(\"webrtc-adapter\"));\n        exports.webRTCAdapter = t.default;\n      },\n      { \"webrtc-adapter\": \"tI1X\" },\n    ],\n    I31f: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.Supports = void 0);\n        var r = require(\"./adapter\");\n        exports.Supports = new ((function () {\n          function e() {\n            (this.isIOS = [\"iPad\", \"iPhone\", \"iPod\"].includes(\n              navigator.platform\n            )),\n              (this.supportedBrowsers = [\"firefox\", \"chrome\", \"safari\"]),\n              (this.minFirefoxVersion = 59),\n              (this.minChromeVersion = 72),\n              (this.minSafariVersion = 605);\n          }\n          return (\n            (e.prototype.isWebRTCSupported = function () {\n              return \"undefined\" != typeof RTCPeerConnection;\n            }),\n            (e.prototype.isBrowserSupported = function () {\n              var r = this.getBrowser(),\n                e = this.getVersion();\n              return (\n                !!this.supportedBrowsers.includes(r) &&\n                (\"chrome\" === r\n                  ? e >= this.minChromeVersion\n                  : \"firefox\" === r\n                  ? e >= this.minFirefoxVersion\n                  : \"safari\" === r && !this.isIOS && e >= this.minSafariVersion)\n              );\n            }),\n            (e.prototype.getBrowser = function () {\n              return r.webRTCAdapter.browserDetails.browser;\n            }),\n            (e.prototype.getVersion = function () {\n              return r.webRTCAdapter.browserDetails.version || 0;\n            }),\n            (e.prototype.isUnifiedPlanSupported = function () {\n              var e,\n                i = this.getBrowser(),\n                t = r.webRTCAdapter.browserDetails.version || 0;\n              if (\"chrome\" === i && t < 72) return !1;\n              if (\"firefox\" === i && t >= 59) return !0;\n              if (\n                !(\n                  window.RTCRtpTransceiver &&\n                  \"currentDirection\" in RTCRtpTransceiver.prototype\n                )\n              )\n                return !1;\n              var o = !1;\n              try {\n                (e = new RTCPeerConnection()).addTransceiver(\"audio\"), (o = !0);\n              } catch (s) {\n              } finally {\n                e && e.close();\n              }\n              return o;\n            }),\n            (e.prototype.toString = function () {\n              return (\n                \"Supports: \\n    browser:\" +\n                this.getBrowser() +\n                \" \\n    version:\" +\n                this.getVersion() +\n                \" \\n    isIOS:\" +\n                this.isIOS +\n                \" \\n    isWebRTCSupported:\" +\n                this.isWebRTCSupported() +\n                \" \\n    isBrowserSupported:\" +\n                this.isBrowserSupported() +\n                \" \\n    isUnifiedPlanSupported:\" +\n                this.isUnifiedPlanSupported()\n              );\n            }),\n            e\n          );\n        })())();\n      },\n      { \"./adapter\": \"sXtV\" },\n    ],\n    BHXf: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__createBinding) ||\n            (Object.create\n              ? function (e, t, r, o) {\n                  void 0 === o && (o = r),\n                    Object.defineProperty(e, o, {\n                      enumerable: !0,\n                      get: function () {\n                        return t[r];\n                      },\n                    });\n                }\n              : function (e, t, r, o) {\n                  void 0 === o && (o = r), (e[o] = t[r]);\n                }),\n          t =\n            (this && this.__setModuleDefault) ||\n            (Object.create\n              ? function (e, t) {\n                  Object.defineProperty(e, \"default\", {\n                    enumerable: !0,\n                    value: t,\n                  });\n                }\n              : function (e, t) {\n                  e.default = t;\n                }),\n          r =\n            (this && this.__importStar) ||\n            function (r) {\n              if (r && r.__esModule) return r;\n              var o = {};\n              if (null != r)\n                for (var n in r)\n                  \"default\" !== n &&\n                    Object.prototype.hasOwnProperty.call(r, n) &&\n                    e(o, r, n);\n              return t(o, r), o;\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.util = void 0);\n        var o = r(require(\"peerjs-js-binarypack\")),\n          n = require(\"./supports\"),\n          i = {\n            iceServers: [\n              { urls: \"stun:stun.l.google.com:19302\" },\n              {\n                urls: \"turn:0.peerjs.com:3478\",\n                username: \"peerjs\",\n                credential: \"peerjsp\",\n              },\n            ],\n            sdpSemantics: \"unified-plan\",\n          };\n        exports.util = new ((function () {\n          function e() {\n            (this.CLOUD_HOST = \"0.peerjs.com\"),\n              (this.CLOUD_PORT = 443),\n              (this.chunkedBrowsers = { Chrome: 1, chrome: 1 }),\n              (this.chunkedMTU = 16300),\n              (this.defaultConfig = i),\n              (this.browser = n.Supports.getBrowser()),\n              (this.browserVersion = n.Supports.getVersion()),\n              (this.supports = (function () {\n                var e,\n                  t = {\n                    browser: n.Supports.isBrowserSupported(),\n                    webRTC: n.Supports.isWebRTCSupported(),\n                    audioVideo: !1,\n                    data: !1,\n                    binaryBlob: !1,\n                    reliable: !1,\n                  };\n                if (!t.webRTC) return t;\n                try {\n                  (e = new RTCPeerConnection(i)), (t.audioVideo = !0);\n                  var r = void 0;\n                  try {\n                    (r = e.createDataChannel(\"_PEERJSTEST\", { ordered: !0 })),\n                      (t.data = !0),\n                      (t.reliable = !!r.ordered);\n\n                    //console.warn(\"peerjs skipping check for binary blob support (for now) so we avoid raising an exception on every run\");\n                    /*\n                    SLD NOTE: skip this test so we can catch all exceptions without the debugger stopping here EVERY TIME...\n                    try {\n                      (r.binaryType = \"blob\"),\n                        (t.binaryBlob = !n.Supports.isIOS);\n                    } catch (o) {}\n                    */\n                    \n                  } catch (o) {\n                  } finally {\n                    r && r.close();\n                  }\n                } catch (o) {\n                } finally {\n                  e && e.close();\n                }\n                return t;\n              })()),\n              (this.pack = o.pack),\n              (this.unpack = o.unpack),\n              (this._dataCount = 1);\n          }\n          return (\n            (e.prototype.noop = function () {}),\n            (e.prototype.validateId = function (e) {\n              return !e || /^[A-Za-z0-9]+(?:[ _-][A-Za-z0-9]+)*$/.test(e);\n            }),\n            (e.prototype.chunk = function (e) {\n              for (\n                var t = [],\n                  r = e.size,\n                  o = Math.ceil(r / exports.util.chunkedMTU),\n                  n = 0,\n                  i = 0;\n                i < r;\n\n              ) {\n                var a = Math.min(r, i + exports.util.chunkedMTU),\n                  u = e.slice(i, a),\n                  s = { __peerData: this._dataCount, n: n, data: u, total: o };\n                t.push(s), (i = a), n++;\n              }\n              return this._dataCount++, t;\n            }),\n            (e.prototype.blobToArrayBuffer = function (e, t) {\n              var r = new FileReader();\n              return (\n                (r.onload = function (e) {\n                  e.target && t(e.target.result);\n                }),\n                r.readAsArrayBuffer(e),\n                r\n              );\n            }),\n            (e.prototype.binaryStringToArrayBuffer = function (e) {\n              for (var t = new Uint8Array(e.length), r = 0; r < e.length; r++)\n                t[r] = 255 & e.charCodeAt(r);\n              return t.buffer;\n            }),\n            (e.prototype.randomToken = function () {\n              return Math.random().toString(36).substr(2);\n            }),\n            (e.prototype.isSecure = function () {\n              return \"https:\" === location.protocol;\n            }),\n            e\n          );\n        })())();\n      },\n      { \"peerjs-js-binarypack\": \"kdPp\", \"./supports\": \"I31f\" },\n    ],\n    JJlS: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e = Object.prototype.hasOwnProperty,\n          t = \"~\";\n        function n() {}\n        function r(e, t, n) {\n          (this.fn = e), (this.context = t), (this.once = n || !1);\n        }\n        function o(e, n, o, s, i) {\n          if (\"function\" != typeof o)\n            throw new TypeError(\"The listener must be a function\");\n          var c = new r(o, s || e, i),\n            f = t ? t + n : n;\n          return (\n            e._events[f]\n              ? e._events[f].fn\n                ? (e._events[f] = [e._events[f], c])\n                : e._events[f].push(c)\n              : ((e._events[f] = c), e._eventsCount++),\n            e\n          );\n        }\n        function s(e, t) {\n          0 == --e._eventsCount ? (e._events = new n()) : delete e._events[t];\n        }\n        function i() {\n          (this._events = new n()), (this._eventsCount = 0);\n        }\n        Object.create &&\n          ((n.prototype = Object.create(null)), new n().__proto__ || (t = !1)),\n          (i.prototype.eventNames = function () {\n            var n,\n              r,\n              o = [];\n            if (0 === this._eventsCount) return o;\n            for (r in (n = this._events))\n              e.call(n, r) && o.push(t ? r.slice(1) : r);\n            return Object.getOwnPropertySymbols\n              ? o.concat(Object.getOwnPropertySymbols(n))\n              : o;\n          }),\n          (i.prototype.listeners = function (e) {\n            var n = t ? t + e : e,\n              r = this._events[n];\n            if (!r) return [];\n            if (r.fn) return [r.fn];\n            for (var o = 0, s = r.length, i = new Array(s); o < s; o++)\n              i[o] = r[o].fn;\n            return i;\n          }),\n          (i.prototype.listenerCount = function (e) {\n            var n = t ? t + e : e,\n              r = this._events[n];\n            return r ? (r.fn ? 1 : r.length) : 0;\n          }),\n          (i.prototype.emit = function (e, n, r, o, s, i) {\n            var c = t ? t + e : e;\n            if (!this._events[c]) return !1;\n            var f,\n              u,\n              a = this._events[c],\n              l = arguments.length;\n            if (a.fn) {\n              switch ((a.once && this.removeListener(e, a.fn, void 0, !0), l)) {\n                case 1:\n                  return a.fn.call(a.context), !0;\n                case 2:\n                  return a.fn.call(a.context, n), !0;\n                case 3:\n                  return a.fn.call(a.context, n, r), !0;\n                case 4:\n                  return a.fn.call(a.context, n, r, o), !0;\n                case 5:\n                  return a.fn.call(a.context, n, r, o, s), !0;\n                case 6:\n                  return a.fn.call(a.context, n, r, o, s, i), !0;\n              }\n              for (u = 1, f = new Array(l - 1); u < l; u++)\n                f[u - 1] = arguments[u];\n              a.fn.apply(a.context, f);\n            } else {\n              var v,\n                h = a.length;\n              for (u = 0; u < h; u++)\n                switch (\n                  (a[u].once && this.removeListener(e, a[u].fn, void 0, !0), l)\n                ) {\n                  case 1:\n                    a[u].fn.call(a[u].context);\n                    break;\n                  case 2:\n                    a[u].fn.call(a[u].context, n);\n                    break;\n                  case 3:\n                    a[u].fn.call(a[u].context, n, r);\n                    break;\n                  case 4:\n                    a[u].fn.call(a[u].context, n, r, o);\n                    break;\n                  default:\n                    if (!f)\n                      for (v = 1, f = new Array(l - 1); v < l; v++)\n                        f[v - 1] = arguments[v];\n                    a[u].fn.apply(a[u].context, f);\n                }\n            }\n            return !0;\n          }),\n          (i.prototype.on = function (e, t, n) {\n            return o(this, e, t, n, !1);\n          }),\n          (i.prototype.once = function (e, t, n) {\n            return o(this, e, t, n, !0);\n          }),\n          (i.prototype.removeListener = function (e, n, r, o) {\n            var i = t ? t + e : e;\n            if (!this._events[i]) return this;\n            if (!n) return s(this, i), this;\n            var c = this._events[i];\n            if (c.fn)\n              c.fn !== n ||\n                (o && !c.once) ||\n                (r && c.context !== r) ||\n                s(this, i);\n            else {\n              for (var f = 0, u = [], a = c.length; f < a; f++)\n                (c[f].fn !== n ||\n                  (o && !c[f].once) ||\n                  (r && c[f].context !== r)) &&\n                  u.push(c[f]);\n              u.length\n                ? (this._events[i] = 1 === u.length ? u[0] : u)\n                : s(this, i);\n            }\n            return this;\n          }),\n          (i.prototype.removeAllListeners = function (e) {\n            var r;\n            return (\n              e\n                ? ((r = t ? t + e : e), this._events[r] && s(this, r))\n                : ((this._events = new n()), (this._eventsCount = 0)),\n              this\n            );\n          }),\n          (i.prototype.off = i.prototype.removeListener),\n          (i.prototype.addListener = i.prototype.on),\n          (i.prefixed = t),\n          (i.EventEmitter = i),\n          \"undefined\" != typeof module && (module.exports = i);\n      },\n      {},\n    ],\n    WOs9: [\n      function (require, module, exports) {\n        \"use strict\";\n        var r =\n            (this && this.__read) ||\n            function (r, e) {\n              var o = \"function\" == typeof Symbol && r[Symbol.iterator];\n              if (!o) return r;\n              var t,\n                n,\n                l = o.call(r),\n                i = [];\n              try {\n                for (; (void 0 === e || e-- > 0) && !(t = l.next()).done; )\n                  i.push(t.value);\n              } catch (s) {\n                n = { error: s };\n              } finally {\n                try {\n                  t && !t.done && (o = l.return) && o.call(l);\n                } finally {\n                  if (n) throw n.error;\n                }\n              }\n              return i;\n            },\n          e =\n            (this && this.__spreadArray) ||\n            function (r, e) {\n              for (var o = 0, t = e.length, n = r.length; o < t; o++, n++)\n                r[n] = e[o];\n              return r;\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.LogLevel = void 0);\n        var o,\n          t = \"PeerJS: \";\n        !(function (r) {\n          (r[(r.Disabled = 0)] = \"Disabled\"),\n            (r[(r.Errors = 1)] = \"Errors\"),\n            (r[(r.Warnings = 2)] = \"Warnings\"),\n            (r[(r.All = 3)] = \"All\");\n        })((o = exports.LogLevel || (exports.LogLevel = {})));\n        var n = (function () {\n          function n() {\n            this._logLevel = o.Disabled;\n          }\n          return (\n            Object.defineProperty(n.prototype, \"logLevel\", {\n              get: function () {\n                return this._logLevel;\n              },\n              set: function (r) {\n                this._logLevel = r;\n              },\n              enumerable: !1,\n              configurable: !0,\n            }),\n            (n.prototype.log = function () {\n              for (var t = [], n = 0; n < arguments.length; n++)\n                t[n] = arguments[n];\n              this._logLevel >= o.All &&\n                this._print.apply(this, e([o.All], r(t)));\n            }),\n            (n.prototype.warn = function () {\n              for (var t = [], n = 0; n < arguments.length; n++)\n                t[n] = arguments[n];\n              this._logLevel >= o.Warnings &&\n                this._print.apply(this, e([o.Warnings], r(t)));\n            }),\n            (n.prototype.error = function () {\n              for (var t = [], n = 0; n < arguments.length; n++)\n                t[n] = arguments[n];\n              this._logLevel >= o.Errors &&\n                this._print.apply(this, e([o.Errors], r(t)));\n            }),\n            (n.prototype.setLogFunction = function (r) {\n              this._print = r;\n            }),\n            (n.prototype._print = function (n) {\n              for (var l = [], i = 1; i < arguments.length; i++)\n                l[i - 1] = arguments[i];\n              var s = e([t], r(l));\n              for (var a in s)\n                s[a] instanceof Error &&\n                  (s[a] = \"(\" + s[a].name + \") \" + s[a].message);\n              n >= o.All\n                ? console.log.apply(console, e([], r(s)))\n                : n >= o.Warnings\n                ? console.warn.apply(console, e([\"WARNING\"], r(s)))\n                : n >= o.Errors &&\n                  console.error.apply(console, e([\"ERROR\"], r(s)));\n            }),\n            n\n          );\n        })();\n        exports.default = new n();\n      },\n      {},\n    ],\n    ZRYf: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e, r, o, n, t, a, i;\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.ServerMessageType =\n            exports.SocketEventType =\n            exports.SerializationType =\n            exports.PeerErrorType =\n            exports.PeerEventType =\n            exports.ConnectionType =\n            exports.ConnectionEventType =\n              void 0),\n          (function (e) {\n            (e.Open = \"open\"),\n              (e.Stream = \"stream\"),\n              (e.Data = \"data\"),\n              (e.Close = \"close\"),\n              (e.Error = \"error\"),\n              (e.IceStateChanged = \"iceStateChanged\");\n          })(\n            (e =\n              exports.ConnectionEventType || (exports.ConnectionEventType = {}))\n          ),\n          (function (e) {\n            (e.Data = \"data\"), (e.Media = \"media\");\n          })((r = exports.ConnectionType || (exports.ConnectionType = {}))),\n          (function (e) {\n            (e.Open = \"open\"),\n              (e.Close = \"close\"),\n              (e.Connection = \"connection\"),\n              (e.Call = \"call\"),\n              (e.Disconnected = \"disconnected\"),\n              (e.Error = \"error\");\n          })((o = exports.PeerEventType || (exports.PeerEventType = {}))),\n          (function (e) {\n            (e.BrowserIncompatible = \"browser-incompatible\"),\n              (e.Disconnected = \"disconnected\"),\n              (e.InvalidID = \"invalid-id\"),\n              (e.InvalidKey = \"invalid-key\"),\n              (e.Network = \"network\"),\n              (e.PeerUnavailable = \"peer-unavailable\"),\n              (e.SslUnavailable = \"ssl-unavailable\"),\n              (e.ServerError = \"server-error\"),\n              (e.SocketError = \"socket-error\"),\n              (e.SocketClosed = \"socket-closed\"),\n              (e.UnavailableID = \"unavailable-id\"),\n              (e.WebRTC = \"webrtc\");\n          })((n = exports.PeerErrorType || (exports.PeerErrorType = {}))),\n          (function (e) {\n            (e.Binary = \"binary\"),\n              (e.BinaryUTF8 = \"binary-utf8\"),\n              (e.JSON = \"json\");\n          })(\n            (t = exports.SerializationType || (exports.SerializationType = {}))\n          ),\n          (function (e) {\n            (e.Message = \"message\"),\n              (e.Disconnected = \"disconnected\"),\n              (e.Error = \"error\"),\n              (e.Close = \"close\");\n          })((a = exports.SocketEventType || (exports.SocketEventType = {}))),\n          (function (e) {\n            (e.Heartbeat = \"HEARTBEAT\"),\n              (e.Candidate = \"CANDIDATE\"),\n              (e.Offer = \"OFFER\"),\n              (e.Answer = \"ANSWER\"),\n              (e.Open = \"OPEN\"),\n              (e.Error = \"ERROR\"),\n              (e.IdTaken = \"ID-TAKEN\"),\n              (e.InvalidKey = \"INVALID-KEY\"),\n              (e.Leave = \"LEAVE\"),\n              (e.Expire = \"EXPIRE\");\n          })(\n            (i = exports.ServerMessageType || (exports.ServerMessageType = {}))\n          );\n      },\n      {},\n    ],\n    wJlv: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__extends) ||\n            (function () {\n              var e = function (t, n) {\n                return (e =\n                  Object.setPrototypeOf ||\n                  ({ __proto__: [] } instanceof Array &&\n                    function (e, t) {\n                      e.__proto__ = t;\n                    }) ||\n                  function (e, t) {\n                    for (var n in t)\n                      Object.prototype.hasOwnProperty.call(t, n) &&\n                        (e[n] = t[n]);\n                  })(t, n);\n              };\n              return function (t, n) {\n                if (\"function\" != typeof n && null !== n)\n                  throw new TypeError(\n                    \"Class extends value \" +\n                      String(n) +\n                      \" is not a constructor or null\"\n                  );\n                function o() {\n                  this.constructor = t;\n                }\n                e(t, n),\n                  (t.prototype =\n                    null === n\n                      ? Object.create(n)\n                      : ((o.prototype = n.prototype), new o()));\n              };\n            })(),\n          t =\n            (this && this.__read) ||\n            function (e, t) {\n              var n = \"function\" == typeof Symbol && e[Symbol.iterator];\n              if (!n) return e;\n              var o,\n                s,\n                r = n.call(e),\n                i = [];\n              try {\n                for (; (void 0 === t || t-- > 0) && !(o = r.next()).done; )\n                  i.push(o.value);\n              } catch (c) {\n                s = { error: c };\n              } finally {\n                try {\n                  o && !o.done && (n = r.return) && n.call(r);\n                } finally {\n                  if (s) throw s.error;\n                }\n              }\n              return i;\n            },\n          n =\n            (this && this.__spreadArray) ||\n            function (e, t) {\n              for (var n = 0, o = t.length, s = e.length; n < o; n++, s++)\n                e[s] = t[n];\n              return e;\n            },\n          o =\n            (this && this.__values) ||\n            function (e) {\n              var t = \"function\" == typeof Symbol && Symbol.iterator,\n                n = t && e[t],\n                o = 0;\n              if (n) return n.call(e);\n              if (e && \"number\" == typeof e.length)\n                return {\n                  next: function () {\n                    return (\n                      e && o >= e.length && (e = void 0),\n                      { value: e && e[o++], done: !e }\n                    );\n                  },\n                };\n              throw new TypeError(\n                t\n                  ? \"Object is not iterable.\"\n                  : \"Symbol.iterator is not defined.\"\n              );\n            },\n          s =\n            (this && this.__importDefault) ||\n            function (e) {\n              return e && e.__esModule ? e : { default: e };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.Socket = void 0);\n        var r = require(\"eventemitter3\"),\n          i = s(require(\"./logger\")),\n          c = require(\"./enums\"),\n          a = (function (s) {\n            function r(e, t, n, o, r, i) {\n              void 0 === i && (i = 5e3);\n              var c = s.call(this) || this;\n              (c.pingInterval = i),\n                (c._disconnected = !0),\n                (c._messagesQueue = []);\n              var a = e ? \"wss://\" : \"ws://\";\n              return (c._baseUrl = a + t + \":\" + n + o + \"peerjs?key=\" + r), c;\n            }\n            return (\n              e(r, s),\n              (r.prototype.start = function (e, t) {\n                var n = this;\n                this._id = e;\n                var o = this._baseUrl + \"&id=\" + e + \"&token=\" + t;\n                !this._socket &&\n                  this._disconnected &&\n                  ((this._socket = new WebSocket(o)),\n                  (this._disconnected = !1),\n                  (this._socket.onmessage = function (e) {\n                    var t;\n                    try {\n                      (t = JSON.parse(e.data)),\n                        i.default.log(\"Server message received:\", t);\n                    } catch (o) {\n                      return void i.default.log(\n                        \"Invalid server message\",\n                        e.data\n                      );\n                    }\n                    n.emit(c.SocketEventType.Message, t);\n                  }),\n                  (this._socket.onclose = function (e) {\n                    n._disconnected ||\n                      (i.default.log(\"Socket closed.\", e),\n                      n._cleanup(),\n                      (n._disconnected = !0),\n                      n.emit(c.SocketEventType.Disconnected));\n                  }),\n                  (this._socket.onopen = function () {\n                    n._disconnected ||\n                      (n._sendQueuedMessages(),\n                      i.default.log(\"Socket open\"),\n                      n._scheduleHeartbeat());\n                  }));\n              }),\n              (r.prototype._scheduleHeartbeat = function () {\n                var e = this;\n                this._wsPingTimer = setTimeout(function () {\n                  e._sendHeartbeat();\n                }, this.pingInterval);\n              }),\n              (r.prototype._sendHeartbeat = function () {\n                if (this._wsOpen()) {\n                  var e = JSON.stringify({\n                    type: c.ServerMessageType.Heartbeat,\n                  });\n                  this._socket.send(e), this._scheduleHeartbeat();\n                } else\n                  i.default.log(\"Cannot send heartbeat, because socket closed\");\n              }),\n              (r.prototype._wsOpen = function () {\n                return !!this._socket && 1 === this._socket.readyState;\n              }),\n              (r.prototype._sendQueuedMessages = function () {\n                var e,\n                  s,\n                  r = n([], t(this._messagesQueue));\n                this._messagesQueue = [];\n                try {\n                  for (var i = o(r), c = i.next(); !c.done; c = i.next()) {\n                    var a = c.value;\n                    this.send(a);\n                  }\n                } catch (u) {\n                  e = { error: u };\n                } finally {\n                  try {\n                    c && !c.done && (s = i.return) && s.call(i);\n                  } finally {\n                    if (e) throw e.error;\n                  }\n                }\n              }),\n              (r.prototype.send = function (e) {\n                if (!this._disconnected)\n                  if (this._id)\n                    if (e.type) {\n                      if (this._wsOpen()) {\n                        var t = JSON.stringify(e);\n                        this._socket.send(t);\n                      }\n                    } else\n                      this.emit(c.SocketEventType.Error, \"Invalid message\");\n                  else this._messagesQueue.push(e);\n              }),\n              (r.prototype.close = function () {\n                this._disconnected ||\n                  (this._cleanup(), (this._disconnected = !0));\n              }),\n              (r.prototype._cleanup = function () {\n                this._socket &&\n                  ((this._socket.onopen =\n                    this._socket.onmessage =\n                    this._socket.onclose =\n                      null),\n                  this._socket.close(),\n                  (this._socket = void 0)),\n                  clearTimeout(this._wsPingTimer);\n              }),\n              r\n            );\n          })(r.EventEmitter);\n        exports.Socket = a;\n      },\n      { eventemitter3: \"JJlS\", \"./logger\": \"WOs9\", \"./enums\": \"ZRYf\" },\n    ],\n    HCdX: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__assign) ||\n            function () {\n              return (e =\n                Object.assign ||\n                function (e) {\n                  for (var n, t = 1, o = arguments.length; t < o; t++)\n                    for (var i in (n = arguments[t]))\n                      Object.prototype.hasOwnProperty.call(n, i) &&\n                        (e[i] = n[i]);\n                  return e;\n                }).apply(this, arguments);\n            },\n          n =\n            (this && this.__awaiter) ||\n            function (e, n, t, o) {\n              return new (t || (t = Promise))(function (i, r) {\n                function c(e) {\n                  try {\n                    s(o.next(e));\n                  } catch (n) {\n                    r(n);\n                  }\n                }\n                function a(e) {\n                  try {\n                    s(o.throw(e));\n                  } catch (n) {\n                    r(n);\n                  }\n                }\n                function s(e) {\n                  var n;\n                  e.done\n                    ? i(e.value)\n                    : ((n = e.value),\n                      n instanceof t\n                        ? n\n                        : new t(function (e) {\n                            e(n);\n                          })).then(c, a);\n                }\n                s((o = o.apply(e, n || [])).next());\n              });\n            },\n          t =\n            (this && this.__generator) ||\n            function (e, n) {\n              var t,\n                o,\n                i,\n                r,\n                c = {\n                  label: 0,\n                  sent: function () {\n                    if (1 & i[0]) throw i[1];\n                    return i[1];\n                  },\n                  trys: [],\n                  ops: [],\n                };\n              return (\n                (r = { next: a(0), throw: a(1), return: a(2) }),\n                \"function\" == typeof Symbol &&\n                  (r[Symbol.iterator] = function () {\n                    return this;\n                  }),\n                r\n              );\n              function a(r) {\n                return function (a) {\n                  return (function (r) {\n                    if (t)\n                      throw new TypeError(\"Generator is already executing.\");\n                    for (; c; )\n                      try {\n                        if (\n                          ((t = 1),\n                          o &&\n                            (i =\n                              2 & r[0]\n                                ? o.return\n                                : r[0]\n                                ? o.throw || ((i = o.return) && i.call(o), 0)\n                                : o.next) &&\n                            !(i = i.call(o, r[1])).done)\n                        )\n                          return i;\n                        switch (\n                          ((o = 0), i && (r = [2 & r[0], i.value]), r[0])\n                        ) {\n                          case 0:\n                          case 1:\n                            i = r;\n                            break;\n                          case 4:\n                            return c.label++, { value: r[1], done: !1 };\n                          case 5:\n                            c.label++, (o = r[1]), (r = [0]);\n                            continue;\n                          case 7:\n                            (r = c.ops.pop()), c.trys.pop();\n                            continue;\n                          default:\n                            if (\n                              !(i =\n                                (i = c.trys).length > 0 && i[i.length - 1]) &&\n                              (6 === r[0] || 2 === r[0])\n                            ) {\n                              c = 0;\n                              continue;\n                            }\n                            if (\n                              3 === r[0] &&\n                              (!i || (r[1] > i[0] && r[1] < i[3]))\n                            ) {\n                              c.label = r[1];\n                              break;\n                            }\n                            if (6 === r[0] && c.label < i[1]) {\n                              (c.label = i[1]), (i = r);\n                              break;\n                            }\n                            if (i && c.label < i[2]) {\n                              (c.label = i[2]), c.ops.push(r);\n                              break;\n                            }\n                            i[2] && c.ops.pop(), c.trys.pop();\n                            continue;\n                        }\n                        r = n.call(e, c);\n                      } catch (a) {\n                        (r = [6, a]), (o = 0);\n                      } finally {\n                        t = i = 0;\n                      }\n                    if (5 & r[0]) throw r[1];\n                    return { value: r[0] ? r[1] : void 0, done: !0 };\n                  })([r, a]);\n                };\n              }\n            },\n          o =\n            (this && this.__importDefault) ||\n            function (e) {\n              return e && e.__esModule ? e : { default: e };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.Negotiator = void 0);\n        var i = require(\"./util\"),\n          r = o(require(\"./logger\")),\n          c = require(\"./enums\"),\n          a = (function () {\n            function o(e) {\n              this.connection = e;\n            }\n            return (\n              (o.prototype.startConnection = function (e) {\n                var n = this._startPeerConnection();\n                if (\n                  ((this.connection.peerConnection = n),\n                  this.connection.type === c.ConnectionType.Media &&\n                    e._stream &&\n                    this._addTracksToConnection(e._stream, n),\n                  e.originator)\n                ) {\n                  if (this.connection.type === c.ConnectionType.Data) {\n                    var t = this.connection,\n                      o = { ordered: !!e.reliable },\n                      i = n.createDataChannel(t.label, o);\n                    t.initialize(i);\n                  }\n                  this._makeOffer();\n                } else this.handleSDP(\"OFFER\", e.sdp);\n              }),\n              (o.prototype._startPeerConnection = function () {\n                r.default.log(\"Creating RTCPeerConnection.\");\n                var e = new RTCPeerConnection(\n                  this.connection.provider.options.config\n                );\n                return this._setupListeners(e), e;\n              }),\n              (o.prototype._setupListeners = function (e) {\n                var n = this,\n                  t = this.connection.peer,\n                  o = this.connection.connectionId,\n                  a = this.connection.type,\n                  s = this.connection.provider;\n                r.default.log(\"Listening for ICE candidates.\"),\n                  (e.onicecandidate = function (e) {\n                    e.candidate &&\n                      e.candidate.candidate &&\n                      (r.default.log(\n                        \"Received ICE candidates for \" + t + \":\",\n                        e.candidate\n                      ),\n                      s.socket.send({\n                        type: c.ServerMessageType.Candidate,\n                        payload: {\n                          candidate: e.candidate,\n                          type: a,\n                          connectionId: o,\n                        },\n                        dst: t,\n                      }));\n                  }),\n                  (e.oniceconnectionstatechange = function () {\n                    switch (e.iceConnectionState) {\n                      case \"failed\":\n                        r.default.log(\n                          \"iceConnectionState is failed, closing connections to \" +\n                            t\n                        ),\n                          n.connection.emit(\n                            c.ConnectionEventType.Error,\n                            new Error(\n                              \"Negotiation of connection to \" + t + \" failed.\"\n                            )\n                          ),\n                          n.connection.close();\n                        break;\n                      case \"closed\":\n                        r.default.log(\n                          \"iceConnectionState is closed, closing connections to \" +\n                            t\n                        ),\n                          n.connection.emit(\n                            c.ConnectionEventType.Error,\n                            new Error(\"Connection to \" + t + \" closed.\")\n                          ),\n                          n.connection.close();\n                        break;\n                      case \"disconnected\":\n                        r.default.log(\n                          \"iceConnectionState changed to disconnected on the connection with \" +\n                            t\n                        );\n                        break;\n                      case \"completed\":\n                        e.onicecandidate = i.util.noop;\n                    }\n                    n.connection.emit(\n                      c.ConnectionEventType.IceStateChanged,\n                      e.iceConnectionState\n                    );\n                  }),\n                  r.default.log(\"Listening for data channel\"),\n                  (e.ondatachannel = function (e) {\n                    r.default.log(\"Received data channel\");\n                    var n = e.channel;\n                    s.getConnection(t, o).initialize(n);\n                  }),\n                  r.default.log(\"Listening for remote stream\"),\n                  (e.ontrack = function (e) {\n                    r.default.log(\"Received remote stream\");\n                    var i = e.streams[0],\n                      a = s.getConnection(t, o);\n                    if (a.type === c.ConnectionType.Media) {\n                      var d = a;\n                      n._addStreamToMediaConnection(i, d);\n                    }\n                  });\n              }),\n              (o.prototype.cleanup = function () {\n                r.default.log(\n                  \"Cleaning up PeerConnection to \" + this.connection.peer\n                );\n                var e = this.connection.peerConnection;\n                if (e) {\n                  (this.connection.peerConnection = null),\n                    (e.onicecandidate =\n                      e.oniceconnectionstatechange =\n                      e.ondatachannel =\n                      e.ontrack =\n                        function () {});\n                  var n = \"closed\" !== e.signalingState,\n                    t = !1;\n                  if (this.connection.type === c.ConnectionType.Data) {\n                    var o = this.connection.dataChannel;\n                    o && (t = !!o.readyState && \"closed\" !== o.readyState);\n                  }\n                  (n || t) && e.close();\n                }\n              }),\n              (o.prototype._makeOffer = function () {\n                return n(this, void 0, Promise, function () {\n                  var n, o, a, s, d, l, u;\n                  return t(this, function (t) {\n                    switch (t.label) {\n                      case 0:\n                        (n = this.connection.peerConnection),\n                          (o = this.connection.provider),\n                          (t.label = 1);\n                      case 1:\n                        return (\n                          t.trys.push([1, 7, , 8]),\n                          [\n                            4,\n                            n.createOffer(this.connection.options.constraints),\n                          ]\n                        );\n                      case 2:\n                        (a = t.sent()),\n                          r.default.log(\"Created offer.\"),\n                          this.connection.options.sdpTransform &&\n                            \"function\" ==\n                              typeof this.connection.options.sdpTransform &&\n                            (a.sdp =\n                              this.connection.options.sdpTransform(a.sdp) ||\n                              a.sdp),\n                          (t.label = 3);\n                      case 3:\n                        return (\n                          t.trys.push([3, 5, , 6]),\n                          [4, n.setLocalDescription(a)]\n                        );\n                      case 4:\n                        return (\n                          t.sent(),\n                          r.default.log(\n                            \"Set localDescription:\",\n                            a,\n                            \"for:\" + this.connection.peer\n                          ),\n                          (s = {\n                            sdp: a,\n                            type: this.connection.type,\n                            connectionId: this.connection.connectionId,\n                            metadata: this.connection.metadata,\n                            browser: i.util.browser,\n                          }),\n                          this.connection.type === c.ConnectionType.Data &&\n                            ((d = this.connection),\n                            (s = e(e({}, s), {\n                              label: d.label,\n                              reliable: d.reliable,\n                              serialization: d.serialization,\n                            }))),\n                          o.socket.send({\n                            type: c.ServerMessageType.Offer,\n                            payload: s,\n                            dst: this.connection.peer,\n                          }),\n                          [3, 6]\n                        );\n                      case 5:\n                        return (\n                          \"OperationError: Failed to set local offer sdp: Called in wrong state: kHaveRemoteOffer\" !=\n                            (l = t.sent()) &&\n                            (o.emitError(c.PeerErrorType.WebRTC, l),\n                            r.default.log(\n                              \"Failed to setLocalDescription, \",\n                              l\n                            )),\n                          [3, 6]\n                        );\n                      case 6:\n                        return [3, 8];\n                      case 7:\n                        return (\n                          (u = t.sent()),\n                          o.emitError(c.PeerErrorType.WebRTC, u),\n                          r.default.log(\"Failed to createOffer, \", u),\n                          [3, 8]\n                        );\n                      case 8:\n                        return [2];\n                    }\n                  });\n                });\n              }),\n              (o.prototype._makeAnswer = function () {\n                return n(this, void 0, Promise, function () {\n                  var e, n, o, a, s;\n                  return t(this, function (t) {\n                    switch (t.label) {\n                      case 0:\n                        (e = this.connection.peerConnection),\n                          (n = this.connection.provider),\n                          (t.label = 1);\n                      case 1:\n                        return t.trys.push([1, 7, , 8]), [4, e.createAnswer()];\n                      case 2:\n                        (o = t.sent()),\n                          r.default.log(\"Created answer.\"),\n                          this.connection.options.sdpTransform &&\n                            \"function\" ==\n                              typeof this.connection.options.sdpTransform &&\n                            (o.sdp =\n                              this.connection.options.sdpTransform(o.sdp) ||\n                              o.sdp),\n                          (t.label = 3);\n                      case 3:\n                        return (\n                          t.trys.push([3, 5, , 6]),\n                          [4, e.setLocalDescription(o)]\n                        );\n                      case 4:\n                        return (\n                          t.sent(),\n                          r.default.log(\n                            \"Set localDescription:\",\n                            o,\n                            \"for:\" + this.connection.peer\n                          ),\n                          n.socket.send({\n                            type: c.ServerMessageType.Answer,\n                            payload: {\n                              sdp: o,\n                              type: this.connection.type,\n                              connectionId: this.connection.connectionId,\n                              browser: i.util.browser,\n                            },\n                            dst: this.connection.peer,\n                          }),\n                          [3, 6]\n                        );\n                      case 5:\n                        return (\n                          (a = t.sent()),\n                          n.emitError(c.PeerErrorType.WebRTC, a),\n                          r.default.log(\"Failed to setLocalDescription, \", a),\n                          [3, 6]\n                        );\n                      case 6:\n                        return [3, 8];\n                      case 7:\n                        return (\n                          (s = t.sent()),\n                          n.emitError(c.PeerErrorType.WebRTC, s),\n                          r.default.log(\"Failed to create answer, \", s),\n                          [3, 8]\n                        );\n                      case 8:\n                        return [2];\n                    }\n                  });\n                });\n              }),\n              (o.prototype.handleSDP = function (e, o) {\n                return n(this, void 0, Promise, function () {\n                  var n, i, a, s;\n                  return t(this, function (t) {\n                    switch (t.label) {\n                      case 0:\n                        (o = new RTCSessionDescription(o)),\n                          (n = this.connection.peerConnection),\n                          (i = this.connection.provider),\n                          r.default.log(\"Setting remote description\", o),\n                          (a = this),\n                          (t.label = 1);\n                      case 1:\n                        return (\n                          t.trys.push([1, 5, , 6]),\n                          [4, n.setRemoteDescription(o)]\n                        );\n                      case 2:\n                        return (\n                          t.sent(),\n                          r.default.log(\n                            \"Set remoteDescription:\" +\n                              e +\n                              \" for:\" +\n                              this.connection.peer\n                          ),\n                          \"OFFER\" !== e ? [3, 4] : [4, a._makeAnswer()]\n                        );\n                      case 3:\n                        t.sent(), (t.label = 4);\n                      case 4:\n                        return [3, 6];\n                      case 5:\n                        return (\n                          (s = t.sent()),\n                          i.emitError(c.PeerErrorType.WebRTC, s),\n                          r.default.log(\"Failed to setRemoteDescription, \", s),\n                          [3, 6]\n                        );\n                      case 6:\n                        return [2];\n                    }\n                  });\n                });\n              }),\n              (o.prototype.handleCandidate = function (e) {\n                return n(this, void 0, Promise, function () {\n                  var n, o, i, a, s, d;\n                  return t(this, function (t) {\n                    switch (t.label) {\n                      case 0:\n                        r.default.log(\"handleCandidate:\", e),\n                          (n = e.candidate),\n                          (o = e.sdpMLineIndex),\n                          (i = e.sdpMid),\n                          (a = this.connection.peerConnection),\n                          (s = this.connection.provider),\n                          (t.label = 1);\n                      case 1:\n                        return (\n                          t.trys.push([1, 3, , 4]),\n                          [\n                            4,\n                            a.addIceCandidate(\n                              new RTCIceCandidate({\n                                sdpMid: i,\n                                sdpMLineIndex: o,\n                                candidate: n,\n                              })\n                            ),\n                          ]\n                        );\n                      case 2:\n                        return (\n                          t.sent(),\n                          r.default.log(\n                            \"Added ICE candidate for:\" + this.connection.peer\n                          ),\n                          [3, 4]\n                        );\n                      case 3:\n                        return (\n                          (d = t.sent()),\n                          s.emitError(c.PeerErrorType.WebRTC, d),\n                          r.default.log(\"Failed to handleCandidate, \", d),\n                          [3, 4]\n                        );\n                      case 4:\n                        return [2];\n                    }\n                  });\n                });\n              }),\n              (o.prototype._addTracksToConnection = function (e, n) {\n                if (\n                  (r.default.log(\n                    \"add tracks from stream \" + e.id + \" to peer connection\"\n                  ),\n                  !n.addTrack)\n                )\n                  return r.default.error(\n                    \"Your browser does't support RTCPeerConnection#addTrack. Ignored.\"\n                  );\n                e.getTracks().forEach(function (t) {\n                  n.addTrack(t, e);\n                });\n              }),\n              (o.prototype._addStreamToMediaConnection = function (e, n) {\n                r.default.log(\n                  \"add stream \" +\n                    e.id +\n                    \" to media connection \" +\n                    n.connectionId\n                ),\n                  n.addStream(e);\n              }),\n              o\n            );\n          })();\n        exports.Negotiator = a;\n      },\n      { \"./util\": \"BHXf\", \"./logger\": \"WOs9\", \"./enums\": \"ZRYf\" },\n    ],\n    tQFK: [\n      function (require, module, exports) {\n        \"use strict\";\n        var t =\n          (this && this.__extends) ||\n          (function () {\n            var t = function (e, n) {\n              return (t =\n                Object.setPrototypeOf ||\n                ({ __proto__: [] } instanceof Array &&\n                  function (t, e) {\n                    t.__proto__ = e;\n                  }) ||\n                function (t, e) {\n                  for (var n in e)\n                    Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);\n                })(e, n);\n            };\n            return function (e, n) {\n              if (\"function\" != typeof n && null !== n)\n                throw new TypeError(\n                  \"Class extends value \" +\n                    String(n) +\n                    \" is not a constructor or null\"\n                );\n              function o() {\n                this.constructor = e;\n              }\n              t(e, n),\n                (e.prototype =\n                  null === n\n                    ? Object.create(n)\n                    : ((o.prototype = n.prototype), new o()));\n            };\n          })();\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.BaseConnection = void 0);\n        var e = require(\"eventemitter3\"),\n          n = (function (e) {\n            function n(t, n, o) {\n              var r = e.call(this) || this;\n              return (\n                (r.peer = t),\n                (r.provider = n),\n                (r.options = o),\n                (r._open = !1),\n                (r.metadata = o.metadata),\n                r\n              );\n            }\n            return (\n              t(n, e),\n              Object.defineProperty(n.prototype, \"open\", {\n                get: function () {\n                  return this._open;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              n\n            );\n          })(e.EventEmitter);\n        exports.BaseConnection = n;\n      },\n      { eventemitter3: \"JJlS\" },\n    ],\n    dbHP: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__extends) ||\n            (function () {\n              var e = function (t, o) {\n                return (e =\n                  Object.setPrototypeOf ||\n                  ({ __proto__: [] } instanceof Array &&\n                    function (e, t) {\n                      e.__proto__ = t;\n                    }) ||\n                  function (e, t) {\n                    for (var o in t)\n                      Object.prototype.hasOwnProperty.call(t, o) &&\n                        (e[o] = t[o]);\n                  })(t, o);\n              };\n              return function (t, o) {\n                if (\"function\" != typeof o && null !== o)\n                  throw new TypeError(\n                    \"Class extends value \" +\n                      String(o) +\n                      \" is not a constructor or null\"\n                  );\n                function r() {\n                  this.constructor = t;\n                }\n                e(t, o),\n                  (t.prototype =\n                    null === o\n                      ? Object.create(o)\n                      : ((r.prototype = o.prototype), new r()));\n              };\n            })(),\n          t =\n            (this && this.__assign) ||\n            function () {\n              return (t =\n                Object.assign ||\n                function (e) {\n                  for (var t, o = 1, r = arguments.length; o < r; o++)\n                    for (var n in (t = arguments[o]))\n                      Object.prototype.hasOwnProperty.call(t, n) &&\n                        (e[n] = t[n]);\n                  return e;\n                }).apply(this, arguments);\n            },\n          o =\n            (this && this.__values) ||\n            function (e) {\n              var t = \"function\" == typeof Symbol && Symbol.iterator,\n                o = t && e[t],\n                r = 0;\n              if (o) return o.call(e);\n              if (e && \"number\" == typeof e.length)\n                return {\n                  next: function () {\n                    return (\n                      e && r >= e.length && (e = void 0),\n                      { value: e && e[r++], done: !e }\n                    );\n                  },\n                };\n              throw new TypeError(\n                t\n                  ? \"Object is not iterable.\"\n                  : \"Symbol.iterator is not defined.\"\n              );\n            },\n          r =\n            (this && this.__importDefault) ||\n            function (e) {\n              return e && e.__esModule ? e : { default: e };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.MediaConnection = void 0);\n        var n = require(\"./util\"),\n          i = r(require(\"./logger\")),\n          a = require(\"./negotiator\"),\n          s = require(\"./enums\"),\n          l = require(\"./baseconnection\"),\n          c = (function (r) {\n            function l(e, t, o) {\n              var i = r.call(this, e, t, o) || this;\n              return (\n                (i._localStream = i.options._stream),\n                (i.connectionId =\n                  i.options.connectionId || l.ID_PREFIX + n.util.randomToken()),\n                (i._negotiator = new a.Negotiator(i)),\n                i._localStream &&\n                  i._negotiator.startConnection({\n                    _stream: i._localStream,\n                    originator: !0,\n                  }),\n                i\n              );\n            }\n            return (\n              e(l, r),\n              Object.defineProperty(l.prototype, \"type\", {\n                get: function () {\n                  return s.ConnectionType.Media;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(l.prototype, \"localStream\", {\n                get: function () {\n                  return this._localStream;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(l.prototype, \"remoteStream\", {\n                get: function () {\n                  return this._remoteStream;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              (l.prototype.addStream = function (e) {\n                i.default.log(\"Receiving stream\", e),\n                  (this._remoteStream = e),\n                  r.prototype.emit.call(this, s.ConnectionEventType.Stream, e);\n              }),\n              (l.prototype.handleMessage = function (e) {\n                var t = e.type,\n                  o = e.payload;\n                switch (e.type) {\n                  case s.ServerMessageType.Answer:\n                    this._negotiator.handleSDP(t, o.sdp), (this._open = !0);\n                    break;\n                  case s.ServerMessageType.Candidate:\n                    this._negotiator.handleCandidate(o.candidate);\n                    break;\n                  default:\n                    i.default.warn(\n                      \"Unrecognized message type:\" +\n                        t +\n                        \" from peer:\" +\n                        this.peer\n                    );\n                }\n              }),\n              (l.prototype.answer = function (e, r) {\n                var n, a;\n                if ((void 0 === r && (r = {}), this._localStream))\n                  i.default.warn(\n                    \"Local stream already exists on this MediaConnection. Are you answering a call twice?\"\n                  );\n                else {\n                  (this._localStream = e),\n                    r &&\n                      r.sdpTransform &&\n                      (this.options.sdpTransform = r.sdpTransform),\n                    this._negotiator.startConnection(\n                      t(t({}, this.options._payload), { _stream: e })\n                    );\n                  var s = this.provider._getMessages(this.connectionId);\n                  try {\n                    for (var l = o(s), c = l.next(); !c.done; c = l.next()) {\n                      var p = c.value;\n                      this.handleMessage(p);\n                    }\n                  } catch (u) {\n                    n = { error: u };\n                  } finally {\n                    try {\n                      c && !c.done && (a = l.return) && a.call(l);\n                    } finally {\n                      if (n) throw n.error;\n                    }\n                  }\n                  this._open = !0;\n                }\n              }),\n              (l.prototype.close = function () {\n                this._negotiator &&\n                  (this._negotiator.cleanup(), (this._negotiator = null)),\n                  (this._localStream = null),\n                  (this._remoteStream = null),\n                  this.provider &&\n                    (this.provider._removeConnection(this),\n                    (this.provider = null)),\n                  this.options &&\n                    this.options._stream &&\n                    (this.options._stream = null),\n                  this.open &&\n                    ((this._open = !1),\n                    r.prototype.emit.call(this, s.ConnectionEventType.Close));\n              }),\n              (l.ID_PREFIX = \"mc_\"),\n              l\n            );\n          })(l.BaseConnection);\n        exports.MediaConnection = c;\n      },\n      {\n        \"./util\": \"BHXf\",\n        \"./logger\": \"WOs9\",\n        \"./negotiator\": \"HCdX\",\n        \"./enums\": \"ZRYf\",\n        \"./baseconnection\": \"tQFK\",\n      },\n    ],\n    GGp6: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__extends) ||\n            (function () {\n              var e = function (t, r) {\n                return (e =\n                  Object.setPrototypeOf ||\n                  ({ __proto__: [] } instanceof Array &&\n                    function (e, t) {\n                      e.__proto__ = t;\n                    }) ||\n                  function (e, t) {\n                    for (var r in t)\n                      Object.prototype.hasOwnProperty.call(t, r) &&\n                        (e[r] = t[r]);\n                  })(t, r);\n              };\n              return function (t, r) {\n                if (\"function\" != typeof r && null !== r)\n                  throw new TypeError(\n                    \"Class extends value \" +\n                      String(r) +\n                      \" is not a constructor or null\"\n                  );\n                function o() {\n                  this.constructor = t;\n                }\n                e(t, r),\n                  (t.prototype =\n                    null === r\n                      ? Object.create(r)\n                      : ((o.prototype = r.prototype), new o()));\n              };\n            })(),\n          t =\n            (this && this.__importDefault) ||\n            function (e) {\n              return e && e.__esModule ? e : { default: e };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.EncodingQueue = void 0);\n        var r = require(\"eventemitter3\"),\n          o = t(require(\"./logger\")),\n          n = (function (t) {\n            function r() {\n              var e = t.call(this) || this;\n              return (\n                (e.fileReader = new FileReader()),\n                (e._queue = []),\n                (e._processing = !1),\n                (e.fileReader.onload = function (t) {\n                  (e._processing = !1),\n                    t.target && e.emit(\"done\", t.target.result),\n                    e.doNextTask();\n                }),\n                (e.fileReader.onerror = function (t) {\n                  o.default.error(\"EncodingQueue error:\", t),\n                    (e._processing = !1),\n                    e.destroy(),\n                    e.emit(\"error\", t);\n                }),\n                e\n              );\n            }\n            return (\n              e(r, t),\n              Object.defineProperty(r.prototype, \"queue\", {\n                get: function () {\n                  return this._queue;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(r.prototype, \"size\", {\n                get: function () {\n                  return this.queue.length;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(r.prototype, \"processing\", {\n                get: function () {\n                  return this._processing;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              (r.prototype.enque = function (e) {\n                this.queue.push(e), this.processing || this.doNextTask();\n              }),\n              (r.prototype.destroy = function () {\n                this.fileReader.abort(), (this._queue = []);\n              }),\n              (r.prototype.doNextTask = function () {\n                0 !== this.size &&\n                  (this.processing ||\n                    ((this._processing = !0),\n                    this.fileReader.readAsArrayBuffer(this.queue.shift())));\n              }),\n              r\n            );\n          })(r.EventEmitter);\n        exports.EncodingQueue = n;\n      },\n      { eventemitter3: \"JJlS\", \"./logger\": \"WOs9\" },\n    ],\n    GBTQ: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__extends) ||\n            (function () {\n              var e = function (t, n) {\n                return (e =\n                  Object.setPrototypeOf ||\n                  ({ __proto__: [] } instanceof Array &&\n                    function (e, t) {\n                      e.__proto__ = t;\n                    }) ||\n                  function (e, t) {\n                    for (var n in t)\n                      Object.prototype.hasOwnProperty.call(t, n) &&\n                        (e[n] = t[n]);\n                  })(t, n);\n              };\n              return function (t, n) {\n                if (\"function\" != typeof n && null !== n)\n                  throw new TypeError(\n                    \"Class extends value \" +\n                      String(n) +\n                      \" is not a constructor or null\"\n                  );\n                function i() {\n                  this.constructor = t;\n                }\n                e(t, n),\n                  (t.prototype =\n                    null === n\n                      ? Object.create(n)\n                      : ((i.prototype = n.prototype), new i()));\n              };\n            })(),\n          t =\n            (this && this.__values) ||\n            function (e) {\n              var t = \"function\" == typeof Symbol && Symbol.iterator,\n                n = t && e[t],\n                i = 0;\n              if (n) return n.call(e);\n              if (e && \"number\" == typeof e.length)\n                return {\n                  next: function () {\n                    return (\n                      e && i >= e.length && (e = void 0),\n                      { value: e && e[i++], done: !e }\n                    );\n                  },\n                };\n              throw new TypeError(\n                t\n                  ? \"Object is not iterable.\"\n                  : \"Symbol.iterator is not defined.\"\n              );\n            },\n          n =\n            (this && this.__importDefault) ||\n            function (e) {\n              return e && e.__esModule ? e : { default: e };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.DataConnection = void 0);\n        var i = require(\"./util\"),\n          o = n(require(\"./logger\")),\n          r = require(\"./negotiator\"),\n          a = require(\"./enums\"),\n          s = require(\"./baseconnection\"),\n          u = require(\"./encodingQueue\"),\n          l = (function (n) {\n            function s(e, t, l) {\n              var f = n.call(this, e, t, l) || this;\n              return (\n                (f.stringify = JSON.stringify),\n                (f.parse = JSON.parse),\n                (f._buffer = []),\n                (f._bufferSize = 0),\n                (f._buffering = !1),\n                (f._chunkedData = {}),\n                (f._encodingQueue = new u.EncodingQueue()),\n                (f.connectionId =\n                  f.options.connectionId || s.ID_PREFIX + i.util.randomToken()),\n                (f.label = f.options.label || f.connectionId),\n                (f.serialization =\n                  f.options.serialization || a.SerializationType.Binary),\n                (f.reliable = !!f.options.reliable),\n                f._encodingQueue.on(\"done\", function (e) {\n                  f._bufferedSend(e);\n                }),\n                f._encodingQueue.on(\"error\", function () {\n                  o.default.error(\n                    \"DC#\" +\n                      f.connectionId +\n                      \": Error occured in encoding from blob to arraybuffer, close DC\"\n                  ),\n                    f.close();\n                }),\n                (f._negotiator = new r.Negotiator(f)),\n                f._negotiator.startConnection(\n                  f.options._payload || { originator: !0 }\n                ),\n                f\n              );\n            }\n            return (\n              e(s, n),\n              Object.defineProperty(s.prototype, \"type\", {\n                get: function () {\n                  return a.ConnectionType.Data;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(s.prototype, \"dataChannel\", {\n                get: function () {\n                  return this._dc;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(s.prototype, \"bufferSize\", {\n                get: function () {\n                  return this._bufferSize;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              (s.prototype.initialize = function (e) {\n                (this._dc = e), this._configureDataChannel();\n              }),\n              (s.prototype._configureDataChannel = function () {\n                var e = this;\n                (i.util.supports.binaryBlob && !i.util.supports.reliable) ||\n                  (this.dataChannel.binaryType = \"arraybuffer\"),\n                  (this.dataChannel.onopen = function () {\n                    o.default.log(\n                      \"DC#\" + e.connectionId + \" dc connection success\"\n                    ),\n                      (e._open = !0),\n                      e.emit(a.ConnectionEventType.Open);\n                  }),\n                  (this.dataChannel.onmessage = function (t) {\n                    o.default.log(\n                      \"DC#\" + e.connectionId + \" dc onmessage:\",\n                      t.data\n                    ),\n                      e._handleDataMessage(t);\n                  }),\n                  (this.dataChannel.onclose = function () {\n                    o.default.log(\n                      \"DC#\" + e.connectionId + \" dc closed for:\",\n                      e.peer\n                    ),\n                      e.close();\n                  });\n              }),\n              (s.prototype._handleDataMessage = function (e) {\n                var t = this,\n                  o = e.data,\n                  r = o.constructor,\n                  s = o;\n                if (\n                  this.serialization === a.SerializationType.Binary ||\n                  this.serialization === a.SerializationType.BinaryUTF8\n                ) {\n                  if (r === Blob)\n                    return void i.util.blobToArrayBuffer(o, function (e) {\n                      var n = i.util.unpack(e);\n                      t.emit(a.ConnectionEventType.Data, n);\n                    });\n                  if (r === ArrayBuffer) s = i.util.unpack(o);\n                  else if (r === String) {\n                    var u = i.util.binaryStringToArrayBuffer(o);\n                    s = i.util.unpack(u);\n                  }\n                } else\n                  this.serialization === a.SerializationType.JSON &&\n                    (s = this.parse(o));\n                if (s === null) {\n                  console.warn(\"peerjs bug handling null message. send(null) was called, which should be valid JSON but peerjs doesn't like it.\");\n                } else {\n                  s.__peerData\n                    ? this._handleChunk(s)\n                    : n.prototype.emit.call(\n                        this,\n                        a.ConnectionEventType.Data,\n                        s\n                      );\n                }\n              }),\n              (s.prototype._handleChunk = function (e) {\n                var t = e.__peerData,\n                  n = this._chunkedData[t] || {\n                    data: [],\n                    count: 0,\n                    total: e.total,\n                  };\n                if (\n                  ((n.data[e.n] = e.data),\n                  n.count++,\n                  (this._chunkedData[t] = n),\n                  n.total === n.count)\n                ) {\n                  delete this._chunkedData[t];\n                  var i = new Blob(n.data);\n                  this._handleDataMessage({ data: i });\n                }\n              }),\n              (s.prototype.close = function () {\n                (this._buffer = []),\n                  (this._bufferSize = 0),\n                  (this._chunkedData = {}),\n                  this._negotiator &&\n                    (this._negotiator.cleanup(), (this._negotiator = null)),\n                  this.provider &&\n                    (this.provider._removeConnection(this),\n                    (this.provider = null)),\n                  this.dataChannel &&\n                    ((this.dataChannel.onopen = null),\n                    (this.dataChannel.onmessage = null),\n                    (this.dataChannel.onclose = null),\n                    (this._dc = null)),\n                  this._encodingQueue &&\n                    (this._encodingQueue.destroy(),\n                    this._encodingQueue.removeAllListeners(),\n                    (this._encodingQueue = null)),\n                  this.open &&\n                    ((this._open = !1),\n                    n.prototype.emit.call(this, a.ConnectionEventType.Close));\n              }),\n              (s.prototype.send = function (e, t) {\n                if (this.open)\n                  if (this.serialization === a.SerializationType.JSON)\n                    this._bufferedSend(this.stringify(e));\n                  else if (\n                    this.serialization === a.SerializationType.Binary ||\n                    this.serialization === a.SerializationType.BinaryUTF8\n                  ) {\n                    var o = i.util.pack(e);\n                    if (!t && o.size > i.util.chunkedMTU)\n                      return void this._sendChunks(o);\n                    i.util.supports.binaryBlob\n                      ? this._bufferedSend(o)\n                      : this._encodingQueue.enque(o);\n                  } else this._bufferedSend(e);\n                else\n                  n.prototype.emit.call(\n                    this,\n                    a.ConnectionEventType.Error,\n                    new Error(\n                      \"Connection is not open. You should listen for the `open` event before sending messages.\"\n                    )\n                  );\n              }),\n              (s.prototype._bufferedSend = function (e) {\n                (!this._buffering && this._trySend(e)) ||\n                  (this._buffer.push(e),\n                  (this._bufferSize = this._buffer.length));\n              }),\n              (s.prototype._trySend = function (e) {\n                var t = this;\n                if (!this.open) return !1;\n                if (this.dataChannel.bufferedAmount > s.MAX_BUFFERED_AMOUNT)\n                  return (\n                    (this._buffering = !0),\n                    setTimeout(function () {\n                      (t._buffering = !1), t._tryBuffer();\n                    }, 50),\n                    !1\n                  );\n                try {\n                  this.dataChannel.send(e);\n                } catch (n) {\n                  return (\n                    o.default.error(\n                      \"DC#:\" + this.connectionId + \" Error when sending:\",\n                      n\n                    ),\n                    (this._buffering = !0),\n                    this.close(),\n                    !1\n                  );\n                }\n                return !0;\n              }),\n              (s.prototype._tryBuffer = function () {\n                if (this.open && 0 !== this._buffer.length) {\n                  var e = this._buffer[0];\n                  this._trySend(e) &&\n                    (this._buffer.shift(),\n                    (this._bufferSize = this._buffer.length),\n                    this._tryBuffer());\n                }\n              }),\n              (s.prototype._sendChunks = function (e) {\n                var n,\n                  r,\n                  a = i.util.chunk(e);\n                o.default.log(\n                  \"DC#\" +\n                    this.connectionId +\n                    \" Try to send \" +\n                    a.length +\n                    \" chunks...\"\n                );\n                try {\n                  for (var s = t(a), u = s.next(); !u.done; u = s.next()) {\n                    var l = u.value;\n                    this.send(l, !0);\n                  }\n                } catch (f) {\n                  n = { error: f };\n                } finally {\n                  try {\n                    u && !u.done && (r = s.return) && r.call(s);\n                  } finally {\n                    if (n) throw n.error;\n                  }\n                }\n              }),\n              (s.prototype.handleMessage = function (e) {\n                var t = e.payload;\n                switch (e.type) {\n                  case a.ServerMessageType.Answer:\n                    this._negotiator.handleSDP(e.type, t.sdp);\n                    break;\n                  case a.ServerMessageType.Candidate:\n                    this._negotiator.handleCandidate(t.candidate);\n                    break;\n                  default:\n                    o.default.warn(\n                      \"Unrecognized message type:\",\n                      e.type,\n                      \"from peer:\",\n                      this.peer\n                    );\n                }\n              }),\n              (s.ID_PREFIX = \"dc_\"),\n              (s.MAX_BUFFERED_AMOUNT = 8388608),\n              s\n            );\n          })(s.BaseConnection);\n        exports.DataConnection = l;\n      },\n      {\n        \"./util\": \"BHXf\",\n        \"./logger\": \"WOs9\",\n        \"./negotiator\": \"HCdX\",\n        \"./enums\": \"ZRYf\",\n        \"./baseconnection\": \"tQFK\",\n        \"./encodingQueue\": \"GGp6\",\n      },\n    ],\n    in7L: [\n      function (require, module, exports) {\n        \"use strict\";\n        var t =\n            (this && this.__awaiter) ||\n            function (t, e, r, o) {\n              return new (r || (r = Promise))(function (n, s) {\n                function i(t) {\n                  try {\n                    a(o.next(t));\n                  } catch (e) {\n                    s(e);\n                  }\n                }\n                function u(t) {\n                  try {\n                    a(o.throw(t));\n                  } catch (e) {\n                    s(e);\n                  }\n                }\n                function a(t) {\n                  var e;\n                  t.done\n                    ? n(t.value)\n                    : ((e = t.value),\n                      e instanceof r\n                        ? e\n                        : new r(function (t) {\n                            t(e);\n                          })).then(i, u);\n                }\n                a((o = o.apply(t, e || [])).next());\n              });\n            },\n          e =\n            (this && this.__generator) ||\n            function (t, e) {\n              var r,\n                o,\n                n,\n                s,\n                i = {\n                  label: 0,\n                  sent: function () {\n                    if (1 & n[0]) throw n[1];\n                    return n[1];\n                  },\n                  trys: [],\n                  ops: [],\n                };\n              return (\n                (s = { next: u(0), throw: u(1), return: u(2) }),\n                \"function\" == typeof Symbol &&\n                  (s[Symbol.iterator] = function () {\n                    return this;\n                  }),\n                s\n              );\n              function u(s) {\n                return function (u) {\n                  return (function (s) {\n                    if (r)\n                      throw new TypeError(\"Generator is already executing.\");\n                    for (; i; )\n                      try {\n                        if (\n                          ((r = 1),\n                          o &&\n                            (n =\n                              2 & s[0]\n                                ? o.return\n                                : s[0]\n                                ? o.throw || ((n = o.return) && n.call(o), 0)\n                                : o.next) &&\n                            !(n = n.call(o, s[1])).done)\n                        )\n                          return n;\n                        switch (\n                          ((o = 0), n && (s = [2 & s[0], n.value]), s[0])\n                        ) {\n                          case 0:\n                          case 1:\n                            n = s;\n                            break;\n                          case 4:\n                            return i.label++, { value: s[1], done: !1 };\n                          case 5:\n                            i.label++, (o = s[1]), (s = [0]);\n                            continue;\n                          case 7:\n                            (s = i.ops.pop()), i.trys.pop();\n                            continue;\n                          default:\n                            if (\n                              !(n =\n                                (n = i.trys).length > 0 && n[n.length - 1]) &&\n                              (6 === s[0] || 2 === s[0])\n                            ) {\n                              i = 0;\n                              continue;\n                            }\n                            if (\n                              3 === s[0] &&\n                              (!n || (s[1] > n[0] && s[1] < n[3]))\n                            ) {\n                              i.label = s[1];\n                              break;\n                            }\n                            if (6 === s[0] && i.label < n[1]) {\n                              (i.label = n[1]), (n = s);\n                              break;\n                            }\n                            if (n && i.label < n[2]) {\n                              (i.label = n[2]), i.ops.push(s);\n                              break;\n                            }\n                            n[2] && i.ops.pop(), i.trys.pop();\n                            continue;\n                        }\n                        s = e.call(t, i);\n                      } catch (u) {\n                        (s = [6, u]), (o = 0);\n                      } finally {\n                        r = n = 0;\n                      }\n                    if (5 & s[0]) throw s[1];\n                    return { value: s[0] ? s[1] : void 0, done: !0 };\n                  })([s, u]);\n                };\n              }\n            },\n          r =\n            (this && this.__importDefault) ||\n            function (t) {\n              return t && t.__esModule ? t : { default: t };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.API = void 0);\n        var o = require(\"./util\"),\n          n = r(require(\"./logger\")),\n          s = (function () {\n            function r(t) {\n              this._options = t;\n            }\n            return (\n              (r.prototype._buildUrl = function (t) {\n                var e =\n                  (this._options.secure ? \"https://\" : \"http://\") +\n                  this._options.host +\n                  \":\" +\n                  this._options.port +\n                  this._options.path +\n                  this._options.key +\n                  \"/\" +\n                  t;\n                return (e += \"?ts=\" + new Date().getTime() + Math.random());\n              }),\n              (r.prototype.retrieveId = function () {\n                return t(this, void 0, Promise, function () {\n                  var t, r, s, i;\n                  return e(this, function (e) {\n                    switch (e.label) {\n                      case 0:\n                        (t = this._buildUrl(\"id\")), (e.label = 1);\n                      case 1:\n                        return e.trys.push([1, 3, , 4]), [4, fetch(t)];\n                      case 2:\n                        if (200 !== (r = e.sent()).status)\n                          throw new Error(\"Error. Status:\" + r.status);\n                        return [2, r.text()];\n                      case 3:\n                        throw (\n                          ((s = e.sent()),\n                          n.default.error(\"Error retrieving ID\", s),\n                          (i = \"\"),\n                          \"/\" === this._options.path &&\n                            this._options.host !== o.util.CLOUD_HOST &&\n                            (i =\n                              \" If you passed in a `path` to your self-hosted PeerServer, you'll also need to pass in that same path when creating a new Peer.\"),\n                          new Error(\"Could not get an ID from the server.\" + i))\n                        );\n                      case 4:\n                        return [2];\n                    }\n                  });\n                });\n              }),\n              (r.prototype.listAllPeers = function () {\n                return t(this, void 0, Promise, function () {\n                  var t, r, s, i;\n                  return e(this, function (e) {\n                    switch (e.label) {\n                      case 0:\n                        (t = this._buildUrl(\"peers\")), (e.label = 1);\n                      case 1:\n                        return e.trys.push([1, 3, , 4]), [4, fetch(t)];\n                      case 2:\n                        if (200 !== (r = e.sent()).status) {\n                          if (401 === r.status)\n                            throw (\n                              ((s = \"\"),\n                              (s =\n                                this._options.host === o.util.CLOUD_HOST\n                                  ? \"It looks like you're using the cloud server. You can email team@peerjs.com to enable peer listing for your API key.\"\n                                  : \"You need to enable `allow_discovery` on your self-hosted PeerServer to use this feature.\"),\n                              new Error(\n                                \"It doesn't look like you have permission to list peers IDs. \" +\n                                  s\n                              ))\n                            );\n                          throw new Error(\"Error. Status:\" + r.status);\n                        }\n                        return [2, r.json()];\n                      case 3:\n                        throw (\n                          ((i = e.sent()),\n                          n.default.error(\"Error retrieving list peers\", i),\n                          new Error(\n                            \"Could not get list peers from the server.\" + i\n                          ))\n                        );\n                      case 4:\n                        return [2];\n                    }\n                  });\n                });\n              }),\n              r\n            );\n          })();\n        exports.API = s;\n      },\n      { \"./util\": \"BHXf\", \"./logger\": \"WOs9\" },\n    ],\n    Hxpd: [\n      function (require, module, exports) {\n        \"use strict\";\n        var e =\n            (this && this.__extends) ||\n            (function () {\n              var e = function (t, n) {\n                return (e =\n                  Object.setPrototypeOf ||\n                  ({ __proto__: [] } instanceof Array &&\n                    function (e, t) {\n                      e.__proto__ = t;\n                    }) ||\n                  function (e, t) {\n                    for (var n in t)\n                      Object.prototype.hasOwnProperty.call(t, n) &&\n                        (e[n] = t[n]);\n                  })(t, n);\n              };\n              return function (t, n) {\n                if (\"function\" != typeof n && null !== n)\n                  throw new TypeError(\n                    \"Class extends value \" +\n                      String(n) +\n                      \" is not a constructor or null\"\n                  );\n                function r() {\n                  this.constructor = t;\n                }\n                e(t, n),\n                  (t.prototype =\n                    null === n\n                      ? Object.create(n)\n                      : ((r.prototype = n.prototype), new r()));\n              };\n            })(),\n          t =\n            (this && this.__assign) ||\n            function () {\n              return (t =\n                Object.assign ||\n                function (e) {\n                  for (var t, n = 1, r = arguments.length; n < r; n++)\n                    for (var o in (t = arguments[n]))\n                      Object.prototype.hasOwnProperty.call(t, o) &&\n                        (e[o] = t[o]);\n                  return e;\n                }).apply(this, arguments);\n            },\n          n =\n            (this && this.__values) ||\n            function (e) {\n              var t = \"function\" == typeof Symbol && Symbol.iterator,\n                n = t && e[t],\n                r = 0;\n              if (n) return n.call(e);\n              if (e && \"number\" == typeof e.length)\n                return {\n                  next: function () {\n                    return (\n                      e && r >= e.length && (e = void 0),\n                      { value: e && e[r++], done: !e }\n                    );\n                  },\n                };\n              throw new TypeError(\n                t\n                  ? \"Object is not iterable.\"\n                  : \"Symbol.iterator is not defined.\"\n              );\n            },\n          r =\n            (this && this.__read) ||\n            function (e, t) {\n              var n = \"function\" == typeof Symbol && e[Symbol.iterator];\n              if (!n) return e;\n              var r,\n                o,\n                i = n.call(e),\n                s = [];\n              try {\n                for (; (void 0 === t || t-- > 0) && !(r = i.next()).done; )\n                  s.push(r.value);\n              } catch (a) {\n                o = { error: a };\n              } finally {\n                try {\n                  r && !r.done && (n = i.return) && n.call(i);\n                } finally {\n                  if (o) throw o.error;\n                }\n              }\n              return s;\n            },\n          o =\n            (this && this.__importDefault) ||\n            function (e) {\n              return e && e.__esModule ? e : { default: e };\n            };\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.Peer = void 0);\n        var i = require(\"eventemitter3\"),\n          s = require(\"./util\"),\n          a = o(require(\"./logger\")),\n          c = require(\"./socket\"),\n          l = require(\"./mediaconnection\"),\n          u = require(\"./dataconnection\"),\n          d = require(\"./enums\"),\n          p = require(\"./api\"),\n          h = (function () {\n            return function () {};\n          })(),\n          f = (function (o) {\n            function i(e, n) {\n              var r,\n                c = o.call(this) || this;\n              return (\n                (c._id = null),\n                (c._lastServerId = null),\n                (c._destroyed = !1),\n                (c._disconnected = !1),\n                (c._open = !1),\n                (c._connections = new Map()),\n                (c._lostMessages = new Map()),\n                e && e.constructor == Object\n                  ? (n = e)\n                  : e && (r = e.toString()),\n                (n = t(\n                  {\n                    debug: 0,\n                    host: s.util.CLOUD_HOST,\n                    port: s.util.CLOUD_PORT,\n                    path: \"/\",\n                    key: i.DEFAULT_KEY,\n                    token: s.util.randomToken(),\n                    config: s.util.defaultConfig,\n                  },\n                  n\n                )),\n                (c._options = n),\n                \"/\" === c._options.host &&\n                  (c._options.host = window.location.hostname),\n                c._options.path &&\n                  (\"/\" !== c._options.path[0] &&\n                    (c._options.path = \"/\" + c._options.path),\n                  \"/\" !== c._options.path[c._options.path.length - 1] &&\n                    (c._options.path += \"/\")),\n                void 0 === c._options.secure &&\n                c._options.host !== s.util.CLOUD_HOST\n                  ? (c._options.secure = s.util.isSecure())\n                  : c._options.host == s.util.CLOUD_HOST &&\n                    (c._options.secure = !0),\n                c._options.logFunction &&\n                  a.default.setLogFunction(c._options.logFunction),\n                (a.default.logLevel = c._options.debug || 0),\n                (c._api = new p.API(n)),\n                (c._socket = c._createServerConnection()),\n                s.util.supports.audioVideo || s.util.supports.data\n                  ? r && !s.util.validateId(r)\n                    ? (c._delayedAbort(\n                        d.PeerErrorType.InvalidID,\n                        'ID \"' + r + '\" is invalid'\n                      ),\n                      c)\n                    : (r\n                        ? c._initialize(r)\n                        : c._api\n                            .retrieveId()\n                            .then(function (e) {\n                              return c._initialize(e);\n                            })\n                            .catch(function (e) {\n                              return c._abort(d.PeerErrorType.ServerError, e);\n                            }),\n                      c)\n                  : (c._delayedAbort(\n                      d.PeerErrorType.BrowserIncompatible,\n                      \"The current browser does not support WebRTC\"\n                    ),\n                    c)\n              );\n            }\n            return (\n              e(i, o),\n              Object.defineProperty(i.prototype, \"id\", {\n                get: function () {\n                  return this._id;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(i.prototype, \"options\", {\n                get: function () {\n                  return this._options;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(i.prototype, \"open\", {\n                get: function () {\n                  return this._open;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(i.prototype, \"socket\", {\n                get: function () {\n                  return this._socket;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(i.prototype, \"connections\", {\n                get: function () {\n                  var e,\n                    t,\n                    o = Object.create(null);\n                  try {\n                    for (\n                      var i = n(this._connections), s = i.next();\n                      !s.done;\n                      s = i.next()\n                    ) {\n                      var a = r(s.value, 2),\n                        c = a[0],\n                        l = a[1];\n                      o[c] = l;\n                    }\n                  } catch (u) {\n                    e = { error: u };\n                  } finally {\n                    try {\n                      s && !s.done && (t = i.return) && t.call(i);\n                    } finally {\n                      if (e) throw e.error;\n                    }\n                  }\n                  return o;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(i.prototype, \"destroyed\", {\n                get: function () {\n                  return this._destroyed;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              Object.defineProperty(i.prototype, \"disconnected\", {\n                get: function () {\n                  return this._disconnected;\n                },\n                enumerable: !1,\n                configurable: !0,\n              }),\n              (i.prototype._createServerConnection = function () {\n                var e = this,\n                  t = new c.Socket(\n                    this._options.secure,\n                    this._options.host,\n                    this._options.port,\n                    this._options.path,\n                    this._options.key,\n                    this._options.pingInterval\n                  );\n                return (\n                  t.on(d.SocketEventType.Message, function (t) {\n                    e._handleMessage(t);\n                  }),\n                  t.on(d.SocketEventType.Error, function (t) {\n                    e._abort(d.PeerErrorType.SocketError, t);\n                  }),\n                  t.on(d.SocketEventType.Disconnected, function () {\n                    e.disconnected ||\n                      (e.emitError(\n                        d.PeerErrorType.Network,\n                        \"Lost connection to server.\"\n                      ),\n                      e.disconnect());\n                  }),\n                  t.on(d.SocketEventType.Close, function () {\n                    e.disconnected ||\n                      e._abort(\n                        d.PeerErrorType.SocketClosed,\n                        \"Underlying socket is already closed.\"\n                      );\n                  }),\n                  t\n                );\n              }),\n              (i.prototype._initialize = function (e) {\n                (this._id = e), this.socket.start(e, this._options.token);\n              }),\n              (i.prototype._handleMessage = function (e) {\n                var t,\n                  r,\n                  o = e.type,\n                  i = e.payload,\n                  s = e.src;\n                switch (o) {\n                  case d.ServerMessageType.Open:\n                    (this._lastServerId = this.id),\n                      (this._open = !0),\n                      this.emit(d.PeerEventType.Open, this.id);\n                    break;\n                  case d.ServerMessageType.Error:\n                    this._abort(d.PeerErrorType.ServerError, i.msg);\n                    break;\n                  case d.ServerMessageType.IdTaken:\n                    this._abort(\n                      d.PeerErrorType.UnavailableID,\n                      'ID \"' + this.id + '\" is taken'\n                    );\n                    break;\n                  case d.ServerMessageType.InvalidKey:\n                    this._abort(\n                      d.PeerErrorType.InvalidKey,\n                      'API KEY \"' + this._options.key + '\" is invalid'\n                    );\n                    break;\n                  case d.ServerMessageType.Leave:\n                    a.default.log(\"Received leave message from \" + s),\n                      this._cleanupPeer(s),\n                      this._connections.delete(s);\n                    break;\n                  case d.ServerMessageType.Expire:\n                    this.emitError(\n                      d.PeerErrorType.PeerUnavailable,\n                      \"Could not connect to peer \" + s\n                    );\n                    break;\n                  case d.ServerMessageType.Offer:\n                    var c = i.connectionId;\n                    if (\n                      ((_ = this.getConnection(s, c)) &&\n                        (_.close(),\n                        a.default.warn(\n                          \"Offer received for existing Connection ID:\" + c\n                        )),\n                      i.type === d.ConnectionType.Media)\n                    )\n                      (_ = new l.MediaConnection(s, this, {\n                        connectionId: c,\n                        _payload: i,\n                        metadata: i.metadata,\n                      })),\n                        this._addConnection(s, _),\n                        this.emit(d.PeerEventType.Call, _);\n                    else {\n                      if (i.type !== d.ConnectionType.Data)\n                        return void a.default.warn(\n                          \"Received malformed connection type:\" + i.type\n                        );\n                      (_ = new u.DataConnection(s, this, {\n                        connectionId: c,\n                        _payload: i,\n                        metadata: i.metadata,\n                        label: i.label,\n                        serialization: i.serialization,\n                        reliable: i.reliable,\n                      })),\n                        this._addConnection(s, _),\n                        this.emit(d.PeerEventType.Connection, _);\n                    }\n                    var p = this._getMessages(c);\n                    try {\n                      for (var h = n(p), f = h.next(); !f.done; f = h.next()) {\n                        var y = f.value;\n                        _.handleMessage(y);\n                      }\n                    } catch (v) {\n                      t = { error: v };\n                    } finally {\n                      try {\n                        f && !f.done && (r = h.return) && r.call(h);\n                      } finally {\n                        if (t) throw t.error;\n                      }\n                    }\n                    break;\n                  default:\n                    if (!i)\n                      return void a.default.warn(\n                        \"You received a malformed message from \" +\n                          s +\n                          \" of type \" +\n                          o\n                      );\n                    var _;\n                    c = i.connectionId;\n                    (_ = this.getConnection(s, c)) && _.peerConnection\n                      ? _.handleMessage(e)\n                      : c\n                      ? this._storeMessage(c, e)\n                      : a.default.warn(\n                          \"You received an unrecognized message:\",\n                          e\n                        );\n                }\n              }),\n              (i.prototype._storeMessage = function (e, t) {\n                this._lostMessages.has(e) || this._lostMessages.set(e, []),\n                  this._lostMessages.get(e).push(t);\n              }),\n              (i.prototype._getMessages = function (e) {\n                var t = this._lostMessages.get(e);\n                return t ? (this._lostMessages.delete(e), t) : [];\n              }),\n              (i.prototype.connect = function (e, t) {\n                if ((void 0 === t && (t = {}), this.disconnected))\n                  return (\n                    a.default.warn(\n                      \"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect, or call reconnect on this peer if you believe its ID to still be available.\"\n                    ),\n                    void this.emitError(\n                      d.PeerErrorType.Disconnected,\n                      \"Cannot connect to new Peer after disconnecting from server.\"\n                    )\n                  );\n                var n = new u.DataConnection(e, this, t);\n                return this._addConnection(e, n), n;\n              }),\n              (i.prototype.call = function (e, t, n) {\n                if ((void 0 === n && (n = {}), this.disconnected))\n                  return (\n                    a.default.warn(\n                      \"You cannot connect to a new Peer because you called .disconnect() on this Peer and ended your connection with the server. You can create a new Peer to reconnect.\"\n                    ),\n                    void this.emitError(\n                      d.PeerErrorType.Disconnected,\n                      \"Cannot connect to new Peer after disconnecting from server.\"\n                    )\n                  );\n                if (t) {\n                  n._stream = t;\n                  var r = new l.MediaConnection(e, this, n);\n                  return this._addConnection(e, r), r;\n                }\n                a.default.error(\n                  \"To call a peer, you must provide a stream from your browser's `getUserMedia`.\"\n                );\n              }),\n              (i.prototype._addConnection = function (e, t) {\n                a.default.log(\n                  \"add connection \" +\n                    t.type +\n                    \":\" +\n                    t.connectionId +\n                    \" to peerId:\" +\n                    e\n                ),\n                  this._connections.has(e) || this._connections.set(e, []),\n                  this._connections.get(e).push(t);\n              }),\n              (i.prototype._removeConnection = function (e) {\n                var t = this._connections.get(e.peer);\n                if (t) {\n                  var n = t.indexOf(e);\n                  -1 !== n && t.splice(n, 1);\n                }\n                this._lostMessages.delete(e.connectionId);\n              }),\n              (i.prototype.getConnection = function (e, t) {\n                var r,\n                  o,\n                  i = this._connections.get(e);\n                if (!i) return null;\n                try {\n                  for (var s = n(i), a = s.next(); !a.done; a = s.next()) {\n                    var c = a.value;\n                    if (c.connectionId === t) return c;\n                  }\n                } catch (l) {\n                  r = { error: l };\n                } finally {\n                  try {\n                    a && !a.done && (o = s.return) && o.call(s);\n                  } finally {\n                    if (r) throw r.error;\n                  }\n                }\n                return null;\n              }),\n              (i.prototype._delayedAbort = function (e, t) {\n                var n = this;\n                setTimeout(function () {\n                  n._abort(e, t);\n                }, 0);\n              }),\n              (i.prototype._abort = function (e, t) {\n                a.default.error(\"Aborting!\"),\n                  this.emitError(e, t),\n                  this._lastServerId ? this.disconnect() : this.destroy();\n              }),\n              (i.prototype.emitError = function (e, t) {\n                var n;\n                a.default.error(\"Error:\", t),\n                  ((n = \"string\" == typeof t ? new Error(t) : t).type = e),\n                  this.emit(d.PeerEventType.Error, n);\n              }),\n              (i.prototype.destroy = function () {\n                this.destroyed ||\n                  (a.default.log(\"Destroy peer with ID:\" + this.id),\n                  this.disconnect(),\n                  this._cleanup(),\n                  (this._destroyed = !0),\n                  this.emit(d.PeerEventType.Close));\n              }),\n              (i.prototype._cleanup = function () {\n                var e, t;\n                try {\n                  for (\n                    var r = n(this._connections.keys()), o = r.next();\n                    !o.done;\n                    o = r.next()\n                  ) {\n                    var i = o.value;\n                    this._cleanupPeer(i), this._connections.delete(i);\n                  }\n                } catch (s) {\n                  e = { error: s };\n                } finally {\n                  try {\n                    o && !o.done && (t = r.return) && t.call(r);\n                  } finally {\n                    if (e) throw e.error;\n                  }\n                }\n                this.socket.removeAllListeners();\n              }),\n              (i.prototype._cleanupPeer = function (e) {\n                var t,\n                  r,\n                  o = this._connections.get(e);\n                if (o)\n                  try {\n                    for (var i = n(o), s = i.next(); !s.done; s = i.next()) {\n                      s.value.close();\n                    }\n                  } catch (a) {\n                    t = { error: a };\n                  } finally {\n                    try {\n                      s && !s.done && (r = i.return) && r.call(i);\n                    } finally {\n                      if (t) throw t.error;\n                    }\n                  }\n              }),\n              (i.prototype.disconnect = function () {\n                if (!this.disconnected) {\n                  var e = this.id;\n                  a.default.log(\"Disconnect peer with ID:\" + e),\n                    (this._disconnected = !0),\n                    (this._open = !1),\n                    this.socket.close(),\n                    (this._lastServerId = e),\n                    (this._id = null),\n                    this.emit(d.PeerEventType.Disconnected, e);\n                }\n              }),\n              (i.prototype.reconnect = function () {\n                if (this.disconnected && !this.destroyed)\n                  a.default.log(\n                    \"Attempting reconnection to server with ID \" +\n                      this._lastServerId\n                  ),\n                    (this._disconnected = !1),\n                    this._initialize(this._lastServerId);\n                else {\n                  if (this.destroyed)\n                    throw new Error(\n                      \"This peer cannot reconnect to the server. It has already been destroyed.\"\n                    );\n                  if (this.disconnected || this.open)\n                    throw new Error(\n                      \"Peer \" +\n                        this.id +\n                        \" cannot reconnect because it is not disconnected from the server!\"\n                    );\n                  a.default.error(\n                    \"In a hurry? We're still trying to make the initial connection!\"\n                  );\n                }\n              }),\n              (i.prototype.listAllPeers = function (e) {\n                var t = this;\n                void 0 === e && (e = function (e) {}),\n                  this._api\n                    .listAllPeers()\n                    .then(function (t) {\n                      return e(t);\n                    })\n                    .catch(function (e) {\n                      return t._abort(d.PeerErrorType.ServerError, e);\n                    });\n              }),\n              (i.DEFAULT_KEY = \"peerjs\"),\n              i\n            );\n          })(i.EventEmitter);\n        exports.Peer = f;\n      },\n      {\n        eventemitter3: \"JJlS\",\n        \"./util\": \"BHXf\",\n        \"./logger\": \"WOs9\",\n        \"./socket\": \"wJlv\",\n        \"./mediaconnection\": \"dbHP\",\n        \"./dataconnection\": \"GBTQ\",\n        \"./enums\": \"ZRYf\",\n        \"./api\": \"in7L\",\n      },\n    ],\n    iTK6: [\n      function (require, module, exports) {\n        \"use strict\";\n        Object.defineProperty(exports, \"__esModule\", { value: !0 }),\n          (exports.peerjs = void 0);\n        var e = require(\"./util\"),\n          r = require(\"./peer\");\n        (exports.peerjs = { Peer: r.Peer, util: e.util }),\n          (exports.default = r.Peer),\n          (window.peerjs = exports.peerjs),\n          (window.Peer = r.Peer);\n      },\n      { \"./util\": \"BHXf\", \"./peer\": \"Hxpd\" },\n    ],\n  },\n  {},\n  [\"iTK6\"],\n  null\n);\n",
  "txMlNpwAbHvFPNkQDo55Rld4kVw6pT45Ai++tG2Zn3U=": "\"use strict\";\n\n/* \n    RzMsg\n\n*/\n\n(class RzMsg extends BMSummaryNode {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"id\", null);\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"content\", null);\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"status\", \"\"); // sent, received\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"sendAction\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Send\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"send\");\n    }\n    \n    {\n      const slot = this.newSlot(\"peer\", null);\n    }\n\n    this.setShouldStoreSubnodes(false);\n    this.setCanDelete(true)\n  }\n\n  init() {\n    super.init();\n    this.setStatus(\"\");\n    this.setIsDebugging(true);\n    return this;\n  }\n\n  title () {\n    return this.id() ? this.id() : \"no message id\"\n  }\n\n  subtitle () {\n    return this.status()\n  }\n\n  // --- sending ---\n\n  send (json) {\n    if (!this.conn()) {\n      console.warn(\"attempt to send to closed connection \", this.peerId());\n      return;\n    }\n    this.conn().send(json);\n  }\n\n  sendThenClose (json) {\n    this.send(json);\n    setTimeout(() => {\n      this.shutdown();\n    }, 500); // without delay, send doesn't occur\n  }\n\n  // --- helpers ---\n\n  peerMessages () {\n    return this.parentNode()\n  }\n\n  peerConn () {\n    return this.peerMessages().peerConn()\n  }\n\n  isConnected () {\n    return this.peerConn().isConnected()\n  }\n\n  // --- sending ---\n\n  send () {\n    this.peerConn().send(this.content()) // content should be valid JSON\n    this.setStatus(\"sent\")\n  }\n\n  sendActionInfo () {\n    return {\n      isEnabled: this.isConnected()\n    }\n  }\n\n  // -- receiving ---\n\n  onReceived () {\n    this.setStatus(\"received\")\n  }\n\n}.initThisClass());\n",
  "F4bkHZBbQQZPkMAWknKZgfTJ0EAT+JMGZfwrr4jC3O4=": "\"use strict\";\n\n/* \n\n    RzMsgs\n\n*/\n\n(class RzMsgs extends BMSummaryNode {\n  \n  initPrototypeSlots () {\n    this.setSubnodeClasses([RzMsg]);\n    this.setTitle(\"peer messages\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  peerConn () {\n    return this.parentNode()\n  }\n\n}.initThisClass());\n",
  "2DPzh1XiJdFvwB5F0X+6VBADXVfxxGiuvZNl0EbArEo=": "\"use strict\";\n\n/* \n    RzPeerConn\n\n    Wrapper for PeerJS DataConnection.\n\n    Delegate messages:\n\n      - onPeerOpen (peerConn)\n      - onPeerClose (peerConn)\n      - onPeerData (peerConn, data)\n      - onPeerError (peerConn)\n    \n*/\n\n(class RzPeerConn extends BMSummaryNode {\n\n  connOptionsDefault () {\n    return {\n      label: undefined,\n      metadata: {},\n      serialization: \"json\",\n      reliable: true, // true ensures no dropped messages \n      /*\n      config: {\n        iceServers: [\n          { url: 'stun:stun1.example.net' },\n          { url: 'turn:turn.example.org', username: 'user', credential: 'pass' }\n        ]\n      } // Allows passing a custom WebRTC configuration. \n      */\n    }\n  }\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"peerId\", null);\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"connOptions\", null);\n      slot.setInspectorPath(\"\");\n      //slot.setLabel(\"connection options\");\n      slot.setShouldStoreSlot(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"JSON Object\");\n    }\n\n\n    {\n      const slot = this.newSlot(\"status\", \"\");\n      slot.setInspectorPath(\"\");\n      //slot.setLabel(\"prompt\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n      //slot.setSummaryFormat(\"value\");\n    }\n\n    // --- error and reconnect ---\n\n    {\n      const slot = this.newSlot(\"error\", null); \n      slot.setShouldStoreSlot(false);\n      slot.setCanEditInspection(false);\n      slot.setSlotType(\"Error\");\n    }\n\n    {\n      const slot = this.newSlot(\"didInitiateConnection\", false); // if we initiated, it's up to us to try to reconnect\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"Boolean\");\n      slot.setCanEditInspection(false);\n    }\n\n    {\n      const slot = this.newSlot(\"shouldAutoReconnect\", true); // (if didInitiateConnection is also true)\n      slot.setShouldStoreSlot(true);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"reconnectAttemptCount\", 0);\n      slot.setShouldStoreSlot(true);\n      slot.setSlotType(\"Number\");\n    }\n\n    // -------------------------\n\n    {\n      const slot = this.newSlot(\"peerMsgs\", null)\n      slot.setFinalInitProto(RzMsgs);\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"RzMsgs\");\n    }\n\n    {\n      const slot = this.newSlot(\"shutdownAction\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Shutdown\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"shutdown\");\n    }\n\n\n\n    {\n      const slot = this.newSlot(\"connectAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Connect\");\n      //slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"connect\");\n    }\n    \n    {\n      const slot = this.newSlot(\"sigServerConn\", null);\n      slot.setSlotType(\"RzSigServerConn\");\n    }\n\n    {\n      const slot = this.newSlot(\"conn\", null);\n      slot.setSlotType(\"DataConnection\"); \n    }\n\n    {\n      const slot = this.newSlot(\"info\", null);\n      slot.setSlotType(\"JSON Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n\n    {\n      const slot = this.newSlot(\"useMessageLog\", false);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    // --- ping pong keepalive ---\n\n    {\n      const slot = this.newSlot(\"useKeepAlive\", false);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"nextPingTimeout\", null);\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"gotPong\", false);\n      slot.setSlotType(\"Boolean\");\n    }\n\n    {\n      const slot = this.newSlot(\"nextPingTimeoutMs\", 30*1000); \n      slot.setSlotType(\"Number\");\n    }\n\n    // --- msg chunking --\n\n    {\n      const slot = this.newSlot(\"chunks\", null); \n      slot.setSlotType(\"Map\");\n    }\n\n\n    this.setShouldStoreSubnodes(false);\n    this.setCanDelete(true)\n  }\n\n  id () {\n    const conn = this.conn();\n    if (conn) {\n      return conn.peer;\n    }\n    return null;\n  }\n\n  shortId () {\n    const id = this.id() \n    return id ? this.id().slice(0,5) + \"...\" : \"null\";\n  }\n\n  debugTypeId () {\n    return this.type() + \" \" + this.shortId();\n  }\n\n  init() {\n    super.init();\n    this.setStatus(\"offline\");\n    this.setIsDebugging(false);\n    this.setConnOptions(this.connOptionsDefault());\n    this.setChunks(new Map());\n    return this;\n  }\n\n  title () {\n    return this.peerId()\n  }\n\n  subtitle () {\n    if (this.isServerConn()) {\n      return \"ourself\"\n    }\n\n    return this.status()\n  }\n\n  setConn (conn) {\n    this._conn = conn;\n    if (conn) {\n      this.setPeerId(conn.peer);\n      this.setupConn();\n      this.watchOnceForNote(\"onDocumentBeforeUnload\");\n    }\n    return this;\n  }\n\n  setupConn  () {\n    const conn = this.conn();\n    conn.on(\"data\", (data) => this.onData(data));\n    conn.on(\"open\", () => this.onOpen());\n    conn.on(\"close\", () => this.onClose());\n    conn.on(\"error\", (error) => this.onError(error));\n    this.setStatus(\"connected to peer\")\n  }\n\n  isServerConn () {\n    if (this.sigServerConn()) {\n      return this.peerId() === this.sigServerConn().peerId()\n    }\n    return false\n  }\n\n  isConnected () {\n    const isConnected = this.isOpen();\n    assert(Type.isBoolean(isConnected));\n    return isConnected;\n  }\n\n  isOpen () {\n    return !Type.isNullOrUndefined(this.conn()) && this.conn().open\n  }\n\n  // --- connection options ---\n\n  // --- label ---\n\n  setConnLabel (s) {\n    // the label we pass when we initiate a connection\n    this.connOptions().label = s\n    return this\n  }\n\n  connLabel () {\n    // the label we pass when we initiate a connection\n    return this.connOptions().label\n  }\n\n  peerLabel () {\n    // the label we receive when we accept a connection\n    return this.conn().label\n  }\n\n  // --- metadata ---\n\n  localMetadata () {\n    // metadata we'll share with peer when we connect\n    return this.connOptions().metadata;\n  }\n\n  remoteMetadata () {\n    // metadata the peer shared with us when we connected\n    if (this.conn()) {\n      return this.conn().metadata;\n    }\n    return null\n  }\n\n  // --------------------------------\n\n  connect () {\n    this.setDidInitiateConnection(true)\n    if (this.isServerConn()) {\n      this.setStatus(\"can't connect to our own peer id\")\n      return this\n    }\n\n    const peer = this.sigServerConn().peer();\n    if (peer) {\n      const conn = peer.connect(this.peerId(), this.connOptions());\n      this.setConn(conn)\n      this.setDidInitiateConnection(true)\n    } else {\n      this.setStatus(\"can't connect to peer when server connection is offline\")\n    }\n  }\n\n  // --- events ---\n\n  onOpen () {\n    this.debugLog(\"onOpen\");\n    this.clearChunks();\n    if (this.useKeepAlive()) {\n      this.sendPing();\n    }\n    this.sendDelegateMessage(\"onPeerOpen\", [this]);\n    this.setReconnectAttemptCount(0);\n  }\n\n  onData (json) { // we set connection transmission format to JSON\n    if (this.useMessageLog()) {\n      const msg = RzMsg.clone().setContent(json)\n      this.peerMsgs().addSubnode(msg)\n    }\n\n    if (json.name === \"RzPeerConnPing\") {\n      this.onPing()\n      return\n    } \n\n    if (json.name === \"RzPeerConnPong\") {\n      this.onPong()\n      return\n    }\n\n    if (json.name === \"RzPeerChunk\") {\n      this.onReceiveChunk(json)\n      return\n    }\n\n    this.sendDelegateMessage(\"onPeerData\", [this, json]);\n  }\n\n  clearChunks () {\n    this.chunks().clear()\n    return this\n  }\n\n  onReceiveChunk (chunk) {\n    /*\n      chunkJson format:\n      {\n        name: \"RzPeerChunk\",\n        index: i, \n        total: total number of chunks,\n        content: aString (part of JSON string)\n      }\n    */\n    const chunks = this.chunks()\n\n    //console.warn(this.type() + \" onReceiveChunk() \", JSON.stringify(chunk));\n\n    chunks.set(chunk.index, chunk.content);\n\n    if (chunks.size === chunk.total) {\n      // Reassemble the original message\n      let s = \"\";\n      for (let i = 0; i < chunk.total; i++) {\n          s += chunks.get(i);\n      }\n\n      const json = JSON.parse(s);\n      this.clearChunks()\n\n      //this.debugLog(this.type() + \" completedChunks \", JSON.stringify(json));\n\n      this.sendDelegateMessage(\"onPeerData\", [this, json]);\n    }\n  }\n\n  onError (error) {\n    this.setError(error)\n    this.debugLog(\"onError:\", error);\n    this.setStatus(\"error: \" + error.message)\n\n    this.sendDelegateMessage(\"onPeerError\", [this, error]);\n\n    const isDisconnect = this.disconnectErrorTypes().includes(error.type);\n    if (isDisconnect) {\n      this.onUnexpectedDisconnect()\n    }\n  }\n\n  disconnectErrorTypes () {\n    return [\n      \"network\",\n      \"peer-unavailable\",\n      \"disconnected\",\n      \"server-error\",\n      \"socket-error\"\n    ];\n  }\n\n  onClose () {\n    this.debugLog(\"onClose\");\n    this.setStatus(\"closed\")\n    this.cancelNextPingTimeout()\n\n    this.sigServerConn().removePeerConnection(this);\n    this.setConn(null);\n\n    this.sendDelegateMessage(\"onPeerClose\", [this]);\n  }\n\n  onUnexpectedDisconnect () {\n    if (this.shouldAutoReconnect() && this.didInitiateConnection()) {\n      const count = this.reconnectAttemptCount();\n      this.setReconnectAttemptCount(this.reconnectAttemptCount() + 1);\n      const delaySeconds = Math.pow(2, count);\n      this.addTimeout(() => { this.reconnect() }, delaySeconds * 1000);\n      console.log(this.typeId() + \" will attempt reconnect in \" + delaySeconds + \" seconds\");\n\n    }\n  }\n\n  reconnect () {\n    console.log(this.typeId() + \" attempting reconnect\")\n    this.connect()\n  }\n\n  onDocumentBeforeUnload (aNote) {\n    console.log(this.typeId() + \" onDocumentBeforeUnload shutdown\")\n    this.shutdown()\n  }\n\n  // --- delegate ---\n\n  sendDelegateMessage (methodName, args = [this]) {\n    const d = this.delegate();\n    if (d) {\n      const m = d[methodName];\n      if (m) {\n        this.debugLog(\"sending delegate message \" + methodName);\n        m.apply(d, args);\n      } else {\n        this.debugLog(\"delegate \" + this.delegate().typeId() + \" missing method \" + methodName);\n      }\n    } else {\n      this.debugLog(\"no delegate\");\n    }\n  }\n\n  // --- sending ---\n\n  maxMessageSize () {\n    const conn = this.conn();\n    if (conn.peerConnection) {\n      const maxSize = conn.peerConnection._sctp.maxMessageSize;\n      return maxSize\n    }\n    // assume default?\n    return 65536; // in bytes\n  }\n\n  send (json) {\n    const conn = this.conn();\n\n    if (!conn) {\n      console.warn(\"attempt to send to closed connection \", this.peerId());\n      return;\n    }\n\n    // chunk message if it's too big\n    const data = JSON.stringify(json);\n    const mSize = data.length;\n    const maxSize = this.maxMessageSize()\n    if (mSize > maxSize) {\n      const s = this.type() + \" send() message size of \" + mSize + \" exceeds max of \" + maxSize;\n      console.warn(s);\n      this.sendDataAsChunks(data);\n      return;\n    }\n\n    conn.send(json);\n  }\n\n  sendDataAsChunks (dataStr) {\n    const wrapperSize = 1024; // safe guess\n    const chunkSize = this.maxMessageSize() - wrapperSize;\n\n    // Calculate the number of chunks\n    const numChunks = Math.ceil(dataStr.length / chunkSize);\n\n    for (let i = 0; i < numChunks; i++) {\n        const chunk = {\n          name: \"RzPeerChunk\",\n          index: i,\n          total: numChunks,\n          content: dataStr.slice(i * chunkSize, (i + 1) * chunkSize)\n        };\n        //console.warn(this.type() + \" sending chunk:\" + JSON.stringify(chunk))\n        this.conn().send(chunk);\n    }\n  }\n\n  sendThenClose (json) {\n    this.send(json);\n    setTimeout(() => {\n      this.shutdown();\n    }, 500); // without delay, send doesn't occur\n  }\n\n  // --- shutdown ---\n\n  disconnect () {\n    this.shutdown();\n  }\n\n  shutdown () {\n    console.warn(this.type() + \" \" + this.shortId() + \" shutdown\");\n    if (this.conn()) { // only close connection if it's still up\n      this.setStatus(\"shutdown\")\n      this.conn().close()\n      this.sigServerConn().removePeerConnection(this);\n      this.setConn(null);\n    }\n  }\n\n  serverIsConnected () {\n    if (this.sigServerConn()) {\n      return this.sigServerConn().isConnected()\n    }\n    return false\n  }\n\n  connectActionInfo () {\n    return {\n      isEnabled: !this.isServerConn() && !this.isOpen() && this.serverIsConnected()\n    }\n  }\n\n  shutdownActionInfo () {\n    return {\n      isEnabled: this.isOpen()\n    }\n  }\n\n  // --- sending ping & receiving pong ---\n\n  sendPing () {\n    if (!this.nextPingTimeout()) {\n      console.log(this.typeId() + \" sendPing\")\n      this.setGotPong(false)\n      this.send({ name: \"RzPeerConnPing\" })\n      this.setupNextPingTimeout()\n    } else {\n      debugger\n    }\n  }\n\n  onPong () {\n    //console.log(this.typeId() + \" onPong\")\n    this.setGotPong(true)\n  }\n\n  // --- ping timeout ---\n\n  setupNextPingTimeout () {\n    this.cancelNextPingTimeout()\n    const po = setTimeout(() => { this.onPingTimeout() }, this.nextPingTimeoutMs());\n    this.setNextPingTimeout(po);\n  }\n\n  cancelNextPingTimeout () {\n    const po = this.nextPingTimeout()\n    if (po) {\n      clearTimeout(po)\n      this.setNextPingTimeout(null)\n    }\n  }\n\n  onPingTimeout () {\n    this.setNextPingTimeout(null)\n    if (this.gotPong()) {\n      this.sendPing()\n    } else {\n      console.log(this.typeId() + \" onPingTimeout shutdown\")\n      this.shutdown()\n    }\n  }\n\n  // --- receiving ping & sending pong ---\n\n  onPing () {\n    //console.log(this.typeId() + \" onPing\")\n    this.sendPong();\n  }\n\n  sendPong () {\n    //console.log(this.typeId() + \" sendPong\")\n    this.send({ name: \"RzPeerConnPong\" })\n  }\n\n}.initThisClass());\n",
  "xlrjYBcS/VTG413o99iEYLIBhtdZ2oMPgmOCgLYmHGw=": "\"use strict\";\n\n/* \n\n    RzPeerConns\n\n*/\n\n(class RzPeerConns extends BMSummaryNode {\n  initPrototypeSlots () {\n    this.setSubnodeClasses([RzPeerConn]);\n    this.setTitle(\"connections to peers\");\n    this.setShouldStore(false);\n    this.setShouldStoreSubnodes(false);\n    this.setNodeCanAddSubnode(false);\n    this.setNodeCanReorderSubnodes(true);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  finalInit() {\n    super.finalInit()\n    assert(this.subnodeCount() === 0); // sanity check\n  }\n\n  sigServerConn () {\n    return this.parentNode()\n  }\n\n  setPeerConClass (aClass) {\n    // assert(aClass.isKindOf(RzPeerConn.thisClass()));\n    this.setSubnodeClasses([aClass])\n    return this\n  }\n\n  peerConnClass () {\n    return this.subnodeClasses().first()\n  }\n\n  addIfAbsentPeerConnForId (id) {\n    this.assertValidSubnodes()\n\n    const match = this.subnodes().detect(sn => sn.peerId() === id)\n    if (match) {\n      return match\n    }\n\n    const pc = this.peerConnClass().clone().setPeerId(id).setSigServerConn(this.sigServerConn())\n    this.addSubnode(pc)\n    return pc\n  }\n\n  assertValidSubnodes () {\n    const invalidMatch = this.subnodes().detect(sn => sn.thisClass().type() !== this.peerConnClass().type())\n    assert(!invalidMatch);\n  }\n\n  addSubnode (aSubnode) {\n    this.assertValidSubnodes()\n    const r = super.addSubnode(aSubnode)\n    this.assertValidSubnodes()\n    return r\n  }\n\n  disconnectAllPeers () {\n    this.subnodes().forEach(sn => sn.disconnect())\n    return this\n  }\n\n}.initThisClass());\n",
  "r/OIH3H7fGP4lDaXAgfImIyvAPxrIa5xdfu6SDFpMz8=": "\"use strict\";\n\n/* \n    RzSigServerConn\n\n    Wrapper for PeerJS Peer object.\n\n*/\n\n(class RzSigServerConn extends BMStorableNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"name\", null);\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"peerIdPrefix\", \"\");\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"our peer id root\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"peerId\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"our peer id\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"status\", null);\n      slot.setInspectorPath(\"\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n      //slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"peer\", null);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(false);\n      slot.setSlotType(\"Peer\");\n    }\n\n    {\n      const slot = this.newSlot(\"isReliable\", true);      \n      slot.setInspectorPath(\"info\")\n      slot.setLabel(\"is reliable\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"key value\")\n    }\n\n    // --- connection prompise ---\n\n    {\n      const slot = this.newSlot(\"connectPromise\", null);\n      slot.setSlotType(\"Promise\");\n    }\n\n    // --- get id retries ---\n\n    {\n      const slot = this.newSlot(\"getIdRetryCount\", 0); \n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"getIdRetryDelayMs\", 100);\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"getIdMaxRetries\", 100);\n      slot.setSlotType(\"Number\"); \n    }\n\n    // --- connect retries ---\n\n    {\n      const slot = this.newSlot(\"connectRetryDelayMs\", 5000);\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"connectRetryCount\", 0);      \n      slot.setInspectorPath(\"info\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"key value\")\n    }\n\n    {\n      const slot = this.newSlot(\"connectMaxRetries\", 3);      \n      slot.setInspectorPath(\"info\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"key value\")\n    }\n\n    // --- ping / pong ---\n\n    {\n      const slot = this.newSlot(\"pingIntervalMs\", 1000);   \n      slot.setInspectorPath(\"info\")\n      slot.setLabel(\"ping interval in ms\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"key value\")\n    }\n\n    {\n      const slot = this.newSlot(\"debug\", false);      \n      slot.setInspectorPath(\"info\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"peerConns\", null)\n      slot.setFinalInitProto(RzPeerConns);\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"RzPeerConns\");\n    }\n\n    {\n      const slot = this.newSlot(\"connectAction\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Connect\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"connect\");\n    }\n\n    {\n      const slot = this.newSlot(\"disconnectAction\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Disconnect\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"disconnect\");\n    }\n\n    {\n      const slot = this.newSlot(\"destroyAction\", null);\n      slot.setCanInspect(true);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Destroy\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"destroy\");\n    }\n\n    {\n      const slot = this.newSlot(\"refreshPeersAction\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Refresh Peers\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"refreshPeers\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setSlotType(\"Error\");\n    }\n\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    this.setIsDebugging(false);\n    this.setCanDelete(true);\n    return this\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.setSubtitle(\"server connection\");\n    this.setPeerId(\"\");\n    this.setStatus(\"unconnected\");\n    this.setCanDelete(true);\n    this.setShouldStore(true);\n  }\n\n  // --- peer connection class ---\n\n  setPeerConnClass (aClass) {\n    this.peerConns().setSubnodeClasses([aClass])\n    return this\n  }\n\n  peerConnClass () {\n    return this.peerConns().subnodeClasses().first()\n  }\n\n  // --- title / subtitle ---\n\n  title () {\n    const id = this.peerId()\n    return id ? id : \"no peer id assigned\"\n  }\n\n  subtitle () {\n    return this.status()\n  }\n\n  // --- connect ---\n\n  isConnected () {\n    const isConnected = !Type.isNullOrUndefined(this.peer()) && !this.peer().disconnected;\n    assert(Type.isBoolean(isConnected));\n    return isConnected;\n  }\n\n  clearConnectPromise () {\n    this.setConnectPromise(null);\n    return this;\n  }\n\n  connectPromise () {\n    if (!this._connectPromise) {\n      this._connectPromise = Promise.clone();\n    }\n    return this._connectPromise \n  }\n\n  connect () {\n    if (!this.isConnected()) {\n      this.setError(null);\n      this.clearConnectPromise();\n      this.setStatus(\"connecting\");\n      this.setGetIdRetryCount(0);\n      this.setConnectRetryCount(0);\n      this.attemptToConnect();\n    }\n    return this.connectPromise();\n  }\n\n  connectActionInfo () {\n    return {\n      isEnabled: !this.isConnected()\n    }\n  }\n\n  // --- disconnect ---\n\n  shutdown () {\n    this.disconnectAllPeers();\n    this.disconnect();\n    return this;\n  }\n\n  disconnect () {\n    if (this.peer()) {\n      this.setStatus(\"disconnecting\")\n      this.peer().disconnect()\n    }\n    return this\n  }\n\n  disconnectAllPeers () {\n    this.peerConns().disconnectAllPeers();\n    return this;\n  }\n\n  disconnectActionInfo () {\n    return {\n      isEnabled: this.isConnected()\n    }\n  }\n\n  // --- destroy ---\n\n  destroy () {\n    if (this.peer()) {\n      this.setStatus(\"destroying\")\n      this.peer().destroy()\n    }\n    return this\n  }\n\n  destroyActionInfo () {\n    return {\n      isEnabled: this.peer() !== null\n    }\n  }\n\n  /*\n  shutdown () {\n    this.peerConnections().valuesArray().forEach((conn) => {\n      conn.shutdown();\n    });\n    return this;\n  }\n  */\n\n  // --- connecting to a peer ----\n\n  sigServerConnections () {\n    return this.parentNode()\n  }\n\n  server () {\n    return this.sigServerConnections().parentNode()\n  }\n\n  /*\n  fullPeerId () {\n    const id = this.peerId()\n    const fullPath = this.server().httpFullPath()\n    return fullPath + \":\" + id\n  }\n  */\n\n  /*\n  peerOptions () {\n    // Deployed peerjs server\n    return {\n        host: \"peerjssignalserver.herokuapp.com\",\n        path: \"/peerjs\",\n        secure: true,\n        port: 443,\n        reliable: true,\n        pingInterval: 1000, // 1 second\n        debug: false\n      }\n  }\n  */\n\n  peerOptions () {\n    const server = this.server();\n    const options = {\n      host: server.host(),\n      path: server.path(),\n      secure: server.isSecure(),\n      port: server.port(),\n      reliable: this.isReliable(),\n      pingInterval: this.pingIntervalMs(),\n      debug: this.debug()\n    };\n    \n    const key = this.server().key().trim();\n    if (key) {\n      options.key = key;\n    }\n\n    return options;\n  }\n\n  setPeer (aPeer) {\n    this._peer = aPeer;\n    return this\n  }\n\n  peer () {\n    return this._peer\n  }\n\n  // --- connect to signaling server ---\n\n  newPeerId () {\n    return this.peerIdPrefix() + \"-\" + RzSigServer.generateRandomPeerId(10)\n  }\n\n  attemptToConnect () {\n    this.debugLog(\"connecting to peerjs signal server: \", JSON.stringify(this.peerOptions(), 2, 2) )\n\n    let requestedPeerId = undefined;\n    if (this.peerIdPrefix().length) {\n      requestedPeerId = this.newPeerId()\n    }\n    const peer = new Peer(requestedPeerId, this.peerOptions()); /* let server assign unique peer id */\n\n    if (peer) {\n      peer.on(\"open\", (id) => this.onOpen(id) );\n      peer.on(\"connection\", (conn) => this.onConnection(conn) );\n      peer.on(\"call\", (call) => this.onCall(call) );\n      peer.on('close', () => this.onClose() );\n      peer.on('disconnected', () => this.onDisconnected() );\n      peer.on(\"error\", (error) => this.onError(error) );\n      this.setPeer(peer);\n    } else {\n      this.setStatus(\"unknown connection error\")\n    }\n    return this;\n  }\n\n  async onOpen (peerId) {\n    this.setPeerId(peerId)\n    //this.debugLog(\"opened with peerId: '\" + peerId + \"'\");\n    this.setStatus(\"connected to server\")\n    //this.refreshPeers()\n    this.sendDelegateMessage(\"onSigServerOpen\", [this]);\n    this.connectPromise().callResolveFunc();\n  }\n\n  // --- incoming peer connections ---\n  \n  addPeerConnection (aPeerConn) {\n    aPeerConn.setSigServerConn(this)\n    this.peerConns().addSubnode(aPeerConn)\n    return this;\n  }\n\n  onClose () {\n    /*\n    Emitted when the peer is destroyed and can no longer accept or create any new connections. \n    At this time, the peer's connections will all be closed.\n    */\n\n    this.setPeerId(\"\") // only if we are having the server assign the id...\n    this.setStatus(\"closed\")\n    this.sendDelegateMessage(\"onSigServerClose\", [this])\n  }\n\n  onDisconnected () {\n    /*\n    Emitted when the peer is disconnected from the signalling server, \n    either manually or because the connection to the signalling server was lost. \n    \n    When a peer is disconnected, its existing connections will stay alive, \n    but the peer cannot accept or create any new connections. \n    \n    You can reconnect to the server by calling peer.reconnect().\n    */\n\n    this.setStatus(\"disconnected\")\n    this.sendDelegateMessage(\"onSigServerDisconnected\", [this])\n  }\n\n  onConnection (conn) {\n    // incoming connection\n\n    const id = conn.peer;\n    this.debugLog(\"incoming connection from: \" + id)\n\n    const peerConn = this.peerConns().addIfAbsentPeerConnForId(id)\n    peerConn.setConn(conn)\n    \n    // better to use onOpenPeerConnection as we can send messages after open\n    this.sendDelegateMessage(\"onPeerConnection\", [peerConn])\n\n    return this\n  }\n\n  onOpenPeerConnection (peerConn) {\n    // sent by a PeerConnection to it's SigServer after it opens\n    // and is ready for messages\n    this.sendDelegateMessage(\"onPeerConnection\", [peerConn])\n  }\n\n  onClosePeerConnection (peerConn) {\n    this.sendDelegateMessage(\"onClosePeerConnection\", [peerConn])\n    this.removePeerConnection(peerConn)\n  }\n\n  removePeerConnection (peerConn) {\n    //if (this.peerConnections().has(pc.id())) {\n      this.sendDelegateMessage(\"onRemovePeerConnection\", [peerConn])\n    //}\n\n    return this\n  }\n\n  // --- error handling ---\n\n  onError (error) {\n    //this.debugLog(\"error \", error);\n    //debugger\n    console.log(\"error: \" + error.message);\n    this.setStatus(error.message);\n    this.setError(error.message);\n\n    const etype =  error.type\n    let errorMethodRoot = etype.split(\"-\").map(s => s.capitalized()).join(\"\") //+ \"Error\";\n    if (!errorMethodRoot.endsWith(\"Error\")) {\n      errorMethodRoot += \"Error\";\n    }\n    const errorMethodName = \"on\" + errorMethodRoot;\n\n    //debugger;\n\n    // send self error message\n    const method = this[errorMethodName]\n    if (method) {\n      method.apply(this, [error])\n    } else {\n      throw new Error(\"missing error handler method '\" + errorMethodName + \"'\")\n    }\n\n    // send delegate error message \n    const delegateErrorMethodName = \"onSignalServer\" + errorMethodRoot;\n    this.sendDelegateMessage(delegateErrorMethodName, [this, error])\n\n    //this.connectPromise().callRejectFunc();\n  }\n\n  // --- error type handlers ---\n\n  onPeerUnavailableError (error) {\n    console.warn(this.typeId() + \" error: \", error)\n  }\n\n  onBrowserIncompatibleError (error) {\n    // ERRORFATAL\n    // The client's browser does not support some or all WebRTC features that you are trying to use.\n  }\n\n  onDisconnectedError (error) {\n    // ERROR\n    // You've already disconnected this peer from the server and can no longer make any new connections on it.\n  }\n\n  onInvalidIdError (error) {\n    // ERRORFATAL\n    // The ID passed into the Peer constructor contains illegal characters.\n  }\n\n  onInvalidKeyError (error) {\n    // ERRORFATAL\n    // The API key passed into the Peer constructor contains illegal characters or is not in the system (cloud server only).\n  }\n\n  onNetworkError (error) {\n    // ERROR\n    // Lost or cannot establish a connection to the signalling server.\n  }\n\n  onPeerUnavailableError (error) {\n    // ERROR\n    // The peer you're trying to connect to does not exist.\n  }\n\n  onSslUnavailableError (error) { \n    // ERRORFATAL\n    // PeerJS is being used securely, but the cloud server does not support SSL. Use a custom SigServer.\n  }\n\n  onServerError (error) {\n    // ERRORFATAL\n    // Unable to reach the server.\n  }\n\n  onSocketError (error) {\n    // ERRORFATAL\n    // An error from the underlying socket.\n  }\n\n  onSocketClosedError (error) {\n    // ERRORFATAL\n    // The underlying socket closed unexpectedly.\n\n    // TODO: retry?\n  }\n\n  onUnavailableIdError (error) {\n    // ERRORSOMETIMES FATAL\n    // The ID passed into the Peer constructor is already taken.\n    // This error is not fatal if your peer has open peer-to-peer connections. \n    // This can happen if you attempt to reconnect a peer that has been disconnected from the server, but its old ID has now been taken.\n    if (this.peerIdPrefix()) {\n      this.retryClosure(() => {\n        debugger;\n        this.attemptToConnect()\n      })\n    }\n  }\n\n  getIdRetryClosure (func) {\n    if (this.getIdRetryCount() < this.getIdMaxRetries()) {\n      this.setGetIdRetryCount(this.getIdRetryCount() + 1);\n      this.addTimeout(() => {\n        console.warn(this.typeId() + \" retry get id\");\n        func();\n      }, this.getIdRetryDelayMs());\n    } else {\n      console.warn(this.typeId() + \" reached max get id retries\");\n    }\n    return this\n  }\n\n  onWebrtcError (error) {\n    // ERROR\n    // Native WebRTC errors.\n  }\n\n  // --- reconnect ---\n\n  attemptToReconnect () {\n\n    if (this.connectRetryCount() < this.connectMaxRetries()) {\n      setTimeout(() => {\n        this.setConnectRetryCount(this.connectRetryCount() + 1);\n        if (!this.isConnected()) {\n          this.setStatus(this.status() + \" retry #\" + this.connectRetryCount()) // + \" in \" + (this.connectRetryDelayMs()/1000) + \" secs\")\n          this.attemptToConnect()\n        } else {\n          this.peer().reconnect(); // TODO: will this call onConnection again?\n        }\n      }, this.connectRetryDelayMs());\n    } else {\n      debugger\n      const warning = \"Reached maximum number of \" + this.maxRetries() + \" retries.\";\n      console.warn(this.type() + \" \" + warning);\n      this.setStatus(warning)\n      // Display a system message here, e.g. by updating the UI\n    }\n  }\n\n  onCall (call) {\n    /*\n\n    // Answer incoming voice call\n    const acceptCall = confirm(\n      `Incoming call. Do you want to accept the call?`\n    );\n\n    if (acceptCall) {\n      call.answer(Microphone.shared().userAudioStream());\n      console.log(\"Answering incoming call from:\", call.peer);\n\n      call.on(\"stream\", (remoteStream) => {\n        handleRemoteStream(remoteStream);\n        updateCalleeVoiceRequestButton(call.peer, call);\n      });\n\n      call.on(\"close\", () => {\n        // Handle call close event\n        console.log(\"Call with peer:\", call.peer, \"has ended\");\n      });\n    } else {\n      console.log(\"Call from\", call.peer, \"rejected\");\n    }\n    */\n  }\n\n  // --- peers ---\n\n  availablePeerIds () {\n    return this.server().availablePeerIds()\n  }\n\n  connectionToPeerId (peerId) {\n    const peerConn = this.peerConnClass().clone().setPeerId(peerId)\n    this.addPeerConnection(peerConn)\n    //peerConn.connect() // caller should call connect() after setting up peerConn\n    return peerConn // the caller should problaby call peerConn.setDelegate(this) and handling it's delegate messages\n  }\n\n  connectToPeerId (peerId) {\n    const peerConn = this.connectionToPeerId(peerId)\n    peerConn.connect()\n    return peerConn // the caller should problaby call peerConn.setDelegate(this) and handling it's delegate messages\n  }\n\n  unconnectedPeerConns () {\n    return this.peerConns().subnodes().select(pc => !pc.isConnected())\n  }\n\n  async refreshPeers () {\n    // NOTE: we want to be able to use custom peerConnClass and we don't want to remove \n    // subnodes on refresh. Maybe we should separate availablePeers from peerConns?\n    \n    /*\n    // compose this for fast lookup - TODO: use subnode index instead of building index\n    const idToPeerMap = new Map();\n    this.peerConns().subnodes().forEach(pc => idToPeerMap.set(pc.peerId(), pc));\n\n    const newPeerIds = await this.server().fetchPeerIds()\n    newPeerIds.sort()\n    newPeerIds.remove(this.peerId())\n\n    const newSubnodes = newPeerIds.map(id => {\n      let pc = idToPeerMap.at(id)\n      if (!pc) {\n        pc = RzPeerConn.clone().setPeerId(id).setSigServerConn(this)\n      }\n      return pc\n    })\n\n    if (!this.subnodes().isEqual(newSubnodes)) {\n      this.peerConns().removeAllSubnodes()\n      this.peerConns().addSubnodes(newSubnodes)\n    }\n\n    // what should we do with connected peers that are no longer in the peer id list?\n    // should we leave them in the list or shut them down?\n    */\n\n    return this\n  }\n\n  // --- delegate ---\n\n  sendDelegateMessage (methodName, args = []) {\n    const d = this.delegate();\n    if (d) {\n      const m = d[methodName];\n      if (m) {\n        m.apply(d, args);\n      }\n    }\n  }\n\n\n}.initThisClass());\n",
  "wfOrvFijT+Hx2HyrOjsg294E9OKPbO9+41alRspPPMY=": "\"use strict\";\n\n/* \n\n    RzSigServerConns \n\n*/\n\n(class RzSigServerConns extends BMSummaryNode {\n  initPrototypeSlots () {\n    this.setSubnodeClasses([RzSigServerConn]);\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"connections to sigserver\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n  finalInit() {\n    super.finalInit()\n    this.setNoteIsSubnodeCount(true);\n    this.removeAllSubnodes();\n  }\n\n  service () {\n    return this.parentNode()\n  }\n\n  connClass () {\n    return this.subnodeClasses().first()\n  }\n\n  /*\n  addWithPeerId (requestedPeerId) {\n    const conn = this.connClass().clone()\n    conn.setPeerId(requestedPeerId)\n    this.addSubnode(conn)\n    return conn\n  }\n  */\n\n}.initThisClass());\n",
  "XyxywfztK1A4+9Bf0tcQ+e5qI3JtXglg0CjuinkOLzU=": "\"use strict\";\n\n/* \n\n    RzPeer\n\n*/\n\n(class RzPeer extends BMStorableNode {\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"peerId\", \"\");      \n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"peer id\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(false)\n      slot.setCanEditInspection(false)\n    }\n\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    this.setIsDebugging(false)\n    this.setCanDelete(false)\n    return this\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setCanDelete(false)\n  }\n\n  title () {\n    return this.peerId()\n  }\n\n  subtitle () {\n    return \"peer\"\n  }\n\n  server () {\n    return this.parentNode().parentNode()\n  }\n\n}.initThisClass());\n",
  "LVrzunuoXY8vnJ8JxwRDPbUlLpzY0tMvctMVY9bJ2+M=": "\"use strict\";\n\n/* \n\n    RzSigServerPeers\n\n*/\n\n(class RzSigServerPeers extends BMSummaryNode {\n  \n  initPrototypeSlots () {\n    this.setTitle(\"peers\");\n    this.setShouldStore(false);\n    this.setShouldStoreSubnodes(false);\n    //this.setSubnodeClasses([RzSigServer]);\n    this.setNodeCanAddSubnode(false);\n    this.setNodeCanReorderSubnodes(false);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n\n  setPeerIdArray (peerIds) {\n    /*\n    const idSet = peerIds.asSet()\n    const subnodesToRemove = this.subnodes().shallowCopy().filter(sn => !idSet.has(sn.peerId()))\n    this.removeSubnodes(subnodesToRemove)\n    */\n\n    // TODO: switch to merge\n    this.removeAllSubnodes()\n    peerIds.sort()\n    peerIds.forEach(peerId => {\n      const rzPeer = RzPeer.clone().setPeerId(peerId)\n      this.addSubnode(rzPeer)\n    })\n    return this\n  }\n\n}.initThisClass());\n",
  "0r3Rt132C6tjRkYs65SwVSDihKlk8dmBYcScftKFYzI=": "\"use strict\";\n\n/* \n    RzSigServer\n\n*/\n\n(class RzSigServer extends BMStorableNode {\n\n  // --- generate a valid peer id ---\n\n  static generateRandomPeerId (length = 10) {\n    let result = '';\n    const characters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const charactersLength = characters.length;\n\n    for (var i = 0; i < length; i++) {\n        result += characters.charAt(Math.floor(Math.random() * charactersLength));\n    }\n\n    return result;\n  }\n\n  // --- prototype ---\n\n  initPrototypeSlots () {\n\n    /*\n    {\n      host: \"peerjssignalserver.herokuapp.com\",\n      path: \"/peerjs\",\n      secure: true,\n      port: 443,\n      reliable: true,\n      pingInterval: 1000, // 1 second\n      debug: false\n    }\n    */\n\n    {\n      const slot = this.newSlot(\"host\", \"peerjssignalserver.herokuapp.com\");      \n      slot.setInspectorPath(\"info\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"path\", \"/peerjs\");      \n      slot.setInspectorPath(\"info\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"port\", 443);      \n      slot.setInspectorPath(\"info\");\n      slot.setLabel(\"port\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(true);\n      slot.setSummaryFormat(\"value\");\n    }\n\n    /*\n    {\n      const slot = this.newSlot(\"webSocketPort\", 443);      \n      slot.setInspectorPath(\"info\")\n      slot.setLabel(\"WebSocket Port\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n    */\n\n    {\n      const slot = this.newSlot(\"key\", \"\");      \n      slot.setInspectorPath(\"info\")\n      //slot.setLabel(\"prompt\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"none\")\n    }\n\n    {\n      const slot = this.newSlot(\"isSecure\", true);      \n      slot.setInspectorPath(\"info\")\n      slot.setLabel(\"is secure\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"key value\")\n    }\n\n    {\n      const slot = this.newSlot(\"status\", null);      \n      //slot.setInspectorPath(\"info\")\n      slot.setLabel(\"Status\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(false)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n    // -------------------\n\n    {\n      const slot = this.newSlot(\"peers\", null)\n      slot.setFinalInitProto(RzSigServerPeers);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"RzSigServerPeers\");\n    }\n\n    {\n      const slot = this.newSlot(\"sigServerConns\", null)\n      slot.setFinalInitProto(RzSigServerConns);\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"RzSigServerConns\");\n    }\n\n    {\n      const slot = this.newSlot(\"refreshAction\", null);\n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"Refresh Peers\");\n      //slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setActionMethodName(\"refreshPeers\");\n    }\n\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    //this.setPeerConnections(new Map());\n    this.setIsDebugging(true)\n    this.setCanDelete(true)\n    return this\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setCanDelete(true)\n    //this.refreshPeers()\n  }\n\n  static fullPathForDict (dict) {\n    return dict.host + \":\" + dict.port + dict.path\n  }\n\n  /*\n  httpFullPath () {\n    return this.host() + \":\" + this.port() + this.path() // path always begins with slash?\n  }\n\n  webSocketFullPath () {\n    return this.host() + \":\" + this.webSocketPort() + this.path() // path always begins with slash?\n  }\n  */\n\n  fullPath () {\n    return this.host() + \":\" + this.port() + this.path() // path always begins with slash?\n  }\n\n  dict () {\n    const dict = {};\n    dict.host = this.host();\n    dict.path = this.path();\n    dict.isSecure = this.isSecure();\n    dict.port = this.port();\n    //dict.webSocketPort = this.webSocketPort();\n    return dict;\n  }\n\n  setDict (dict) {\n    /*\n    sample dict:\n\n    {\n      host: \"peerjssignalserver.herokuapp.com\",\n      path: \"/peerjs\",\n      isSecure: true,\n      port: 443,\n      webSocketPort: 443,\n      reliable: true,\n      pingInterval: 1000, // 1 second TODO: change to pingIntervalMs\n      debug: false\n    }\n    */\n\n    assert(Type.isString(dict.host))\n    this.setHost(dict.host)\n\n    assert(Type.isString(dict.path))\n    this.setPath(dict.path)\n\n    assert(Type.isBoolean(dict.isSecure))\n    this.setIsSecure(dict.isSecure === true)\n\n    assert(Type.isInteger(dict.port))\n    this.setPort(dict.port)\n\n    //assert(Type.isInteger(dict.webSocketPort))\n    //this.setPort(dict.webSocketPort)\n\n    // optional server connection defaults for this server\n\n    /*\n    if (dict.isReliable !== undefined) {\n      assert(Type.isBoolean(dict.isReliable))\n      this.setIsReliable(dict.isReliable)\n    }\n\n    if (dict.debug !== undefined) {\n      assert(Type.isBoolean(dict.isReliable))\n      this.setDebug(dict.debug)\n    }\n\n    if (dict.pingInterval !== undefined) {\n      assert(Type.isNumber(dict.isReliable))\n      this.setPingInterval(dict.pingInterval)\n    }\n    */\n\n    return this\n  }\n\n  title () {\n    return this.host() \n  }\n\n  subtitle () {\n    //const http = this.httpProtocol();\n    //const ws = secure ? \"wss\" : \"ws\";\n\n    //return http + \" \" + this.port() + \"\\n\" + ws + \" \" + this.webSocketPort();\n    const summary = this.port() + \" \" + this.path() + \" \" + (this.isSecure() ? \"secure\" : \"\");\n    return [summary, this.status()].join(\"\\n\");\n    //return http + \":\" + this.port() + \", \" + ws + \":\" + this.webSocketPort() + \" \" + (this.isSecure() ? \"secure\" : \"\");\n  }\n\n  httpProtocol () {\n    const secure = this.isSecure();\n    return secure ? \"https\" : \"http\"; \n  }\n\n  /*\n  shutdown () {\n    this.peerConnections().valuesArray().forEach((conn) => {\n      conn.shutdown();\n    });\n    return this;\n  }\n  */\n\n  // --- getting peer list ----\n\n  getPeersUrl () {\n    return this.httpProtocol() + \"://\" + this.host() + \":\" + this.port() + this.path() + '/api/peers';\n  }\n\n  async refreshPeers () {\n    const peerIds = await this.fetchPeerIds();\n    this.peers().setPeerIdArray(peerIds)\n    return peerIds\n  }\n\n  async fetchPeerIds() { // Note this is a GET request, so we don't need to be connected to do this\n    this.setStatus(\"\");\n\n    try {\n      const url = this.getPeersUrl();\n      this.debugLog(\"getPeersUrl: '\" + url + \"'\");\n\n      const options = {\n        method: 'GET', // HTTP method\n        headers: {\n          'Authorization': `Bearer ${this.key()}`, // Passing the API key in the Authorization header\n          'Content-Type': 'application/json' // Assuming JSON data is expected\n        }\n      }\n\n      if (this.key()) {\n        options.headers['x-peer-key'] = this.key();\n      }\n\n      console.log(\"headers: \", JSON.stringify(options, 2, 2));\n\n      const promise = fetch(url, options);\n      const response = await promise;\n      \n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const peers = await response.json();\n      return peers;\n    } catch (error) {\n      this.setStatus(\"ERROR: \" + error.message);\n      return [];\n    }\n  }\n\n  availablePeerIds () {\n    return this.peers().subnodes().map(rzPeer => rzPeer.title())\n  }\n\n  // --- connecting to a peer ----\n  /*\n  connectToPeerId (peerId) {\n    const conn = this.peer().connect(peerId);\n    const pc = PeerConnection.clone().setConn(conn)\n    this.addPeerConnection(pc);\n    return pc\n  }\n  */\n\n\n}.initThisClass());\n",
  "0Uy88YUaxec5PblFxk6Tsj4WsRqB24/IhzvLmpIkR60=": "\"use strict\";\n\n/* \n    RzSigServers\n\n*/\n\n(class RzSigServers extends BMSummaryNode {\n  initPrototypeSlots () {\n    this.setSubnodeClasses([RzSigServer]);\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setTitle(\"PeerJS Signalling Servers\");\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setupDefaultServers();\n  }\n\n  setupDefaultServers () {\n    const map = this.jsonStringToServerMap() // TODO: use node hash support instead\n    this.defaultServerDicts().forEach(dict => {\n      const jsonString = JSON.stableStringify(dict);\n      const server = map.at(jsonString)\n      if (!server) {\n        const newServer = RzSigServer.clone().setDict(dict)\n        this.addSubnode(newServer)\n        map.atPut(jsonString, newServer)\n      }\n    });\n  }\n\n  jsonStringToServerMap () {\n    const m = new Map();\n    this.servers().forEach(server => {\n      const k = JSON.stableStringify(server.dict());\n      m.atPut(k, server);\n    });\n    return m;\n  }\n\n  defaultServerDicts () {\n    return [\n      {\n        host: \"peerjssignalserver.herokuapp.com\",\n        path: \"/peerjs\",\n        isSecure: true,\n        port: 443\n        //webSocketPort: 443\n        /*\n        // this are server connection settings \n        isReliable: true,\n        pingInterval: 1000, // 1 second\n        debug: false\n        */\n      },\n      {\n        host: \"undreamedof.ai\",\n        path: \"/peerjs\",\n        isSecure: true,\n        port: 9000\n        //webSocketPort: 9001\n        /*\n        isReliable: true,\n        pingInterval: 1000, // 1 second\n        debug: false\n        */\n      },\n      {\n        host: \"localhost\",\n        path: \"/peerjs\",\n        isSecure: true,\n        port: 9000\n        //webSocketPort: 9001\n        /*\n        isReliable: true,\n        pingInterval: 1000, // 1 second\n        debug: false\n        */\n      }\n    ]\n  }\n\n  servers () {\n    return this.subnodes();\n  }\n\n  /*\n  didInit () {\n    super.didInit()\n  }\n  */\n\n  service () {\n    return this.parentNode()\n  }\n\n}.initThisClass());\n",
  "AUFNiWpC3BPpXzKy2HTIqjPyFC2f91Yag8b6IB49/h4=": "\"use strict\";\n\n/* \n    PeerService\n\n*/\n\n(class PeerService extends BMSummaryNode {\n  \n  static initClass () {\n    this.setIsSingleton(true)\n  }\n\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"servers\", null)\n      slot.setFinalInitProto(RzSigServers)\n      slot.setShouldStoreSlot(true);\n      slot.setIsSubnode(true);\n      slot.setSlotType(\"RzSigServers\");\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init () {\n    super.init();\n  }\n\n  finalInit () {\n    super.finalInit()\n    this.setTitle(\"WebRTC\");\n    this.setSubtitle(\"peer-to-peer networking\");\n  }\n\n  defaultSignalServer () {\n    return this.servers().subnodes().first();\n  }\n\n}.initThisClass());\n",
  "C1sRn0Q19wVr+OTNZ957yDMQPYJgi4gorUNaULeWedA=": "\"use strict\";\n\n/* \n\n    SttMessage\n\n*/\n\n(class SttMessage extends BMSummaryNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"result\", \"\");      \n      slot.setInspectorPath(\"settings\")\n      slot.setLabel(\"Don't break on Pauses\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n  }\n\n  init() {\n    super.init();\n    this.setSubtitle(\"\")\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setNodeCanReorderSubnodes(false);\n    this.setIsDebugging(true)\n  }\n\n  title () {\n    return this.result()\n  }\n\n  finalInit() {\n    super.finalInit()\n  }\n\n}.initThisClass());\n",
  "uAD5UL8phbvDRcNNRei2p6XqTpaZXCEMOPfiODB9QZY=": "\"use strict\";\n\n/* \n    SttMessages\n\n*/\n\n(class SttMessages extends BMSummaryNode {\n  initPrototypeSlots () {\n    this.setSubnodeClasses([SttMessage]);\n    this.setTitle(\"log\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  /*\n  service () {\n    return this.parentNode()\n  }\n  */\n\n}.initThisClass());\n",
  "2vRPtTB/twzJqT87PtCPzUt03RQz6B43Y7s1HTTF+1M=": "\"use strict\";\n\n/* \n\n    SpeechToTextSession\n\n*/\n\n(class SpeechToTextSession extends BMSummaryNode {\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"recognition\", null);\n      slot.setSlotType(\"SpeechRecognition\");\n    }\n\n    {\n      const slot = this.newSlot(\"delegate\", null);\n      slot.setSlotType(\"Object\");\n    }\n\n    {\n      const slot = this.newSlot(\"sessionLabel\", \"\");      \n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"label\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"language\", 'en-US');\n      slot.setCanEditInspection(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setInspectorPath(\"settings\")\n      slot.setLabel(\"language\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true);\n      slot.setValidValues(['en-US']);\n      slot.setSummaryFormat(\"key value\");\n    }\n\n\n    {\n      const slot = this.newSlot(\"inputTimeoutId\", null);\n      slot.setSlotType(\"Number\");\n    }\n\n    {\n      const slot = this.newSlot(\"inputTimeoutMs\", 1500);      \n      slot.setInspectorPath(\"settings\");\n      slot.setLabel(\"inputTimeoutMs\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(true);\n      slot.setSummaryFormat(\"key value\");\n    }\n\n\n    {\n      /* \n      If continuous is set to true, the recognition service continues listening and returning results, \n      even if the user takes a pause. This allows for continuous recognition, \n      where the user can speak, pause, and then continue speaking without the recognition service stopping.\n      */\n\n      const slot = this.newSlot(\"isContinuous\", true);      \n      slot.setInspectorPath(\"settings\");\n      slot.setLabel(\"Don't break on Pauses\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Boolean\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(true);\n      slot.setSummaryFormat(\"key value\");\n    }\n\n    {\n      /*\n      If interimResults is set to true, the system will return both interim (temporary or provisional) results and final results. \n      Interim results are essentially guesses or partial results that might change as more audio is processed. \n      They allow you to show what the system is recognizing in real-time as the user is speaking.\n      */\n      const slot = this.newSlot(\"getInterimResults\", true);      \n      slot.setInspectorPath(\"settings\");\n      slot.setLabel(\"Shares Interim Results\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Boolean\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(true);\n      slot.setSummaryFormat(\"key value\");\n    }\n\n\n    {\n      const slot = this.newSlot(\"interimTranscript\", \"\");      \n      slot.setInspectorPath(\"\");\n      slot.setLabel(\"interim transcript\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"finalTranscript\", \"\");      \n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"final transcript\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n\n    {\n      const slot = this.newSlot(\"fullTranscript\", \"\");      \n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"full transcript\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n      slot.setSummaryFormat(\"value\")\n    }\n\n    {\n      const slot = this.newSlot(\"isRecording\", false);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"is recording\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n      slot.setSummaryFormat(\"value\")\n    }\n    \n    {\n      const slot = this.newSlot(\"toggleRecordingAction\", null);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Start\")\n      //slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Action\")\n      slot.setIsSubnodeField(true)\n      slot.setActionMethodName(\"toggleRecording\");\n    }\n\n    {\n      const slot = this.newSlot(\"transcriptPromise\", null);\n      slot.setSlotType(\"Promise\");\n    }\n\n  }\n\n  init() {\n    super.init();\n    this.setSubtitle(\"STT Session\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setNodeCanReorderSubnodes(false);\n    this.setIsDebugging(true);\n  }\n\n  finalInit() {\n    super.finalInit()\n    this.setNoteIsSubnodeCount(false);\n    this.setCanDelete(true);\n    this.setIsRecording(false);\n  }\n\n  title () {\n    const label = this.sessionLabel()\n    if (label) {\n      return label\n    }\n\n    if (this.fullTranscript()) {\n      let s = this.fullTranscript().substr(0, 100)\n      if (s.length < 20) {\n        s += \"...\"\n      }\n      return s\n    }\n\n    return \"Unlabeled\"\n  }\n\n  didUpdateSlotIsContinuos (oldValue, newValue) {\n    if (this.recognition()) {\n      this.recognition().continuous = newValue;\n    }\n  }\n\n  didUpdateSlotGetInterimResults (oldValue, newValue) {\n    if (this.recognition()) {\n      this.recognition().interimResults = newValue;\n    }\n  }\n\n  didUpdateSlotIsRecording (oldValue, newValue) {\n    if (this.recognition()) {\n      this.didUpdateNode()\n    }\n  }\n\n  setupIfNeeded () {\n    if (!this.recognition()) {\n      const SpeechRecognition = globalThis.SpeechRecognition || globalThis.webkitSpeechRecognition;\n\n      const rec = new SpeechRecognition();\n      //console.log(\"setup SpeechRecognition\")\n      assert(rec)\n\n      rec.continuous = this.isContinuous();\n      //console.log(\"rec.continuous:\", rec.continuous);\n      rec.interimResults = this.getInterimResults();\n      rec.lang = this.language();\n      \n      rec.onresult = (event) => {\n          this.onResult(event)\n      };\n\n      rec.onspeechend = (event) => {\n         // fired when speech recognition detects that the user has stopped speaking.\n         this.onSpeechEnd(event)\n      };\n\n      rec.onend = (event) => {\n        // fired when the recognition service has disconnected and the session has ended, \n        // whether it's due to completion, an error, or a call to the stop() method.\n        this.onEnd(event)\n      };\n\n      rec.onerror = (event) => {\n        this.onError(event);\n      };\n\n      this.setRecognition(rec)\n    }\n\n    return this\n  }\n\n  // --- timeout ---\n\n  usesInputTimeout () {\n    return this.getInterimResults()\n  }\n\n  startInputTimeout () {\n    this.clearInputTimeout()\n    if (this.usesInputTimeout()) {\n      const tid = setTimeout(() => this.onInputTimeout(), this.inputTimeoutMs());\n      this.setInputTimeoutId(tid)\n    }\n    return this\n  }\n\n  clearInputTimeout () {\n    const tid = this.inputTimeoutId()\n    if (tid) {\n      clearTimeout(tid)\n      this.setInputTimeoutId(null)\n    }\n    return this\n  }\n\n  resetInputTimeout () {\n    this.clearInputTimeout()\n    this.startInputTimeout()\n    return this\n  }\n\n  onInputTimeout () {\n    this.clearInputTimeout();\n    console.log(\"SPEECH onInputTimeout() stop\");\n    this.onInput();\n    this.stop();\n    /*\n    if (this.isContinuous()) {\n      this.start();\n    }\n    */\n    return this\n  }\n\n  // --- events ---\n\n  onResult (event) {\n    //this.debugLog(\"onResult\")\n\n    let interim = '';\n    let final = '';\n\n    for (let i = event.resultIndex; i < event.results.length; ++i) {\n        const word = event.results[i][0].transcript;\n        if (event.results[i].isFinal) {\n          final += word;\n        } else {\n          interim += word;\n        }\n    }\n\n    console.log(\"SPEECH onResult interm: '\" + interim + \"'\")\n\n    if (interim.length) {\n      this.resetInputTimeout()\n    }\n\n    this.setInterimTranscript(interim);\n    if (interim.length) {\n      this.sendDelegateMessage(\"onSpeechInterimResult\", [this])\n    }\n\n    if (final) {\n      this.setFinalTranscript(final)\n      this.appendToFullTranscript(this.finalTranscript())\n      //console.log(\"SPEECH onResult full: '\" + this.fullTranscript() + \"'\")\n\n      console.log(\"SPEECH onResult final: '\" + final + \"'\")\n      this.sendDelegateMessage(\"onSpeechFinal\", [this])\n      \n      if (!this.isRecording()) {\n        this.setFinalTranscript(\"\")\n      }\n    }\n  }\n\n  intermFullTranscript () {\n    return this.fullTranscript() + this.interimTranscript()\n  }\n\n  appendToFullTranscript (s) {\n    const ft = this.fullTranscript()\n    const spacer = ft.length === 0 ? \"\" : \" \"\n    this.setFullTranscript(ft + spacer + s)\n    return this\n  }\n\n  clearTranscript () {\n    this.setInterimTranscript(\"\")\n    this.setFinalTranscript(\"\")\n    this.setFullTranscript(\"\")\n    return this\n  }\n\n  onSpeechEnd (event) {\n    this.sendDelegateMessage(\"onSpeechEnd\", [this]);\n  }\n\n  onInput () {\n    // copy any interm to full Transcript\n    // any transcript marked final was (presumably) already added to full transcript in onResult()\n    this.appendToFullTranscript(this.interimTranscript());\n    this.setInterimTranscript(\"\");\n    this.setFinalTranscript(\"\");\n    this.stop(); // copying the interim transcript is only valid if we stop the recording, which clears the results.\n    this.sendDelegateMessage(\"onSpeechInput\", [this]);\n    this.transcriptPromise().callResolveFunc(this.fullTranscript());\n  }\n\n  onEnd (event) {\n    this.setIsRecording(false)\n    this.sendDelegateMessage(\"onSessionEnd\", [this])\n  }\n\n  onError (event) {\n    const error = event.error;\n    this.sendDelegateMessage(\"onSpeechError\", [this, error]);\n    console.warn(this.typeId() + \" error: \" + error);\n    if (this.transcriptPromise()) {\n      this.transcriptPromise().callRejectFunc(error);\n    }\n  }\n\n  start () {\n    this.debugLog(\"start\")\n    if (!this.isRecording()) {\n      this.setTranscriptPromise(Promise.clone());\n      this.clearTranscript();\n      this.setupIfNeeded();\n      this.startInputTimeout()\n      this.recognition().start();\n      this.setIsRecording(true);\n    }\n    return this.transcriptPromise();\n  }\n\n  startActionInfo () {\n    return {\n      isEnabled: !this.isRecording()\n    }\n  }\n\n  stop () {\n    //this.debugLog(\"stop\")\n    if (this.isRecording()) {\n      this.clearInputTimeout()\n      this.recognition().stop();\n      this.setIsRecording(false);\n      //this.appendToFullTranscript(this.interimTranscript())\n      //this.setInterimTranscript(\"\")\n      //this.setFinalTranscript(\"\")\n    }\n    return this\n  }\n\n  stopActionInfo () {\n    return {\n      isEnabled: this.isRecording()\n    }\n  }\n\n  toggleRecording () {\n    if (this.isRecording()) {\n      this.stop() \n    } else {\n      this.start()\n    }\n  }\n\n  toggleRecordingActionInfo () {\n    return {\n      isEnabled: true,\n      title: this.isRecording() ? \"stop\" : \"start\"\n    }\n  }\n\n  // --- delegate ---\n\n  sendDelegateMessage (methodName, args = []) {\n    const d = this.delegate();\n    if (d) {\n      const m = d[methodName];\n      if (m) {\n        m.apply(d, args);\n      }\n    }\n  }\n\n}.initThisClass());\n",
  "0Vxi7m8YTeG/nMw8xwlvLe5ROX1xIcoIiO7lwAXCv0I=": "\"use strict\";\n\n/* \n    SpeechToTextSessions\n\n*/\n\n(class SpeechToTextSessions extends BMSummaryNode {\n  \n  initPrototypeSlots () {\n    this.setSubnodeClasses([SpeechToTextSession]);\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setNoteIsSubnodeCount(false);\n    this.setTitle(\"Web Speech to Text\");\n    this.setSubtitle(\"speech-to-text service\");\n  }\n\n}.initThisClass());\n",
  "VdiWq5BxC7lJPSOOz3kkc2MbCpciPNxxsDNL9mxpJ8k=": "\"use strict\";\n\n/* \n    ProxyServer\n\n    NOTES:\n\n    This is setup up for a simple proxy with a path and url sent in a url parameter.\n    Use another class or subclass to handle more complex proxy request, such as passing \n    an XML/JSON body with auth and/or other info.\n\n*/\n\n(class ProxyServer extends BMSummaryNode {\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"isSecure\", true);\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Secure\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Boolean\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"subdomain\", \"\");\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Sudomain\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"domain\", \"\");\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Domain\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"port\", 0);\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Port\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"Number\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"path\", \"\");\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Path\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"parameterName\", null);\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Parameter Name\")\n      slot.setShouldStoreSlot(true)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(true)\n    }\n\n    {\n      const slot = this.newSlot(\"error\", \"\");\n      slot.setShouldJsonArchive(true)\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"Error\")\n      slot.setShouldStoreSlot(false)\n      slot.setSyncsToView(true)\n      slot.setDuplicateOp(\"duplicate\")\n      slot.setSlotType(\"String\")\n      slot.setIsSubnodeField(true)\n      slot.setCanEditInspection(false)\n    }\n\n    //this.setSubnodeClasses([ProxyRequest]);\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setTitle(\"Unnamed Proxy Server\");\n    this.setCanDelete(true);\n    this.setNoteIsSubnodeCount(false);\n    this.setNodeCanReorderSubnodes(false);\n    this.setNodeCanEditTitle(true);\n    this.setSubtitle(\"\");\n  }\n\n  protocolString () {\n    return this.isSecure() ? \"https\" : \"http\";\n  }\n\n  // --- hostname ---\n\n  hostname () {\n    const s = this.subdomain();\n    const d = this.domain();\n    \n    if (d === \"localhost\") {\n      return d;\n    }\n\n    if (s) {\n      return s + \".\" + d;\n    }\n    return d;\n  }\n\n  setHostname (hostname) {\n      // Split the hostname by the dots\n      const parts = hostname.split('.');\n  \n      if (parts.length < 2) {\n          this.setDomain(hostname); // e.g. localhost\n          return this;\n      }\n  \n      // Extract the domain (last two parts)\n      const domain = parts.slice(-2).join('.');\n  \n      // Extract the subdomain (everything except the last two parts)\n      const subdomain = parts.slice(0, -2).join('.') || null;\n  \n      this.setDomain(domain);\n      this.setSubdomain(subdomain);\n      return this;\n  }\n\n  // -----------------------\n\n  validationErrors () {\n    const errors = []\n\n    if (!Type.isString(this.hostname())) {\n      errors.push(\"hostname isn't a string\");\n    } else if (this.hostname().length === 0) {\n      errors.push(\"hostname is empty\")\n    }\n\n    if (!Type.isString(this.parameterName())) {\n      errors.push(\"parameterName isn't a string\")\n    } else if (this.parameterName().length === 0) {\n      errors.push(\"parameterName is empty\")\n    }\n\n    return errors\n  }\n\n  subtitle () {\n    return this.proxyUrlForUrl(\"targetUrl\")\n  }\n\n  proxyUrlForUrl (targetUrl) {\n    assert(targetUrl);\n\n    const errors = this.validationErrors()\n    if(errors.length) {\n      this.setError(\"ERROR: \" + errors[0]);\n      this.showError();\n      return null\n    }\n\n\n    const parameterValue = targetUrl;\n    \n    let urlString = this.protocolString() + \"://\" + this.hostname();\n\n    if (this.port() !== 0 && this.port() !== null) {\n        urlString += \":\" + this.port();\n    }\n\n    if (this.path()) {\n      urlString += this.path();\n    }\n\n    let resultUrl;\n    try {\n      const url = new URL(urlString);\n      //console.log(\"ProxyServer proxyURL: '\" + parameterValue + \"'\");\n      url.searchParams.set(this.parameterName(), parameterValue);\n      //url.searchParams.set(this.parameterName(), encodeURIComponent(parameterValue));\n      resultUrl = url.toString();\n    } catch (e) {\n      this.setError(e.message);\n      this.showError();\n      return null;\n    }\n\n    this.setError(\"\");\n    return resultUrl;\n  }\n\n  showError () {\n    console.warn(this.type() + \" ERROR: \" + this.error());\n    return this;\n  }\n\n}.initThisClass());\n",
  "jGJLb4SPncZBIZ7F/CwZd9s/edAzyJvemwRSKj11fh8=": "\"use strict\";\n\n/* \n    ProxyServer\n\n*/\n\n(class DefaultProxyServer extends ProxyServer {\n  \n  initPrototypeSlots () {\n  }\n\n  init() {\n    super.init();\n  }\n\n  finalInit() {\n    super.finalInit()\n    this.setTitle(\"Default Proxy Server\");\n    this.setParameterName(\"proxyUrl\");\n    this.setupForPage()\n  }\n\n  setupForPage () {\n    this.setHostname(window.location.hostname);\n    this.setPort(window.location.port);\n    this.setIsSecure(window.location.protocol === \"https:\");\n  }\n\n}.initThisClass());\n",
  "AKs+nwPYxb9JjqmPhOVSPq9kn0uFAnunSHaDQe8uL4s=": "\"use strict\";\n\n/* \n    ProxyServers\n\n    example use:\n\n    const proxyUrl = ProxyServers.shared().defaultServer().proxyUrlForUrl(targetUrl);\n\n*/\n\n(class ProxyServers extends BMSummaryNode {\n      \n  static initClass () {\n    this.setIsSingleton(true)\n  }\n\n  initPrototypeSlots () {\n    this.setSubnodeClasses([ProxyServer]);\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setNoteIsSubnodeCount(false);\n    this.setTitle(\"Proxies\");\n    this.setSubtitle(\"web proxy servers\");\n  }\n\n  finalInit() {\n    super.finalInit()\n    this.addDefaultIfNeeded()\n  }\n\n  addDefaultIfNeeded () {\n    if (this.subnodesCount() === 0) {\n      this.addSubnode(DefaultProxyServer.clone())\n    }\n  }\n\n  defaultServer () {\n    return this.subnodes().first()\n  }\n\n}.initThisClass());\n",
  "fGOjEE75ppsPnlsN3glI6dvWUJEvh3zMyn7Aq2qQrnY=": "\"use strict\";\n\n/* \n    HomeAssistantFolder\n\n*/\n\n(class HomeAssistantFolder extends BMSummaryNode {\n  initPrototypeSlots () {\n    this.setTitle(\"folder\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setSubnodeClasses([HomeAssistantFolder]);\n    this.setNoteIsSubnodeCount(true);\n    this.setNodeCanEditTitle(true);\n    this.setNodeCanEditSubtitle(true);\n    this.setNodeCanAddSubnode(true);\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.makeSortSubnodesByTitle();\n  }\n\n  /*\n  setupSubnodeClasses () {\n    const classes = []; \n    //HomeAssistantObject.subclasses().shallowCopy();\n    classes.push(HomeAssistantFolder);\n    this.setSubnodeClasses(classes);\n  }\n  */\n\n}.initThisClass());\n",
  "d6yzubIIUa/qEgMoCwwmrJErZ9q7UO7WwYbAH9JQI0w=": "\"use strict\";\n\n/* \n    HomeAssistantObject\n\n*/\n\n(class HomeAssistantObject extends BMSummaryNode {\n  initPrototypeSlots () {\n\n    {\n      const slot = this.newSlot(\"group\", null) // ref to HomeAssistantGroup subclass instance\n      slot.setShouldStoreSlot(true);\n    }\n\n    {\n      const slot = this.newSlot(\"owner\", null)\n      slot.setShouldStoreSlot(true);\n    }\n\n    {\n      const slot = this.newSlot(\"name\", \"\")\n      slot.setShouldStoreSlot(true);\n    }\n\n    {\n      const slot = this.newSlot(\"haJson\", null)\n      slot.setShouldStoreSlot(false);\n    }\n\n    {\n      const slot = this.newSlot(\"jsonString\", \"\");\n      slot.setCanEditInspection(false);\n      slot.setCanInspect(true);\n      //slot.setInspectorPath(\"Info\");\n      slot.setLabel(\"json\");\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      //slot.setIsSubnodeField(true);\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"\");\n    this.setCanDelete(true);\n    this.setHaJson({});\n  }\n  \n  finalInit () {\n    super.finalInit();\n    this.setCanDelete(true);\n    this.setNodeCanEditTitle(true);\n    this.setNodeSubtitleIsChildrenSummary(false);\n    this.setSummaryFormat(\"key value\");\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  jsonString () {\n    return JSON.stringify(this.haJson(), 2, 2);\n  }\n\n  homeAssistant () {\n    return this.group().homeAssistant();\n//    return this.firstParentChainNodeOfClass(HomeAssistant)\n  }\n\n  area () {\n    return this.firstParentChainNodeOfClass(HomeAssistantArea)\n  }\n\n  // --- connecting to owner ---\n\n  ownerId () {\n    throw new Error(\"subclasses should override\");\n  }\n\n  ownerGroup () {\n    throw new Error(\"subclasses should override\");\n  }\n\n  findOwner () {\n    return this.ownerGroup().objectWithId(this.ownerId());\n  }\n\n  connectObjects () {\n    const owner = this.findOwner();\n    if (owner) {\n      this.setOwner(owner);\n      owner.addChild(this);\n    } else{\n      console.warn(this.type() + \" \" + this.id() + \" unable to find owner with id \" + this.ownerId())\n    }\n    return this;\n  }\n\n  addChild (node) {\n    this.addSubnode(node);\n  }\n\n  completeSetup () {\n    this.updateTitles();\n  }\n\n  updateTitles () {\n    this.setTitle(this.computeShortName());\n    this.setSubtitle(this.type().after(\"HomeAssistant\"));\n  }\n\n  id () {\n    throw new Error(\"subclasses should implement this method\");\n  }\n\n  parentChainPath () {\n    return this.parentChainNodes().map(node => {\n      return node.type() + \" \\\"\" + node.title() + \"\\\"\";\n    }).join(\" / \");\n  }\n\n  /*\n  title () {\n    return this.computeShortName();\n  }\n  */\n\n  computeShortName () {\n    let name = this.name();\n    const owner = this.findOwner();\n    //console.log(\"\", this.parentChainPath());\n    //debugger;\n    if (owner) {\n      const prefix = owner.title();\n      if (name.beginsWith(prefix) && name !== prefix) {\n        name = name.after(prefix);\n      }\n    }\n    return name;\n  }\n\n}).initThisClass();\n",
  "J4SpBqTmyUojVaLz9IaBtpnVo3xOxSLDQU+DiOQgRpM=": "\"use strict\";\n\n/* \n    HomeAssistantGroup\n\n*/\n\n(class HomeAssistantGroup extends BMSummaryNode {\n\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"homeAssistant\", null);\n      slot.setSlotType(\"HomeAssistant\");\n    }\n\n    {\n      const slot = this.newSlot(\"getMessageType\", null);\n      slot.setSlotType(\"String\");\n    }\n\n    {\n      const slot = this.newSlot(\"idMap\", null);\n      slot.setSlotType(\"Map\");\n    }\n\n    this.setTitle(\"devices\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    //this.setSubnodeClasses([HomeAssistantDevice]);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n    this.setNoteIsSubnodeCount(true);\n  }\n\n  init() {\n    super.init();\n    this.setIdMap(new Map());\n  }\n\n  finalInit () {\n    super.finalInit();\n    this.makeSortSubnodesByTitle();\n  }\n\n  objectWithId (id) {\n    return this.idMap().get(id);\n  }\n\n  defaultSubnodeClass () {\n    return this.subnodeClasses().first();\n  }\n\n  groupName () {\n    return this.type().after(\"HomeAssistant\");\n  }\n\n  async asyncRefresh () {\n    this.removeAllSubnodes();\n\n    const s = \"refreshing \" + this.groupName() + \"s...\";\n    console.log(s);\n    this.homeAssistant().setStatus(s);\n\n    const json = await this.homeAssistant().asyncSendMessageDict({ type: this.getMessageType() });\n    this.setHaJson(json);\n    this.connectObjects();\n    //this.completeSetup();\n  }\n\n  setHaJson (json) {\n    this.removeAllSubnodes();\n    json.forEach(snJson => {\n      const node = this.defaultSubnodeClass().clone();\n      node.setHaJson(snJson);\n      node.setGroup(this);\n      this.idMap().set(node.id(), node);\n      this.addLinkSubnode(node);\n    });\n    return this;\n  }\n\n  haObjects () {\n    return this.idMap().valuesArray();\n  }\n\n  connectObjects () {\n    this.haObjects().shallowCopy().forEach(sn => sn.connectObjects());\n    return this;\n  }\n\n  completeSetup () {\n    this.haObjects().shallowCopy().forEach(sn => sn.completeSetup());\n    return this;\n  }\n\n  subnodeWithId (id) {\n    throw new Error(\"shouldn't use this\");\n    //const ids = this.subnodes().map(sn => sn.id());\n    return this.subnodes().detect(sn => sn.id() === id);\n  }\n\n}.initThisClass());\n",
  "vR0szPQ66zu0lSlZKF94NW2whAIsDHltACGeQDpBpQc=": "\"use strict\";\n\n/* \n    HomeAssistantState\n\n    {\n      \"entity_id\": \"media_player.homepod_tv_left\",\n      \"state\": \"standby\",\n      \"attributes\": {\n        \"volume_level\": 0.35,\n        \"media_content_id\": \"a626811e-62c9-4ca9-8bcc-8f2676b21890\",\n        \"media_content_type\": \"video\",\n        \"media_duration\": 1530,\n        \"media_position\": 1407,\n        \"media_title\": \"The Bear | S1 E5 - Sheridan\",\n        \"app_id\": \"com.apple.tvairplayd\",\n        \"app_name\": \"Hulu\",\n        \"entity_picture\": \"/api/media_player_proxy/media_player.homepod_tv_left?token=139d6797cc4da521aa19c39e2fab71091823014b8016e6bb77632b120ec773fb&cache=6A00EEDC-8E75-4454-90B2-3A0F3DBDE0B1\",\n        \"friendly_name\": \"HomePod TV Left\",\n        \"supported_features\": 448439\n      },\n      \"last_changed\": \"2024-01-20T06:02:33.356314+00:00\",\n      \"last_updated\": \"2024-01-23T07:12:10.065147+00:00\",\n      \"context\": {\n        \"id\": \"01HMTJK1AHNKQ25DKQKWZ056Z2\",\n        \"parent_id\": null,\n        \"user_id\": null\n      }\n    }\n\n*/\n\n(class HomeAssistantState extends HomeAssistantObject {\n\n  initPrototypeSlots () {\n\n    {\n      //const slot = this.newSlot(\"entity\", null);\n    }\n\n    /*\n\n    {\n      const slot = this.newSlot(\"jsonString\", null)\n      //slot.setFinalInitProto(BMTextAreaField);\n      slot.setShouldStoreSlot(false);\n      //slot.setIsSubnode(true);\n    }\n    */\n\n\n    /*\n    {\n      const slot = this.newSlot(\"scanAction\", null);\n      //slot.setInspectorPath(\"Character\");\n      slot.setLabel(\"Scan\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setCanInspect(true)\n      slot.setActionMethodName(\"scan\");\n    }\n    */\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n    this.setSummaryFormat(\"key value\");\n  }\n\n  init() {\n    super.init();\n  }\n\n  /*\n  subtitle () {\n    return \"Entity\";\n  }\n  */\n  \n  finalInit () {\n    super.finalInit();\n    this.setNoteIsSubnodeCount(false);\n  }\n\n/*\n  scanActionInfo () {\n    return {\n        isEnabled: this.hasValidUrl(),\n        //title: this.title(),\n        subtitle: this.hasValidUrl() ? null : \"Invalid Host URL\",\n        isVisible: true\n    }\n  }\n  */\n\n  id () {\n    return this.haJson().context.id; // is this correct?\n  }\n\n  entityId () {\n    return this.haJson().entity_id;\n  }\n\n  /*\n  findOwner () {\n    const entity = this.homeAssistant().entityWithId(this.entityId());\n    return entity;\n  }\n  */\n\n  ownerId () {\n    return this.entityId();\n  }\n\n  ownerGroup () {\n    return this.homeAssistant().entitiesNode();\n  }\n\n  updateTitles () {\n    this.setName(this.name());\n    this.setTitle(this.computeShortName());\n    this.setSubtitle(this.haJson().state);\n  }\n\n  name () {\n    const json = this.haJson();\n    let name = json.attributes.friendly_name;\n    if (!name) {\n      name = json.entity_id\n    }\n    return name;\n  }\n\n  /*\n  updateTitle () {\n    this.setName(this.computeName());\n    this.setTitle(this.computeShortName());\n    return this;\n  }\n  */\n\n  state () {\n    return this.haJson().state;\n  }\n\n}).initThisClass();\n",
  "AHheuZZi+/Dhvexyx8PjZsRqoKs8OYcftvlmFPQSCZ0=": "\"use strict\";\n\n/* \n    HomeAssistantStates\n\n*/\n\n(class HomeAssistantStates extends HomeAssistantGroup {\n  initPrototypeSlots () {\n\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"states\");\n    this.setSubnodeClasses([HomeAssistantState]);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setGetMessageType(\"get_states\");\n    this.setNodeSubtitleIsChildrenSummary(false);\n  }\n\n}.initThisClass());\n",
  "9C5g0J5uatfMXrzWfzVw9MsQ1A1fnXa8/DvDw0CChys=": "\"use strict\";\n\n/* \n    HomeAssistantEntity\n\n  \n    {\n  \"area_id\": null,\n  \"config_entry_id\": \"0c5f8e74567b2b5ed23bff95c748fd73\",\n  \"device_id\": \"fde6bc1b7ab8ddb70724c217783eb2e6\",\n  \"disabled_by\": null,\n  \"entity_category\": \"config\",\n  \"entity_id\": \"switch.deck_speakers_surround_music_full_volume\",\n  \"has_entity_name\": true,\n  \"hidden_by\": null,\n  \"icon\": null,\n  \"id\": \"7d631fa422dc59846bf5bd201bed8e30\",\n  \"name\": null,\n  \"options\": {\n    \"conversation\": {\n      \"should_expose\": false\n    }\n  },\n  \"original_name\": \"Surround music full volume\",\n  \"platform\": \"sonos\",\n  \"translation_key\": \"surround_mode\",\n  \"unique_id\": \"RINCON_C438755F9BC701400-surround_mode\"\n}\n\n*/\n\n(class HomeAssistantEntity extends HomeAssistantObject {\n  initPrototypeSlots () {\n\n    /*\n    {\n      const slot = this.newSlot(\"scanAction\", null);\n      //slot.setInspectorPath(\"Character\");\n      slot.setLabel(\"Scan\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setCanInspect(true)\n      slot.setActionMethodName(\"scan\");\n    }\n    */\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"\");\n    this.setCanDelete(true);\n  }\n\n  \n  finalInit () {\n    super.finalInit();\n    this.setNodeSubtitleIsChildrenSummary(true);\n  }\n\n  areaId () {\n    return this.haJson().area_id;\n  }\n\n  deviceId () {\n    return this.haJson().device_id;\n  }\n\n  id () {\n    return this.haJson().entity_id;\n  }\n\n  statesNode () {\n    return this;\n  }\n\n  statesCount () {\n    return this.statesNode().subnodeCount();\n  }\n\n  ownerId () {\n    return this.deviceId();\n  }\n\n  ownerGroup () {\n    return this.homeAssistant().devicesNode();\n  }\n\n  updateTitles () {\n    const json = this.haJson();\n    this.updateName();\n    this.setTitle(this.computeShortName());\n    this.setSubtitle(\"entiy\");\n\n    if (this.state()) {\n      this.setSubtitle(this.state());\n    }\n  }\n\n  state () {\n    if (this.subnodesCount() === 1) {\n      return this.subnodes().first().state();\n    }\n    return undefined;\n  }\n\n  updateName () {\n    const json = this.haJson();\n    let name = json.original_name;\n    if (!name) {\n      name = json.entity_id;\n    }\n    this.setName(name);\n    return this;\n  }\n\n  /*\n  updateSubtitle () {\n    if (this.statesCount() === 1) {\n      const s = this.statesNode().subnodes().first().state();\n      this.setSubtitle(s);\n    } else {\n      const s = [this.id(), this.statesCount() + \" states\"].join(\"\\n\");\n      this.setSubtitle(s);\n    }\n    return this;\n  }\n\n  addState (state) {\n    state.removeFromParentNode();\n    this.statesNode().addSubnode(state);\n    return this;\n  }\n\n  scanActionInfo () {\n    return {\n        isEnabled: this.hasValidUrl(),\n        //title: this.title(),\n        subtitle: this.hasValidUrl() ? null : \"Invalid Host URL\",\n        isVisible: true\n    }\n  }\n  */\n\n}).initThisClass();\n",
  "9PSBskTRB8KjQVGf9i3J0s+SI4QTrtRJB1TyOkP82wg=": "\"use strict\";\n\n/* \n    HomeAssistantEntities\n\n*/\n\n(class HomeAssistantEntities extends HomeAssistantGroup {\n  initPrototypeSlots () {\n\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"entities\");\n    this.setSubnodeClasses([HomeAssistantEntity]);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setGetMessageType(\"config/entity_registry/list\");\n  }\n\n}.initThisClass());\n",
  "0LjGEnS7jLYQsXKqeDGNTs/uaQim5JDbnwRNmHDIyP8=": "\"use strict\";\n\n/* \n    HomeAssistantDevice\n\n\n   HomeAssistantDevice:{\n  \"area_id\": null,\n  \"configuration_url\": null,\n  \"config_entries\": [\n    \"a8bc13c525dbdcf6e0bbcd6b8693dadc\"\n  ],\n  \"connections\": [],\n  \"disabled_by\": null,\n  \"entry_type\": \"service\",\n  \"hw_version\": null,\n  \"id\": \"6cdcb91bb251ccd6ba6828d4b56c761b\",\n  \"identifiers\": [\n    [\n      \"sun\",\n      \"a8bc13c525dbdcf6e0bbcd6b8693dadc\"\n    ]\n  ],\n  \"manufacturer\": null,\n  \"model\": null,\n  \"name_by_user\": null,\n  \"name\": \"Sun\",\n  \"serial_number\": null,\n  \"sw_version\": null,\n  \"via_device_id\": null\n}\n\n*/\n\n(class HomeAssistantDevice extends HomeAssistantObject {\n  initPrototypeSlots () {\n\n  }\n\n  init() {\n    super.init();\n  }\n  \n  finalInit () {\n    super.finalInit();\n    this.setNodeCanEditTitle(true);\n  }\n\n  entitiesNode () {\n    return this;\n  }\n\n  /*\n  updateSubtitle () {\n    const s = [\n      this.entitiesNode().subnodeCount() + \" entities\",\n      this.statesCount() + \" states\"\n    ].join(\"\\n\");\n    this.setSubtitle(s);\n    return this;\n  }\n  */\n\n  id () {\n    return this.haJson().id;\n  }\n\n  areaId () {\n    return this.haJson().area_id;\n  }\n\n  ownerId () {\n    return this.areaId();\n  }\n\n  ownerGroup () {\n    return this.homeAssistant().areasNode();\n  }\n\n  updateTitles () {\n    let name = this.haJson().name_by_user;\n    if (!name) {\n      name = this.haJson().name;\n    }\n    if (name === null) {\n      name = \"NULL\";\n    }\n    //    this.removeAllSubnodes();\n    this.setName(name);\n    this.setTitle(this.computeShortName());\n\n    if (this.state()) {\n      this.setSubtitle(this.state());\n    }\n    //this.updateSubtitle();\n  }\n\n  state () {\n    if (this.subnodesCount() === 1) {\n      return this.subnodes().first().state();\n    }\n    return undefined;\n  }\n\n  addEntity (entity) {\n    entity.removeFromParentNode();\n    this.entitiesNode().addSubnode(entity);\n    return this;\n  }\n\n}).initThisClass();\n",
  "eicpcZoFlb/abfBd3aJXDMts+jSujLdBEiGIJpK+Rpk=": "\"use strict\";\n\n/* \n    HomeAssistantDevices\n\n*/\n\n(class HomeAssistantDevices extends HomeAssistantGroup {\n  initPrototypeSlots () {\n\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"devices\");\n    this.setSubnodeClasses([HomeAssistantDevice]);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setGetMessageType(\"config/device_registry/list\");\n  }\n\n\n}.initThisClass());\n",
  "YX/8EudrvBVPbEUSyNlnVFCZwKa3iuHEMgfrmZbANyY=": "\"use strict\";\n\n/* \n    HomeAssistantArea\n\n*/\n\n(class HomeAssistantArea extends HomeAssistantObject {\n  initPrototypeSlots () {\n\n  }\n\n  init() {\n    super.init();\n  }\n  \n  finalInit () {\n    super.finalInit();\n    this.setNodeCanEditTitle(true);\n    //this.setNodeSubtitleIsChildrenSummary(true);\n  }\n\n  id () {\n    return this.haJson().area_id;\n  }\n\n  updateTitle () {\n    if (this.id()) {\n      const parts = this.id().split(\"_\");\n      const s = parts.map(part => part.capitalized()).join(\" \");\n      this.setTitle(s);\n    } else {\n      this.setTitle(\"null\");\n    }\n    return this;\n  }\n\n  connectObjects () {\n    // no parents to connect to\n  }\n\n  updateTitles () {\n    this.updateTitle();\n    //this.updateSubtitle();\n    this.setSubtitle(\"area\");\n    return this;\n  }\n\n  findOwner () {\n    debugger;\n    return null;\n  }\n\n  /*\n  updateSubtitle () {\n    const s = [\n      this.subnodeCount() + \" devices\"\n    ].join(\"\\n\");\n    this.setSubtitle(s);\n    return this;\n  }\n\n  addDevice (device) {\n    device.removeFromParentNode();\n    this.devicesNode().addSubnode(device);\n    return this;\n  }\n  */\n\n}).initThisClass();\n",
  "U2QAhidFs71Iu1pww5I31eFbq9263moBfvM7wsUQrXw=": "\"use strict\";\n\n/* \n    HomeAssistantAreas\n\n*/\n\n(class HomeAssistantAreas extends HomeAssistantGroup {\n  initPrototypeSlots () {\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"areas\");\n    this.setSubnodeClasses([HomeAssistantArea]);\n  }\n\n  finalInit() {\n    super.finalInit();\n    this.setGetMessageType(\"config/area_registry/list\");\n  }\n\n  completeSetup () {\n    super.completeSetup();\n    \n    const root = this.homeAssistant().rootFolder();\n    root.removeAllSubnodes();\n    root.addSubnodes(this.haObjects());\n  }\n\n}.initThisClass());\n",
  "Byfdxd0/xsyhE3/yP3ECy+TaZNHbjQ8C2N3cMwTDYsU=": "\"use strict\";\n\n/* \n    HomeAssistant\n\n*/\n\n(class HomeAssistant extends BMSummaryNode {\n  initPrototypeSlots () {\n    {\n      const slot = this.newSlot(\"regionOptions\", []);\n      slot.setSlotType(\"Array\");\n    }\n\n    {\n      const slot = this.newSlot(\"protocol\", \"wss\");\n      slot.setInspectorPath(\"Settings\")\n      slot.setLabel(\"Protocol\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setValidValues([\"wss\", \"ws\"]);\n    }\n\n    {\n      //const slot = this.newSlot(\"host\", \"umbrel.local\");\n      const slot = this.newSlot(\"host\", \"localnode.ddns.net\");\n      slot.setInspectorPath(\"Settings\")\n      slot.setLabel(\"Host (HomeAssistant websocket server)\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n    }\n\n    {\n      //const slot = this.newSlot(\"port\", 8123);\n      const slot = this.newSlot(\"port\", 8124);\n      slot.setInspectorPath(\"Settings\")\n      slot.setLabel(\"Port\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Number\");\n      slot.setIsSubnodeField(true);\n    }\n\n    {\n      const slot = this.newSlot(\"url\", 8124);\n      slot.setInspectorPath(\"Settings\")\n      slot.setLabel(\"Url\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n      slot.setCanEditInspection(false);\n      slot.setSummaryFormat(\"value\");\n    }\n\n    {\n      const slot = this.newSlot(\"accessToken\", \"\");\n      slot.setInspectorPath(\"Settings\")\n      slot.setLabel(\"Access Token\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(true);\n    }\n\n    {\n      const slot = this.newSlot(\"status\", \"\");\n      slot.setCanEditInspection(false);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"status\");\n      slot.setShouldStoreSlot(true);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      slot.setIsSubnodeField(false);\n    }\n\n    {\n      const slot = this.newSlot(\"error\", null);\n      slot.setCanEditInspection(false);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"error\");\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"String\");\n      //slot.setIsSubnodeField(true);\n    }\n\n    {\n      const slot = this.newSlot(\"hasAuth\", false);\n      slot.setCanEditInspection(false);\n      slot.setInspectorPath(\"\")\n      slot.setLabel(\"has auth\");\n      slot.setShouldStoreSlot(false);\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Boolean\");\n      slot.setIsSubnodeField(false);\n    }\n\n\n    {\n      const slot = this.newSlot(\"rootFolder\", null)\n      slot.setFinalInitProto(HomeAssistantFolder);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(true);\n    }\n\n    const showNodes = false;\n\n    {\n      const slot = this.newSlot(\"areasNode\", null)\n      slot.setFinalInitProto(HomeAssistantAreas);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(showNodes);\n    }\n\n    {\n      const slot = this.newSlot(\"devicesNode\", null)\n      slot.setFinalInitProto(HomeAssistantDevices);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(showNodes);\n    }\n\n    {\n      const slot = this.newSlot(\"entitiesNode\", null)\n      slot.setFinalInitProto(HomeAssistantEntities);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(showNodes);\n    }\n\n    {\n      const slot = this.newSlot(\"statesNode\", null)\n      slot.setFinalInitProto(HomeAssistantStates);\n      slot.setShouldStoreSlot(false);\n      slot.setIsSubnode(showNodes);\n    }\n\n\n    {\n      const slot = this.newSlot(\"toggleConnectAction\", null);\n      //slot.setInspectorPath(\"Character\");\n      slot.setLabel(\"Connect\");\n      slot.setSyncsToView(true);\n      slot.setDuplicateOp(\"duplicate\");\n      slot.setSlotType(\"Action\");\n      slot.setIsSubnodeField(true);\n      slot.setCanInspect(true)\n      slot.setActionMethodName(\"connect\");\n    }\n\n    {\n      const slot = this.newSlot(\"socket\", null);\n    }\n\n    {\n      const slot = this.newSlot(\"sentMessageCount\", 0);\n    }\n\n    {\n      const slot = this.newSlot(\"messagePromises\", null);\n    }\n\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(false);\n  }\n\n  init() {\n    super.init();\n    this.setTitle(\"Home Assistant\");\n    this.setCanDelete(true);\n    this.setMessagePromises(new Map());\n  }\n\n  subtitle () {\n    return [this.url(), this.status()].join(\"\\n\");\n  }\n  \n  finalInit () {\n    super.finalInit();\n    this.setCanDelete(true);\n    this.updateUrl();\n    this.setNodeCanEditTitle(true);\n    this.setStatus(\"not connected\");\n    this.rootFolder().setTitle(\"regions\");\n    this.groups().forEach(group => group.setHomeAssistant(this));\n  }\n\n  didUpdateSlotHost () {\n    this.updateUrl()\n  }\n\n  didUpdateSlotPort () {\n    this.updateUrl()\n  }\n\n  composedUrl () {\n    const url = this.protocol() + \"://\" + this.host() + \":\" + this.port() + \"/\";\n    return url;\n  }\n\n  updateUrl () {\n    this.setUrl(this.composedUrl());\n  }\n\n  didUpdateSlotUrl () {\n    //this.rescan();\n  }\n\n  hasValidUrl () {\n    return this.host().length > 0 && this.port() >= 0;\n  }\n\n  toggleConnect () {\n    if (this.isConnected()) {\n      this.disconnect();\n    } else {\n      this.connect();\n    }\n  }\n\n  disconnect () {\n    this.setStatus(\"disconnecting...\");\n    this.socket().close();\n    //this.setSocket(null); // needed?\n  }\n\n  connect () {\n    this.setStatus(\"connecting...\");\n\n    const socket = new WebSocket(this.url());\n    this.setSocket(socket);\n\n    socket.addEventListener('open',() => {\n      this.onOpen();\n    });\n\n    socket.addEventListener('message', (event) => {\n       this.onMessage(event);\n    });\n\n    socket.addEventListener('error', (error) => {\n      this.onError(error);\n    });\n\n    socket.addEventListener('close', (event) => {\n      this.onClose(event);\n    });\n  }\n\n  isConnected () {\n    return this.socket() !== null;\n  }\n\n  toggleConnectActionInfo () {\n    return {\n        isEnabled: true,\n        title: this.isConnected() ? \"Disconnect\" : \"Connect\",\n        subtitle: this.hasValidUrl() ? null : \"Invalid Host URL\",\n        isVisible: true\n    }\n  }\n\n  onClose (event) {\n    if (event.wasClean) {\n      //console.log(`Connection closed cleanly, code=${event.code}, reason=${event.reason}`);\n      this.setStatus('unconnected');\n    } else {\n      this.setStatus('Connection died');\n    }\n    this.setSocket(null);\n  }\n\n  onError (error) {\n    if (error.currentTarget.readyState === 3) {\n      console.log(\"ERROR: unable to connect\");\n    }\n    console.warn(this.typeId() + \" \" + this.wsUrl() + \" onError:\", error);\n    this.setStatus(\"ERROR: \" + error.message);\n    error.rethrow();\n  }\n\n  async getAuth () {\n    const hasAuth = await this.asyncSendMessageDict({\n      type: 'auth',\n      access_token: this.accessToken()\n    });\n\n    if (!hasAuth) {\n      this.setStatus(\"ERROR: invalid access token\");\n    } else {\n      this.setStatus(\"access token accepted\");\n    }\n    this.setHasAuth(hasAuth);\n    return hasAuth;\n  }\n\n  async onOpen (event) {\n    this.setStatus(\"connected, authorizing...\");\n    // await  onMessage message.type === \"auth_required\"\n  }\n\n  groups () {\n    return [ \n      this.areasNode(),\n      this.devicesNode(),\n      this.entitiesNode(),\n      this.statesNode()\n    ];\n  }\n\n  async refresh () {\n    try {\n      //debugger;\n      // fetch the JSON and setup objects\n      this.setStatus(\"refreshing objects...\");\n\n      await Promise.all(this.groups().map(group => group.asyncRefresh()));\n\n      this.groups().forEach(group => group.completeSetup());\n\n      this.setStatus(\"\");\n      this.didUpdateNode();\n    } catch (error) {\n      this.setError(error);\n      throw error;\n      this.disconnect();\n    }\n  }\n\n  /*\n  // change device areaId\n  const updateAreaMessage = {\n    id: messageId,\n    type: 'config/device_registry/update',\n    device_id: deviceId,\n    area_id: newAreaId\n  };\n\n  // change entity name\n    const updateEntityMessage = {\n        id: messageId,\n        type: 'config/entity_registry/update',\n        entity_id: entityId,\n        name: newFriendlyName\n    };\n*/\n\n/*\n\n  asyncAreaRegistry () {\n    return this.asyncSendMessageDict({ type: 'config/area_registry/list' });\n  }\n\n  asyncEntityRegistry () {\n    return this.asyncSendMessageDict({ type: 'config/entity_registry/list'});\n  }\n\n  asyncDeviceRegistry () {\n    return this.asyncSendMessageDict({ type: 'config/device_registry/list'});\n  }\n\n  asyncGetStates () {\n    return this.asyncSendMessageDict({ type: 'get_states'});\n  }\n  */\n\n  newMessageId () {\n    const count = this.sentMessageCount();\n    this.setSentMessageCount(count + 1);\n    return count;\n  }\n\n  asyncSendMessageDict (dict) {\n    // we will add the id to the dict\n    const promise = Promise.clone();\n    let id = this.newMessageId();\n    promise.beginTimeout(3000); // auth request and response aren't numbered\n\n    if (dict[\"type\"] !== \"auth\") {\n      dict.id = id;\n      //promise.beginTimeout(3000); // auth request and response aren't numbered\n    } else {\n      id = \"auth\";\n    }\n    this.messagePromises().set(id, promise);\n\n    const s = JSON.stringify(dict);\n    promise.setLabel(\"HomeAssistant request: \" + s);\n    console.log(this.type() + \" asyncSendMessageDict( \" + s.clipWithEllipsis(40) + \" )\");\n    this.socket().send(s);\n\n    this.updateStatus();\n    return promise;\n  }\n\n  updateStatus () {\n    if (this.messagePromises().size) {\n      const ids = Array.from(this.messagePromises().keys());\n      //this.setStatus(\"awaiting \" + this.messagePromises().size + \" messages (\" + JSON.stringify(ids) + \")\");\n      this.setStatus(\"awaiting \" + this.messagePromises().size + \" messages...\");\n    } else {\n      if (this.socket()) {\n        this.setStatus(\"connected\");\n      }\n    }\n  }\n\n  async onAuthOk () {\n    this.refresh();\n  }\n\n  async onAuthInvalid () {\n    this.disconnect();\n  }\n\n  popPromiseWithId (id) {\n    const promise = this.messagePromises().get(id);\n    this.messagePromises().delete(id);\n    return promise;\n  }\n\n  async onMessage (event) {\n    const message = JSON.parse(event.data);\n    console.log(this.type() + \" onMessage( \", event.data.clipWithEllipsis(40) + \" )\");\n\n    if (message.type === \"auth_required\") {\n      await this.getAuth(); // response is handled with \"auth\" and \"auth_invalid\" message types\n    } else if (message.type === 'auth_ok') {\n      const promise = this.popPromiseWithId(\"auth\");\n      promise.callResolveFunc(true); // should this be before resolve?\n      this.onAuthOk();\n    } else if (message.type === 'auth_invalid') {\n      const promise = this.popPromiseWithId(\"auth\");\n      promise.callResolveFunc(false); \n      this.onAuthInvalid(); // should this be before resolve/reject?\n      //promise.callRejectFunc();\n    } else if (message.type === 'result') {\n      if (message.success === false) {\n        this.setError(new Error(message.error.message));\n        this.setStatus(\"ERROR: \", message.error.message);\n      } else {\n        const id = message.id;\n        const result = message.result;\n        const promise = this.popPromiseWithId(id);\n        promise.callResolveFunc(result);\n      }\n\n    } else {\n      console.warn(this.typeId() + \" WARNING: unhandled message [[\" + JSON.stringify(message, 2, 2) + \"]]\");\n    }\n    this.updateStatus();\n  }\n\n  finsihScan () {\n        /*\n      this.devices().forEach(device => {\n          // Find entities that belong to this device in the states\n          const deviceEntityIds = this.states().filter(state => state.device_id === device.id).map(state => state.entity_id);\n          const deviceEntities = this.entities().filter(entity => deviceEntityIds.includes(entity.entity_id));\n\n          const entityStates = deviceEntities.map(entity => `${entity.entity_id.split('.')[1]}: ${entity.state}`).join(', ');\n\n          const node = HomeAssistantDevice.clone();\n          node.setJsonDict(device);\n          node.setEntitiesJson(deviceEntities);\n\n          node.setTitle(device.name);\n          //node.setSubtitle(entityStates);\n          this.devicesNode().addSubnode(node);\n\n          deviceEntities.forEach(deviceEntity => {\n            const sn = HomeAssistantEntity.clone();\n            //sn.setTitle(deviceEntity.entity_id.before(\".\"));\n            sn.setTitle(deviceEntity.entity_id);\n            sn.setSubtitle(deviceEntity.state);\n            sn.setSummaryFormat(\"key value\");\n            node.addSubnode(sn);\n          });\n      });\n      */\n\n\n      //console.log(\"SHOW: \", s);\n  }\n\n\n  scanActionInfo () {\n    return {\n        isEnabled: this.hasValidUrl(),\n        //title: this.title(),\n        subtitle: this.hasValidUrl() ? null : \"Invalid Host URL\",\n        isVisible: true\n    }\n  }\n\n  /*\n  areaWithId (id) {\n    return this.areasNode().subnodeWithId(id);\n  }\n\n  deviceWithId (id) {\n    return this.devicesNode().subnodeWithId(id);\n  }\n\n  entityWithId (id) {\n    return this.entitiesNode().subnodeWithId(id);\n  }\n\n  stateWithId (id) {\n    return this.statesNode().subnodeWithId(id);\n  }\n  */\n  \n}).initThisClass();\n\n/*\nfunction changeDeviceArea(deviceId, newAreaId) {\n    const messageId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);\n\n    const updateAreaMessage = {\n        id: messageId,\n        type: 'config/device_registry/update',\n        device_id: deviceId,\n        area_id: newAreaId\n    };\n\n    socket.send(JSON.stringify(updateAreaMessage));\n}\n*/",
  "57Iyl5fSBX9ez6mb0TCWxkGZIky1BEWTTbILmUAW9jM=": "\"use strict\";\n\n/* \n    HomeAssistants\n\n*/\n\n(class HomeAssistants extends BMSummaryNode {\n  \n  initPrototypeSlots () {\n    this.setTitle(\"Home Assistants\");\n    this.setNoteIsSubnodeCount(true);\n    this.setSubtitle(\"home automation\");\n    this.setShouldStore(true);\n    this.setShouldStoreSubnodes(true);\n    this.setSubnodeClasses([HomeAssistant]);\n    this.setNodeCanAddSubnode(true);\n    this.setNodeCanReorderSubnodes(true);\n  }\n\n}.initThisClass());\n",
  "DRNb9TPofTFVySJ+QJ+pPh7eNdgMOxXvncPOByNwWGA=": "\"use strict\";\n\n/*\n\n    Services\n\n*/\n\n(class Services extends BMSummaryNode {\n    \n    static initClass () {\n        this.setIsSingleton(true);\n    }\n\n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"anthropicService\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(AnthropicService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"AnthropicService\");\n        }\n        \n        {\n            const slot = this.newSlot(\"openAiService\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(OpenAiService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"OpenAiService\");\n        }\n\n        {\n            const slot = this.newSlot(\"groqService\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(GroqService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"GroqService\");\n        }\n\n\n        {\n            const slot = this.newSlot(\"geminiService\", null);\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(GeminiService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"GeminiService\");\n        }\n\n        /*\n        {\n            const slot = this.newSlot(\"midjourneyService\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(MJService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"MJService\");\n        }\n        */\n\n        /*\n        {\n            const slot = this.newSlot(\"azureService\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(AzureService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"AzureService\");\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"youtubeService\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(YouTubeService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"YouTubeService\");\n        }\n\n        {\n            const slot = this.newSlot(\"peerService\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(PeerService);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"PeerService\");\n        }\n\n        {\n            const slot = this.newSlot(\"speechToTextSessions\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(SpeechToTextSessions);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"SpeechToTextSessions\");\n        }\n\n        {\n            const slot = this.newSlot(\"proxyServers\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(ProxyServers);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"ProxyServers\");\n        }\n\n        {\n            const slot = this.newSlot(\"homeAssistants\", null)\n            slot.setShouldStoreSlot(true);\n            slot.setFinalInitProto(HomeAssistants);\n            slot.setIsSubnode(true);\n            slot.setSlotType(\"HomeAssistants\");\n        }\n    }\n\n    init () {\n        super.init()\n        this.setTitle(\"Services\");\n        this.setNodeCanReorderSubnodes(false);\n        this.setShouldStore(true);\n        this.setShouldStoreSubnodes(false);\n        return this;\n    }\n\n    aiServices () {\n        return this.subnodes().filter(sn => sn.thisClass().isKindOf(AiService));\n    }\n\n    // --- ai model helpers ---\n\n    defaultChatModel () {\n        return this.aiServices().first().defaultChatModel();\n    }\n\n    chatModels () {\n        return this.aiServices().map(s => s.models().subnodes()).flat();\n    }\n\n    chatModelNames () {\n        const names = this.chatModels().map(m => m.modelName());\n        return names;\n    }\n\n    chatModelWithName (name) {\n        return this.chatModels().detect(m => m.modelName() === name);\n    }\n\t\n}.initThisClass());\n",
  "QQZZuImndSoX8bBhSnp/7syLxPwlYODkOTnu9anj0fc=": "\"use strict\";\n\n/*\n    \n    BMSettingsNode\n\n    Do we want:\n    - a static set of slots whose values are shown as subnodes?\n    - just have some accessors that look up subnodes by title?\n\n    Using slots might allow better use of slot meta data, and \n    we already have inspector for slot meta data...\n\n    slot.setIsSubnodeTitled(title)\n    - on didInit() (after deserialization) we enumerate these slots and:\n    -- foreach slot with subnodeTitle:\n    --- if subnode is present, set slot value to subnode \n    --- else alloc slot via initProto and add then add subnode for it\n\n*/\n\n(class BMSettingsNode extends BMStorableNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.addSubnodeSlot(\"prototypes\", BMNode);\n        }\n\n        {\n            const slot = this.addSubnodeSlot(\"resources\", BMResources);\n        }\n\n        {\n            const slot = this.addSubnodeSlot(\"storage\", BMDataStore);\n        }\n\n        {\n            const slot = this.addSubnodeSlot(\"blobs\", BMBlobs);\n        }\n        \n    }\n\n    addSubnodeSlot (slotName, proto) {\n        const slot = this.newSlot(slotName, null);\n        slot.setShouldStoreSlot(true);\n        slot.setFinalInitProto(proto);\n        slot.setIsSubnode(true);\n        return slot;\n    }\n  \n    initPrototype () {\n        this.setNodeCanReorderSubnodes(false);\n        this.setNodeCanAddSubnode(true);\n\n        // settings are effectively a global node that references other globals\n        // so we don't need to store it (for now)\n\n        this.setShouldStore(false);\n        this.setShouldStoreSubnodes(false);\n    }\n\n}.initThisClass());",
  "RDK7fqqWK/ltGRdKP41iU/h+KBdz8mKOYyuXPIGovXY=": "\"use strict\";\n\n/*\n    \n    BreadCrumbsNode\n    \n\n*/\n\n(class BreadCrumbsNode extends BMFolderNode {\n    \n    initPrototypeSlots () {\n        /*\n        {\n            const slot = this.newSlot(\"blobs\", null)\n            slot.setFinalInitProto(BMBlobs)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n        */\n    }\n  \n    initPrototype () {\n        this.setNodeTileClassName(\"BreadCrumbsTile\");\n        this.setCanDelete(false);\n        this.setNodeMinTileHeight(55);\n        this.setNodeCanReorderSubnodes(false);\n        this.setNodeIsVertical(true);\n        this.setNodeCanAddSubnode(false);\n    }\n\n}.initThisClass());",
  "UJESqgT9F80S/L1oz7afz3zpYr9TEOcU5nMQz37WQaU=": "\"use strict\";\n\n/*\n    \n    HeaderNode\n    \n    This singleton sets up: \n\n    - themes (inspectable) slot\n    - blobs (inspectable) slot\n    - breadcrumb subnode\n\n    (if not already set up after loading from store)\n\n*/\n\n(class HeaderNode extends BMFolderNode {\n    \n    initPrototypeSlots () {\n\n        {\n            const slot = this.newSlot(\"blobs\", null)\n            slot.setFinalInitProto(BMBlobs)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n\n        {\n            const slot = this.newSlot(\"themes\", null)\n            slot.setFinalInitProto(BMThemeResources)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }        \n        \n        {\n            const slot = this.newSlot(\"prototypes\", null)\n            slot.setFinalInitProto(BMPrototypesNode)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n\n        /*\n        {\n            const slot = this.newSlot(\"settings\", null)\n            slot.setShouldStoreSlot(false)\n            slot.setCanInspect(true)\n        }\n        */\n\n        /*\n        {\n            const slot = this.newSlot(\"settings\", true)\n            slot.setShouldStoreSlot(false)\n            //slot.setSlotType(\"Boolean\")\n            slot.setCanInspect(true)\n        }\n\n\n        {\n            const slot = this.newSlot(\"breadCrumbs\", true)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n        }\n        */\n\n        {\n            const slot = this.newSlot(\"breadCrumbsNode\", null);\n            slot.setFinalInitProto(BreadCrumbsNode)\n            slot.setShouldStoreSlot(true)\n            slot.setCanInspect(true)\n            slot.setIsSubnode(true)\n        }\n    }\n  \n    initPrototype () {\n        this.setNodeCanReorderSubnodes(true);\n        //this.setNodeCanAddSubnode(true);\n        //const node = BMFolderNode.clone(); // FolderNode?\n        this.setNodeTileClassName(\"HeaderTile\");\n        this.setNodeMinTileHeight(100);\n        this.setTitle(\"my app header\");\n        this.setNodeCanEditTitle(true);\n        this.setNodeIsVertical(false);\n        this.setCanDelete(false);\n        this.setNodeCanAddSubnode(false);\n        this.setShouldStoreSubnodes(false);\n    }\n\n    onTapOfNode () {\n        super.onTapOfNode()\n        setTimeout(() => this.postShouldFocusAndExpandSubnode(this.breadCrumbsNode()), 0)\n    }\n\n}.initThisClass());",
  "wIm5Wpti1Ah7hd+2YHQf+CHvgYfMxgC2shILBF1d3aI=": "\"use strict\";\n\n/*\n    \n    RootContentNode\n\n    Root node to use for app persistent store.\n    The app is responsible for loading this from the store or creating it if it doesn't exist.\n\n    The BrowserView node should be this node.\n    The app header node is a subnode of this one, and the breadcrumbs node would be a subnode of the header.\n    \n    This singleton sets up: \n\n    - themes (inspectable) slot\n    - blobs (inspectable) slot\n    - breadcrumb subnode\n\n    (if not already set up after loading from store)\n\n*/\n\n(class RootContentNode extends BMFolderNode {\n    \n    initPrototypeSlots () {\n        {\n            const slot = this.newSlot(\"browserHeaderNode\", null)\n            slot.setShouldStoreSlot(true)\n            slot.setFinalInitProto(HeaderNode)\n            slot.setIsSubnode(true)\n        }\n    }\n  \n    initPrototype () {\n        this.setTitle(\"Root Content Node\");\n        this.setNodeCanReorderSubnodes(true);\n        this.setNodeMinTileHeight(75);\n        this.setNodeIsVertical(false); // not setting BrowserView to down direction - why?\n        this.setNodeCanReorderSubnodes(false);\n        this.setShouldStoreSubnodes(false);\n        this.setNodeCanAddSubnode(false);\n    }\n\n}.initThisClass());",
  "6YJNcH9GgUI9IcFPVxIc+OzFQWbef8PyLThmBFg8P60=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 37.644 37.644\" style=\"enable-background:new 0 0 37.644 37.644;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M37.644,5.957c0,0.829-0.672,1.5-1.5,1.5h-2.118v2.119c0,0.829-0.672,1.5-1.5,1.5s-1.5-0.671-1.5-1.5V7.457h-2.119\r\n\t\tc-0.828,0-1.5-0.671-1.5-1.5c0-0.829,0.672-1.5,1.5-1.5h2.119V2.339c0-0.829,0.672-1.5,1.5-1.5s1.5,0.671,1.5,1.5v2.118h2.118\r\n\t\tC36.972,4.457,37.644,5.129,37.644,5.957z M33.246,28.093l-10.557-3.299c2.28-2.717,3.668-7.024,3.668-11.055\r\n\t\tC26.357,7.64,22.88,3.7,17.502,3.7c-5.38,0-8.857,3.94-8.857,10.039c0,4.03,1.387,8.338,3.669,11.055L1.756,28.093\r\n\t\tC0.711,28.419,0,29.384,0,30.48v3.824c0,1.383,1.119,2.5,2.5,2.5h30.002c1.381,0,2.5-1.117,2.5-2.5V30.48\r\n\t\tC35.002,29.386,34.291,28.42,33.246,28.093z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "T7gERds4SLhKX/T8PAbsMm6tA5V3D4s0gHs2OnhlvZs=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 401.994 401.994\" style=\"enable-background:new 0 0 401.994 401.994;\" xml:space=\"preserve\">\r\n\t<path d=\"M394,154.175c-5.331-5.33-11.806-7.994-19.417-7.994H255.811V27.406c0-7.611-2.666-14.084-7.994-19.414\r\n\t\tC242.488,2.666,236.02,0,228.398,0h-54.812c-7.612,0-14.084,2.663-19.414,7.993c-5.33,5.33-7.994,11.803-7.994,19.414v118.775\r\n\t\tH27.407c-7.611,0-14.084,2.664-19.414,7.994S0,165.973,0,173.589v54.819c0,7.618,2.662,14.086,7.992,19.411\r\n\t\tc5.33,5.332,11.803,7.994,19.414,7.994h118.771V374.59c0,7.611,2.664,14.089,7.994,19.417c5.33,5.325,11.802,7.987,19.414,7.987\r\n\t\th54.816c7.617,0,14.086-2.662,19.417-7.987c5.332-5.331,7.994-11.806,7.994-19.417V255.813h118.77\r\n\t\tc7.618,0,14.089-2.662,19.417-7.994c5.329-5.325,7.994-11.793,7.994-19.411v-54.819C401.991,165.973,399.332,159.502,394,154.175z\" />\r\n</svg>\r\n",
  "ekFgS5X2gRaqVYXB/4Cj3y6JDCuf9NPAjQHGduljdUA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 150 150\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#000000\" d=\"M74.997,1.917c-5.786,0-10.495,4.71-10.495,10.5c0,5.789,4.709,10.501,10.495,10.501\r\n\t\tc5.79,0,10.505-4.712,10.505-10.501C85.502,6.626,80.787,1.917,74.997,1.917z\" />\r\n\t\t<path fill=\"#000000\" d=\"M74.998,71.359c-4.135,0-7.498,3.363-7.498,7.5c0,4.137,3.363,7.5,7.498,7.5c4.136,0,7.502-3.363,7.502-7.5\r\n\t\tC82.5,74.722,79.134,71.359,74.998,71.359z\" />\r\n\t\t<path fill=\"#000000\" d=\"M74.998,139.084c-2.479,0-4.496,2.018-4.496,4.5s2.018,4.5,4.496,4.5c2.483,0,4.504-2.018,4.504-4.5\r\n\t\tS77.481,139.084,74.998,139.084z\" />\r\n\t\t<path fill=\"#000000\" d=\"M7.968,71.947c-4.136,0-7.499,3.363-7.499,7.5c0,4.137,3.363,7.5,7.499,7.5c4.138,0,7.501-3.363,7.501-7.5\r\n\t\tC15.469,75.31,12.105,71.947,7.968,71.947z\" />\r\n\t\t<path fill=\"#000000\" d=\"M142.029,71.947c-4.135,0-7.498,3.363-7.498,7.5c0,4.137,3.363,7.5,7.498,7.5s7.502-3.363,7.502-7.5\r\n\t\tC149.531,75.31,146.164,71.947,142.029,71.947z\" />\r\n\t\t<path fill=\"#000000\" d=\"M108.367,37.083c-4.966,0-9.002,4.037-9.002,8.999c0,4.965,4.036,9.001,9.002,9.001\r\n\t\tc4.96,0,8.998-4.036,8.998-9.001C117.365,41.121,113.327,37.083,108.367,37.083z\" />\r\n\t\t<path fill=\"#000000\" d=\"M40.776,37.083c-4.965,0-9.001,4.037-9.001,8.999c0,4.965,4.036,9.001,9.001,9.001\r\n\t\tc4.961,0,8.999-4.036,8.999-9.001C49.775,41.121,45.737,37.083,40.776,37.083z\" />\r\n\t\t<path fill=\"#000000\" d=\"M108.366,107.102c-3.309,0-6.001,2.689-6.001,5.998c0,3.307,2.692,6.002,6.001,6.002\r\n\t\tc3.31,0,5.999-2.695,5.999-6.002C114.365,109.791,111.676,107.102,108.366,107.102z\" />\r\n\t\t<path fill=\"#000000\" d=\"M40.776,107.102c-3.309,0-6.003,2.689-6.003,5.998c0,3.307,2.694,6.002,6.003,6.002\r\n\t\tc3.307,0,5.997-2.695,5.997-6.002C46.773,109.791,44.083,107.102,40.776,107.102z\" />\r\n\t</g>\r\n</svg>\r\n",
  "gP8qW5ViMbxlTuIu10aJps/VG6iORPNGen9voK8yeTM=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 490.2 490.2\" style=\"enable-background:new 0 0 490.2 490.2;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<path d=\"M420.95,61.8C376.25,20.6,320.65,0,254.25,0c-69.8,0-129.3,23.4-178.4,70.3s-73.7,105.2-73.7,175   c0,66.9,23.4,124.4,70.1,172.6c46.9,48.2,109.9,72.3,189.2,72.3c47.8,0,94.7-9.8,140.7-29.5c15-6.4,22.3-23.6,16.2-38.7l0,0   c-6.3-15.6-24.1-22.8-39.6-16.2c-40,17.2-79.2,25.8-117.4,25.8c-60.8,0-107.9-18.5-141.3-55.6c-33.3-37-50-80.5-50-130.4   c0-54.2,17.9-99.4,53.6-135.7c35.6-36.2,79.5-54.4,131.5-54.4c47.9,0,88.4,14.9,121.4,44.7s49.5,67.3,49.5,112.5   c0,30.9-7.6,56.7-22.7,77.2c-15.1,20.6-30.8,30.8-47.1,30.8c-8.8,0-13.2-4.7-13.2-14.2c0-7.7,0.6-16.7,1.7-27.1l18.6-152.1h-64   l-4.1,14.9c-16.3-13.3-34.2-20-53.6-20c-30.8,0-57.2,12.3-79.1,36.8c-22,24.5-32.9,56.1-32.9,94.7c0,37.7,9.7,68.2,29.2,91.3   c19.5,23.2,42.9,34.7,70.3,34.7c24.5,0,45.4-10.3,62.8-30.8c13.1,19.7,32.4,29.5,57.9,29.5c37.5,0,69.9-16.3,97.2-49   c27.3-32.6,41-72,41-118.1C488.05,152.9,465.75,103,420.95,61.8z M273.55,291.9c-11.3,15.2-24.8,22.9-40.5,22.9   c-10.7,0-19.3-5.6-25.8-16.8c-6.6-11.2-9.9-25.1-9.9-41.8c0-20.6,4.6-37.2,13.8-49.8s20.6-19,34.2-19c11.8,0,22.3,4.7,31.5,14.2   s13.8,22.1,13.8,37.9C290.55,259.2,284.85,276.6,273.55,291.9z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "zQq+OSCKvRjlfIaWqZG3zIYV0nwDUQcb9S281elHjM4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 25.314 25.314\" style=\"enable-background:new 0 0 25.314 25.314;\" xml:space=\"preserve\">\n\t<g>\n\t\t<path d=\"M24.663,20.725c-0.086,0.168-0.258,0.271-0.443,0.271h-8.762c0.171,0.383,0.27,0.803,0.27,1.246   c0,1.697-1.375,3.072-3.07,3.072c-1.694,0-3.07-1.375-3.07-3.072c0-0.443,0.099-0.863,0.271-1.246H1.096   c-0.188,0-0.358-0.104-0.445-0.271c-0.084-0.166-0.069-0.366,0.041-0.521l4.17-5.787V7.798C4.861,3.498,8.359,0,12.659,0   c4.301,0,7.798,3.498,7.798,7.798v6.619l4.171,5.787C24.732,20.358,24.748,20.559,24.663,20.725z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "HbXKAnjOloDeucLWXkGJnSxUozQMnmvYAZpmIZmougQ=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 27.75 27.75\" style=\"enable-background:new 0 0 27.75 27.75;\" xml:space=\"preserve\">\n\t<g>\n\t\t<path d=\"M13.875,27.75l-4.268-7.393H4.273c-2.195,0-3.98-1.618-3.98-3.609V3.61C0.293,1.619,2.079,0,4.273,0h19.204   c2.194,0,3.979,1.619,3.979,3.61v13.138c0,1.991-1.785,3.609-3.979,3.609h-5.334L13.875,27.75z M4.273,2   c-1.091,0-1.98,0.722-1.98,1.61v13.138c0,0.888,0.889,1.609,1.98,1.609h6.486l3.113,5.393l3.112-5.393h6.49   c1.092,0,1.979-0.722,1.979-1.609V3.61c0-0.888-0.89-1.61-1.979-1.61H4.273z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "FRuLDx/lSUQCq/ihFdJuu7GiBpVFkQiHwR40ODLB7gs=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 491.536,108.384l-147.152,148.048l 147.152,147.168c 6.16,6.144, 6.16,16.112,0.00,22.272 l-66.816,66.80c-6.128,6.16-16.096,6.16-22.256,0.00l-146.912-146.912l-146.032,146.912c-6.144,6.16-16.112,6.16-22.272,0.00l-66.80-66.80 c-6.144-6.16-6.144-16.128,0.00-22.272l 146.032-146.912L 20.464,110.672c-6.144-6.144-6.144-16.112,0.00-22.272l 66.80-66.80 c 6.144-6.16, 16.112-6.16, 22.272,0.00l 145.76,145.76l 147.184-148.048c 6.16-6.16, 16.128-6.16, 22.256,0.00l 66.816,66.80 C 497.68,92.272, 497.68,102.24, 491.536,108.384z\">\n\t</path>\n</svg>\n",
  "cCfxfug+8DAuC9LZnM3T4ZbyZI355NmSZlMCK4pRUEg=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm-1.959 17l-4.5-4.319 1.395-1.435 3.08 2.937 7.021-7.183 1.422 1.409-8.418 8.591z\" />\n</svg>\n",
  "QEWr9VW3thd5hGhxMJXA15c1tugfh9gldP6h/s/mBV0=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M12 0c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm4.597 17.954l-4.591-4.55-4.555 4.596-1.405-1.405 4.547-4.592-4.593-4.552 1.405-1.405 4.588 4.543 4.545-4.589 1.416 1.403-4.546 4.587 4.592 4.548-1.403 1.416z\" />\n</svg>\n",
  "wFWs3Ccg3urcRpOuBzy2l55JA0TI9VrTJlM/+nS7+PU=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M10.041 17l-4.5-4.319 1.395-1.435 3.08 2.937 7.021-7.183 1.422 1.409-8.418 8.591zm-5.041-15c-1.654 0-3 1.346-3 3v14c0 1.654 1.346 3 3 3h14c1.654 0 3-1.346 3-3v-14c0-1.654-1.346-3-3-3h-14zm19 3v14c0 2.761-2.238 5-5 5h-14c-2.762 0-5-2.239-5-5v-14c0-2.761 2.238-5 5-5h14c2.762 0 5 2.239 5 5z\" />\n</svg>\n",
  "AtXBTMzNDnnbjQRBUlY7feyQwGECzXLk1TnnruKxBzE=": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\">\n\t<path d=\"M5 2c-1.654 0-3 1.346-3 3v14c0 1.654 1.346 3 3 3h14c1.654 0 3-1.346 3-3v-14c0-1.654-1.346-3-3-3h-14zm19 3v14c0 2.761-2.238 5-5 5h-14c-2.762 0-5-2.239-5-5v-14c0-2.761 2.238-5 5-5h14c2.762 0 5 2.239 5 5z\" />\n</svg>\n",
  "xp/LIoGZgjCT46DaqcjiDX8pQLqC0qCLXOV2cxIROEE=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 463.968,136.496l-34.144-34.144c-6.304-6.288-16.48-6.288-22.768,0.00L 202.336,307.072 L 104.96,208.992c-6.288-6.288-16.464-6.288-22.768,0.00l-34.144,34.144c-6.288,6.304-6.288,16.48,0.00,22.768l 142.784,143.744 c 6.288,6.288, 16.48,6.288, 22.768,0.00L 463.968,159.264C 470.256,152.992, 470.256,142.784, 463.968,136.496z\">\n\t</path>\n</svg>\n",
  "XoUYzCCSx/NW1Ed8q0Yk/QI0gm1yNQRLohEVxF0kUms=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 23.331 23.331\" style=\"enable-background:new 0 0 23.331 23.331;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path style=\"fill:#010002;\" d=\"M16.043,11.667L22.609,5.1c0.963-0.963,0.963-2.539,0-3.502l-0.875-0.875\r\n\t\tc-0.963-0.964-2.539-0.964-3.502,0L11.666,7.29L5.099,0.723c-0.962-0.963-2.538-0.963-3.501,0L0.722,1.598\r\n\t\tc-0.962,0.963-0.962,2.539,0,3.502l6.566,6.566l-6.566,6.567c-0.962,0.963-0.962,2.539,0,3.501l0.876,0.875\r\n\t\tc0.963,0.963,2.539,0.963,3.501,0l6.567-6.565l6.566,6.565c0.963,0.963,2.539,0.963,3.502,0l0.875-0.875\r\n\t\tc0.963-0.963,0.963-2.539,0-3.501L16.043,11.667z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Tg4a2aAuIfmasnxZ/cd1o1L7I0cEJU6/hbV53Btyf7A=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 174.239 174.239\" style=\"enable-background:new 0 0 174.239 174.239;\" xml:space=\"preserve\">\r\n\t<path d=\"M146.537,1.047c-1.396-1.396-3.681-1.396-5.077,0L89.658,52.849c-1.396,1.396-3.681,1.396-5.077,0L32.78,1.047\r\n\tc-1.396-1.396-3.681-1.396-5.077,0L1.047,27.702c-1.396,1.396-1.396,3.681,0,5.077l51.802,51.802c1.396,1.396,1.396,3.681,0,5.077\r\n\tL1.047,141.46c-1.396,1.396-1.396,3.681,0,5.077l26.655,26.655c1.396,1.396,3.681,1.396,5.077,0l51.802-51.802\r\n\tc1.396-1.396,3.681-1.396,5.077,0l51.801,51.801c1.396,1.396,3.681,1.396,5.077,0l26.655-26.655c1.396-1.396,1.396-3.681,0-5.077\r\n\tl-51.801-51.801c-1.396-1.396-1.396-3.681,0-5.077l51.801-51.801c1.396-1.396,1.396-3.681,0-5.077L146.537,1.047z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "OvobHd6hZALZkJa7ZyZ4WahgNy/uMZVWbAsCwjN+76o=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 192.00,256.00l-32.176,77.44L 256.00,320.00L 192.00,256.00z M 224.00,229.824L 282.192,288.00L 512.00,58.192L 453.808,0.00 L 224.00,229.824z M 64.00,0.00C 32.00,0.00,0.00,32.00,0.00,64.00l0.00,384.00 c0.00,32.00, 32.00,64.00, 64.00,64.00l 384.00,0.00 c 32.00,0.00, 64.00-32.00, 64.00-64.00L 512.00,134.40 L 448.00,172.80L 448.00,384.00 c0.00,32.00-32.00,64.00-64.00,64.00L 128.00,448.00 c-32.00,0.00-64.00-32.00-64.00-64.00L 64.00,128.00 c0.00-32.00, 32.00-64.00, 64.00-64.00l 192.00,0.00 l 64.00-64.00L 64.00,0.00 z\">\n\t</path>\n</svg>\n",
  "ToEiSRDvSnI3D5lvq28KAWQle6zgsFyeGzPvhHNSaGo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 459 459\" style=\"enable-background:new 0 0 459 459;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g id=\"delete\">\r\n\t\t\t<path d=\"M76.5,408c0,28.05,22.95,51,51,51h204c28.05,0,51-22.95,51-51V102h-306V408z M408,25.5h-89.25L293.25,0h-127.5l-25.5,25.5\r\n\t\t\tH51v51h357V25.5z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "mgQPMx6Ry/V65gFY88531cIgKaXfFWIYUb8jR5qIuiE=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 96.00,96.00l-96.00,96.00l 256.00,256.00l 256.00-256.00l-96.00-96.00L 256.00,256.00L 96.00,96.00z\">\n\t</path>\n</svg>\n",
  "yy5Bz98Cdj44asW/ySQ+twRVrI2ncszKxtJw6Sv3QVY=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 27.857 27.857\" style=\"enable-background:new 0 0 27.857 27.857;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path style=\"fill:#010002;\" d=\"M2.203,5.331l10.034,7.948c0.455,0.36,1.082,0.52,1.691,0.49c0.608,0.03,1.235-0.129,1.69-0.49\r\n\t\t\tl10.034-7.948c0.804-0.633,0.622-1.152-0.398-1.152H13.929H2.604C1.583,4.179,1.401,4.698,2.203,5.331z\" />\r\n\t\t\t<path style=\"fill:#010002;\" d=\"M26.377,7.428l-10.965,8.325c-0.41,0.308-0.947,0.458-1.482,0.451\r\n\t\t\tc-0.536,0.007-1.073-0.144-1.483-0.451L1.48,7.428C0.666,6.811,0,7.142,0,8.163v13.659c0,1.021,0.836,1.857,1.857,1.857h12.071H26\r\n\t\t\tc1.021,0,1.857-0.836,1.857-1.857V8.163C27.857,7.142,27.191,6.811,26.377,7.428z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "T5Xkjz+OTwP3xh1kUbuHRuziWCU8L6LV47nrPS0W4hE=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 20 20\" style=\"enable-background:new 0 0 20 20;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path style=\"fill:#030104;\" d=\"M19.82,9.43c-0.083-0.119-2.062-2.944-4.793-4.875C13.612,3.552,11.826,3,10,3\r\n\t\tC8.175,3,6.389,3.552,4.97,4.555C2.238,6.486,0.261,9.311,0.179,9.43c-0.238,0.343-0.238,0.798,0,1.141\r\n\t\tc0.083,0.119,2.06,2.944,4.791,4.875C6.389,16.448,8.175,17,10,17c1.826,0,3.612-0.552,5.028-1.555\r\n\t\tc2.731-1.931,4.71-4.756,4.793-4.875C20.059,10.228,20.059,9.772,19.82,9.43z M10,13.5c-1.934,0-3.5-1.57-3.5-3.5\r\n\t\tc0-1.934,1.566-3.5,3.5-3.5c1.93,0,3.5,1.566,3.5,3.5C13.5,11.93,11.93,13.5,10,13.5z\" />\r\n\t\t<g>\r\n\t\t\t<path style=\"fill:#030104;\" d=\"M12,10c0,1.102-0.898,2-2,2c-1.105,0-2-0.898-2-2c0-1.105,0.895-2,2-2C11.102,8,12,8.895,12,10z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "DOjG174x6FB9F/ZtnO6kTxBWRYGYIXbf6GKo80ZbeMU=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 500 500\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 250.00,30.00L 309.70,198.05L 470.00,198.05L 339.20,296.75L 385.95,470.00L 250.00,366.15L 114.05,470.00L 160.80,296.75L 30.00,198.05L 190.30,198.05 z\">\n\t</path>\n</svg>\n",
  "qDSZJFFZz7IvTnu+TZexv5VwD+fV6f4g5/BpahnxDFw=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 268.765 268.765\" style=\"enable-background:new 0 0 268.765 268.765;\" xml:space=\"preserve\">\r\n\t<g id=\"Settings\">\r\n\t\t<g>\r\n\t\t\t<path style=\"fill-rule:evenodd;clip-rule:evenodd;\" d=\"M267.92,119.461c-0.425-3.778-4.83-6.617-8.639-6.617\r\n\t\t\tc-12.315,0-23.243-7.231-27.826-18.414c-4.682-11.454-1.663-24.812,7.515-33.231c2.889-2.641,3.24-7.062,0.817-10.133\r\n\t\t\tc-6.303-8.004-13.467-15.234-21.289-21.5c-3.063-2.458-7.557-2.116-10.213,0.825c-8.01,8.871-22.398,12.168-33.516,7.529\r\n\t\t\tc-11.57-4.867-18.866-16.591-18.152-29.176c0.235-3.953-2.654-7.39-6.595-7.849c-10.038-1.161-20.164-1.197-30.232-0.08\r\n\t\t\tc-3.896,0.43-6.785,3.786-6.654,7.689c0.438,12.461-6.946,23.98-18.401,28.672c-10.985,4.487-25.272,1.218-33.266-7.574\r\n\t\t\tc-2.642-2.896-7.063-3.252-10.141-0.853c-8.054,6.319-15.379,13.555-21.74,21.493c-2.481,3.086-2.116,7.559,0.802,10.214\r\n\t\t\tc9.353,8.47,12.373,21.944,7.514,33.53c-4.639,11.046-16.109,18.165-29.24,18.165c-4.261-0.137-7.296,2.723-7.762,6.597\r\n\t\t\tc-1.182,10.096-1.196,20.383-0.058,30.561c0.422,3.794,4.961,6.608,8.812,6.608c11.702-0.299,22.937,6.946,27.65,18.415\r\n\t\t\tc4.698,11.454,1.678,24.804-7.514,33.23c-2.875,2.641-3.24,7.055-0.817,10.126c6.244,7.953,13.409,15.19,21.259,21.508\r\n\t\t\tc3.079,2.481,7.559,2.131,10.228-0.81c8.04-8.893,22.427-12.184,33.501-7.536c11.599,4.852,18.895,16.575,18.181,29.167\r\n\t\t\tc-0.233,3.955,2.67,7.398,6.595,7.85c5.135,0.599,10.301,0.898,15.481,0.898c4.917,0,9.835-0.27,14.752-0.817\r\n\t\t\tc3.897-0.43,6.784-3.786,6.653-7.696c-0.451-12.454,6.946-23.973,18.386-28.657c11.059-4.517,25.286-1.211,33.281,7.572\r\n\t\t\tc2.657,2.89,7.047,3.239,10.142,0.848c8.039-6.304,15.349-13.534,21.74-21.494c2.48-3.079,2.13-7.559-0.803-10.213\r\n\t\t\tc-9.353-8.47-12.388-21.946-7.529-33.524c4.568-10.899,15.612-18.217,27.491-18.217l1.662,0.043\r\n\t\t\tc3.853,0.313,7.398-2.655,7.865-6.588C269.044,139.917,269.058,129.639,267.92,119.461z M134.595,179.491\r\n\t\t\tc-24.718,0-44.824-20.106-44.824-44.824c0-24.717,20.106-44.824,44.824-44.824c24.717,0,44.823,20.107,44.823,44.824\r\n\t\t\tC179.418,159.385,159.312,179.491,134.595,179.491z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "mY/E1jjfwNQUXVSd8j4L1mhO5473MosryyH9B6TydKo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Layer_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M256,151c-57.897,0-105,47.103-105,105c0,57.897,47.103,105,105,105c57.897,0,105-47.103,105-105    C361,198.103,313.897,151,256,151z M256,331c-41.355,0-75-33.645-75-75c0-41.355,33.645-75,75-75s75,33.645,75,75    S297.355,331,256,331z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M500.582,211.434l-58.674-14.428c-3.532-11.13-8.068-21.925-13.551-32.249c8.78-14.634,27.343-45.573,27.343-45.573    c3.541-5.902,2.611-13.457-2.256-18.324l-42.426-42.426c-4.867-4.867-12.422-5.797-18.324-2.256    c-0.38,0.228-30.777,18.466-45.626,27.355c-10.269-5.431-20.995-9.927-32.052-13.434c-4.428-17.976-14.451-58.686-14.452-58.686    C298.914,4.711,292.902,0,286,0h-60c-6.903,0-12.915,4.711-14.565,11.414c-4.126,16.76-11.024,44.779-14.45,58.68    c-11.762,3.73-23.143,8.578-34.001,14.482c-6.428-3.856-16.007-9.604-24.869-14.921l-22.462-13.477    c-5.905-3.541-13.457-2.61-18.324,2.256L54.901,100.86c-4.867,4.867-5.797,12.422-2.256,18.324    c0.2,0.335,17.785,29.644,29.271,48.869c-4.712,9.31-8.665,18.986-11.817,28.919c-20.002,4.976-58.223,14.35-58.671,14.46    C4.718,213.077,0,219.092,0,226v60c0,6.909,4.719,12.923,11.429,14.568c0.443,0.109,38.381,9.411,58.687,14.436    c3.565,11.302,8.184,22.273,13.796,32.78l-26.194,43.66c-3.541,5.902-2.611,13.458,2.256,18.324l42.427,42.427    c4.867,4.868,12.421,5.797,18.324,2.256c0.369-0.222,29.463-17.678,43.746-26.227c10.419,5.547,21.313,10.131,32.547,13.692    l14.416,58.66C213.079,507.284,219.093,512,226,512h60c6.904,0,12.917-4.713,14.566-11.418l14.427-58.669    c11.539-3.661,22.671-8.39,33.257-14.128c14.427,8.656,44.444,26.667,44.444,26.667c5.901,3.541,13.457,2.612,18.324-2.256    l42.426-42.427c4.867-4.867,5.797-12.422,2.256-18.324c0,0-18.271-30.452-26.958-44.931c5.308-10.088,9.712-20.634,13.161-31.511    c17.824-4.399,58.19-14.317,58.676-14.436C507.285,298.919,512,292.906,512,286v-60C512,219.095,507.287,213.083,500.582,211.434z     M482,274.24c-17.32,4.257-48.723,11.979-54.72,13.479l-1.131,0.283c-5.231,1.36-9.326,5.43-10.719,10.653    c-3.795,14.229-9.495,27.872-16.942,40.548c-2.779,4.732-2.753,10.605,0.069,15.312c0.78,1.301,16.489,27.483,25.393,42.322    L398.087,422.7c-15.046-9.027-41.716-25.029-41.942-25.165c-4.775-2.866-10.743-2.853-15.501,0.035    c-13,7.885-27.109,13.892-41.938,17.854c-5.177,1.383-9.224,5.422-10.614,10.597c-0.828,3.081-1.644,6.34-1.658,6.397L274.241,482    h-36.479l-10.813-44.042l-2.916-11.664c-1.322-5.292-5.415-9.45-10.686-10.855c-14.533-3.876-28.479-9.747-41.449-17.447    c-4.709-2.797-10.57-2.802-15.285-0.018c-3.23,1.908-27.254,16.313-41.282,24.728l-25.865-25.865l24.661-41.104    c2.841-4.736,2.85-10.65,0.022-15.395c-7.784-13.063-13.685-27.073-17.535-41.643c-1.397-5.286-5.56-9.393-10.863-10.719    c-10.737-2.684-39.564-9.767-55.752-13.741v-36.473c16.342-4.015,45.537-11.199,55.762-13.786    c5.271-1.334,9.408-5.417,10.812-10.671c3.564-13.347,8.822-26.228,15.63-38.286c2.646-4.686,2.578-10.43-0.177-15.053    c-7.25-12.166-20.08-33.577-27.632-46.172l25.865-25.866l12.42,7.452c14.968,8.981,31.98,19.188,32.44,19.463    c4.768,2.85,10.722,2.832,15.472-0.049c13.341-8.088,27.726-14.222,42.756-18.232c5.264-1.404,9.352-5.552,10.68-10.836    c0.282-1.121,9.071-36.815,13.728-55.726h36.49c4.915,19.958,13.621,55.312,13.724,55.722c1.326,5.288,5.417,9.44,10.685,10.845    c14.382,3.836,28.193,9.626,41.05,17.208c4.714,2.781,10.57,2.773,15.276-0.021c4.208-2.498,28.881-17.293,43.106-25.827    l25.864,25.864c-9.037,15.062-25.121,41.869-25.795,42.991c-2.836,4.725-2.853,10.625-0.043,15.367    c7.628,12.872,13.451,26.714,17.308,41.141c1.382,5.167,5.408,9.207,10.57,10.604c3.097,0.839,6.373,1.657,6.428,1.671    L482,237.758V274.24z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "MLUX1tLgNiMGVDmevSESoOwLITefLy6zkRz2DbCAoeA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 51.997 51.997\" style=\"enable-background:new 0 0 51.997 51.997;\" xml:space=\"preserve\">\r\n\t<path d=\"M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905\r\n\tc-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478\r\n\tc1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014\r\n\tC52.216,18.553,51.97,16.611,51.911,16.242z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "KvfdVXrCilY5NbVUwXs9uGfd5t0RUGOicd1j21sK81A=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 51.997 51.997\" style=\"enable-background:new 0 0 51.997 51.997;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905\r\n\t\tc-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478\r\n\t\tc1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014\r\n\t\tC52.216,18.553,51.97,16.611,51.911,16.242z M49.521,21.261c-0.984,4.172-3.265,7.973-6.59,10.985L25.855,47.481L9.072,32.25\r\n\t\tc-3.331-3.018-5.611-6.818-6.596-10.99c-0.708-2.997-0.417-4.69-0.416-4.701l0.015-0.101C2.725,9.139,7.806,3.826,14.158,3.826\r\n\t\tc4.687,0,8.813,2.88,10.771,7.515l0.921,2.183l0.921-2.183c1.927-4.564,6.271-7.514,11.069-7.514\r\n\t\tc6.351,0,11.433,5.313,12.096,12.727C49.938,16.57,50.229,18.264,49.521,21.261z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "H1TBwTvnGf/BM8oOEamNspvY3ITq/lYk/uG57o9Qz0k=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 50 50\" style=\"enable-background:new 0 0 50 50;\" xml:space=\"preserve\">\r\n\t<path style=\"fill:#D75A4A;\" d=\"M24.85,10.126c2.018-4.783,6.628-8.125,11.99-8.125c7.223,0,12.425,6.179,13.079,13.543\r\n\tc0,0,0.353,1.828-0.424,5.119c-1.058,4.482-3.545,8.464-6.898,11.503L24.85,48L7.402,32.165c-3.353-3.038-5.84-7.021-6.898-11.503\r\n\tc-0.777-3.291-0.424-5.119-0.424-5.119C0.734,8.179,5.936,2,13.159,2C18.522,2,22.832,5.343,24.85,10.126z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "4xL9bcwwiOGdZbiZA+0Btmjz6gUgkovFyCJUudK/x3s=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 495.398 495.398\" style=\"enable-background:new 0 0 495.398 495.398;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<path d=\"M487.083,225.514l-75.08-75.08V63.704c0-15.682-12.708-28.391-28.413-28.391c-15.669,0-28.377,12.709-28.377,28.391\r\n\t\t\t\tv29.941L299.31,37.74c-27.639-27.624-75.694-27.575-103.27,0.05L8.312,225.514c-11.082,11.104-11.082,29.071,0,40.158\r\n\t\t\t\tc11.087,11.101,29.089,11.101,40.172,0l187.71-187.729c6.115-6.083,16.893-6.083,22.976-0.018l187.742,187.747\r\n\t\t\t\tc5.567,5.551,12.825,8.312,20.081,8.312c7.271,0,14.541-2.764,20.091-8.312C498.17,254.586,498.17,236.619,487.083,225.514z\" />\r\n\t\t\t\t<path d=\"M257.561,131.836c-5.454-5.451-14.285-5.451-19.723,0L72.712,296.913c-2.607,2.606-4.085,6.164-4.085,9.877v120.401\r\n\t\t\t\tc0,28.253,22.908,51.16,51.16,51.16h81.754v-126.61h92.299v126.61h81.755c28.251,0,51.159-22.907,51.159-51.159V306.79\r\n\t\t\t\tc0-3.713-1.465-7.271-4.085-9.877L257.561,131.836z\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "/LNRqGCRBK6ydHvLRV9YV3yQ00LxkPEDQI7fZcuxREs=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 79.536 79.537\" style=\"enable-background:new 0 0 79.536 79.537;\" xml:space=\"preserve\">\n<g>\n\t<polygon points=\"9.942,74.565 34.795,74.565 34.795,54.681 44.739,54.681 44.739,74.565 69.595,74.565    69.595,44.739 79.536,44.739 39.769,4.971 0,44.739 9.942,44.739  \" fill=\"#FFFFFF\"/>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n</svg>\n",
  "7ZP9d3UHVGVturRrH1lncDQDPNaaFoYcBMYTVhjp7zo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 510 510\" style=\"enable-background:new 0 0 510 510;\" xml:space=\"preserve\">\n<g>\n\t<g id=\"home\">\n\t\t<polygon points=\"204,471.75 204,318.75 306,318.75 306,471.75 433.5,471.75 433.5,267.75 510,267.75 255,38.25 0,267.75     76.5,267.75 76.5,471.75   \" fill=\"#FFFFFF\"/>\n\t</g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n<g>\n</g>\n</svg>\n",
  "CGfh1124j++HzJgPEcMVt860JH+fhKR4bGHHhvf5QJQ=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\n\t<g>\n\t\t<path d=\"M512,296l-96-96V56h-64v80l-96-96L0,296v16h64v160h160v-96h64v96h160V312h64V296z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "udeWbKT9Is3Mov54VqyftG3t6MDTxfzh6U8XFkAhcIc=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 416.00,416.00l-96.00,96.00L 64.00,256.00L 320.00,0.00l 96.00,96.00L 256.00,256.00L 416.00,416.00z\">\n\t</path>\n</svg>\n",
  "PUOHJ/2kiGO6M2xvtLu3yGuIjuD/Iebxjhxz6Wixp+s=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 398.528 398.528\" style=\"enable-background:new 0 0 398.528 398.528;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<path d=\"M315.232,9.015C311.883,3.276,305.681,0,298.244,0h-91.308c-10.9,0-22.224,7.113-26.93,16.924   L83.17,218.041c-3.162,6.56-2.967,13.518,0.471,19.037c3.463,5.568,9.592,8.811,16.859,8.966l71.662,0.902l-51.877,129.675   c-1.276,3.235-3.959,10.014,0.821,16.981c2.089,3.056,5.674,4.926,9.364,4.926h0.837c6.999,0,11.217-5.308,13.241-7.868   L312.176,180.17c7.153-8.966,4.202-17.013,3.121-19.354c-1.122-2.243-5.625-9.592-17.046-9.592h-53.34l69.8-122.985   C318.37,21.752,318.573,14.729,315.232,9.015z\" fill=\"#FFFFFF\" />\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "qk6VLEA3SEu196CGXwhlwhyoPuriMLzRHD5aNCvDRTo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Layer_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M400.388,175.787c-1.707-3.413-4.267-5.12-7.68-5.12H292.015L391.855,12.8c1.707-2.56,1.707-5.973,0-8.533    S387.588,0,384.175,0H247.642c-3.413,0-5.973,1.707-7.68,4.267l-128,256c-1.707,2.56-1.707,5.973,0,8.533    c1.707,2.56,5.12,4.267,7.68,4.267h87.893l-95.573,227.84c-1.707,3.413,0,7.68,3.413,10.24c0.853,0.853,2.56,0.853,4.267,0.853    c2.56,0,5.12-0.853,6.827-2.56l273.067-324.267C401.242,182.613,402.095,179.2,400.388,175.787z M149.508,454.827l78.507-187.733    c0.853-2.56,0.853-5.12-0.853-7.68c-1.707-1.707-4.267-3.413-6.827-3.413h-87.04L252.762,17.067h116.053L268.122,174.933    c-1.707,2.56-1.707,5.973,0,8.533s4.267,4.267,7.68,4.267h98.987L149.508,454.827z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "OikLBuTUCMxMzYFpvtODuYIDztGJFhzjKvBGpVuVDhM=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 18.1.1, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\" width=\"100%\" height=\"100%\">\n\t<g>\n\t\t<g>\n\t\t\t<g>\n\t\t\t\t<path d=\"M30,92c-8,0-13,0.667-15,2s-2.333,2.833-1,4.5s4.667,4.5,10,8.5c2.667,2,4.667,3.667,6,5l226,172     l226-171l5-5c5.333-4,8.833-6.833,10.5-8.5s1.5-3.333-0.5-5s-7-2.5-15-2.5H241H30z\" fill=\"#FFFFFF\" />\n\t\t\t\t<path d=\"M0,132v254c0,7.333,3,14.833,9,22.5S21,420,27,420h458c6,0,12-3.833,18-11.5s9-15.167,9-22.5V132     L256,328L0,132z\" fill=\"#FFFFFF\" />\n\t\t\t</g>\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "Gi2ygeOXLpsi6jUuoZVlRXJlZ/4oRK979+KBiKqIYcc=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 24 24\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" enable-background=\"new 0 0 24 24\">\n\t<path d=\"m23,10h-8.5c-0.3,0-0.5-0.2-0.5-0.5v-8.5c0-0.6-0.4-1-1-1h-2c-0.6,0-1,0.4-1,1v8.5c0,0.3-0.2,0.5-0.5,0.5h-8.5c-0.6,0-1,0.4-1,1v2c0,0.6 0.4,1 1,1h8.5c0.3,0 0.5,0.2 0.5,0.5v8.5c0,0.6 0.4,1 1,1h2c0.6,0 1-0.4 1-1v-8.5c0-0.3 0.2-0.5 0.5-0.5h8.5c0.6,0 1-0.4 1-1v-2c0-0.6-0.4-1-1-1z\" />\n</svg>\n",
  "6GsrA1ucxJ3ROgtV+vbMl4pJ5MA2OoA+ZNm2hbVh9Yo=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 384 384\" style=\"enable-background:new 0 0 384 384;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M149.333,117.333V32L0,181.333l149.333,149.333V243.2C256,243.2,330.667,277.333,384,352\r\n\t\tC362.667,245.333,298.667,138.667,149.333,117.333z\" />\r\n\t</g>\r\n</svg>\r\n",
  "/JPXVH7ap6Nnn1MFcUUDqbSx0l7h8rvJWcQt5F/OdMA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 95.561 95.561\" style=\"enable-background:new 0 0 95.561 95.561;\" xml:space=\"preserve\">\n\t<g>\n\t\t<g>\n\t\t\t<path d=\"M95.37,56.591c-0.33-0.701-1.034-1.147-1.81-1.147h-6.955V20.729c0-1.104-0.896-2-2-2H26.677    c-0.776,0-1.482,0.449-1.812,1.152c-0.329,0.703-0.222,1.533,0.275,2.129l7.474,8.963c0.38,0.456,0.943,0.719,1.536,0.719h39.491    v23.75h-6.955c-0.774,0-1.479,0.447-1.81,1.148c-0.33,0.7-0.227,1.528,0.268,2.125l13.437,16.25    c0.381,0.459,0.945,0.727,1.542,0.727c0.598,0,1.162-0.266,1.542-0.727l13.438-16.25C95.597,58.119,95.7,57.291,95.37,56.591z\" fill=\"#FFFFFF\" />\n\t\t\t<path d=\"M62.945,64.587c-0.38-0.455-0.942-0.719-1.536-0.719H21.92v-23.75h6.953c0.008,0,0.014,0,0.021,0c1.104,0,2-0.896,2-2    c0-0.574-0.242-1.091-0.628-1.456l-13.286-16.07c-0.38-0.459-0.945-0.726-1.542-0.726s-1.162,0.266-1.542,0.726L0.459,36.844    C-0.035,37.441-0.14,38.27,0.19,38.97c0.33,0.701,1.035,1.148,1.811,1.148h6.955v34.713c0,1.104,0.896,2,2,2h57.929    c0.775,0,1.481-0.449,1.812-1.152c0.329-0.703,0.223-1.532-0.274-2.129L62.945,64.587z\" fill=\"#FFFFFF\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "xiImCr9cnkG2Q3oW1io1lcDhw6GUUwTetpYFY7OoB6Q=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 100 100\" style=\"enable-background:new 0 0 100 100;\" xml:space=\"preserve\">\r\n\t<path d=\"M24.9,66V39.9H35L17.5,20L0,39.9h10.1V70c0,5.523,4.476,10,10,10H65L52.195,66H24.9z M89.9,60.1V30\r\n\t\t\tc0-5.523-4.477-10-10-10H35l12.804,14h27.295v26.1H65L82.5,80L100,60.1H89.9z\" />\r\n</svg>\r\n",
  "S6H5DKACKG0p+8lFXNbR6WbXmj0VWNuMNROSS0E0o+s=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 306 306\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n\t<polygon points=\"94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153\" fill=\"#888\" opacity=\"0.5\"/>\n</svg>\n",
  "5uoYjUmNAayFQvH1raDHOdXWjaozPlzjBI4Hr+waRVw=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\" id=\"Capa_1\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 306 306\" style=\"enable-background:new 0 0 306 306;\" xml:space=\"preserve\">\n\t<g>\n\t\t<g id=\"chevron-right\">\n\t\t\t<polygon points=\"94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153   \" fill=\"#888\" />\n\t\t</g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n\t<g>\n\t</g>\n</svg>\n",
  "LqxuSvC7qy12DAXKRQ1lsyNHvbitUI3FnAt/BGNBWKs=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 64.00,416.00l 96.00,96.00l 256.00-256.00L 160.00,0.00L 64.00,96.00l 160.00,160.00L 64.00,416.00z\">\n\t</path>\n</svg>\n",
  "e0fnuhmCNb7Om569CkCw6lcDBiCvZr6XDOa84SaD1qc=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 92.833 92.833\" style=\"enable-background:new 0 0 92.833 92.833;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M89.834,1.75H3c-1.654,0-3,1.346-3,3v13.334c0,1.654,1.346,3,3,3h86.833c1.653,0,3-1.346,3-3V4.75\r\n\t\t\tC92.834,3.096,91.488,1.75,89.834,1.75z\" />\r\n\t\t\t<path d=\"M89.834,36.75H3c-1.654,0-3,1.346-3,3v13.334c0,1.654,1.346,3,3,3h86.833c1.653,0,3-1.346,3-3V39.75\r\n\t\t\tC92.834,38.096,91.488,36.75,89.834,36.75z\" />\r\n\t\t\t<path d=\"M89.834,71.75H3c-1.654,0-3,1.346-3,3v13.334c0,1.654,1.346,3,3,3h86.833c1.653,0,3-1.346,3-3V74.75\r\n\t\t\tC92.834,73.095,91.488,71.75,89.834,71.75z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Q05ug8gKz1DVejtOGiOhgzpx0Mmh1GqswLarZtkfbt8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 410.23 410.23\" style=\"enable-background:new 0 0 410.23 410.23;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M401.625,364.092l-107.1-107.1c19.125-26.775,30.6-59.288,30.6-93.713c0-89.888-72.675-162.562-162.562-162.562\r\n\t\tS0,73.392,0,163.279s72.675,162.562,162.562,162.562c34.425,0,66.938-11.475,93.713-30.6l107.1,107.1\r\n\t\tc9.562,9.562,26.775,9.562,38.25,0l0,0C413.1,390.867,413.1,375.566,401.625,364.092z M162.562,287.592\r\n\t\tc-68.85,0-124.312-55.463-124.312-124.312c0-68.85,55.462-124.312,124.312-124.312c68.85,0,124.312,55.462,124.312,124.312\r\n\t\tC286.875,232.129,231.412,287.592,162.562,287.592z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "7rt7MhkAN/Gg+rYmrT7Ynl68O/rc3rGU4p2MSQGhiK8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 18.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 334.5 334.5\" style=\"enable-background:new 0 0 334.5 334.5;\" xml:space=\"preserve\">\r\n\t<path d=\"M332.797,13.699c-1.489-1.306-3.608-1.609-5.404-0.776L2.893,163.695c-1.747,0.812-2.872,2.555-2.893,4.481\r\n\ts1.067,3.693,2.797,4.542l91.833,45.068c1.684,0.827,3.692,0.64,5.196-0.484l89.287-66.734l-70.094,72.1\r\n\tc-1,1.029-1.51,2.438-1.4,3.868l6.979,90.889c0.155,2.014,1.505,3.736,3.424,4.367c0.513,0.168,1.04,0.25,1.561,0.25\r\n\tc1.429,0,2.819-0.613,3.786-1.733l48.742-56.482l60.255,28.79c1.308,0.625,2.822,0.651,4.151,0.073\r\n\tc1.329-0.579,2.341-1.705,2.775-3.087L334.27,18.956C334.864,17.066,334.285,15.005,332.797,13.699z\" />\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Zm1ZR1Egp4yAdzM4xNCxJrJC7A+lbFJnlfzMKswFzes=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<path d=\"M256,192c-35.292,0-64,28.708-64,64s28.708,64,64,64s64-28.708,64-64S291.292,192,256,192z M256,298.667\r\n\t\t\t\tc-23.521,0-42.667-19.135-42.667-42.667s19.146-42.667,42.667-42.667s42.667,19.135,42.667,42.667S279.521,298.667,256,298.667z\" />\r\n\t\t\t\t<path d=\"M256,384c-35.292,0-64,28.708-64,64c0,35.292,28.708,64,64,64s64-28.708,64-64C320,412.708,291.292,384,256,384z\r\n\t\t\t\t M256,490.667c-23.521,0-42.667-19.135-42.667-42.667s19.146-42.667,42.667-42.667s42.667,19.135,42.667,42.667\r\n\t\t\t\tS279.521,490.667,256,490.667z\" />\r\n\t\t\t\t<path d=\"M256,128c35.292,0,64-28.708,64-64S291.292,0,256,0s-64,28.708-64,64S220.708,128,256,128z M256,21.333\r\n\t\t\t\tc23.521,0,42.667,19.135,42.667,42.667S279.521,106.667,256,106.667S213.333,87.531,213.333,64S232.479,21.333,256,21.333z\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "ykBsmQ5qBYfOlD6oMvWFSCc5YmlrgoT6v4IJ8hg7p+4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 19.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<circle cx=\"256\" cy=\"256\" r=\"64\" />\r\n\t\t\t\t<circle cx=\"256\" cy=\"448\" r=\"64\" />\r\n\t\t\t\t<circle cx=\"256\" cy=\"64\" r=\"64\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "/dWQCZcWsqUOdn4xlIijasfndzqRwmGgJwILXYQUtGc=": "<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 20010904//EN\" \"http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd\">\n<svg version=\"1.0\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"100%\" viewBox=\"0 0 64.000000 64.000000\" preserveAspectRatio=\"xMidYMid meet\">\n\t<metadata>\n\t\tCreated by potrace 1.15, written by Peter Selinger 2001-2017\n\t</metadata>\n\t<g transform=\"translate(0.000000,64.000000) scale(0.100000,-0.100000)\" fill=\"#000000\" stroke=\"none\">\n\t\t<path d=\"M101 492 c-54 -27 -93 -83 -99 -141 -7 -72 5 -117 40 -157 54 -61 67\n-64 275 -64 212 0 233 5 286 72 52 66 50 181 -5 244 -54 61 -67 64 -275 64\n-159 0 -193 -3 -222 -18z m170 -55 c93 -62 88 -177 -12 -245 -83 -58 -212 16\n-212 120 0 88 58 148 144 148 31 0 57 -7 80 -23z\" />\n\t</g>\n</svg>\n",
  "KZ5yxZZkEc8jATCf3u/Stpklvq213g1CcrvBJ47QuhI=": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<!-- Creator: CorelDRAW -->\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xml:space=\"preserve\" width=\"100%\" height=\"100%\" style=\"shape-rendering:geometricPrecision; text-rendering:geometricPrecision; image-rendering:optimizeQuality; fill-rule:evenodd; clip-rule:evenodd\" viewBox=\"0 0 640 640\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n\t<defs>\r\n\t\t<style type=\"text/css\">\r\n\t\t\t<![CDATA[     .fil0 {fill:black}    ]]>\r\n\t\t</style>\r\n\t</defs>\r\n\t<g id=\"Layer_x0020_1\">\r\n\t\t<metadata id=\"CorelCorpID_0Corel-Layer\" />\r\n\t\t<path class=\"fil0\" d=\"M185.884 128.883l268.232 0c102.226,0 185.884,85.9971 185.884,191.117l0 0c0,105.119 -83.6585,191.117 -185.884,191.117l-268.232 0c-102.226,0 -185.884,-85.9971 -185.884,-191.117l0 0c0,-105.119 83.6585,-191.117 185.884,-191.117zm262.999 40.9493c84.2845,0 152.648,68.3512 152.648,152.636 0,84.2963 -68.363,152.671 -152.648,152.671 -84.2963,0 -152.648,-68.3749 -152.648,-152.671 0,-84.2845 68.3512,-152.636 152.648,-152.636z\" />\r\n\t</g>\r\n</svg>\r\n",
  "TR7BQR5l3d+ykOijtBMChw4cQdtTC2jYiUylS50oSOQ=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Generator: IcoMoon.io -->\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" fill=\"#000000\">\n\t<path d=\"M 96.00,448.00l-96.00-96.00L 256.00,96.00l 256.00,256.00l-96.00,96.00L 256.00,288.00L 96.00,448.00z\">\n\t</path>\n</svg>\n",
  "YGAbVN5f08Vy7ucASS1O/34AkzhCX5zz13ozrIifpyA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 45.958 45.958\" style=\"enable-background:new 0 0 45.958 45.958;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M39.287,41.955l-1.626-12.76c-0.556-4.375-4.278-7.61-8.688-7.61H16.985c-4.41,0-8.133,3.235-8.688,7.61L6.67,41.979\r\n\t\t\tc-0.112,0.894,0.163,2.018,0.758,2.692c0.596,0.675,1.453,1.287,2.353,1.287h26.395c0.9,0,1.757-0.624,2.354-1.299\r\n\t\t\tC39.125,43.982,39.4,42.85,39.287,41.955z\" />\r\n\t\t\t<circle cx=\"22.978\" cy=\"9.33\" r=\"9.33\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "rsG1GQj99WN9qlrKmww1KRpBYDCK9tXEeRaHqjIG4aA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 80.13 80.13\" style=\"enable-background:new 0 0 80.13 80.13;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M48.355,17.922c3.705,2.323,6.303,6.254,6.776,10.817c1.511,0.706,3.188,1.112,4.966,1.112\r\n\t\tc6.491,0,11.752-5.261,11.752-11.751c0-6.491-5.261-11.752-11.752-11.752C53.668,6.35,48.453,11.517,48.355,17.922z M40.656,41.984\r\n\t\tc6.491,0,11.752-5.262,11.752-11.752s-5.262-11.751-11.752-11.751c-6.49,0-11.754,5.262-11.754,11.752S34.166,41.984,40.656,41.984\r\n\t\tz M45.641,42.785h-9.972c-8.297,0-15.047,6.751-15.047,15.048v12.195l0.031,0.191l0.84,0.263\r\n\t\tc7.918,2.474,14.797,3.299,20.459,3.299c11.059,0,17.469-3.153,17.864-3.354l0.785-0.397h0.084V57.833\r\n\t\tC60.688,49.536,53.938,42.785,45.641,42.785z M65.084,30.653h-9.895c-0.107,3.959-1.797,7.524-4.47,10.088\r\n\t\tc7.375,2.193,12.771,9.032,12.771,17.11v3.758c9.77-0.358,15.4-3.127,15.771-3.313l0.785-0.398h0.084V45.699\r\n\t\tC80.13,37.403,73.38,30.653,65.084,30.653z M20.035,29.853c2.299,0,4.438-0.671,6.25-1.814c0.576-3.757,2.59-7.04,5.467-9.276\r\n\t\tc0.012-0.22,0.033-0.438,0.033-0.66c0-6.491-5.262-11.752-11.75-11.752c-6.492,0-11.752,5.261-11.752,11.752\r\n\t\tC8.283,24.591,13.543,29.853,20.035,29.853z M30.589,40.741c-2.66-2.551-4.344-6.097-4.467-10.032\r\n\t\tc-0.367-0.027-0.73-0.056-1.104-0.056h-9.971C6.75,30.653,0,37.403,0,45.699v12.197l0.031,0.188l0.84,0.265\r\n\t\tc6.352,1.983,12.021,2.897,16.945,3.185v-3.683C17.818,49.773,23.212,42.936,30.589,40.741z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "Bg2mkjExPE/WSCEFBNUgqo9jz7/qNPzmAqf7Pn8hN4A=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\" style=\"enable-background:new 0 0 512 512;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path d=\"M448,177.14V448c0,35.344-28.656,64-64,64H64c-35.344,0-64-28.656-64-64V128c0-35.344,28.656-64,64-64h270.844l-63.969,64\r\n\t\tH64v320h320V241.156L448,177.14z M398.875,45.25L376.25,67.875l67.875,67.891l22.625-22.625L398.875,45.25z M444.125,0\r\n\t\tL421.5,22.625l67.875,67.891L512,67.875L444.125,0z M150,294.188l67.875,67.875L421.5,158.406l-67.875-67.891L150,294.188z\r\n\t\t M128,384h64l-64-64V384z\" />\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "6xgElmBvS6p2cKnXDynHDtbEkljYJ1wDiTOnvwwI7eU=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg version=\"1.1\" id=\"Capa_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 284.936 284.936\" style=\"enable-background:new 0 0 284.936 284.936;\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275\r\n\t\t\tc-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677\r\n\t\t\tc-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854\r\n\t\t\tc2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z\" />\r\n\t\t\t<path d=\"M170.732,142.471c0-2.474-0.947-4.665-2.857-6.571L34.833,2.857C32.931,0.955,30.741,0,28.267,0s-4.665,0.955-6.567,2.857\r\n\t\t\tL7.426,17.133C5.52,19.036,4.57,21.222,4.57,23.7c0,2.478,0.95,4.664,2.856,6.567L119.63,142.471L7.426,254.677\r\n\t\t\tc-1.906,1.903-2.856,4.093-2.856,6.564c0,2.477,0.95,4.667,2.856,6.57l14.273,14.271c1.903,1.905,4.093,2.854,6.567,2.854\r\n\t\t\ts4.664-0.951,6.567-2.854l133.042-133.044C169.785,147.136,170.732,144.945,170.732,142.471z\" />\r\n\t\t</g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n\t<g>\r\n\t</g>\r\n</svg>\r\n",
  "W8R5k23nzbkExNYvtWDzlfyMuRe/dSnFdDEqtAZzGv4=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<rect x=\"7.019\" y=\"15.058\" fill=\"#FFFFFF\" width=\"16.001\" height=\"2\" />\r\n\t\t<rect x=\"7.019\" y=\"21.058\" fill=\"#FFFFFF\" width=\"8.658\" height=\"2\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"30.629,3.414 28.828,1.614 26.128,4.313 23.429,1.614 21.628,3.414 24.328,6.113 21.628,8.813 \r\n\t\t23.429,10.612 26.128,7.913 28.828,10.612 30.629,8.813 27.929,6.113 \t\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"19.508,10.936 17.626,9.057 7.019,9.057 7.019,11.058 19.63,11.058 \t\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.707,12.734l-0.579-0.579l-0.108,0.108v14.794c0,0.552-0.448,1-1,1H5.019c-0.552,0-1-0.448-1-1V5.057\r\n\t\tc0-0.552,0.448-1,1-1h13.009l-0.643-0.643l1.357-1.357H5.019c-1.657,0-3,1.343-3,3v22.001c0,1.656,1.343,3,3,3H25.02\r\n\t\tc1.656,0,3-1.344,3-3V14.046L26.707,12.734z\" />\r\n\t</g>\r\n</svg>\r\n",
  "baB1jdaWAqaQ/ICKz31jxNltTlZSdyK3YckwbQqobG0=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M21.02,5.005c2.168,0,4,2.519,4,5.5s-1.832,5.5-4,5.5s-4-2.519-4-5.5S18.852,5.005,21.02,5.005\r\n\t\t M21.02,3.005c-3.313,0-6,3.358-6,7.5c0,4.143,2.687,7.5,6,7.5s6-3.357,6-7.5C27.02,6.363,24.333,3.005,21.02,3.005L21.02,3.005z\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M15.927,20.811c-0.356,0.634-0.79,1.192-1.283,1.661c2.406,0.851,4.273,2.495,5.019,4.534H2.375\r\n\t\tc0.745-2.039,2.612-3.684,5.019-4.534C6.9,22.003,6.467,21.444,6.11,20.811c-3.608,1.504-6.092,4.604-6.092,8.195h22\r\n\t\tC22.019,25.415,19.535,22.314,15.927,20.811z\" />\r\n\t\t<g>\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M29.663,21.005H15.811c-0.487,0.81-1.101,1.492-1.807,2H32.02c0-3.591-2.483-6.69-6.092-8.194\r\n\t\t\tc-0.356,0.633-0.79,1.192-1.283,1.661C27.051,17.321,28.918,18.967,29.663,21.005z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M17.019,16.505c0,0.041-0.005,0.08-0.005,0.12c0.128-0.051,0.25-0.108,0.381-0.154\r\n\t\t\tc-0.141-0.134-0.265-0.291-0.396-0.438C17.008,16.19,17.019,16.346,17.019,16.505z\" />\r\n\t\t</g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M11.019,11.005c2.168,0,4,2.519,4,5.5c0,2.981-1.832,5.5-4,5.5s-4-2.52-4-5.5\r\n\t\tC7.019,13.524,8.851,11.005,11.019,11.005 M11.019,9.005c-3.313,0-6,3.358-6,7.5c0,4.143,2.687,7.5,6,7.5s6-3.357,6-7.5\r\n\t\tC17.019,12.363,14.332,9.005,11.019,9.005L11.019,9.005z\" />\r\n\t</g>\r\n</svg>\r\n",
  "3NySF1M+BlFpdKgiCLUITWDVKchFkR61BhH5wPSQ1jk=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.02,8.008c0.552,0,1,0.449,1,1v14c0,0.552-0.448,1-1,1H6.019c-0.552,0-1-0.448-1-1v-14\r\n\t\tc0-0.551,0.448-1,1-1H26.02 M26.02,6.008H6.019c-1.657,0-3,1.343-3,3v14c0,1.657,1.343,3,3,3H26.02c1.656,0,3-1.343,3-3v-14\r\n\t\tC29.02,7.352,27.676,6.008,26.02,6.008L26.02,6.008z\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M16.019,17.008c-0.215,0-0.43-0.069-0.609-0.207l-10.401-8c-0.438-0.336-0.52-0.964-0.184-1.402\r\n\t\tC5.161,6.96,5.789,6.877,6.227,7.215l9.792,7.531l10.214-7.856c0.438-0.337,1.065-0.255,1.402,0.183\r\n\t\tc0.336,0.438,0.255,1.066-0.184,1.402l-10.823,8.325C16.448,16.939,16.233,17.008,16.019,17.008z\" />\r\n\t</g>\r\n</svg>\r\n",
  "ySLntl3dfzYbNgoTBdqy+xs9WSo/jPPnBJ63p1WweMc=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<polygon fill=\"#FFFFFF\" points=\"16.724,21.453 12.094,22.812 13.7,18.262 28.304,4.432 31.326,7.624 \" />\r\n\t<path fill=\"#FFFFFF\" d=\"M24.02,18.675v8.345c0,0.551-0.448,1-1,1H3.019c-0.552,0-1-0.449-1-1v-22c0-0.551,0.448-1,1-1H23.02\r\n\tc0.361,0,0.664,0.203,0.84,0.49l1.466-1.388C24.774,2.454,23.951,2.02,23.02,2.02H3.019c-1.657,0-3,1.343-3,3v22\r\n\tc0,1.656,1.343,3,3,3H23.02c1.656,0,3-1.344,3-3V16.781L24.02,18.675z\" />\r\n\t<g>\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"9.265,21.814 9.545,21.02 5.019,21.02 5.019,23.02 8.839,23.02 \t\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"19.096,9.02 5.019,9.02 5.019,11.02 16.984,11.02 \t\" />\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"11.112,16.581 11.638,16.083 12.761,15.02 5.019,15.02 5.019,17.02 10.957,17.02 \t\" />\r\n\t</g>\r\n</svg>\r\n",
  "pRV/6DXh/b+GeLEkWBax19DQZPTt+K/V8mJzX2bhFrA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<path fill=\"#FFFFFF\" d=\"M26.02,4.005c0.552,0,1,0.449,1,1v22c0,0.552-0.448,1-1,1H6.019c-0.552,0-1-0.448-1-1v-22\r\n\tc0-0.551,0.448-1,1-1H26.02 M26.02,2.005H6.019c-1.657,0-3,1.343-3,3v22c0,1.657,1.343,3,3,3H26.02c1.656,0,3-1.343,3-3v-22\r\n\tC29.02,3.348,27.676,2.005,26.02,2.005L26.02,2.005z\" />\r\n\t<g>\r\n\t\t<rect x=\"12.019\" y=\"9.005\" fill=\"#FFFFFF\" width=\"12.001\" height=\"2\" />\r\n\t\t<rect x=\"12.019\" y=\"15.005\" fill=\"#FFFFFF\" width=\"12.001\" height=\"2\" />\r\n\t\t<rect x=\"12.019\" y=\"21.006\" fill=\"#FFFFFF\" width=\"12.001\" height=\"2\" />\r\n\t</g>\r\n\t<g>\r\n\t\t<rect x=\"8.019\" y=\"9.005\" fill=\"#FFFFFF\" width=\"2\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"15.005\" fill=\"#FFFFFF\" width=\"2\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"21.006\" fill=\"#FFFFFF\" width=\"2\" height=\"2\" />\r\n\t</g>\r\n</svg>\r\n",
  "E8Xuh/aYOqLWlVv+Dwg9Bh7JWeSlZjPnINdz4PB77Tg=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<rect x=\"11.023\" y=\"7.005\" fill=\"#FFFFFF\" width=\"16.001\" height=\"3\" />\r\n\t\t<rect x=\"5.022\" y=\"7.001\" fill=\"#FFFFFF\" width=\"3\" height=\"3\" />\r\n\t\t<rect x=\"11.023\" y=\"14.006\" fill=\"#FFFFFF\" width=\"16.001\" height=\"3\" />\r\n\t\t<rect x=\"5.022\" y=\"14.002\" fill=\"#FFFFFF\" width=\"3\" height=\"3\" />\r\n\t\t<rect x=\"11.023\" y=\"21.006\" fill=\"#FFFFFF\" width=\"16.001\" height=\"3\" />\r\n\t\t<rect x=\"5.022\" y=\"21.002\" fill=\"#FFFFFF\" width=\"3\" height=\"3\" />\r\n\t</g>\r\n</svg>\r\n",
  "MONEwokmzwvC3cVaUZPPsNR5adO6+SFjEDtlI1LEkMU=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<rect x=\"9.016\" y=\"10.003\" fill=\"#FFFFFF\" width=\"14\" height=\"2\" />\r\n\t\t<rect x=\"9.016\" y=\"16.003\" fill=\"#FFFFFF\" width=\"14\" height=\"2\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.009,4.021h-20c-1.656,0-2.999,1.344-2.999,3v14.001c0,1.656,1.343,3,2.999,3h13.495l6.643,4.981v-4.995\r\n\t\tc1.591-0.074,2.862-1.377,2.862-2.986V7.021C29.009,5.364,27.665,4.021,26.009,4.021z M27.009,21.021c0,0.552-0.448,1-1,1h-1.99\r\n\t\tv0.981v1.019v0.981l-1.309-0.981l0,0l-2.667-2H6.009c-0.551,0-0.999-0.448-0.999-1V7.021c0-0.552,0.448-1,0.999-1h20\r\n\t\tc0.552,0,1,0.448,1,1V21.021z\" />\r\n\t</g>\r\n</svg>\r\n",
  "+heMPb20qCH+9HRzHoZkJvyIHvKoHlsE92mEJUWGcRA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.02,4.001c0.552,0,1,0.449,1,1v22c0,0.552-0.448,1-1,1H6.019c-0.552,0-1-0.448-1-1v-22\r\n\t\tc0-0.551,0.448-1,1-1H26.02 M26.02,2.001H6.019c-1.657,0-3,1.343-3,3v22c0,1.657,1.343,3,3,3H26.02c1.656,0,3-1.343,3-3v-22\r\n\t\tC29.02,3.344,27.676,2.001,26.02,2.001L26.02,2.001z\" />\r\n\t\t<rect x=\"8.019\" y=\"9.001\" fill=\"#FFFFFF\" width=\"8\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"15.001\" fill=\"#FFFFFF\" width=\"16.001\" height=\"2\" />\r\n\t\t<rect x=\"8.019\" y=\"21.002\" fill=\"#FFFFFF\" width=\"12\" height=\"2\" />\r\n\t</g>\r\n</svg>\r\n",
  "EUuH2xXJlGXqsCiNZIrN76PfP+EydjXQuC5EEz/LJ4E=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<path fill=\"#FFFFFF\" d=\"M21.837,18.006c-0.33,0.633-0.725,1.202-1.166,1.707c3.516,1.115,6.186,3.444,7.05,6.289H4.317\r\n\tc0.864-2.845,3.534-5.174,7.05-6.289c-0.441-0.505-0.836-1.074-1.166-1.707c-4.825,1.736-8.183,5.554-8.183,9.996H30.02\r\n\tC30.02,23.56,26.661,19.742,21.837,18.006z\" />\r\n\t<path fill=\"#FFFFFF\" d=\"M16.019,6.001c2.711,0,5.001,3.206,5.001,7s-2.29,7-5.001,7c-2.71,0-5-3.206-5-7S13.309,6.001,16.019,6.001\r\n\t M16.019,4.001c-3.865,0-7,4.029-7,9c0,4.971,3.135,9,7,9c3.866,0,7.001-4.029,7.001-9C23.02,8.031,19.885,4.001,16.019,4.001\r\n\tL16.019,4.001z\" />\r\n</svg>\r\n",
  "etFh4I/O9aOZHQ6H1Db3w5Jo9ZDNPlgzdcSNAaJxIN4=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M16.019,8.201c2.711,0,5.001,3.206,5.001,7c0,3.795-2.29,7-5.001,7c-2.71,0-5-3.205-5-7\r\n\t\tC11.019,11.407,13.309,8.201,16.019,8.201 M16.019,6.201c-3.865,0-7,4.029-7,9s3.135,9,7,9c3.866,0,7.001-4.029,7.001-9\r\n\t\tS19.885,6.201,16.019,6.201L16.019,6.201z\" />\r\n\t</g>\r\n\t<rect x=\"22.013\" y=\"6\" fill=\"#FFFFFF\" width=\"8\" height=\"2\" />\r\n\t<rect x=\"25.013\" y=\"3\" fill=\"#FFFFFF\" width=\"2\" height=\"8\" />\r\n\t<path fill=\"#FFFFFF\" d=\"M21.837,20.205c-0.33,0.633-0.725,1.203-1.166,1.708c3.516,1.114,6.186,3.444,7.05,6.288H4.317\r\n\tc0.864-2.844,3.534-5.174,7.05-6.288c-0.441-0.505-0.836-1.075-1.166-1.708c-4.825,1.736-8.183,5.555-8.183,9.996H30.02\r\n\tC30.02,25.76,26.661,21.941,21.837,20.205z\" />\r\n</svg>\r\n",
  "wQCv9WSePSmQId7vpolJ7L6jyMUGv4YLAeftA/PVQ0E=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<polygon fill=\"#FFFFFF\" points=\"15.723,19.498 11.093,20.857 12.7,16.307 27.303,2.476 30.326,5.668 \t\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M26.02,13.878v13.187c0,0.552-0.448,1-1,1H5.019c-0.552,0-1-0.448-1-1V7.063c0-0.552,0.448-1,1-1h14.134\r\n\t\tl2.112-2H5.019c-1.657,0-3,1.343-3,3v20.001c0,1.656,1.343,3,3,3H25.02c1.656,0,3-1.344,3-3V11.983L26.02,13.878z\" />\r\n\t</g>\r\n</svg>\r\n",
  "ceppsRyLhBzNc1PAypgMpzHvDKDvt/VPIK6bR2G8Qus=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<path fill=\"#FFFFFF\" d=\"M15.982,4.863c0.013,0,0.024,0,0.036,0s0.023,0,0.035,0c0.036,0.006,0.073,0.01,0.11,0.014\r\n\t\tc3.551,0.318,6.334,4.506,6.348,9.54c-0.04,0.801-0.206,6.158,2.244,8.746c0.521,0.549,1.131,0.946,1.805,1.18v1.577H16.298H15.74\r\n\t\tH5.477v-1.577c0.674-0.233,1.284-0.631,1.805-1.18c2.45-2.588,2.284-7.945,2.244-8.746c0.014-5.034,2.798-9.222,6.349-9.54\r\n\t\tC15.911,4.874,15.947,4.869,15.982,4.863 M16.298,3.346c-0.094,0-0.186,0.014-0.279,0.018c-0.094-0.004-0.185-0.018-0.278-0.018\r\n\t\tv0.037C11.434,3.77,8.025,8.572,8.025,14.455c0,0,0.471,8.635-4.049,8.635v4.33H15.74h0.558h11.763v-4.33\r\n\t\tc-4.52,0-4.049-8.635-4.049-8.635c0-5.883-3.407-10.686-7.714-11.072V3.346L16.298,3.346z\" />\r\n\t\t<circle fill=\"#FFFFFF\" cx=\"15.74\" cy=\"2.629\" r=\"2.629\" />\r\n\t\t<path fill=\"#FFFFFF\" d=\"M20.118,30.75c-2.225,0-4.034-1.81-4.034-4.033h1.5c0,1.396,1.137,2.533,2.534,2.533\r\n\t\ts2.535-1.137,2.535-2.533h1.5C24.153,28.94,22.343,30.75,20.118,30.75z\" />\r\n\t</g>\r\n</svg>\r\n",
  "wsw7fAiZgCrxi4qsVyBRBCKpQXaDj0Rnz6I82YBou7g=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<polygon fill=\"#FFFFFF\" points=\"22.523,12.003 15.522,16.003 22.523,20.003 \" />\r\n\t<path fill=\"#FFFFFF\" d=\"M26.014,4.013c0.552,0,1,0.448,1,1v22.002c0,0.552-0.448,1-1,1h-20c-0.551,0-0.999-0.448-0.999-1V5.013\r\n\tc0-0.552,0.448-1,0.999-1H26.014 M26.014,2.013h-20c-1.656,0-2.999,1.344-2.999,3v22.002c0,1.656,1.343,3,2.999,3h20\r\n\tc1.656,0,3-1.344,3-3V5.013C29.014,3.356,27.67,2.013,26.014,2.013L26.014,2.013z\" />\r\n\t<path fill=\"#FFFFFF\" d=\"M11.791,29.015h-2v-2h2V29.015z M11.791,25.015h-2v-2h2V25.015z M11.791,21.015h-2v-2h2V21.015z\r\n\t M11.791,17.015h-2v-2h2V17.015z M11.791,13.015h-2v-2h2V13.015z M11.791,9.015h-2v-2h2V9.015z M11.791,5.015h-2v-2h2V5.015z\" />\r\n</svg>\r\n",
  "qlhr53STMnYuZOYO4KgCJL1rFJ6VG8AcIFjyQkGgrnM=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<polygon fill=\"#FFFFFF\" points=\"16.519,20.003 23.52,16.003 16.519,12.003 \" />\r\n\t<path fill=\"#FFFFFF\" d=\"M26.009,4.013c0.552,0,1,0.448,1,1v22.002c0,0.552-0.448,1-1,1h-20c-0.551,0-0.999-0.448-0.999-1V5.013\r\n\tc0-0.552,0.448-1,0.999-1H26.009 M26.009,2.013h-20c-1.656,0-2.999,1.344-2.999,3v22.002c0,1.656,1.343,3,2.999,3h20\r\n\tc1.656,0,3-1.344,3-3V5.013C29.009,3.356,27.665,2.013,26.009,2.013L26.009,2.013z\" />\r\n\t<rect x=\"9.786\" y=\"3.015\" fill=\"#FFFFFF\" width=\"2\" height=\"26\" />\r\n</svg>\r\n",
  "9LkL0VWdA0KsoX3MsJoCMsizXCXQ6o4M9NvXunK3tFA=": "<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 32 32\" xml:space=\"preserve\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<g>\r\n\t\t\t\t<path fill=\"#FFFFFF\" d=\"M25.02,22.502c1.379,0,2.5,1.121,2.5,2.5s-1.121,2.5-2.5,2.5s-2.5-1.121-2.5-2.5\r\n\t\t\t\tS23.641,22.502,25.02,22.502 M25.02,21.002c-2.209,0-4,1.791-4,4s1.791,4,4,4s4-1.791,4-4S27.229,21.002,25.02,21.002\r\n\t\t\t\tL25.02,21.002z\" />\r\n\t\t\t</g>\r\n\t\t\t<g>\r\n\t\t\t\t<path fill=\"#FFFFFF\" d=\"M16.019,13.501c1.379,0,2.5,1.122,2.5,2.5c0,1.378-1.121,2.5-2.5,2.5s-2.5-1.122-2.5-2.5\r\n\t\t\t\tC13.519,14.623,14.64,13.501,16.019,13.501 M16.019,12.001c-2.209,0-4,1.791-4,4s1.791,4,4,4s4-1.791,4-4\r\n\t\t\t\tS18.228,12.001,16.019,12.001L16.019,12.001z\" />\r\n\t\t\t</g>\r\n\t\t\t<g>\r\n\t\t\t\t<path fill=\"#FFFFFF\" d=\"M7.018,4.5c1.379,0,2.5,1.122,2.5,2.5s-1.121,2.5-2.5,2.5s-2.5-1.122-2.5-2.5S5.639,4.5,7.018,4.5\r\n\t\t\t\t M7.018,3c-2.209,0-4,1.791-4,4s1.791,4,4,4s4-1.791,4-4S9.227,3,7.018,3L7.018,3z\" />\r\n\t\t\t</g>\r\n\t\t</g>\r\n\t\t<g>\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M12.019,16.001c0-0.322,0.048-0.631,0.12-0.931H0.017v2h12.165C12.086,16.728,12.019,16.374,12.019,16.001\r\n\t\t\tz\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M3.018,7c0-0.322,0.048-0.631,0.12-0.931H0.017v2h3.164C3.085,7.728,3.018,7.374,3.018,7z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M10.897,6.07c0.072,0.3,0.12,0.609,0.12,0.931c0,0.373-0.067,0.727-0.163,1.069h21.164v-2H10.897z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M21.02,25.002c0-0.322,0.048-0.631,0.12-0.931H0.017v2h21.166C21.087,25.729,21.02,25.375,21.02,25.002z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M20.019,16.001c0,0.373-0.067,0.727-0.163,1.069h12.163v-2h-12.12\r\n\t\t\tC19.971,15.37,20.019,15.679,20.019,16.001z\" />\r\n\t\t\t<path fill=\"#FFFFFF\" d=\"M29.02,25.002c0,0.373-0.067,0.727-0.163,1.069h3.162v-2h-3.119C28.972,24.371,29.02,24.68,29.02,25.002z\" />\r\n\t\t</g>\r\n\t</g>\r\n</svg>\r\n",
  "ou4RtWKwl4vfjc7ZHjfwbNAjwg+QseDtNjn35J/ww8I=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!-- Generator: Adobe Illustrator 16.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0) -->\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"  width=\"100%\" height=\"100%\" viewBox=\"0 0 401.994 401.994\">\r\n\t<path d=\"M394,154.175c-5.331-5.33-11.806-7.994-19.417-7.994H255.811V27.406c0-7.611-2.666-14.084-7.994-19.414\r\n\t\tC242.488,2.666,236.02,0,228.398,0h-54.812c-7.612,0-14.084,2.663-19.414,7.993c-5.33,5.33-7.994,11.803-7.994,19.414v118.775\r\n\t\tH27.407c-7.611,0-14.084,2.664-19.414,7.994S0,165.973,0,173.589v54.819c0,7.618,2.662,14.086,7.992,19.411\r\n\t\tc5.33,5.332,11.803,7.994,19.414,7.994h118.771V374.59c0,7.611,2.664,14.089,7.994,19.417c5.33,5.325,11.802,7.987,19.414,7.987\r\n\t\th54.816c7.617,0,14.086-2.662,19.417-7.987c5.332-5.331,7.994-11.806,7.994-19.417V255.813h118.77\r\n\t\tc7.618,0,14.089-2.662,19.417-7.994c5.329-5.325,7.994-11.793,7.994-19.411v-54.819C401.991,165.973,399.332,159.502,394,154.175z\"\r\n\t\t/>\r\n</svg>\r\n",
  "htg5toQYFNrXiHYnUiNiLbEAfwqoLQct3bIobgtBgiM=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 174.239 174.239\" style=\"enable-background:new 0 0 174.239 174.239;\" xml:space=\"preserve\">\r\n\t<path d=\"M146.537,1.047c-1.396-1.396-3.681-1.396-5.077,0L89.658,52.849c-1.396,1.396-3.681,1.396-5.077,0L32.78,1.047\r\n\t\tc-1.396-1.396-3.681-1.396-5.077,0L1.047,27.702c-1.396,1.396-1.396,3.681,0,5.077l51.802,51.802c1.396,1.396,1.396,3.681,0,5.077\r\n\t\tL1.047,141.46c-1.396,1.396-1.396,3.681,0,5.077l26.655,26.655c1.396,1.396,3.681,1.396,5.077,0l51.802-51.802\r\n\t\tc1.396-1.396,3.681-1.396,5.077,0l51.801,51.801c1.396,1.396,3.681,1.396,5.077,0l26.655-26.655c1.396-1.396,1.396-3.681,0-5.077\r\n\t\tl-51.801-51.801c-1.396-1.396-1.396-3.681,0-5.077l51.801-51.801c1.396-1.396,1.396-3.681,0-5.077L146.537,1.047z\" />\r\n</svg>\r\n",
  "Jphu9eYn1YFH99wfkQadp1YZXaISCu+Vq3WfLXj4LLk=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" preserveAspectRatio=\"xMidYMin slice\" viewBox=\"0 0 284.936 284.936\" style=\"enable-background:new 0 0 284.936 284.936;\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275\r\n\t\t\t\tc-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677\r\n\t\t\t\tc-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854\r\n\t\t\t\tc2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z\" />\r\n\t\t\t<path d=\"M170.732,142.471c0-2.474-0.947-4.665-2.857-6.571L34.833,2.857C32.931,0.955,30.741,0,28.267,0s-4.665,0.955-6.567,2.857\r\n\t\t\t\tL7.426,17.133C5.52,19.036,4.57,21.222,4.57,23.7c0,2.478,0.95,4.664,2.856,6.567L119.63,142.471L7.426,254.677\r\n\t\t\t\tc-1.906,1.903-2.856,4.093-2.856,6.564c0,2.477,0.95,4.667,2.856,6.57l14.273,14.271c1.903,1.905,4.093,2.854,6.567,2.854\r\n\t\t\t\ts4.664-0.951,6.567-2.854l133.042-133.044C169.785,147.136,170.732,144.945,170.732,142.471z\" />\r\n\t\t</g>\r\n\t</g>\r\n</svg>\r\n",
  "gzqCjL2ZPnleYFzmzFrQM4HLYtoLXqvxO5gbD/dZQgA=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 51.997 51.997\">\r\n\t<path d=\"M51.911,16.242C51.152,7.888,45.239,1.827,37.839,1.827c-4.93,0-9.444,2.653-11.984,6.905\r\n\t\tc-2.517-4.307-6.846-6.906-11.697-6.906c-7.399,0-13.313,6.061-14.071,14.415c-0.06,0.369-0.306,2.311,0.442,5.478\r\n\t\tc1.078,4.568,3.568,8.723,7.199,12.013l18.115,16.439l18.426-16.438c3.631-3.291,6.121-7.445,7.199-12.014\r\n\t\tC52.216,18.553,51.97,16.611,51.911,16.242z\" />\r\n</svg>\r\n",
  "Y/aWD3bBQXqnTr4SyePk5ITIqc644HmrrWfbdcWFKJ8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg height='100%' width='100%' viewBox='0 0 16 16' xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\r\n\t<circle stroke-width='1' cx=\"7\" cy=\"7\" r=\"4\" />\r\n</svg>\r\n",
  "y+406ZqF4Qnx/v1TFit7PgfOxGRIP+WjRFYgRDztzN4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 512 512\">\r\n\t<path d=\"M 416.00,416.00l-96.00,96.00L 64.00,256.00L 320.00,0.00l 96.00,96.00L 256.00,256.00L 416.00,416.00z\">\r\n\t</path>\r\n</svg>\r\n",
  "p7guqGDTnmdLbYMqEQkVwWZb1MveUgY/RioNkjxD9yE=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" height='100%' width='100%' viewBox='0 0 16 16'>\r\n\t<circle stroke-width='1' cx=\"7\" cy=\"7\" r=\"6\" />\r\n</svg>\r\n\r\n",
  "847+d+8IOSqpM/X9dlyA2trOF5A++lZmOs7CHAyBjy4=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 100 100\">\r\n\t<path d=\"M24.9,66V39.9H35L17.5,20L0,39.9h10.1V70c0,5.523,4.476,10,10,10H65L52.195,66H24.9z M89.9,60.1V30 c0-5.523-4.477-10-10-10H35l12.804,14h27.295v26.1H65L82.5,80L100,60.1H89.9z\" />\r\n</svg>\r\n",
  "lLFn49Y/4Rtb9QRSB5dUihcJOGKeyXsc7XixPjz/0H8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" viewBox=\"0 0 306 306\">\r\n\t<polygon points=\"94.35,0 58.65,35.7 175.95,153 58.65,270.3 94.35,306 247.35,153\" fill=\"#888\" />\r\n</svg>\r\n",
  "Ss41Nb4mLWs2d2bzqjycl3C5QY9tLOHobhjtIMwROP8=": "<?xml version=\"1.0\" encoding=\"iso-8859-1\"?>\r\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\r\n<svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" x=\"0px\" y=\"0px\" width=\"100%\" height=\"100%\" viewBox=\"0 0 284.936 284.936\" style=\"enable-background:new 0 0 284.936 284.936;\">\r\n\t<g>\r\n\t\t<g>\r\n\t\t\t<path d=\"M277.515,135.9L144.464,2.857C142.565,0.955,140.375,0,137.9,0c-2.472,0-4.659,0.955-6.562,2.857l-14.277,14.275\r\n\t\t\t\tc-1.903,1.903-2.853,4.089-2.853,6.567c0,2.478,0.95,4.664,2.853,6.567l112.207,112.204L117.062,254.677\r\n\t\t\t\tc-1.903,1.903-2.853,4.093-2.853,6.564c0,2.477,0.95,4.667,2.853,6.57l14.277,14.271c1.902,1.905,4.089,2.854,6.562,2.854\r\n\t\t\t\tc2.478,0,4.665-0.951,6.563-2.854l133.051-133.044c1.902-1.902,2.851-4.093,2.851-6.567S279.417,137.807,277.515,135.9z\" />\r\n\t\t</g>\r\n\t</g>\r\n</svg>\r\n"
}